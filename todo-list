
In progress:

Things to do:

In libraries:
Make subbytes/bytes-copy! fast
change all mains to accept environment.
make prim-signature not tied to prim-implementation

In bootstrap compiler:
Improve error message of typechecker when applying non function

In compiler:
Add tests for validator.
Improve warning for free types in type definitions.
Make regexp for matching the whole string not be an element in the list of matches.
Allow rename on export
Fix error message for vararg application with non single type array function.
make boolean patterns accepted
remove trivial constraint from unification error messages
Prevent accessing unexported patterns
Make polymorphic calls work in more cases.
  * add annotations for let
  * support instantiation of polymorphic type
Check bytes length when doing reads/writes
Cond statements
Provide better location info for error messages.
Make error message for case with multiple bodies in a clause better.
Make error messages for function definitions with missing type variables better.
Make #; comments work
Make closure names for defined functions and data type functions be in sync.
  _code vs _closure.
Make blocks work in lambdas
Check kind of types somewhere before type unification.
Make polymorphic function inference not crash compiler
  'polymorphic functions constraints not yet implemented'
Do 'cuts' when parsing after seeing keyword.
Make error message for typechecking lambda in non function expectation better
Clean up: function-definition->assembly-fragment.
add set-empty? instead of (= 0 (set-count s)); same with dict-count
casing on a function type panics the compiler

In test suites:
Provide better scoping of error messages.

In linter:
Warn about unused local variables.
Warn about unused datatypes.
Do global analysis to find unused exported bindings
Make linter check indentation of imports

In tools:
Answer question of where is variable used.
Add import when well known binding is unbound.
Sort import sections in rewrite.
Rewrite imports should remove empty sections

Migrate modules to multipart names as appropriate

New syntax
#:module (dir1 dir2 name)
#:imports {
  #:import (dir1 dir2 name2) {
    #:types {
      T1
      T2
      T3
    }
    #:values {
      V1
      V2
      V3
    }
    #:patterns {
      P1
      P2
      P3
    }
  }
}
#:exports {
  #:types {
    T1
    T2
    T3
  }
  #:values {
    V1
    V2
    V3
  }
  #:patterns {
    P1
    P2
    P3
    T1
  }
}
#:type-definitions {
  (define-type (List A)
    (cons [head : A] [tail : (List A)])
    (empty))
}
#:function-definitions {
  (define (foo [x : Bar]) : Baz
    (foobarbaz x))
}

Improve optimizations
inline bytes-length/bytes-ref
inline data constructors
don't heap allocte for zero arg constructors.
don't move rbp to rsp when it would be a noop.
