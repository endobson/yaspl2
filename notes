DataTypes
  Byte
  Boolean
  Void
  InputPort
  OutputPort
  CodePoint
  String
  (List <t>)
  (a, ...) -> b


Starting Point:

A function is a series of expressions, with arguments, and types.

(define (f (arg1 : type1) (arg2 : type2))
  body1
  body2)

A module looks is a collection of imports, exports, and function definitions.

(module module-name
  (import
    [module1
      (f1 : type1)
      (f2 : type2)])
  (export h1 h2)
  (define (h1)
    body))


To run a program we have a bunch of modules and a module name/function name pair.

The function must have type (InputPort OutputPort OutputPort (List String) -> Byte).

1. Hello world
2. Echo Args
2. Echo Input
3. Echo Distinct words on different lines.
4. RPN
5. Parse Trees of parens
6. Tree calculator.
7. Tree calculator with variables.
8. Tree calculator with functions.


(module hello-world
  (import)
  (export main)
  (define (main in out err args)
    (write-string out "hello world")))
    
(module 'echo-args
  (import)
  (export main)
  (define (main in out err args)
    (loop args out))
  (define (loop strings out)
    (if (null? strings)
        (void)
        (begin
          (write-string (first strings))
          (loop (rest strings) out)))))
          
;; Racket interpreter, types are ignored at first


parse-module : sexp -> module
(struct module imports exports definitions)
;; Imports is a hashmap from local name -> global name
;; Local name is a symbol; global name is a module name/local name
;; Exports is a list of symbols
;; Definitions is hashmap of local name to definition.

(struct definition (args body))
;; args are a listof symbol
;; body is an expression

expression 
(struct app& ([op : expression] [args : (Listof expression)]))
(struct if& ([cond : expression] [true : expression] [false : expression]))
(struct string-literal ([value : string]))
(struct byte-literal ([value : byte]))
(struct begin ([exprs : (Listof expresion )]))
(struct variable ([value : symbol]))

run-program : (listof module) module-name main-name input output error args -> error-code

run-program first sanity checks the program (typecheck, variable boundness checks, etc);

Then it creates a library (a set of linked together modules).

We then run eval. This is going to be a CEK machine.

(struct apply-k (listof expression))
(struct apply2-k fun-value (listof value) (listof expression))
(struct if-k (true expression) (false expression))

(struct eval-machine-state : expression environment cont)
(struct cont-machine-state : cont environment)

