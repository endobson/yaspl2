(module totality-checker
  (import
    (bytes bytes-append bytes=?)
    (list
      #:types (List)
      #:values (append append* cons empty foldl interleave list map zip)
      #:patterns (cons empty))
    (maybe
      #:types (Maybe)
      #:values (just nothing)
      #:patterns (just nothing))
    (prim
      #:types (Boolean Bytes)
      #:values (and or panic)
      #:patterns ())
    (source-language
      #:types (Pattern)
      #:values ()
      #:patterns (abstraction-pattern bytes-pattern ignore-pattern int-pattern variable-pattern))
    (tuples
      #:types (Tuple2)
      #:values (tuple2)
      #:patterns (tuple2))
    (type-checker-context
      #:types (Context)
      #:values (context-ref-pattern)
      #:patterns (pattern-descriptor)))
  (export
    #:types ()
    #:values (totality-check-patterns check-patterns*
              abstract-match any-value abstract-match/values)
    #:patterns ())
  (types
    (define-type AbstractValue
      (any-value)
      (full-variant [name : Bytes])
      (variant [name : Bytes] [fields : (List AbstractValue)])))

  (define (totality-check-patterns [context : Context] [patterns : (List Pattern)]) : (Maybe Bytes)
    (case (check-patterns* context patterns (varargs list (any-value)))
      [(empty) (nothing)]
      [values
       (just (bytes-append
                     (cons #"Patterns are not exhaustive.\n"
                           (interleave (map abstract-value->bytes values) #"\n"))))]))

  (define (abstract-value->bytes [v : AbstractValue]) : Bytes
    (case v
      [(any-value) #"*"]
      [(full-variant variant-name)
       (bytes-append (varargs list #"(" variant-name #" ...)"))]
      [(variant variant-name fields)
       (bytes-append
         (append
           (varargs list #"(" variant-name)
           (append
             (map (lambda ([v : AbstractValue])
                    (bytes-append (varargs list #" " (abstract-value->bytes v))))
                  fields)
             (varargs list #")"))))]))

  (define (check-patterns* [context : Context] [patterns : (List Pattern)] [vals : (List AbstractValue)]) :
    (List AbstractValue)
    (case patterns
      [(empty) vals]
      [(cons pat patterns)
       (match-define (tuple2 vals matched) (abstract-match/values context pat vals))
       ;; TODO record error for patterns that don't match
       (check-patterns* context patterns vals) ]))

  (define (abstract-match/values [context : Context] [pat : Pattern] [vals : (List AbstractValue)])
    : (Tuple2 (List AbstractValue) Boolean)
    (abstract-match/values* context pat vals (empty) #f))

  (define (abstract-match/values*
            [context : Context] [pat : Pattern] [vals : (List AbstractValue)]
            [acc-values : (List AbstractValue)] [acc-matched : Boolean])
    : (Tuple2 (List AbstractValue) Boolean)
    (case vals
      [(empty) (tuple2 acc-values acc-matched)]
      [(cons val vals)
       (match-define (tuple2 values matched) (abstract-match context pat val))
       (abstract-match/values* context pat vals (append values acc-values)
                               (or matched acc-matched))]))

  (define (lookup-variants [context : Context] [name : Bytes]) : (List AbstractValue)
    (case (context-ref-pattern context name)
      [(nothing) (panic #"Bad pattern")]
      [(just (pattern-descriptor _ _ _ _ all-variants))
       (map full-variant all-variants)]))

  (define (matches-variant [context : Context] [pat-name : Bytes] [var-name : Bytes])
    : Boolean
    (case (context-ref-pattern context pat-name)
      [(nothing) (panic #"Bad pattern")]
      [(just (pattern-descriptor _ _ _ matched-name _))
       (bytes=? matched-name var-name)]))

  (define (abstract-match/vec [context : Context] [patterns : (List Pattern)] [vals : (List AbstractValue)])
    : (Tuple2 (List (List AbstractValue)) Boolean)
    (case (zip patterns vals)
      [(nothing) (panic #"Some pattern doesn't match its spec")]
      [(just pat/vals)
       (let ([match-results
              (map
                (lambda ([t : (Tuple2 Pattern AbstractValue)])
                  (case t
                    [(tuple2 pat val)
                     (abstract-match context pat val)]))
                pat/vals)])
         (tuple2
           (map (lambda ([r : (Tuple2 (List AbstractValue) Boolean)])
                  (case r [(tuple2 v _) v]))
                match-results)
           (foldl (lambda ([r : (Tuple2 (List AbstractValue) Boolean)] [acc : Boolean])
                    (case r
                      [(tuple2 _ v)
                       (and v acc)]))
                  match-results
                  #t)))]))

  (define (A) (cartesian-product [vss : (List (List A))]) : (List (List A))
    (case vss
      [(empty) (varargs list (empty))]
      [(cons vs vss)
       (let ([sub-products (cartesian-product vss)])
         (append*
           (map
             (lambda ([new-elem : A])
               (map
                 (lambda ([sub-product : (List A)])
                   (cons new-elem sub-product))
                 sub-products))
             vs)))]))

  (define (abstract-match [context : Context] [pattern : Pattern] [val : AbstractValue])
    : (Tuple2 (List AbstractValue) Boolean)
    (case pattern
      [(bytes-pattern _)
       (tuple2 (varargs list val) #t)]
      [(int-pattern _)
       (tuple2 (varargs list val) #t)]
      [(variable-pattern _)
       (tuple2 (empty) #t)]
      [(ignore-pattern)
       (tuple2 (empty) #t)]
      [(abstraction-pattern name patterns)
       (case val
         [(any-value)
          (abstract-match/values context pattern (lookup-variants context name))]
         [(full-variant var-name)
          (if (matches-variant context name var-name)
              (case patterns
                [(empty)
                 (tuple2 (empty) #t)]
                [_
                 (case (abstract-match/vec context patterns
                                           (map (lambda ([p : Pattern]) (any-value)) patterns))
                   [(tuple2 vecs matched)
                    (tuple2
                      (map (lambda ([vs : (List AbstractValue)]) (variant var-name vs))
                           (cartesian-product vecs))
                      matched)])])
              (tuple2 (varargs list val) #f))]
         [(variant var-name fields)
          (if (matches-variant context name var-name)
              (case (abstract-match/vec context patterns fields)
                [(tuple2 vecs matched)
                 (tuple2
                   (map (lambda ([vs : (List AbstractValue)]) (variant var-name vs))
                        (cartesian-product vecs))
                   matched)])
              (tuple2 (varargs list val) #f))])])))
