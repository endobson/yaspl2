#:module (sexp-parser)
#:import {
  (bytes)
  (data lifted-primitives)
  (data source-location)
  (either)
  (lexer)
  (list)
  (maybe)
  (numbers)
  (prim)
}
(export
  (#:types Sexp SexpResult)
  (#:values parse-single-sexp parse-sexp parse-sexps node bytes-sexp number-sexp boolean-sexp symbol-sexp
            bracket-node)
  (#:patterns node brace-node bracket-node symbol-sexp bytes-sexp keyword-sexp boolean-sexp
              number-sexp bracket paren sexp-result sexp-result-error))
(types
  (define-type Sexp
    (node [list : (List Sexp)])
    (bracket-node [list : (List Sexp)])
    (brace-node [list : (List Sexp)])
    (symbol-sexp [bytes : Bytes])
    (bytes-sexp [bytes : Bytes])
    (keyword-sexp [bytes : Bytes])
    (boolean-sexp [v : Boolean])
    (number-sexp [byte : Int]))
  (define-type ParenStyle
    (bracket)
    (brace)
    (paren))

  (define-type Sexp/S
    (node/s [list : (List Sexp/S)] [source : SourceSpan])
    (bracket-node/s [list : (List Sexp/S)] [source : SourceSpan])
    (brace-node/s [list : (List Sexp/S)] [source : SourceSpan])
    (symbol-sexp/s [bytes : Bytes] [source : SourceSpan])
    (bytes-sexp/s [bytes : Bytes] [source : SourceSpan])
    (keyword-sexp/s [bytes : Bytes] [source : SourceSpan])
    (boolean-sexp/s [v : Boolean] [source : SourceSpan])
    (number-sexp/s [byte : Int] [source : SourceSpan]))

  (define-type SexpResult
    (sexp-result [v : Sexp/S] [lexer : Lexer])
    (sexp-result-error [v : Bytes])))

(define (parse-sexps [sbytes : SourcedBytes]) : (Either Bytes (List Sexp))
  (parse-sexps/acc (make-lexer sbytes) (empty)))

(define (parse-sexps/acc [lexer : Lexer] [acc : (List Sexp)]) : (Either Bytes (List Sexp))
  (let ([val (loop lexer)])
    (case val
      [(nothing) (right (reverse acc))]
      [(just (sexp-result v lexer))
       (parse-sexps/acc lexer (cons (drop-source v) acc))]
      [(just (sexp-result-error bytes)) (left bytes)])))

(define (parse-single-sexp [sbytes : SourcedBytes]) : (Either Bytes Sexp)
  (let ([lexer (make-lexer sbytes)])
    (let ([val (loop lexer)])
      (case val
        [(nothing) (left #"End of input")]
        [(just (sexp-result-error bytes)) (left bytes)]
        [(just (sexp-result v lexer))
          (case (run-lexer lexer)
            [(lex-result _v _lexer) (left #"Leftovers")]
            [(bad-input v) (left (bytes-append (varargs list #"Leftovers: Bad input: " v)))]
            [(end-of-input) (right (drop-source v))])]))))

(define (parse-sexp [lexer : Lexer]) : (Maybe SexpResult)
  (loop lexer))

(define (loop [lexer : Lexer]) : (Maybe SexpResult)
  (let ([val (run-lexer lexer)])
    (case val
      [(end-of-input) (nothing)]
      [(bad-input v)
       (just (sexp-result-error (bytes-append (varargs list #"Unable to lex input: " v))))]
      [(lex-result (source-span-annotated source v) lexer)
       (case v
         [(decimal-number-lexeme bytes)
          (case (decimal-bytes->integer bytes)
            [(nothing) (panic #"decimal-number-lexeme didn't contain a decimal number")]
            [(just (lifted-int n))
             (just (sexp-result (number-sexp/s n source) lexer))])]
         [(hexadecimal-number-lexeme bytes)
          (case (hexadecimal-bytes->integer bytes)
            [(nothing) (panic #"hexadecimal-number-lexeme didn't contain a hexadecimal number")]
            [(just (lifted-int n))
             (just (sexp-result (number-sexp/s n source) lexer))])]
         [(symbol-lexeme bytes) (just (sexp-result (symbol-sexp/s bytes source) lexer))]
         [(bytes-lexeme bytes) (just (sexp-result (bytes-sexp/s bytes source) lexer))]
         [(keyword-lexeme bytes) (just (sexp-result (keyword-sexp/s bytes source) lexer))]
         [(boolean-lexeme bool) (just (sexp-result (boolean-sexp/s bool source) lexer))]
         [(left-paren-lexeme) (just (node-loop (empty) source (paren) lexer))]
         [(left-bracket-lexeme) (just (node-loop (empty) source (bracket) lexer))]
         [(left-brace-lexeme) (just (node-loop (empty) source (brace) lexer))]
         [(comment-lexeme) (loop lexer)]
         [(right-bracket-lexeme) (just (sexp-result-error #"Unexpected ]."))]
         [(right-brace-lexeme) (just (sexp-result-error #"Unexpected }."))]
         [(right-paren-lexeme) (just (sexp-result-error #"Unexpected )."))])])))


(define (drop-source [s : Sexp/S]) : Sexp
  (case s
    [(node/s vs _) (node (map drop-source vs))]
    [(bracket-node/s vs _) (bracket-node (map drop-source vs))]
    [(brace-node/s vs _) (brace-node (map drop-source vs))]
    [(symbol-sexp/s v _) (symbol-sexp v)]
    [(bytes-sexp/s v _) (bytes-sexp v)]
    [(keyword-sexp/s v _) (keyword-sexp v)]
    [(boolean-sexp/s v _) (boolean-sexp v)]
    [(number-sexp/s v _) (number-sexp v)]))


(define (node-loop [vals : (List Sexp/S)] [source-start : SourceSpan]
                   [paren-style : ParenStyle] [lexer : Lexer])
  : SexpResult
  (let ([val (run-lexer lexer)])
    (case val
      [(end-of-input) (sexp-result-error #"Unexpected end of input.")]
      [(bad-input v) (sexp-result-error (bytes-append (varargs list #"Unable to lex input: " v)))]
      [(lex-result (source-span-annotated source v) lexer)
        (case v
          [(comment-lexeme)
           (node-loop vals source-start paren-style lexer)]
          [(symbol-lexeme bytes)
           (node-loop (cons (symbol-sexp/s bytes source) vals) source-start paren-style lexer)]
          [(decimal-number-lexeme bytes)
           (case (decimal-bytes->integer bytes)
             [(nothing) (panic #"decimal-number-lexeme didn't contain a decimal number")]
             [(just (lifted-int n))
              (node-loop (cons (number-sexp/s n source) vals) source-start paren-style lexer)])]
          [(hexadecimal-number-lexeme bytes)
           (case (hexadecimal-bytes->integer bytes)
             [(nothing) (panic #"hexadecimal-number-lexeme didn't contain a hexadecimal number")]
             [(just (lifted-int n))
              (node-loop (cons (number-sexp/s n source) vals) source-start paren-style lexer)])]
          [(bytes-lexeme bytes)
           (node-loop (cons (bytes-sexp/s bytes source) vals) source-start paren-style lexer)]
          [(keyword-lexeme bytes)
           (node-loop (cons (keyword-sexp/s bytes source) vals) source-start paren-style lexer)]
          [(boolean-lexeme bool)
           (node-loop (cons (boolean-sexp/s bool source) vals) source-start paren-style lexer)]
          [(left-paren-lexeme)
            (case (node-loop (empty) source (paren) lexer)
              [(sexp-result v lexer)
               (node-loop (cons v vals) source-start paren-style lexer)]
              [(sexp-result-error v) (sexp-result-error v)])]
          [(left-bracket-lexeme)
            (case (node-loop (empty) source (bracket) lexer)
              [(sexp-result v lexer)
               (node-loop (cons v vals) source-start paren-style lexer)]
              [(sexp-result-error v) (sexp-result-error v)])]
          [(left-brace-lexeme)
            (case (node-loop (empty) source (brace) lexer)
              [(sexp-result v lexer)
               (node-loop (cons v vals) source-start paren-style lexer)]
              [(sexp-result-error v) (sexp-result-error v)])]
          [(right-bracket-lexeme)
           (case paren-style
             [(bracket)
              (sexp-result (bracket-node/s (reverse vals) (full-span source-start source)) lexer)]
             [_ (sexp-result-error #"Unexpected ].")])]
          [(right-brace-lexeme)
           (case paren-style
             [(brace)
              (sexp-result (brace-node/s (reverse vals) (full-span source-start source)) lexer)]
             [_ (sexp-result-error #"Unexpected }.")])]
          [(right-paren-lexeme)
           (case paren-style
             [(paren)
              (sexp-result (node/s (reverse vals) (full-span source-start source)) lexer)]
             [_ (sexp-result-error #"Unexpected ).")])])])))

(define (full-span [s1 : SourceSpan] [s2 : SourceSpan]) : SourceSpan
  (match-define (source-span source1 start-line start-column _ _) s1)
  (match-define (source-span source2 _ _ end-line end-column) s2)
  (if (source=? source1 source2)
      (source-span source1 start-line start-column end-line end-column)
      (panic #"Broken sources")))
