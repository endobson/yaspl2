(module sexp-parser
  (import
    (lexer
      #:types (Lexer)
      #:values (make-lexer run-lexer lex-result-v lex-result-next)
      #:patterns (end-of-input bad-input lex-result))
    (numbers decimal-bytes->integer)
    (io read-all-bytes)

    (prim
      #:types (Bytes Byte InputPort OutputPort)
      #:values (void panic)
      #:patterns ())
    (either
      #:types (Either)
      #:values (left right)
      #:patterns (left right))
    (list
      #:types (List)
      #:values (cons empty reverse)
      #:patterns ()))
  (export Sexp parse-sexp main)
  (types
    (define-type Sexp
       (node [list (List Sexp)])
       (symbol-sexp [bytes Bytes])
       (number-sexp [byte Byte]))

    (define-type SexpResult
       (sexp-result [v Sexp] [lexer Lexer])
       (sexp-result-error)))



  (define (parse-sexp [bytes : Bytes]) : (Either Bytes Sexp)
    (let ([lexer (make-lexer bytes)])
      (let ([val (loop lexer)])
        (case val
          [(sexp-result v lexer)
            (case (run-lexer lexer)
              [(lex-result v lexer) (left #"Leftovers")]
              [(bad-input) (left #"Bad input")]
              [(end-of-input) (right v)])]
          [(sexp-result-error) (left #"Sexp result error")]))))

  (define (loop [lexer : Lexer]) : SexpResult
    (let ([val (run-lexer lexer)])
      (case val
        [(end-of-input) (sexp-result-error)]
        [(bad-input) (sexp-result-error)]
        [(lex-result v lexer)
          (case v
            [(number-lexeme bytes) (sexp-result (number-sexp (decimal-bytes->integer bytes)) lexer)]
            [(symbol-lexeme bytes) (sexp-result (symbol-sexp bytes) lexer)]
            [(left-paren-lexeme) (node-loop (empty) lexer)]
            [(right-paren-lexeme) (sexp-result-error)])])))

  (define (node-loop [vals : (List Sexp)] [lexer : Lexer]) : SexpResult
    (let ([val (run-lexer lexer)])
      (case val
        [(end-of-input) (sexp-result-error)]
        [(bad-input) (sexp-result-error)]
        [(lex-result v lexer)
          (case (lex-result-v val)
            [(symbol-lexeme bytes)
             (node-loop (cons (symbol-sexp bytes) vals) lexer)]
            [(number-lexeme bytes)
             (node-loop (cons (number-sexp (decimal-bytes->integer bytes)) vals) lexer)]
            [(left-paren-lexeme)
              (case (node-loop (empty) lexer)
                [(sexp-result v lexer)
                 (node-loop (cons v vals) lexer)]
                [(sexp-result-error) (sexp-result-error)])]
            [(right-paren-lexeme) (sexp-result (node (reverse vals)) lexer)])])))

  (define (main [stdin : InputPort] [stderr : OutputPort] [stdout : OutputPort]) : Byte
    (let ([result (parse-sexp (read-all-bytes stdin))])
      (case result
        [(right v) 0]
        [(left v) (panic v)]))))
