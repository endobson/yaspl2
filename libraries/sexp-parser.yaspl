(module sexp-parser
  (import
    (lexer
      #:types (Lexer)
      #:values (make-lexer run-lexer lex-result-v lex-result-next)
      #:patterns (end-of-input bad-input lex-result
                  symbol-lexeme decimal-number-lexeme hexadecimal-number-lexeme
                  left-paren-lexeme right-paren-lexeme
                  left-bracket-lexeme right-bracket-lexeme comment-lexeme
                  bytes-lexeme boolean-lexeme
                  keyword-lexeme))
    (numbers decimal-bytes->integer hexadecimal-bytes->integer)
    (io read-all-bytes write-line)
    (prim
      #:types (Bytes Byte InputPort OutputPort Boolean Array)
      #:values (void)
      #:patterns ())
    (either
      #:types (Either)
      #:values (left right)
      #:patterns (left right))
    (maybe
      #:types (Maybe)
      #:values (just nothing)
      #:patterns (just nothing))
    (list
      #:types (List)
      #:values (cons empty reverse)
      #:patterns ()))
  (export Sexp parse-sexp parse-sexps main)
  (types
    (define-type Sexp
      (node [list (List Sexp)])
      (symbol-sexp [bytes Bytes])
      (bytes-sexp [bytes Bytes])
      (keyword-sexp [bytes Bytes])
      (boolean-sexp [v Boolean])
      (number-sexp [byte Byte]))
    (define-type ParenStyle
      (bracket)
      (paren))

    (define-type SexpResult
      (sexp-result [v Sexp] [lexer Lexer])
      (sexp-result-error [v Bytes])))


  (define (parse-sexps [bytes : Bytes]) : (Either Bytes (List Sexp))
    (parse-sexps/acc (make-lexer bytes) (empty)))

  (define (parse-sexps/acc [lexer : Lexer] [acc : (List Sexp)]) : (Either Bytes (List Sexp))
    (let ([val (loop lexer)])
      (case val
        [(nothing) (right (reverse acc))]
        [(just (sexp-result v lexer))
         (parse-sexps/acc lexer (cons v acc))]
        [(just (sexp-result-error bytes)) (left bytes)])))


  (define (parse-sexp [bytes : Bytes]) : (Either Bytes Sexp)
    (let ([lexer (make-lexer bytes)])
      (let ([val (loop lexer)])
        (case val
          [(nothing) (left #"End of input")]
          [(just (sexp-result-error bytes)) (left bytes)]
          [(just (sexp-result v lexer))
            (case (run-lexer lexer)
              [(lex-result v lexer) (left #"Leftovers")]
              [(bad-input) (left #"Bad input")]
              [(end-of-input) (right v)])]))))

  (define (loop [lexer : Lexer]) : (Maybe SexpResult)
    (let ([val (run-lexer lexer)])
      (case val
        [(end-of-input) (nothing)]
        [(bad-input) (just (sexp-result-error #"Unable to lex input."))]
        [(lex-result v lexer)
         (case v
           [(decimal-number-lexeme bytes)
            (just (sexp-result (number-sexp (decimal-bytes->integer bytes)) lexer))]
           [(hexadecimal-number-lexeme bytes)
            (just (sexp-result (number-sexp (hexadecimal-bytes->integer bytes)) lexer))]
           [(symbol-lexeme bytes) (just (sexp-result (symbol-sexp bytes) lexer))]
           [(bytes-lexeme bytes) (just (sexp-result (bytes-sexp bytes) lexer))]
           [(keyword-lexeme bytes) (just (sexp-result (keyword-sexp bytes) lexer))]
           [(boolean-lexeme bool) (just (sexp-result (boolean-sexp bool) lexer))]
           [(left-paren-lexeme) (just (node-loop (empty) (paren) lexer))]
           [(left-bracket-lexeme) (just (node-loop (empty) (bracket) lexer))]
           [(comment-lexeme) (loop lexer)]
           [(right-bracket-lexeme) (just (sexp-result-error #"Unexpected ]."))]
           [(right-paren-lexeme) (just (sexp-result-error #"Unexpected )."))])])))

  (define (node-loop [vals : (List Sexp)] [paren-style : ParenStyle] [lexer : Lexer]) : SexpResult
    (let ([val (run-lexer lexer)])
      (case val
        [(end-of-input) (sexp-result-error #"Unexpected end of input.")]
        [(bad-input) (sexp-result-error #"Unable to lex input.")]
        [(lex-result v lexer)
          (case (lex-result-v val)
            [(comment-lexeme)
             (node-loop vals paren-style lexer)]
            [(symbol-lexeme bytes)
             (node-loop (cons (symbol-sexp bytes) vals) paren-style lexer)]
            [(decimal-number-lexeme bytes)
             (node-loop (cons (number-sexp (decimal-bytes->integer bytes)) vals) paren-style lexer)]
            [(hexadecimal-number-lexeme bytes)
             (node-loop (cons (number-sexp (hexadecimal-bytes->integer bytes)) vals) paren-style lexer)]
            [(bytes-lexeme bytes)
             (node-loop (cons (bytes-sexp bytes) vals) paren-style lexer)]
            [(keyword-lexeme bytes)
             (node-loop (cons (keyword-sexp bytes) vals) paren-style lexer)]
            [(boolean-lexeme bool)
             (node-loop (cons (boolean-sexp bool) vals) paren-style lexer)]
            [(left-paren-lexeme)
              (case (node-loop (empty) (paren) lexer)
                [(sexp-result v lexer)
                 (node-loop (cons v vals) paren-style lexer)]
                [(sexp-result-error v) (sexp-result-error v)])]
            [(left-bracket-lexeme)
              (case (node-loop (empty) (bracket) lexer)
                [(sexp-result v lexer)
                 (node-loop (cons v vals) paren-style lexer)]
                [(sexp-result-error v) (sexp-result-error v)])]
            [(right-bracket-lexeme)
             (case paren-style
               [(bracket) (sexp-result (node (reverse vals)) lexer)]
               [(paren) (sexp-result-error #"Unexpected ].")])]
            [(right-paren-lexeme)
             (case paren-style
               [(paren) (sexp-result (node (reverse vals)) lexer)]
               [(bracket) (sexp-result-error #"Unexpected ).")])])])))

  (define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Byte
    (let ([result (parse-sexp (read-all-bytes stdin))])
      (case result
        [(right v) 0]
        [(left v)
         (begin
           (write-line v stderr)
           1)]))))
