#:module sexp-parser
#:import {
  bytes {
    #:values
      bytes-append
  }
  either {
    #:types
      Either
    #:values
      left
      right
    #:patterns
      left
      right
  }
  io {
    #:values
      read-all-bytes
      write-line
  }
  lexer {
    #:types
      Lexer
    #:values
      make-lexer
      run-lexer
    #:patterns
      bad-input
      boolean-lexeme
      bytes-lexeme
      comment-lexeme
      decimal-number-lexeme
      end-of-input
      hexadecimal-number-lexeme
      keyword-lexeme
      left-brace-lexeme
      left-bracket-lexeme
      left-paren-lexeme
      lex-result
      right-brace-lexeme
      right-bracket-lexeme
      right-paren-lexeme
      symbol-lexeme
  }
  list {
    #:types
      List
    #:values
      cons
      empty
      list
      reverse
  }
  maybe {
    #:types
      Maybe
    #:values
      just
      nothing
    #:patterns
      just
      nothing
  }
  numbers {
    #:values
      decimal-bytes->integer
      hexadecimal-bytes->integer
  }
  prim {
    #:types
      Array
      Boolean
      Bytes
      InputPort
      Int
      OutputPort
    #:values
      panic
  }
}
(export
  #:types (Sexp)
  #:values (parse-sexp parse-sexps main node bytes-sexp number-sexp boolean-sexp symbol-sexp)
  #:patterns (node brace-node bracket-node symbol-sexp bytes-sexp keyword-sexp boolean-sexp
              number-sexp bracket paren))
(types
  (define-type Sexp
    (node [list : (List Sexp)])
    (bracket-node [list : (List Sexp)])
    (brace-node [list : (List Sexp)])
    (symbol-sexp [bytes : Bytes])
    (bytes-sexp [bytes : Bytes])
    (keyword-sexp [bytes : Bytes])
    (boolean-sexp [v : Boolean])
    (number-sexp [byte : Int]))
  (define-type ParenStyle
    (bracket)
    (brace)
    (paren))

  (define-type SexpResult
    (sexp-result [v : Sexp] [lexer : Lexer])
    (sexp-result-error [v : Bytes])))


(define (parse-sexps [bytes : Bytes]) : (Either Bytes (List Sexp))
  (parse-sexps/acc (make-lexer bytes) (empty)))

(define (parse-sexps/acc [lexer : Lexer] [acc : (List Sexp)]) : (Either Bytes (List Sexp))
  (let ([val (loop lexer)])
    (case val
      [(nothing) (right (reverse acc))]
      [(just (sexp-result v lexer))
       (parse-sexps/acc lexer (cons v acc))]
      [(just (sexp-result-error bytes)) (left bytes)])))


(define (parse-sexp [bytes : Bytes]) : (Either Bytes Sexp)
  (let ([lexer (make-lexer bytes)])
    (let ([val (loop lexer)])
      (case val
        [(nothing) (left #"End of input")]
        [(just (sexp-result-error bytes)) (left bytes)]
        [(just (sexp-result v lexer))
          (case (run-lexer lexer)
            [(lex-result v lexer) (left #"Leftovers")]
            [(bad-input v) (left (bytes-append (varargs list #"Leftovers: Bad input: " v)))]
            [(end-of-input) (right v)])]))))

(define (loop [lexer : Lexer]) : (Maybe SexpResult)
  (let ([val (run-lexer lexer)])
    (case val
      [(end-of-input) (nothing)]
      [(bad-input v)
       (just (sexp-result-error (bytes-append (varargs list #"Unable to lex input: " v))))]
      [(lex-result v lexer)
       (case v
         [(decimal-number-lexeme bytes)
          (case (decimal-bytes->integer bytes)
            [(nothing) (panic #"decimal-number-lexeme didn't contain a decimal number")]
            [(just n)
             (just (sexp-result (number-sexp n) lexer))])]
         [(hexadecimal-number-lexeme bytes)
          (case (hexadecimal-bytes->integer bytes)
            [(nothing) (panic #"hexadecimal-number-lexeme didn't contain a hexadecimal number")]
            [(just n)
             (just (sexp-result (number-sexp n) lexer))])]
         [(symbol-lexeme bytes) (just (sexp-result (symbol-sexp bytes) lexer))]
         [(bytes-lexeme bytes) (just (sexp-result (bytes-sexp bytes) lexer))]
         [(keyword-lexeme bytes) (just (sexp-result (keyword-sexp bytes) lexer))]
         [(boolean-lexeme bool) (just (sexp-result (boolean-sexp bool) lexer))]
         [(left-paren-lexeme) (just (node-loop (empty) (paren) lexer))]
         [(left-bracket-lexeme) (just (node-loop (empty) (bracket) lexer))]
         [(left-brace-lexeme) (just (node-loop (empty) (brace) lexer))]
         [(comment-lexeme) (loop lexer)]
         [(right-bracket-lexeme) (just (sexp-result-error #"Unexpected ]."))]
         [(right-brace-lexeme) (just (sexp-result-error #"Unexpected }."))]
         [(right-paren-lexeme) (just (sexp-result-error #"Unexpected )."))])])))

(define (node-loop [vals : (List Sexp)] [paren-style : ParenStyle] [lexer : Lexer]) : SexpResult
  (let ([val (run-lexer lexer)])
    (case val
      [(end-of-input) (sexp-result-error #"Unexpected end of input.")]
      [(bad-input v) (sexp-result-error (bytes-append (varargs list #"Unable to lex input: " v)))]
      [(lex-result v lexer)
        (case v
          [(comment-lexeme)
           (node-loop vals paren-style lexer)]
          [(symbol-lexeme bytes)
           (node-loop (cons (symbol-sexp bytes) vals) paren-style lexer)]
          [(decimal-number-lexeme bytes)
           (case (decimal-bytes->integer bytes)
             [(nothing) (panic #"decimal-number-lexeme didn't contain a decimal number")]
             [(just n)
              (node-loop (cons (number-sexp n) vals) paren-style lexer)])]
          [(hexadecimal-number-lexeme bytes)
           (case (hexadecimal-bytes->integer bytes)
             [(nothing) (panic #"hexadecimal-number-lexeme didn't contain a hexadecimal number")]
             [(just n)
              (node-loop (cons (number-sexp n) vals) paren-style lexer)])]
          [(bytes-lexeme bytes)
           (node-loop (cons (bytes-sexp bytes) vals) paren-style lexer)]
          [(keyword-lexeme bytes)
           (node-loop (cons (keyword-sexp bytes) vals) paren-style lexer)]
          [(boolean-lexeme bool)
           (node-loop (cons (boolean-sexp bool) vals) paren-style lexer)]
          [(left-paren-lexeme)
            (case (node-loop (empty) (paren) lexer)
              [(sexp-result v lexer)
               (node-loop (cons v vals) paren-style lexer)]
              [(sexp-result-error v) (sexp-result-error v)])]
          [(left-bracket-lexeme)
            (case (node-loop (empty) (bracket) lexer)
              [(sexp-result v lexer)
               (node-loop (cons v vals) paren-style lexer)]
              [(sexp-result-error v) (sexp-result-error v)])]
          [(left-brace-lexeme)
            (case (node-loop (empty) (brace) lexer)
              [(sexp-result v lexer)
               (node-loop (cons v vals) paren-style lexer)]
              [(sexp-result-error v) (sexp-result-error v)])]
          [(right-bracket-lexeme)
           (case paren-style
             [(bracket) (sexp-result (bracket-node (reverse vals)) lexer)]
             [_ (sexp-result-error #"Unexpected ].")])]
          [(right-brace-lexeme)
           (case paren-style
             [(brace) (sexp-result (brace-node (reverse vals)) lexer)]
             [_ (sexp-result-error #"Unexpected }.")])]
          [(right-paren-lexeme)
           (case paren-style
             [(paren) (sexp-result (node (reverse vals)) lexer)]
             [_ (sexp-result-error #"Unexpected ).")])])])))

(define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Int
  (let ([result (parse-sexp (read-all-bytes stdin))])
    (case result
      [(right v) 0]
      [(left v)
       (begin
         (write-line v stderr)
         1)])))
