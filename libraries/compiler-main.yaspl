(module compiler-main
  (import
    (bytes bytes-append)
    (compiler compile-modules parse-module-files)
    (either
      #:types ()
      #:values ()
      #:patterns (left right))
    (io write-line call-with-output-file)
    (list
      #:types ()
      #:values (array->list list)
      #:patterns (cons empty))
    (prim
      #:types (Array Bytes InputPort Int OutputPort)
      #:values ()
      #:patterns ())
    (x86-64-stack-machine compile-stack-machine write-fragments))
  (export
    #:types ()
    #:values (main)
    #:patterns ())
  (types)

  (define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Int
    (case (array->list args)
      [(empty)
       (begin
         (write-line #"No executable specified???" stderr)
         1)]
      [(cons _ (empty))
       (begin
         (write-line #"No output file name supplied." stderr)
         1)]
      [(cons _ (cons _ (empty)))
       (begin
         (write-line #"No module name supplied" stderr)
         1)]
      [(cons _ (cons output-file-name (cons module-name module-files)))
       (call-with-output-file output-file-name
         (lambda ([output : OutputPort])
           (case (parse-module-files module-files)
             [(left v)
              (begin
                (write-line v stderr)
                1)]
             [(right modules)
              (case (compile-modules modules)
                [(left v)
                 (begin
                   (write-line v stderr)
                   1)]
                [(right code)
                 (let ([assembly (compile-stack-machine
                                   (bytes-append (varargs list module-name #"_main"))
                                   code)])
                   (begin
                     (write-fragments assembly output)
                     0))])])))])))
