#:module (resolved-types-language)
#:import {
  (bytes)
  (data lifted-primitives)
  (data source-location)
  (dict)
  (either)
  (list)
  (maybe)
  (module-name)
  (module-signature)
  (prim)
  {(resolved-imports-language)
    {#:types
      [Block ri:Block]
      [BlockDefinition ri:BlockDefinition]
      [CaseClause ri:CaseClause]
      Export
      [Exports ri:Exports]
      [Expression ri:Expression]
      [FunctionArg ri:FunctionArg]
      [FunctionDefinition ri:FunctionDefinition]
      [Imports ri:Imports]
      [Module ri:Module]
      [Pattern ri:Pattern]
      PreType
      [TypeDefinition ri:TypeDefinition]
      [VariantDefinition ri:VariantDefinition]
      [VariantField ri:VariantField]
    }
    {#:values
      [type-definition-name ri:type-definition-name]
    }
    {#:patterns
      [abstraction-pattern ri:abstraction-pattern]
      [annotated-expr ri:annotated-expr]
      [app-expr ri:app-expr]
      [begin-expr ri:begin-expr]
      [block ri:block]
      [boolean-literal ri:boolean-literal]
      [bytes-literal ri:bytes-literal]
      [bytes-pattern ri:bytes-pattern]
      [case-clause ri:case-clause]
      [case-expr ri:case-expr]
      export
      [exports ri:exports]
      fun-pre-type
      [function-arg ri:function-arg]
      [function-definition ri:function-definition]
      [if-expr ri:if-expr]
      [ignore-pattern ri:ignore-pattern]
      [imports ri:imports]
      [int-literal ri:int-literal]
      [int-pattern ri:int-pattern]
      [lambda-expr ri:lambda-expr]
      [let-expr ri:let-expr]
      [match-def ri:match-def]
      [module ri:module]
      type-app-pre-type
      [type-definition ri:type-definition]
      [var-expr ri:var-expr]
      var-pre-type
      [varargs-app-expr ri:varargs-app-expr]
      [variable-pattern ri:variable-pattern]
      [variant-definition ri:variant-definition]
      [variant-field ri:variant-field]
    }
  }
  (sexp-printer)
  (top-level-name)
  (tuples)
  (types)
}
(export
  (#:types Module Block BlockDefinition CaseClause Expression FunctionDefinition FunctionArg TypeDefinition
           VariantDefinition VariantField Exports TypeExport PatternExport Imports Export Pattern)
  (#:values resolve-types module-definitions module-imports module-name case-clause-pattern
            function-definition-name function-arg-pattern function-arg-type
            type-definition-name variant-definition-name variant-field-type
            variant-field-name var-expr int-literal case-expr case-clause bytes-literal boolean-literal
            block app-expr bytes-pattern ignore-pattern)
  (#:patterns module annotated-expr app-expr type-export exports begin-expr block boolean-literal
              bytes-literal case-clause case-expr function-definition function-arg if-expr int-literal
              lambda-expr let-expr
              match-def type-definition var-expr varargs-app-expr variant-definition variant-field
              imports abstraction-pattern bytes-pattern export ignore-pattern int-pattern
              variable-pattern pattern-export))
(types
  (define-type Module
    (module [name : ModName]
            [imports : Imports]
            [exports : Exports]
            [types : (List TypeDefinition)]
            [definitions : (List FunctionDefinition)]))
  (define-type Imports
    (imports
      [values : (Dict Bytes ValueSignature)]
      [static-info : (Dict TopLevelName TopLevelSignature)]))
  (define-type Exports
    (exports [types : (List TypeExport)]
             [values : (List Export)]
             [patterns : (List PatternExport)]))
  (define-type TypeExport
    (type-export [exported-name : Bytes] [type : Type]))
  (define-type PatternExport
    (pattern-export [exported-name : Bytes] [desc : PatternSignature]))

  (define-type TypeDefinition
    (type-definition [name : Bytes] [vars : (Maybe (List Bytes))] [variants : (List VariantDefinition)]))

  (define-type VariantDefinition
    (variant-definition [name : Bytes] [fields : (List VariantField)]))
  (define-type VariantField
    (variant-field [name : Bytes] [type : Type]))

  (define-type FunctionDefinition
    (function-definition [name : Bytes]
                         [type-vars : (List Bytes)]
                         [args : (List FunctionArg)]
                         [return-type : Type]
                         [body : Block]))
  (define-type Block
    (block [definitions : (List BlockDefinition)] [expr : Expression]))
  (define-type BlockDefinition
    (match-def [pattern : Pattern] [type : (Maybe Type)] [expr : Expression]))

  (define-type Expression
    (int-literal [v : Int])
    (bytes-literal [v : Bytes])
    (boolean-literal [v : Boolean])
    (var-expr [v : Bytes])
    (annotated-expr [t : Type] [e : Expression])
    (if-expr [cond : Expression] [true : Expression] [false : Expression])
    (begin-expr [exprs : (List Expression)] [last-expr : Expression])
    (app-expr [tail-position : Boolean] [op : Expression] [args : (List Expression)])
    (varargs-app-expr [tail-position : Boolean] [op : Expression] [args : (List Expression)])
    (let-expr [name : Bytes] [expr : Expression] [body : Block])
    (lambda-expr [args : (List FunctionArg)] [type : (Maybe Type)] [body : Block])
    (case-expr [expr : Expression] [clauses : (List CaseClause)]))

  (define-type FunctionArg
    (function-arg
      [pattern : Pattern]
      [type : Type]))

  (define-type CaseClause
    (case-clause [pattern : Pattern] [body : Block]))

  (define-type Pattern
    (bytes-pattern [v : Bytes])
    (int-pattern [v : Int])
    (variable-pattern [v : Bytes])
    (ignore-pattern)
    (abstraction-pattern [descriptor : PatternSignature] [patterns : (List Pattern)]))

  (define-type Context
    (context
      [types : (Dict Bytes Type)]
      [patterns : (Dict Bytes PatternSignature)])))

(define (resolve-types [mod : ri:Module]) : (Either Bytes Module)
  (match-define ctx (init-context mod))
  (match-define (ri:module name imports exports types definitions) mod)
  (match-define error
    (lambda ([v : Bytes]) : (Either Bytes Module)
      (left (bytes-append (varargs list #"Error resolving types in " (mod-name->bytes name) #":\n" v)))))
  (case (resolve-types/type-defs types ctx)
    [(left v) (error v)]
    [(right types)
     (match-define ctx (context-add-defined-patterns ctx name types))
     (case (resolve-types/functions definitions ctx)
       [(left v) (error v)]
       [(right definitions)
        (case (resolve-types/exports exports ctx)
          [(left v) (error v)]
           [(right exports)
            (match-define imports (resolve-types/imports imports))
            (right (module name imports exports types definitions))])])]))

(define (init-context [mod : ri:Module]) : Context
  (match-define (ri:module mod-name imports _ type-defs _) mod)
  (match-define (ri:imports imported-types _ _ _) imports)
  (context
    (type-definitions->types mod-name type-defs imported-types)
    (imports->patterns imports)))

(define (context-add-defined-patterns [ctx : Context] [mod-name : ModName] [defs : (List TypeDefinition)])
  : Context
  (match-define (context types patterns) ctx)
  (context
    types
    (type-definitions->patterns mod-name defs patterns)))


(define (type-definitions->patterns [mod-name : ModName] [defs : (List TypeDefinition)]
                                    [acc : (Dict Bytes PatternSignature)])
  : (Dict Bytes PatternSignature)
  (foldl
    (lambda ([def : TypeDefinition] [acc : (Dict Bytes PatternSignature)])
      (type-definition->patterns mod-name def acc))
    defs
    acc))


(define (type-definition->patterns [mod-name : ModName] [def : TypeDefinition]
                                   [acc : (Dict Bytes PatternSignature)])
  : (Dict Bytes PatternSignature)
  (case def
    [(type-definition type-name type-vars variants)
     (let ([simple-type-vars (simplify-type-vars type-vars)])
       (let ([type-sig (type-signature (map variant-definition-name variants))])
         (foldl
           (lambda ([tagged-vdef : (Tuple2 VariantDefinition LiftedU8)]
                    [acc : (Dict Bytes PatternSignature)])
             (case tagged-vdef
               [(tuple2 (variant-definition variant-name fields) (lifted-u8 variant-tag))
                (dict-add
                  acc
                  variant-name
                  (pattern-signature
                    variant-name
                    variant-tag
                    mod-name
                    type-name
                    simple-type-vars
                    (map variant-field-type fields)
                    type-sig))]))
           (map/indexed
             (lambda ([vdef : VariantDefinition] [index : Int])
               (tuple2 vdef (lifted-u8 (u8 index))))
             variants)
           acc)))]))

(define (simplify-type-vars [type-vars : (Maybe (List Bytes))]) : (List Bytes)
  (case type-vars
    [(nothing) (empty)]
    [(just vars) vars]))

(define (imports->patterns [imports : ri:Imports])
  : (Dict Bytes PatternSignature)
  (case imports
    [(ri:imports _ _ patterns _) patterns]))

(define (type-definitions->types
          [mod-name : ModName]
          [defs : (List ri:TypeDefinition)]
          [acc : (Dict Bytes Type)]) : (Dict Bytes Type)
  (case defs
    [(empty) acc]
    [(cons def defs)
     (type-definitions->types
       mod-name
       defs
       (dict-add
         acc
         (ri:type-definition-name def)
         (type-definition->type mod-name def)))]))

(define (type-definition->type [mod-name : ModName] [def : ri:TypeDefinition]) : Type
  (case def
    [(ri:type-definition name (nothing) _)
     (abstract-type mod-name name (empty) (star-kind))]
    [(ri:type-definition name (just vars) _)
     (type-constructor mod-name name (map (lambda ([_v : Bytes]) (star-kind)) vars))]))

(define (resolve-types/exports [e : ri:Exports] [ctx : Context])
  : (Either Bytes Exports)
  (match-define (ri:exports types values patterns) e)
  (case (resolve-types/type-exports types ctx)
    [(left v) (left v)]
    [(right types)
     (case (resolve-types/pattern-exports patterns ctx)
       [(left v) (left v)]
       [(right patterns)
        (right (exports types values patterns))])]))

(define (resolve-types/type-exports [exports : (List Export)] [ctx : Context])
  : (Either Bytes (List TypeExport))
  (extract-rights
    (map
      (lambda ([export : Export]) (resolve-types/type-export export ctx))
      exports)))

(define (resolve-types/type-export [export : Export] [ctx : Context])
  : (Either Bytes TypeExport)
  (match-define (export local-name exported-name) export)
  (case (context-ref-type ctx local-name)
    [(nothing) (left (bytes-append (varargs list #"Unbound exported type:" local-name)))]
    [(just v)
     (right (type-export exported-name v))]))

(define (resolve-types/pattern-exports [exports : (List Export)] [ctx : Context])
  : (Either Bytes (List PatternExport))
  (extract-rights
    (map
      (lambda ([export : Export]) (resolve-types/pattern-export export ctx))
      exports)))

(define (resolve-types/pattern-export [export : Export] [ctx : Context])
  : (Either Bytes PatternExport)
  (match-define (export local-name exported-name) export)
  (case (context-ref-pattern ctx local-name)
    [(nothing) (left (bytes-append (varargs list #"Unbound exported pattern:" local-name)))]
    [(just v)
     (right (pattern-export exported-name v))]))

(define (resolve-types/type-defs [defs : (List ri:TypeDefinition)] [ctx : Context])
  : (Either Bytes (List TypeDefinition))
  (extract-rights
    (map
      (lambda ([def : ri:TypeDefinition]) (resolve-types/type-def def ctx))
      defs)))

(define (resolve-types/type-def [def : ri:TypeDefinition] [ctx : Context])
  : (Either Bytes TypeDefinition)
  (match-define (ri:type-definition name vars variants) def)
  (match-define ctx
    (case vars
      [(nothing) ctx]
      [(just vars)
       (context-add-var-types ctx vars)]))
  (case (resolve-types/variants variants ctx)
    [(left v) (left v)]
    [(right variants)
     (right (type-definition name vars variants))]))


(define (resolve-types/variants [defs : (List ri:VariantDefinition)] [ctx : Context])
  : (Either Bytes (List VariantDefinition))
  (extract-rights
    (map
      (lambda ([def : ri:VariantDefinition]) (resolve-types/variant def ctx))
      defs)))

(define (resolve-types/variant [def : ri:VariantDefinition] [ctx : Context])
  : (Either Bytes VariantDefinition)
  (match-define (ri:variant-definition name fields) def)
  (case (resolve-types/variant-fields fields ctx)
    [(left v) (left v)]
    [(right fields)
     (right (variant-definition name fields))]))


(define (resolve-types/variant-fields [fields : (List ri:VariantField)] [ctx : Context])
  : (Either Bytes (List VariantField))
  (extract-rights
    (map
      (lambda ([field : ri:VariantField]) (resolve-types/variant-field field ctx))
      fields)))

(define (resolve-types/variant-field [def : ri:VariantField] [ctx : Context])
  : (Either Bytes VariantField)
  (match-define (ri:variant-field name type) def)
  (case (pre-type->type type ctx)
    [(left v) (left v)]
    [(right type)
     (right (variant-field name type))]))


(define (resolve-types/functions [defs : (List ri:FunctionDefinition)] [ctx : Context])
  : (Either Bytes (List FunctionDefinition))
  (extract-rights
    (map
      (lambda ([def : ri:FunctionDefinition]) (resolve-types/function def ctx))
      defs)))

(define (resolve-types/function [def : ri:FunctionDefinition] [ctx : Context])
  : (Either Bytes FunctionDefinition)
  (match-define (ri:function-definition name type-vars args return-type body) def)
  (match-define ctx (context-add-var-types ctx type-vars))
  (case (resolve-types/args args ctx)
    [(left v) (left v)]
    [(right args)
     (case (pre-type->type return-type ctx)
       [(left v) (left v)]
       [(right return-type)
        (case (resolve-types/block body ctx)
          [(left v) (left v)]
          [(right body)
           (right (function-definition name type-vars args return-type body))])])]))

(define (resolve-types/args [args : (List ri:FunctionArg)] [ctx : Context])
  : (Either Bytes (List FunctionArg))
  (extract-rights
    (map (lambda ([arg : ri:FunctionArg]) : (Either Bytes FunctionArg)
           (case arg
             [(ri:function-arg pattern pre-type)
              (case (resolve-types/pattern pattern ctx)
                [(left v) (left v)]
                [(right pattern)
                 (case (pre-type->type pre-type ctx)
                   [(left v) (left v)]
                   [(right type)
                    (case (type->kind type)
                      [(fun-kind _ _)
                       (left (bytes-append (varargs list
                                #"Function argument type's kind must corespond to a value, got: "
                                (print-type type))))]
                      [(star-kind)
                       (right (function-arg pattern type))]
                      [(prim64-kind)
                       (right (function-arg pattern type))])])])]))
         args)))

(define (resolve-types/exprs [exprs : (List ri:Expression)] [ctx : Context])
  : (Either Bytes (List Expression))
  (extract-rights
    (map
      (lambda ([expr : ri:Expression]) (resolve-types/expr expr ctx))
      exprs)))

(define (resolve-types/expr [expr : ri:Expression] [ctx : Context]) : (Either Bytes Expression)
  (case expr
    [(ri:lambda-expr args maybe-return-type body)
     (case (resolve-types/args args ctx)
       [(left v) (left v)]
       [(right args)
        (case
          (ann (Either Bytes (Maybe Type))
            (case maybe-return-type
              [(nothing) (right (nothing))]
              [(just return-type)
               (case (pre-type->type return-type ctx)
                 [(left v) (left v)]
                 [(right t)
                  (right (just t))])]))
          [(left v) (left v)]
          [(right maybe-return-type)
           (case (resolve-types/block body ctx)
             [(left v) (left v)]
             [(right body)
              (right (lambda-expr args maybe-return-type body))])])])]
    [(ri:annotated-expr pre-type expr)
     (case (pre-type->type pre-type ctx)
       [(left v) (left v)]
       [(right type)
        (case (resolve-types/expr expr ctx)
          [(left v) (left v)]
          [(right expr)
           (right (annotated-expr type expr))])])]
    ;; Recur structurally
    [(ri:var-expr v)
     (right (var-expr v))]
    [(ri:int-literal v)
     (right (int-literal v))]
    [(ri:bytes-literal v)
     (right (bytes-literal v))]
    [(ri:boolean-literal v)
     (right (boolean-literal v))]
    [(ri:if-expr c t f)
     (case (resolve-types/expr c ctx)
       [(left v) (left v)]
       [(right c)
        (case (resolve-types/expr t ctx)
          [(left v) (left v)]
          [(right t)
           (case (resolve-types/expr f ctx)
             [(left v) (left v)]
             [(right f)
              (right (if-expr c t f))])])])]
    [(ri:begin-expr void-exprs last-expr)
     (case (resolve-types/exprs void-exprs ctx)
       [(left v) (left v)]
       [(right void-exprs)
        (case (resolve-types/expr last-expr ctx)
          [(left v) (left v)]
          [(right last-expr)
           (right (begin-expr void-exprs last-expr))])])]
    [(ri:let-expr name expr body)
     (case (resolve-types/expr expr ctx)
       [(left v) (left v)]
       [(right expr)
        (case (resolve-types/block body ctx)
          [(left v) (left v)]
          [(right body)
           (right (let-expr name expr body))])])]
    [(ri:app-expr tail-position op args)
     (case (resolve-types/expr op ctx)
       [(left v) (left v)]
       [(right op)
        (case (resolve-types/exprs args ctx)
          [(left v) (left v)]
          [(right args)
           (right (app-expr tail-position op args))])])]
    [(ri:varargs-app-expr tail-position op args)
     (case (resolve-types/expr op ctx)
       [(left v) (left v)]
       [(right op)
        (case (resolve-types/exprs args ctx)
          [(left v) (left v)]
          [(right args)
           (right (varargs-app-expr tail-position op args))])])]
    [(ri:case-expr expr clauses)
     (case (resolve-types/expr expr ctx)
       [(left v) (left v)]
       [(right expr)
        (case (resolve-types/case-clauses clauses ctx)
          [(left v) (left v)]
          [(right clauses)
           (right (case-expr expr clauses))])])]))


(define (resolve-types/case-clauses [clauses : (List ri:CaseClause)] [ctx : Context])
  : (Either Bytes (List CaseClause))
  (extract-rights
    (map
      (lambda ([clause : ri:CaseClause]) (resolve-types/case-clause clause ctx))
      clauses)))

(define (resolve-types/case-clause [clause : ri:CaseClause] [ctx : Context])
  : (Either Bytes CaseClause)
  (match-define (ri:case-clause pattern body) clause)
  (case (resolve-types/pattern pattern ctx)
    [(left v) (left v)]
    [(right pattern)
     (case (resolve-types/block body ctx)
       [(left v) (left v)]
       [(right body)
        (right (case-clause pattern body))])]))

(define (resolve-types/block [b : ri:Block] [ctx : Context])
  : (Either Bytes Block)
  (match-define (ri:block defs expr) b)
  (case
    (extract-rights
      (map
        (lambda ([def : ri:BlockDefinition]) : (Either Bytes BlockDefinition)
          (case def
            [(ri:match-def pattern type expr)
             (case (resolve-types/pattern pattern ctx)
               [(left v) (left v)]
               [(right pattern)
                (case
                  (ann (Either Bytes (Maybe Type))
                    (case type
                      [(nothing) (right (nothing))]
                      [(just type)
                       (case (pre-type->type type ctx)
                         [(left v) (left v)]
                         [(right t)
                          (right (just t))])]))
                  [(left v) (left v)]
                  [(right type)
                   (case (resolve-types/expr expr ctx)
                     [(left v) (left v)]
                     [(right expr)
                      (right (match-def pattern type expr))])])])]))
        defs))
    [(left v) (left v)]
    [(right defs)
     (case (resolve-types/expr expr ctx)
       [(left v) (left v)]
       [(right expr)
        (right (block defs expr))])]))

(define (resolve-types/pattern [pattern : ri:Pattern] [ctx : Context])
  : (Either Bytes Pattern)
  (case pattern
    [(ri:bytes-pattern v _)
     (right (bytes-pattern v))]
    [(ri:int-pattern v _)
     (right (int-pattern v))]
    [(ri:variable-pattern v _)
     (right (variable-pattern v))]
    [(ri:ignore-pattern _)
     (right (ignore-pattern))]
    [(ri:abstraction-pattern (source-span-annotated _ name) patterns _)
     (case (context-ref-pattern ctx name)
       [(nothing) (left #"Unbound pattern")]
       [(just descriptor)
        (case (extract-rights
                (map
                  (lambda ([p : ri:Pattern])
                    (resolve-types/pattern p ctx))
                  patterns))
          [(left v) (left v)]
          [(right patterns)
           (right (abstraction-pattern descriptor patterns))])])]))

(define (resolve-types/imports [i : ri:Imports]) : Imports
  (case i
    [(ri:imports _types values _patterns static-info)
     (imports values static-info)]))

(define (context-ref-type [ctx : Context] [name : Bytes]) : (Maybe Type)
  (case ctx
    [(context types _patterns)
     (dict-ref types name)]))

(define (context-add-type [ctx : Context] [name : Bytes] [type : Type]) : Context
  (case ctx
    [(context types patterns)
     (context (dict-add types name type) patterns)]))

(define (context-add-var-types [context : Context] [names : (List Bytes)]) : Context
  (case names
    [(empty) context]
    [(cons name names)
     (context-add-var-types
       (context-add-type context name (var-type name))
       names)]))

(define (context-ref-pattern [ctx : Context] [name : Bytes]) : (Maybe PatternSignature)
  (case ctx
    [(context _types patterns)
     (dict-ref patterns name)]))

(define (pre-type->type [pre : PreType] [context : Context]) : (Either Bytes Type)
  (case pre
    [(var-pre-type v _)
     (case (context-ref-type context v)
       [(nothing) (left (bytes-append (varargs list #"Unbound type variable: " v)))]
       [(just v) (right v)])]
    [(fun-pre-type type-vars args result _)
     (match-define context (context-add-var-types context type-vars))
     (match-define recur (lambda ([pre : PreType]) (pre-type->type pre context)))
     (case (extract-rights (map recur args))
       [(left v) (left v)]
       [(right args)
        (case (recur result)
          [(left v) (left v)]
          [(right result)
           (right (fun-type type-vars args result))])])]
    [(type-app-pre-type constructor args _)
     (case (context-ref-type context constructor)
       [(nothing) (left (bytes-append (varargs list #"Unbound type constructor: " constructor)))]
       ;; TODO actually check that the kind of the argument types match the expected kinds
       [(just (type-constructor mod-name name arg-kinds))
        (case (zip args arg-kinds)
          [(just args+kinds)
           (case (extract-rights
                   (map (lambda ([t : (Tuple2 PreType Kind)]) : (Either Bytes Type)
                          (case t
                            [(tuple2 pre kind)
                             (case (pre-type->type pre context)
                               [(left v) (left v)]
                               [(right t)
                                (if (kind=? kind (type->kind t))
                                    (right t)
                                    (left
                                      #"Kind doesn't match in type constructor application"))])]))
                          args+kinds))
             [(left v) (left v)]
             [(right types)
              (right (abstract-type mod-name name types (star-kind)))])]
          [(nothing)
           (left #"Number of arguments to type constructor doesn't match.")])]
       [(just t)
        (left
          (bytes-append
            (varargs list
              #"Cannot apply non constructor type: "
              (print-sexp (type->sexp t)))))])]))
