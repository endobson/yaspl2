#:module (resolved-types-language)
#:import {
  (bytes)
  (data source-location)
  (dict)
  (either)
  (list)
  (maybe)
  (module-name)
  (module-signature)
  (prim)
  {(resolved-imports-language)
    {#:types
      [Block ri:Block]
      [BlockDefinition ri:BlockDefinition]
      [CaseClause ri:CaseClause]
      Export
      [Exports ri:Exports]
      [Expression ri:Expression]
      [FunctionArg ri:FunctionArg]
      [FunctionDefinition ri:FunctionDefinition]
      [Imports ri:Imports]
      [Module ri:Module]
      [Pattern ri:Pattern]
      PreType
      [StaticDefinition ri:StaticDefinition]
      [TypeDefinition ri:TypeDefinition]
      [VariantDefinition ri:VariantDefinition]
      [VariantField ri:VariantField]
    }
    {#:values
      pre-type-source-span
      [type-definition-name ri:type-definition-name]
    }
    {#:patterns
      [abstraction-pattern ri:abstraction-pattern]
      [annotated-expr ri:annotated-expr]
      [app-expr ri:app-expr]
      [begin-expr ri:begin-expr]
      [block ri:block]
      [boolean-literal ri:boolean-literal]
      [bytes-literal ri:bytes-literal]
      [bytes-pattern ri:bytes-pattern]
      [case-clause ri:case-clause]
      [case-expr ri:case-expr]
      export
      [exports ri:exports]
      fun-pre-type
      [function-arg ri:function-arg]
      [function-definition ri:function-definition]
      [if-expr ri:if-expr]
      [ignore-pattern ri:ignore-pattern]
      [imports ri:imports]
      [int-literal ri:int-literal]
      [int-pattern ri:int-pattern]
      [lambda-expr ri:lambda-expr]
      [let-expr ri:let-expr]
      [match-def ri:match-def]
      [module ri:module]
      type-app-pre-type
      [type-definition ri:type-definition]
      [var-expr ri:var-expr]
      var-pre-type
      [varargs-app-expr ri:varargs-app-expr]
      [varargs-definition ri:varargs-definition]
      [variable-pattern ri:variable-pattern]
      [variant-definition ri:variant-definition]
      [variant-field ri:variant-field]
    }
  }
  (top-level-name)
  (tuples)
  (types)
}
(export
  (#:types Module Block BlockDefinition CaseClause Expression FunctionDefinition FunctionArg TypeDefinition
           VariantDefinition VariantField Exports TypeExport Imports Export Pattern
           StaticDefinition TypeResolutionError)
  (#:values resolve-types module-definitions module-imports module-name case-clause-pattern
            function-definition-name function-arg-pattern function-arg-type
            type-definition-name variant-definition-name variant-field-type
            variant-field-name var-expr int-literal case-expr case-clause bytes-literal boolean-literal
            block app-expr bytes-pattern ignore-pattern pattern-source-span exports
            imports-patterns type-resolution-error->bytes)
  (#:patterns module annotated-expr app-expr type-export exports begin-expr block boolean-literal
              bytes-literal case-clause case-expr function-definition function-arg if-expr int-literal
              lambda-expr let-expr
              match-def type-definition var-expr varargs-app-expr
              variant-definition variant-field
              imports abstraction-pattern bytes-pattern export ignore-pattern int-pattern
              variable-pattern varargs-definition))
(types
  (define-type Module
    (module [name : ModName]
            [imports : Imports]
            [exports : Exports]
            [types : (List TypeDefinition)]
            [definitions : (List FunctionDefinition)]
            [static-definitions : (List StaticDefinition)]))
  (define-type Imports
    (imports
      [values : (Dict Bytes ValueSignature)]
      [patterns : (Dict Bytes PatternSignature)]
      [static-bindings : (Dict Bytes StaticSignature)]
      [static-info : (Dict TopLevelName TopLevelSignature)]))
  (define-type Exports
    (exports [types : (List TypeExport)]
             [values : (List Export)]
             [patterns : (List Export)]
             [statics : (List Export)]))
  (define-type TypeExport
    (type-export [exported-name : Bytes] [type : Type]))

  (define-type TypeDefinition
    (type-definition [name : Bytes] [vars : (Maybe (List Bytes))] [variants : (List VariantDefinition)]))

  (define-type VariantDefinition
    (variant-definition [name : Bytes] [fields : (List VariantField)]))
  (define-type VariantField
    (variant-field [name : Bytes] [type : Type]))

  (define-type FunctionDefinition
    (function-definition [name : Bytes]
                         [type-vars : (List Bytes)]
                         [args : (List FunctionArg)]
                         [return-type : (SourceSpanAnnotated Type)]
                         [body : Block]))
  (define-type Block
    (block [definitions : (List BlockDefinition)] [expr : Expression]))
  (define-type BlockDefinition
    (match-def [pattern : Pattern] [type : (Maybe Type)] [expr : Expression]))

  (define-type Expression
    (int-literal [v : Int] [source : SourceSpan])
    (bytes-literal [v : Bytes] [source : SourceSpan])
    (boolean-literal [v : Boolean] [source : SourceSpan])
    (var-expr [v : Bytes] [source : SourceSpan])
    (annotated-expr [t : Type] [e : Expression] [source : SourceSpan])
    (if-expr [cond : Expression] [true : Expression] [false : Expression] [source : SourceSpan])
    (begin-expr [exprs : (List Expression)] [last-expr : Expression] [source : SourceSpan])
    (app-expr [tail-position : Boolean] [op : Expression] [args : (List Expression)]
              [source : SourceSpan])
    (varargs-app-expr [tail-position : Boolean] [op : (SourceSpanAnnotated Bytes)] [args : (List Expression)]
                      [source : SourceSpan])
    (let-expr [name : Bytes] [expr : Expression] [body : Block] [source : SourceSpan])
    (lambda-expr [args : (List FunctionArg)] [type : (Maybe Type)] [body : Block] [source : SourceSpan])
    (case-expr [expr : Expression] [clauses : (List CaseClause)] [source : SourceSpan]))

  (define-type FunctionArg
    (function-arg
      [pattern : Pattern]
      [type : Type]))

  (define-type CaseClause
    (case-clause [pattern : Pattern] [body : Block]))

  (define-type Pattern
    (bytes-pattern [v : Bytes] [source : SourceSpan])
    (int-pattern [v : Int] [source : SourceSpan])
    (variable-pattern [v : Bytes] [source : SourceSpan])
    (ignore-pattern [source : SourceSpan])
    (abstraction-pattern [name : Bytes] [patterns : (List Pattern)] [source : SourceSpan]))

  (define-type StaticDefinition
    (varargs-definition [name : Bytes]
                        [type-vars : (List Bytes)]
                        [arg-type : Type]
                        [return-type : Type]
                        [cons-func : (SourceSpanAnnotated Bytes)]
                        [empty-func : (SourceSpanAnnotated Bytes)]))

  (define-type Context
    (context
      [types : (Dict Bytes Type)]))

  (define-type TypeResolutionError
    (type-resolution-error [mod-name : ModName] [err : LocalTypeResolutionError]))
  (define-type LocalTypeResolutionError
    (unbound-type-variable [variable : Bytes])
    (type-constructor-bad-arg-kind)
    (type-constructor-bad-number-of-args)
    (type-constructor-bad-constructor [t : Type])
    (function-definition-bad-arg-kind [t : Type])))


(define (resolve-types [mod : ri:Module]) : (Either TypeResolutionError Module)
  (match-define ctx (init-context mod))
  (match-define (ri:module name imports exports types definitions statics) mod)
  (match-define error
    (lambda ([v : LocalTypeResolutionError]) : (Either TypeResolutionError Module)
      (left (type-resolution-error name v))))
  (case (resolve-types/type-defs types ctx)
    [(left v) (error v)]
    [(right types)
     (case (resolve-types/functions definitions ctx)
       [(left v) (error v)]
       [(right definitions)
        (case (resolve-types/exports exports ctx)
          [(left v) (error v)]
          [(right exports)
           (case (resolve-types/statics statics ctx)
             [(left v) (error v)]
             [(right statics)
              (match-define imports (resolve-types/imports imports))
              (right (module name imports exports types definitions statics))])])])]))

(define (init-context [mod : ri:Module]) : Context
  (match-define (ri:module mod-name imports _ type-defs _ _) mod)
  (match-define (ri:imports imported-types _ _ _ _) imports)
  (context
    (type-definitions->types mod-name type-defs imported-types)))

(define (type-definitions->types
          [mod-name : ModName]
          [defs : (List ri:TypeDefinition)]
          [acc : (Dict Bytes Type)]) : (Dict Bytes Type)
  (case defs
    [(empty) acc]
    [(cons def defs)
     (type-definitions->types
       mod-name
       defs
       (dict-add
         acc
         (ri:type-definition-name def)
         (type-definition->type mod-name def)))]))

(define (type-definition->type [mod-name : ModName] [def : ri:TypeDefinition]) : Type
  (case def
    [(ri:type-definition name (nothing) _)
     (abstract-type mod-name name (empty) (star-kind))]
    [(ri:type-definition name (just vars) _)
     (type-constructor mod-name name (map (lambda ([_v : Bytes]) (star-kind)) vars))]))

(define (resolve-types/exports [e : ri:Exports] [ctx : Context])
  : (Either LocalTypeResolutionError Exports)
  (match-define (ri:exports types values patterns statics) e)
  (case (resolve-types/type-exports types ctx)
    [(left v) (left v)]
    [(right types)
     (right (exports types values patterns statics))]))

(define (resolve-types/type-exports [exports : (List Export)] [ctx : Context])
  : (Either LocalTypeResolutionError (List TypeExport))
  (extract-rights
    (map
      (lambda ([export : Export]) (resolve-types/type-export export ctx))
      exports)))

(define (resolve-types/type-export [export : Export] [ctx : Context])
  : (Either LocalTypeResolutionError TypeExport)
  (match-define (export local-name exported-name) export)
  (case (context-ref-type ctx local-name)
    [(nothing) (left (unbound-type-variable local-name))]
    [(just v)
     (right (type-export exported-name v))]))

(define (resolve-types/statics [statics : (List ri:StaticDefinition)] [ctx : Context])
  : (Either LocalTypeResolutionError (List StaticDefinition))
  (extract-rights
    (map
      (lambda ([static : ri:StaticDefinition])
        : (Either LocalTypeResolutionError StaticDefinition)
        (case static
          [(ri:varargs-definition name type-vars arg-type return-type cons-func empty-func)
           (match-define ctx (context-add-var-types ctx type-vars))
           (case (pre-type->type arg-type ctx)
             [(left v) (left v)]
             [(right arg-type)
              (case (pre-type->type return-type ctx)
                [(left v) (left v)]
                [(right return-type)
                 (right (varargs-definition name type-vars arg-type return-type cons-func
                                            empty-func))])])]))
      statics)))

(define (resolve-types/type-defs [defs : (List ri:TypeDefinition)] [ctx : Context])
  : (Either LocalTypeResolutionError (List TypeDefinition))
  (extract-rights
    (map
      (lambda ([def : ri:TypeDefinition]) (resolve-types/type-def def ctx))
      defs)))

(define (resolve-types/type-def [def : ri:TypeDefinition] [ctx : Context])
  : (Either LocalTypeResolutionError TypeDefinition)
  (match-define (ri:type-definition name vars variants) def)
  (match-define ctx
    (case vars
      [(nothing) ctx]
      [(just vars)
       (context-add-var-types ctx vars)]))
  (case (resolve-types/variants variants ctx)
    [(left v) (left v)]
    [(right variants)
     (right (type-definition name vars variants))]))


(define (resolve-types/variants [defs : (List ri:VariantDefinition)] [ctx : Context])
  : (Either LocalTypeResolutionError (List VariantDefinition))
  (extract-rights
    (map
      (lambda ([def : ri:VariantDefinition]) (resolve-types/variant def ctx))
      defs)))

(define (resolve-types/variant [def : ri:VariantDefinition] [ctx : Context])
  : (Either LocalTypeResolutionError VariantDefinition)
  (match-define (ri:variant-definition name fields) def)
  (case (resolve-types/variant-fields fields ctx)
    [(left v) (left v)]
    [(right fields)
     (right (variant-definition name fields))]))


(define (resolve-types/variant-fields [fields : (List ri:VariantField)] [ctx : Context])
  : (Either LocalTypeResolutionError (List VariantField))
  (extract-rights
    (map
      (lambda ([field : ri:VariantField]) (resolve-types/variant-field field ctx))
      fields)))

(define (resolve-types/variant-field [def : ri:VariantField] [ctx : Context])
  : (Either LocalTypeResolutionError VariantField)
  (match-define (ri:variant-field name type) def)
  (case (pre-type->type type ctx)
    [(left v) (left v)]
    [(right type)
     (right (variant-field name type))]))


(define (resolve-types/functions [defs : (List ri:FunctionDefinition)] [ctx : Context])
  : (Either LocalTypeResolutionError (List FunctionDefinition))
  (extract-rights
    (map
      (lambda ([def : ri:FunctionDefinition]) (resolve-types/function def ctx))
      defs)))

(define (resolve-types/function [def : ri:FunctionDefinition] [ctx : Context])
  : (Either LocalTypeResolutionError FunctionDefinition)
  (match-define (ri:function-definition name type-vars args return-pre-type body) def)
  (match-define ctx (context-add-var-types ctx type-vars))
  (case (resolve-types/args args ctx)
    [(left v) (left v)]
    [(right args)
     (case (pre-type->type return-pre-type ctx)
       [(left v) (left v)]
       [(right return-type)
        (case (resolve-types/block body ctx)
          [(left v) (left v)]
          [(right body)
           (match-define ann-return-type
             (source-span-annotated return-type (pre-type-source-span return-pre-type)))
           (right (function-definition name type-vars args ann-return-type body))])])]))

(define (resolve-types/args [args : (List ri:FunctionArg)] [ctx : Context])
  : (Either LocalTypeResolutionError (List FunctionArg))
  (extract-rights
    (map (lambda ([arg : ri:FunctionArg]) : (Either LocalTypeResolutionError FunctionArg)
           (case arg
             [(ri:function-arg pattern pre-type)
              (case (resolve-types/pattern pattern ctx)
                [(left v) (left v)]
                [(right pattern)
                 (case (pre-type->type pre-type ctx)
                   [(left v) (left v)]
                   [(right type)
                    (case (type->kind type)
                      [(fun-kind _ _)
                       (left (function-definition-bad-arg-kind type))]
                      [(star-kind)
                       (right (function-arg pattern type))]
                      [(prim64-kind)
                       (right (function-arg pattern type))])])])]))
         args)))

(define (resolve-types/exprs [exprs : (List ri:Expression)] [ctx : Context])
  : (Either LocalTypeResolutionError (List Expression))
  (extract-rights
    (map
      (lambda ([expr : ri:Expression]) (resolve-types/expr expr ctx))
      exprs)))

(define (resolve-types/expr [expr : ri:Expression] [ctx : Context])
  : (Either LocalTypeResolutionError Expression)
  (case expr
    [(ri:lambda-expr args maybe-return-type body src)
     (case (resolve-types/args args ctx)
       [(left v) (left v)]
       [(right args)
        (case (maybe-pre-type->maybe-type maybe-return-type ctx)
          [(left v) (left v)]
          [(right maybe-return-type)
           (case (resolve-types/block body ctx)
             [(left v) (left v)]
             [(right body)
              (right (lambda-expr args maybe-return-type body src))])])])]
    [(ri:annotated-expr pre-type expr src)
     (case (pre-type->type pre-type ctx)
       [(left v) (left v)]
       [(right type)
        (case (resolve-types/expr expr ctx)
          [(left v) (left v)]
          [(right expr)
           (right (annotated-expr type expr src))])])]
    ;; Recur structurally
    [(ri:var-expr v src)
     (right (var-expr v src))]
    [(ri:int-literal v src)
     (right (int-literal v src))]
    [(ri:bytes-literal v src)
     (right (bytes-literal v src))]
    [(ri:boolean-literal v src)
     (right (boolean-literal v src))]
    [(ri:if-expr c t f src)
     (case (resolve-types/expr c ctx)
       [(left v) (left v)]
       [(right c)
        (case (resolve-types/expr t ctx)
          [(left v) (left v)]
          [(right t)
           (case (resolve-types/expr f ctx)
             [(left v) (left v)]
             [(right f)
              (right (if-expr c t f src))])])])]
    [(ri:begin-expr void-exprs last-expr src)
     (case (resolve-types/exprs void-exprs ctx)
       [(left v) (left v)]
       [(right void-exprs)
        (case (resolve-types/expr last-expr ctx)
          [(left v) (left v)]
          [(right last-expr)
           (right (begin-expr void-exprs last-expr src))])])]
    [(ri:let-expr (source-span-annotated name _) expr body src)
     (case (resolve-types/expr expr ctx)
       [(left v) (left v)]
       [(right expr)
        (case (resolve-types/block body ctx)
          [(left v) (left v)]
          [(right body)
           (right (let-expr name expr body src))])])]
    [(ri:app-expr tail-position op args src)
     (case (resolve-types/expr op ctx)
       [(left v) (left v)]
       [(right op)
        (case (resolve-types/exprs args ctx)
          [(left v) (left v)]
          [(right args)
           (right (app-expr tail-position op args src))])])]
    [(ri:varargs-app-expr tail-position op args src)
     (case (resolve-types/exprs args ctx)
       [(left v) (left v)]
       [(right args)
        (right (varargs-app-expr tail-position op args src))])]
    [(ri:case-expr expr clauses src)
     (case (resolve-types/expr expr ctx)
       [(left v) (left v)]
       [(right expr)
        (case (resolve-types/case-clauses clauses ctx)
          [(left v) (left v)]
          [(right clauses)
           (right (case-expr expr clauses src))])])]))


(define (resolve-types/case-clauses [clauses : (List ri:CaseClause)] [ctx : Context])
  : (Either LocalTypeResolutionError (List CaseClause))
  (extract-rights
    (map
      (lambda ([clause : ri:CaseClause]) (resolve-types/case-clause clause ctx))
      clauses)))

(define (resolve-types/case-clause [clause : ri:CaseClause] [ctx : Context])
  : (Either LocalTypeResolutionError CaseClause)
  (match-define (ri:case-clause pattern body) clause)
  (case (resolve-types/pattern pattern ctx)
    [(left v) (left v)]
    [(right pattern)
     (case (resolve-types/block body ctx)
       [(left v) (left v)]
       [(right body)
        (right (case-clause pattern body))])]))

(define (resolve-types/block [b : ri:Block] [ctx : Context])
  : (Either LocalTypeResolutionError Block)
  (match-define (ri:block defs expr) b)
  (case
    (extract-rights
      (map
        (lambda ([def : ri:BlockDefinition])
          : (Either LocalTypeResolutionError BlockDefinition)
          (case def
            [(ri:match-def pattern type expr)
             (case (resolve-types/pattern pattern ctx)
               [(left v) (left v)]
               [(right pattern)
                (case (maybe-pre-type->maybe-type type ctx)
                  [(left v) (left v)]
                  [(right type)
                   (case (resolve-types/expr expr ctx)
                     [(left v) (left v)]
                     [(right expr)
                      (right (match-def pattern type expr))])])])]))
        defs))
    [(left v) (left v)]
    [(right defs)
     (case (resolve-types/expr expr ctx)
       [(left v) (left v)]
       [(right expr)
        (right (block defs expr))])]))

(define (resolve-types/pattern [pattern : ri:Pattern] [ctx : Context])
  : (Either LocalTypeResolutionError Pattern)
  (case pattern
    [(ri:bytes-pattern v src)
     (right (bytes-pattern v src))]
    [(ri:int-pattern v src)
     (right (int-pattern v src))]
    [(ri:variable-pattern v src)
     (right (variable-pattern v src))]
    [(ri:ignore-pattern src)
     (right (ignore-pattern src))]
    [(ri:abstraction-pattern (source-span-annotated name _) patterns src)
     (case (extract-rights
             (map
               (lambda ([p : ri:Pattern])
                 (resolve-types/pattern p ctx))
               patterns))
       [(left v) (left v)]
       [(right patterns)
        (right (abstraction-pattern name patterns src))])]))

(define (resolve-types/imports [i : ri:Imports]) : Imports
  (case i
    [(ri:imports _types values patterns statics static-info)
     (imports values patterns statics static-info)]))

(define (context-ref-type [ctx : Context] [name : Bytes]) : (Maybe Type)
  (case ctx
    [(context types)
     (dict-ref types name)]))

(define (context-add-type [ctx : Context] [name : Bytes] [type : Type]) : Context
  (case ctx
    [(context types)
     (context (dict-set types name type))]))

(define (context-add-var-types [context : Context] [names : (List Bytes)]) : Context
  (case names
    [(empty) context]
    [(cons name names)
     (context-add-var-types
       (context-add-type context name (var-type name))
       names)]))

(define (pre-type->type [pre : PreType] [context : Context])
  : (Either LocalTypeResolutionError Type)
  (case pre
    [(var-pre-type v _)
     (case (context-ref-type context v)
       [(nothing)
        (left (unbound-type-variable v))]
       [(just v) (right v)])]
    [(fun-pre-type type-vars args result _)
     (match-define context (context-add-var-types context type-vars))
     (match-define recur (lambda ([pre : PreType]) (pre-type->type pre context)))
     (case (extract-rights (map recur args))
       [(left v) (left v)]
       [(right args)
        (case (recur result)
          [(left v) (left v)]
          [(right result)
           (right (fun-type type-vars args result))])])]
    [(type-app-pre-type (source-span-annotated constructor _) args _)
     (case (context-ref-type context constructor)
       [(nothing)
        (left (unbound-type-variable constructor))]
       ;; TODO actually check that the kind of the argument types match the expected kinds
       [(just (type-constructor mod-name name arg-kinds))
        (case (zip args arg-kinds)
          [(just args+kinds)
           (case (extract-rights
                   (map (lambda ([t : (Tuple2 PreType Kind)])
                          : (Either LocalTypeResolutionError Type)
                          (case t
                            [(tuple2 pre kind)
                             (case (pre-type->type pre context)
                               [(left v) (left v)]
                               [(right t)
                                (if (kind=? kind (type->kind t))
                                    (right t)
                                    (left (type-constructor-bad-arg-kind)))])]))
                          args+kinds))
             [(left v) (left v)]
             [(right types)
              (right (abstract-type mod-name name types (star-kind)))])]
          [(nothing)
           (left (type-constructor-bad-number-of-args))])]
       [(just t)
        (left (type-constructor-bad-constructor t))])]))

(define (maybe-pre-type->maybe-type [t : (Maybe PreType)] [ctx : Context])
  : (Either LocalTypeResolutionError (Maybe Type))
  (case t
    [(nothing) (right (nothing))]
    [(just t)
     (case (pre-type->type t ctx)
       [(left v) (left v)]
       [(right t) (right (just t))])]))

(define (pattern-source-span [p : Pattern]) : SourceSpan
  (case p
    [(bytes-pattern _ src) src]
    [(int-pattern _ src) src]
    [(variable-pattern _ src) src]
    [(ignore-pattern src) src]
    [(abstraction-pattern _ _ src) src]))

(define (type-resolution-error->bytes [v : TypeResolutionError]) : Bytes
  (match-define (type-resolution-error mod-name error) v)
  (match-define msg
    (case error
      [(unbound-type-variable v)
       (bytes-append (varargs list #"Unbound type variable: " v))]
      [(type-constructor-bad-arg-kind)
       #"Kind doesn't match in type constructor application"]
      [(type-constructor-bad-number-of-args)
       #"Number of arguments to type constructor doesn't match."]
      [(type-constructor-bad-constructor type)
       (bytes-append (varargs list
         #"Cannot apply non constructor type: "
         (print-type type)))]
      [(function-definition-bad-arg-kind type)
       (bytes-append (varargs list
         #"Function argument type's kind must corespond to a value, got: "
         (print-type type)))]))
  (bytes-append
    (varargs list #"Error resolving types in " (mod-name->bytes mod-name) #":\n" msg)))
