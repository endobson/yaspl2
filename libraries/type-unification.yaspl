(module type-unification
  (import
    (prim
      #:types (Int Bytes Boolean)
      #:values (= and)
      #:patterns ())
    (bytes bytes=? bytes-append)
    (maybe
      #:types (Maybe)
      #:values (just nothing)
      #:patterns (just nothing))
    (list
      #:types (List)
      #:values (map ormap append zip extract-justs list)
      #:patterns (cons empty))
    (dict
      #:types (Dict)
      #:values (make-dict dict-value-map dict-add dict-map dict-add-all)
      #:patterns ())
    (tuples
      #:types (Tuple2)
      #:values (tuple2)
      #:patterns (tuple2))
    (numbers integer->decimal-bytes)
    (types
      #:types (Type)
      #:values (abstract-type var-type)
      #:patterns ()))
  (export
    #:types (UnificationVar Constraint Constrainable)
    #:values (unify uvar constrain-uvar constrain-var-type constrain-abstract-type
              eq-constraint uvar->bytes)
    #:patterns ())
  (types
    (define-type UnificationVar
      (uvar [id Int]))
    (define-type Constrainable
      (constrain-uvar [v UnificationVar])
      (constrain-var-type [v Bytes])
      (constrain-abstract-type [mod-name Bytes] [name Bytes] [args (List Constrainable)]))
    (define-type Constraint
      (eq-constraint [lhs Constrainable] [rhs Constrainable])))

  (define (nothing/uvar-type) : (Maybe (Tuple2 UnificationVar Type))
    (nothing))

  (define (unify [constraints : (List Constraint)]) : (Maybe (Dict UnificationVar Type))
    (case (unify* constraints (make-dict uvar=?))
      [(nothing) (nothing)]
      [(just solution)
       (case (extract-justs
               (dict-map
                 solution
                 (lambda ([uvar : UnificationVar] [c : Constrainable])
                   (case (constrainable->type c)
                     [(nothing) (nothing/uvar-type)]
                     [(just t) (just (tuple2 uvar t))]))))
         [(nothing) (nothing)]
         [(just uvar-types)
          (just (dict-add-all (make-dict uvar=?) uvar-types))])]))

  (define (unify*/var
            [uvar : UnificationVar]
            [c : Constrainable]
            [constraints : (List Constraint)]
            [solution : (Dict UnificationVar Constrainable)])
    : (Maybe (Dict UnificationVar Constrainable))
    (unify*
      (map (subst/constraint uvar c) constraints)
      (dict-add
        (dict-value-map solution (subst uvar c))
        uvar c)))

  (define (unify*
            [constraints : (List Constraint)]
            [solution : (Dict UnificationVar Constrainable)])
    : (Maybe (Dict UnificationVar Constrainable))
    (case constraints
      [(empty) (just solution)]
      [(cons constraint constraints)
       (case constraint
         [(eq-constraint (constrain-uvar v1) (constrain-uvar v2))
          (if (uvar=? v1 v2)
              (unify* constraints solution)
              (unify*/var v1 (constrain-uvar v2) constraints solution))]
         [(eq-constraint (constrain-uvar v1) c2)
          (if (occurs-check? v1 c2)
              (nothing)
              (unify*/var v1 c2 constraints solution))]
         [(eq-constraint c1 (constrain-uvar v2))
          (if (occurs-check? v2 c1)
              (nothing)
              (unify*/var v2 c1 constraints solution))]
         [(eq-constraint (constrain-var-type v1) (constrain-var-type v2))
          (if (bytes=? v1 v2)
              (unify* constraints solution)
              (nothing))]
         [(eq-constraint
            (constrain-abstract-type mod1 name1 types1)
            (constrain-abstract-type mod2 name2 types2))
          (if (and (bytes=? mod1 mod2) (bytes=? name1 name2))
              (case (zip types1 types2)
                [(nothing) (nothing)]
                [(just zipped-types)
                 (unify*
                   (append
                     (map (lambda ([t : (Tuple2 Constrainable Constrainable)])
                            (case t
                              [(tuple2 lhs rhs) (eq-constraint lhs rhs)]))
                          zipped-types)
                     constraints)
                   solution)])
              (nothing))]
         [(eq-constraint (constrain-var-type _) (constrain-abstract-type _ _ _))
          (nothing)]
         [(eq-constraint (constrain-abstract-type _ _ _) (constrain-var-type _))
          (nothing)])]))


  (define (subst [uvar : UnificationVar] [c : Constrainable])
    : (Constrainable -> Constrainable)
    (lambda ([c2 : Constrainable])  (subst* uvar c c2)))

  (define (subst/constraint [uvar : UnificationVar] [c : Constrainable])
    : (Constraint -> Constraint)
    (lambda ([c2 : Constraint])
      (case c2
        [(eq-constraint lhs rhs)
         (eq-constraint
           (subst* uvar c lhs)
           (subst* uvar c rhs))])))

  (define (subst* [uvar : UnificationVar] [v : Constrainable] [c : Constrainable])
    : Constrainable
    (case c
      [(constrain-uvar u)
       (if (uvar=? u uvar) v c)]
      [(constrain-var-type _) c]
      [(constrain-abstract-type mod name types)
       (constrain-abstract-type mod name (map (subst uvar v) types))]))

  (define (occurs-check? [uvar : UnificationVar] [c : Constrainable]) : Boolean
    (case c
      [(constrain-uvar u)
       (uvar=? u uvar)]
      [(constrain-var-type _) #f]
      [(constrain-abstract-type _ _ types)
       (ormap (lambda ([c : Constrainable]) (occurs-check? uvar c)) types)]))

  (define (uvar=? [uvar1 : UnificationVar] [uvar2 : UnificationVar]) : Boolean
    (case uvar1
      [(uvar v1)
       (case uvar2
         [(uvar v2)
          (= v1 v2)])]))

  (define (uvar->bytes [uvar : UnificationVar]) : Bytes
    (bytes-append
      (varargs list #"(uvar " (integer->decimal-bytes (uvar-id uvar)) #")")))

  (define (constrainable->type [c : Constrainable]) : (Maybe Type)
    (case c
      [(constrain-uvar _) (nothing)]
      [(constrain-var-type v) (just (var-type v))]
      [(constrain-abstract-type mod-name name cs)
       (case (extract-justs (map constrainable->type cs))
         [(nothing) (nothing)]
         [(just types)
          (just (abstract-type mod-name name types))])]))
  )
