#:module (depth-first-search-test)
#:import {
  (depth-first-search) {
    #:values
      depth-first-search
  }
  (list) {
    #:types
      List
    #:values
      empty
      list
      list=?
  }
  (maybe) {
    #:types
      Maybe
    #:values
      just
      nothing
  }
  (prim) {
    #:types
      Array
      Bytes
      InputPort
      Int
      OutputPort
    #:values
      =
      panic
  }
  (yunit) {
    #:types
      FailedAssertion
    #:values
      failure
      new-test-case
      yunit/main
  }
}
(export)
(types)

(define (graph1 [v : Int]) : (List Int)
  (case v
    [0 (varargs list 1 2)]
    [1 (empty)]
    [2 (varargs list 3)]
    [3 (varargs list 1)]
    [_ (panic #"Bad node")]))

(define (test-depth-first-search [graph : (Int -> (List Int))] [expected : (List Int)])
  : (-> (Maybe FailedAssertion))
  (lambda ()
    (let ([actual (depth-first-search graph (varargs list 0) =)])
      (if ((list=? =) actual expected)
          (nothing)
          (just (failure #"Actual value doesn't match expected"))))))

(define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]): Int
  (yunit/main stderr
    (varargs list
      (new-test-case #"graph1" (test-depth-first-search graph1 (varargs list 0 2 3 1))))))
