(module source-to-stack
  (import
    (prim
      #:types (Bytes Boolean Byte)
      #:values (panic + * - =)
      #:patterns ())
    (list
      #:types (List)
      #:values (cons empty length append map append*)
      #:patterns (cons empty))
    (bytes bytes=? bytes-append)
    (dict
      #:types (Dict)
      #:values (make-dict dict-ref dict-set)
      #:patterns ())
    (maybe
      #:types (Maybe)
      #:values ()
      #:patterns (just nothing))
    (join-list
      #:types ()
      #:values (jl->list empty-jl append-jl snoc-jl)
      #:patterns ())
    (stack-machine
      #:types (StackFunction StackBasicBlock StackCmd StackTerminal GenState)
      #:values (stack-function stack-basic-block gen-state-cmds gen-state
                initial-variables return add-byte-literal name-temporary unscope-variable
                variable-ref function-ref call-function add-boolean-literal remove-temporaries
                tmp-slot boolean-jmp uncond-jmp add-bytes-literal ignore-value
                alloc-variant-cmd dup-cmd variant-ref-cmd)
      #:patterns (gen-state))
    (source-language
      #:types (Module FunctionDefinition Expression Imports Import TypeDefinition VariantDefinition
                      VariantField)
      #:values (module-name module-definitions module-types
                function-definition-name
                type-definition-variants)
      #:patterns (module imports import function-definition bytes-literal byte-literal boolean-literal
                  let-expr var-expr app-expr if-expr begin-expr variant-definition type-definition
                  variant-field
                  )))
  (export compile-module module-signature)
  (types
    (define-type VarReference
      (local-var)
      (global-function [name Bytes]))
    (define-type ModuleSignature
      (module-signature [name Bytes] [exports (Dict Bytes Bytes)])))

  (define (compile-module [mod : Module] [sigs : (List ModuleSignature)]) : (List StackFunction)
    ;; TODO add imports to global env
    (let ([env (make-global-env mod sigs)])
      (append
        (compile-type-definitions mod)
        (compile-function-definitions mod env))))

  (define (make-global-env [mod : Module] [sigs : (List ModuleSignature)]) : (Dict Bytes VarReference)
    (add-type-definitions-functions/top
      (add-locally-defined-functions
        (add-all-imported-functions
          (initial-env) mod sigs)
        mod)
      mod))

  (define (initial-env) : (Dict Bytes VarReference)
    (make-dict bytes=?))


  (define (add-all-imported-functions
            [env : (Dict Bytes VarReference)]
            [mod : Module]
            [sigs : (List ModuleSignature)]) : (Dict Bytes VarReference)
    (case mod
      [(module _ imports _ _ _)
       (add-all-imports env imports sigs)]))

  (define (add-all-imports
            [env : (Dict Bytes VarReference)]
            [imps : (List Imports)]
            [sigs : (List ModuleSignature)]) : (Dict Bytes VarReference)
    (case imps
      [(empty) env]
      [(cons (imports mod-name _ values _) imps)
       (add-all-imports
         (add-imports env values (lookup-module-signature mod-name sigs))
         imps sigs)]))

  (define (add-imports
            [env : (Dict Bytes VarReference)]
            [imps : (List Import)]
            [sig : ModuleSignature]) : (Dict Bytes VarReference)
    (case imps
      [(empty) env]
      [(cons (import exported-name local-name) imps)
       (case (dict-ref (module-signature-exports sig) exported-name)
         [(nothing) (panic #"No corresponding export for import")]
         [(just global-name)
          (add-imports
            (dict-set env local-name (global-function global-name))
            imps
            sig)])]))

  (define (lookup-module-signature [mod-name : Bytes] [sigs : (List ModuleSignature)]) : ModuleSignature
    (case sigs
      [(empty) (panic #"No module found for import")]
      [(cons sig sigs)
       (if (bytes=? (module-signature-name sig) mod-name)
           sig
           (lookup-module-signature mod-name sigs))]))

  (define (add-locally-defined-functions [env : (Dict Bytes VarReference)] [mod : Module])
    : (Dict Bytes VarReference)
    (let ([var-names (map function-definition-name (module-definitions mod))])
      (let ([fun-names (get-function-names (module-name mod) (module-definitions mod))])
        (add-all-globals env var-names fun-names))))

  (define (get-function-names [mod-name : Bytes] [funs : (List FunctionDefinition)]) : (List Bytes)
    (case funs
      [(empty) (empty)]
      [(cons (function-definition name _ _ _) funs)
       (cons
         (bytes-append (cons mod-name (cons #"_" (cons name (empty)))))
         (get-function-names mod-name funs))]))

  (define (add-all-globals [env : (Dict Bytes VarReference)]
                           [var-names : (List Bytes)]
                           [fun-names : (List Bytes)])
    : (Dict Bytes VarReference)
    (case var-names
      [(empty) env]
      [(cons var-name var-names)
       (case fun-names
         [(empty) (panic #"var-names not the same length as fun-names")]
         [(cons fun-name fun-names)
          (add-all-globals
            (dict-set env var-name (global-function fun-name)) var-names fun-names)])]))

  (define (add-type-definitions-functions/top [env : (Dict Bytes VarReference)] [mod : Module])
    : (Dict Bytes VarReference)
    (add-type-definitions-functions env (module-name mod) (module-types mod)))

  (define (add-type-definitions-functions
            [env : (Dict Bytes VarReference)]
            [mod-name : Bytes]
            [defs : (List TypeDefinition)]) : (Dict Bytes VarReference)
    (case defs
      [(empty) env]
      [(cons def defs)
       (add-type-definitions-functions
         (add-type-definition-functions env mod-name def)
         mod-name
         defs)]))

  (define (add-type-definition-functions
            [env : (Dict Bytes VarReference)]
            [mod-name : Bytes]
            [def : TypeDefinition]) : (Dict Bytes VarReference)
    (case def
      [(type-definition name _ variants)
       (add-variant-definitions-functions env mod-name name variants)]))

  (define (add-variant-definitions-functions
            [env : (Dict Bytes VarReference)]
            [mod-name : Bytes]
            [type-name : Bytes]
            [defs : (List VariantDefinition)]) : (Dict Bytes VarReference)
    (case defs
      [(empty) env]
      [(cons def defs)
       (add-variant-definitions-functions
         (add-variant-definition-functions env mod-name type-name def)
         mod-name
         type-name
         defs)]))

  (define (add-variant-definition-functions
            [env : (Dict Bytes VarReference)]
            [mod-name : Bytes]
            [type-name : Bytes]
            [def : VariantDefinition]) : (Dict Bytes VarReference)
    (case def
      [(variant-definition name fields)
       (add-variant-definition-accessors
         (dict-set
           env
           name
           (global-function
             (bytes-append
               (cons mod-name (cons #"_" (cons type-name (cons #"_" (cons name (empty)))))))))
         mod-name
         type-name
         name
         fields)]))

  (define (add-variant-definition-accessors
            [env : (Dict Bytes VarReference)]
            [mod-name : Bytes]
            [type-name : Bytes]
            [variant-name : Bytes]
            [fields : (List VariantField)]) : (Dict Bytes VarReference)
    (case fields
      [(empty) env]
      [(cons (variant-field name _) defs)
       (dict-set
         env
         (bytes-append (cons variant-name (cons #"-" (cons name (empty)))))
         (global-function
           (bytes-append
             (cons mod-name (cons #"_"
                (cons type-name (cons #"_"
                  (cons variant-name (cons #"_" (cons name (empty)))))))))))]))


  (define (add-all-locals [env : (Dict Bytes VarReference)] [names : (List Bytes)])
    : (Dict Bytes VarReference)
    (case names
      [(empty) env]
      [(cons name names) (add-all-locals (dict-set env name (local-var)) names)]))


  (define (compile-type-definitions [mod : Module]) : (List StackFunction)
    (case mod
      [(module name _ _ types _)
       (compile-type-definitions/list name types (empty))]))

  (define (compile-type-definitions/list
            [mod-name : Bytes]
            [defs : (List TypeDefinition)]
            [acc : (List StackFunction)]) : (List StackFunction)
    (case defs
      [(empty) acc]
      [(cons def defs)
       (compile-type-definitions/list
         mod-name
         defs
         (compile-type-definition mod-name def acc))]))

  (define (compile-type-definition
            [mod-name : Bytes]
            [def : TypeDefinition]
            [acc : (List StackFunction)]) : (List StackFunction)
    (case def
      [(type-definition name _ variants)
       (compile-type-definition/variants mod-name name 0 variants acc)]))

  (define (compile-type-definition/variants
            [mod-name : Bytes]
            [type-name : Bytes]
            [variant-index : Byte]
            [variants : (List VariantDefinition)]
            [acc : (List StackFunction)]) : (List StackFunction)
    (case variants
      [(empty) acc]
      [(cons variant variants)
       (compile-type-definition/variants
         mod-name
         type-name
         variant-index
         variants
         (compile-variant-definition mod-name type-name variant-index variant acc))]))

  (define (compile-variant-definition
            [mod-name : Bytes]
            [type-name : Bytes]
            [variant-index : Byte]
            [def : VariantDefinition]
            [acc : (List StackFunction)]) : (List StackFunction)
    (case def
      [(variant-definition name fields)
       (cons
         (stack-function
           (bytes-append (cons mod-name (cons #"_" (cons type-name (cons #"_" (cons name (empty)))))))
           (cons
             (stack-basic-block
               (add-reversed-args
                 (length fields)
                 (cons
                   (alloc-variant-cmd variant-index (length fields))
                   (empty)))
               (return (length fields)))
             (empty)))
         (compile-variant-definition/accessors
           mod-name
           type-name
           name
           variant-index
           0
           fields
           acc))]))

  (define (compile-variant-definition/accessors
            [mod-name : Bytes]
            [type-name : Bytes]
            [variant-name : Bytes]
            [variant-index : Byte]
            [field-index : Byte]
            [fields : (List VariantField)]
            [acc : (List StackFunction)]) : (List StackFunction)
    (case fields
      [(empty) acc]
      [(cons (variant-field name _) fields)
       (compile-variant-definition/accessors
         mod-name
         type-name
         variant-name
         variant-index
         field-index
         fields
         (cons
           (stack-function
             (bytes-append
               (cons mod-name (cons #"_"
                 (cons type-name (cons #"_"
                   (cons variant-name (cons #"_" (cons name (empty)))))))))
             (cons
               (stack-basic-block
                 (add-reversed-args 1 (cons (variant-ref-cmd variant-index field-index) (empty)))
                 (return 1))
               (empty)))
           acc))]))

  (define (add-reversed-args [args : Byte] [cmds : (List StackCmd)]) : (List StackCmd)
    (if (= 0 args)
        cmds
        (add-reversed-args
          (- args 1)
          (cons (dup-cmd (- (* 2 args) 1)) cmds))))


  (define (compile-function-definitions [mod : Module] [env : (Dict Bytes VarReference)]) : (List StackFunction)
    (compile-function-definitions/list (module-name mod) (module-definitions mod) env))

  (define (compile-function-definitions/list
            [mod-name : Bytes]
            [funs : (List FunctionDefinition)]
            [env : (Dict Bytes VarReference)]) : (List StackFunction)
    (case funs
      [(empty) (empty)]
      [(cons fun funs)
       (cons (compile-function-definition mod-name fun env)
             (compile-function-definitions/list mod-name funs env))]))

  (define (compile-function-definition [mod-name : Bytes] [fun : FunctionDefinition] [env : (Dict Bytes VarReference)]) : StackFunction
    (case fun
      [(function-definition name pre-type arg-names body)
       (stack-function
         (bytes-append (cons mod-name (cons #"_" (cons name (empty)))))
         ;; TODO validate the genstate has one temporary left in it, the return addr, and then the
         ;; variables.
         (case (compile-expression
                 body
                 (add-all-locals env arg-names)
                 (gen-state (initial-variables arg-names) (empty-jl) 0 (empty-jl)))
           [(gen-state _ cmds label blocks)
            (jl->list
              (snoc-jl
                blocks
                (stack-basic-block (jl->list cmds) (return (length arg-names)))))]))]))

  (define (compile-expressions
            [exprs : (List Expression)]
            [env : (Dict Bytes VarReference)]
            [state : GenState]) : GenState
    (case exprs
      [(empty) state]
      [(cons expr exprs)
       (compile-expressions exprs env
         (compile-expression expr env state))]))

  (define (compile-expression
            [expr : Expression]
            [env : (Dict Bytes VarReference)]
            [state : GenState]) : GenState
    (case expr
      [(byte-literal v) (add-byte-literal v state)]
      [(boolean-literal v) (add-boolean-literal v state)]
      [(bytes-literal v) (add-bytes-literal v state)]
      [(let-expr name expr body)
       (unscope-variable name
         (compile-expression body (dict-set env name (local-var))
           (name-temporary name
             (compile-expression expr env state))))]
      [(var-expr v)
       (case (dict-ref env v)
         [(just (local-var)) (variable-ref v state)]
         [(just (global-function n))
          (function-ref n state)]
         [(nothing) (panic #"Unbound variable")])]
      ;; TODO make effects of op go before arguments
      [(app-expr op args)
       (call-function (length args)
         (compile-expression op env
           (compile-expressions args env state)))]
      [(if-expr c t f)
       (case (compile-expression c env state)
         [(gen-state stack cmds-c label-c-end blocks)
          (let ([stack-split (remove-temporaries 1 stack)])
            (let ([label-t-begin (+ label-c-end 1)])
              (case (compile-expression t env
                      (gen-state stack-split (empty-jl) label-t-begin (empty-jl)))
                [(gen-state stack-t cmds-t label-t-end blocks-t)
                 (let ([label-f-begin (+ label-t-end 1)])
                   (case (compile-expression f env
                           (gen-state stack-split (empty-jl) label-f-begin (empty-jl)))
                     [(gen-state stack-f cmds-f label-f-end blocks-f)
                      ;; TODO Check that stack-f = stack-t = (tmp-slot stack-split)
                      (let ([new-label (+ label-f-end 1)])
                        (gen-state
                          (tmp-slot stack-split)
                          (empty-jl)
                          new-label
                          (append-jl
                            (snoc-jl
                              blocks
                              (stack-basic-block (jl->list cmds-c) (boolean-jmp label-t-begin label-f-begin)))
                            (append-jl
                              (snoc-jl
                                blocks-t
                                (stack-basic-block (jl->list cmds-t) (uncond-jmp new-label)))
                              (snoc-jl
                                blocks-f
                                (stack-basic-block (jl->list cmds-f) (uncond-jmp new-label)))))))]))])))])]
      [(begin-expr expr exprs)
       (compile-begin-exprs exprs env (compile-expression expr env state))]
      [_ (panic #"Not yet supported expression")]))

  (define (compile-begin-exprs
            [exprs : (List Expression)]
            [env : (Dict Bytes VarReference)]
            [state : GenState]) : GenState
    (case exprs
      [(empty) state]
      [(cons expr exprs)
       (compile-begin-exprs exprs env (compile-expression expr env (ignore-value state)))])))


