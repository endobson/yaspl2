(module source-to-stack
  (import
    (prim
      #:types (Bytes)
      #:values (panic)
      #:patterns ())
    (list
      #:types (List)
      #:values (cons empty length append map)
      #:patterns (cons empty))
    (bytes bytes=?)
    (dict
      #:types (Dict)
      #:values (make-dict dict-ref dict-set)
      #:patterns ())
    (maybe
      #:types (Maybe)
      #:values ()
      #:patterns (just nothing))
    (join-list
      #:types ()
      #:values (jl->list empty-jl)
      #:patterns ())
    (stack-machine
      #:types (StackFunction StackBasicBlock StackCmd StackTerminal GenState)
      #:values (stack-function stack-basic-block gen-state-cmds gen-state
                initial-variables return add-literal name-temporary unscope-variable
                variable-ref)
      #:patterns ())
    (source-language
      #:types (Module FunctionDefinition Expression)
      #:values (module-definitions function-definition-name)
      #:patterns (function-definition byte-literal let-expr var-expr)))
  (export compile-module)
  (types
    (define-type VarReference
      (local-var)
      (global-function [name Bytes])))

  (define (compile-module [mod : Module]) : (List StackFunction)
    ;; TODO add imports to global env
    (let ([env (make-global-env mod)])
      (append
        (compile-data-type-functions mod)
        (compile-function-definitions mod env))))

  (define (make-global-env [mod : Module]) : (Dict Bytes VarReference)
    (let ([names (map function-definition-name (module-definitions mod))])
      (add-all-globals (make-dict bytes=?) names)))

  (define (add-all-globals [env : (Dict Bytes VarReference)] [names : (List Bytes)])
    : (Dict Bytes VarReference)
    (case names
      [(empty) env]
      [(cons name names) (add-all-globals (dict-set env name (global-function name)) names)]))



  ;; TODO implement this
  (define (compile-data-type-functions [mod : Module]) : (List StackFunction)
    (empty))

  (define (compile-function-definitions [mod : Module] [env : (Dict Bytes VarReference)]) : (List StackFunction)
    (compile-function-definitions/list (module-definitions mod) env))

  (define (compile-function-definitions/list
            [funs : (List FunctionDefinition)] [env : (Dict Bytes VarReference)]) : (List StackFunction)
    (case funs
      [(empty) (empty)]
      [(cons fun funs)
       (cons (compile-function-definition fun env)
             (compile-function-definitions/list funs env))]))

  (define (compile-function-definition [fun : FunctionDefinition] [env : (Dict Bytes VarReference)]) : StackFunction
    (case fun
      [(function-definition name pre-type arg-names body)
       (stack-function
         name
         (cons
           ;; TODO validate this has one temporary left in it, the return addr, and then the variables.
           (stack-basic-block
             (jl->list
               (gen-state-cmds
                 (compile-expression body env (gen-state (initial-variables arg-names) (empty-jl)))))
             (return (length arg-names)))
           (empty)))]))

  (define (compile-expression
            [body : Expression]
            [env : (Dict Bytes VarReference)]
            [state : GenState]) : GenState
    (case body
      [(byte-literal v) (add-literal v state)]
      [(let-expr name expr body)
       (unscope-variable name
         (compile-expression body (dict-set env name (local-var))
           (name-temporary name
             (compile-expression expr env state))))]
      [(var-expr v)
       (case (dict-ref env v)
         [(just (local-var)) (variable-ref v state)]
         [(just (global-function n))
          (panic #"Function pointers not yet implemented")]
         [(nothing) (panic #"Unbound variable")])]
      [_ (panic #"Not yet supported expression")])))
