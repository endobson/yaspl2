(module source-to-stack
  (import
    (prim
      #:types (Bytes)
      #:values (panic)
      #:patterns ())
    (list
      #:types (List)
      #:values (cons empty length append map)
      #:patterns (cons empty))
    (bytes bytes=? bytes-append)
    (dict
      #:types (Dict)
      #:values (make-dict dict-ref dict-set)
      #:patterns ())
    (maybe
      #:types (Maybe)
      #:values ()
      #:patterns (just nothing))
    (join-list
      #:types ()
      #:values (jl->list empty-jl)
      #:patterns ())
    (stack-machine
      #:types (StackFunction StackBasicBlock StackCmd StackTerminal GenState)
      #:values (stack-function stack-basic-block gen-state-cmds gen-state
                initial-variables return add-literal name-temporary unscope-variable
                variable-ref function-ref call-function)
      #:patterns ())
    (source-language
      #:types (Module FunctionDefinition Expression)
      #:values (module-name module-definitions function-definition-name)
      #:patterns (function-definition byte-literal let-expr var-expr app-expr)))
  (export compile-module module-signature)
  (types
    (define-type VarReference
      (local-var)
      (global-function [name Bytes]))
    (define-type ModuleSignature
      (module-signature [name Bytes] [exports (Dict Bytes Bytes)])))

  (define (compile-module [mod : Module] [sigs : (List ModuleSignature)]) : (List StackFunction)
    ;; TODO add imports to global env
    (let ([env (make-global-env mod sigs)])
      (append
        (compile-data-type-functions mod)
        (compile-function-definitions mod env))))

  (define (make-global-env [mod : Module] [sigs : (List ModuleSignature)]) : (Dict Bytes VarReference)
    (add-locally-defined-functions
      (add-all-imported-functions
        (initial-env) mod sigs)
      mod))

  (define (initial-env) : (Dict Bytes VarReference)
    (make-dict bytes=?))


  (define (add-all-imported-functions
            [env : (Dict Bytes VarReference)]
            [mod : Module]
            [sigs : (List ModuleSignature)]) : (Dict Bytes VarReference)
    env)

  (define (add-locally-defined-functions [env : (Dict Bytes VarReference)] [mod : Module])
    : (Dict Bytes VarReference)
    (let ([var-names (map function-definition-name (module-definitions mod))])
      (let ([fun-names (get-function-names (module-name mod) (module-definitions mod))])
        (add-all-globals env var-names fun-names))))

  (define (get-function-names [mod-name : Bytes] [funs : (List FunctionDefinition)]) : (List Bytes)
    (case funs
      [(empty) (empty)]
      [(cons (function-definition name _ _ _) funs)
       (cons
         (bytes-append (cons mod-name (cons #"_" (cons name (empty)))))
         (get-function-names mod-name funs))]))

  (define (add-all-globals [env : (Dict Bytes VarReference)]
                           [var-names : (List Bytes)]
                           [fun-names : (List Bytes)])
    : (Dict Bytes VarReference)
    (case var-names
      [(empty) env]
      [(cons var-name var-names)
       (case fun-names
         [(empty) (panic #"var-names not the same length as fun-names")]
         [(cons fun-name fun-names)
          (add-all-globals
            (dict-set env var-name (global-function fun-name)) var-names fun-names)])]))

  (define (add-all-locals [env : (Dict Bytes VarReference)] [names : (List Bytes)])
    : (Dict Bytes VarReference)
    (case names
      [(empty) env]
      [(cons name names) (add-all-locals (dict-set env name (local-var)) names)]))


  ;; TODO implement this
  (define (compile-data-type-functions [mod : Module]) : (List StackFunction)
    (empty))

  (define (compile-function-definitions [mod : Module] [env : (Dict Bytes VarReference)]) : (List StackFunction)
    (compile-function-definitions/list (module-name mod) (module-definitions mod) env))

  (define (compile-function-definitions/list
            [mod-name : Bytes]
            [funs : (List FunctionDefinition)]
            [env : (Dict Bytes VarReference)]) : (List StackFunction)
    (case funs
      [(empty) (empty)]
      [(cons fun funs)
       (cons (compile-function-definition mod-name fun env)
             (compile-function-definitions/list mod-name funs env))]))

  (define (compile-function-definition [mod-name : Bytes] [fun : FunctionDefinition] [env : (Dict Bytes VarReference)]) : StackFunction
    (case fun
      [(function-definition name pre-type arg-names body)
       (stack-function
         (bytes-append (cons mod-name (cons #"_" (cons name (empty)))))
         (cons
           ;; TODO validate this has one temporary left in it, the return addr, and then the variables.
           (stack-basic-block
             (jl->list
               (gen-state-cmds
                 (compile-expression
                   body 
                   (add-all-locals env arg-names)
                   (gen-state (initial-variables arg-names) (empty-jl)))))
             (return (length arg-names)))
           (empty)))]))

  (define (compile-expressions
            [exprs : (List Expression)]
            [env : (Dict Bytes VarReference)]
            [state : GenState]) : GenState
    (case exprs
      [(empty) state]
      [(cons expr exprs)
       (compile-expressions exprs env
         (compile-expression expr env state))]))

  (define (compile-expression
            [expr : Expression]
            [env : (Dict Bytes VarReference)]
            [state : GenState]) : GenState
    (case expr
      [(byte-literal v) (add-literal v state)]
      [(let-expr name expr body)
       (unscope-variable name
         (compile-expression body (dict-set env name (local-var))
           (name-temporary name
             (compile-expression expr env state))))]
      [(var-expr v)
       (case (dict-ref env v)
         [(just (local-var)) (variable-ref v state)]
         [(just (global-function n))
          (function-ref n state)]
         [(nothing) (panic #"Unbound variable")])]
      ;; TODO make effects of op go before arguments
      [(app-expr op args)
       (call-function (length args)
         (compile-expression op env
           (compile-expressions args env state)))]
      [_ (panic #"Not yet supported expression")])))
