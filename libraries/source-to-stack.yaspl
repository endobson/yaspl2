(module source-to-stack
  (import
    (prim 
      #:types (Bytes)
      #:values (panic)
      #:patterns ())
    (list
      #:types (List)
      #:values (cons empty length append map)
      #:patterns (cons empty))
    (bytes bytes=?)
    (dict 
      #:types (Dict)
      #:values (make-dict)
      #:patterns ())
    (join-list
      #:types ()
      #:values (jl->list empty-jl)
      #:patterns ())
    (stack-machine
      #:types (StackFunction StackBasicBlock StackCmd StackTerminal GenState)
      #:values (stack-function stack-basic-block gen-state-cmds gen-state
                initial-variables return add-literal name-temporary unscope-variable
                variable-ref)
      #:patterns ())
    (source-language
      #:types (Module FunctionDefinition Expression)
      #:values (module-definitions)
      #:patterns (function-definition byte-literal let-expr var-expr)))
  (export compile-module)
  (types
    (define-type VarReference
      (local-var)
      (global-function [name Bytes])))

  (define (compile-module [mod : Module]) : (List StackFunction)
    ;; TODO add imports to global env
    (let ([env (make-global-env mod)])
      (append
        (compile-data-type-functions mod)
        (compile-function-definitions mod env))))

  (define (make-global-env [mod : Module]) : (Dict Bytes VarReference)
    (make-dict bytes=?))



  ;; TODO implement this
  (define (compile-data-type-functions [mod : Module]) : (List StackFunction)
    (empty))

  (define (compile-function-definitions [mod : Module] [env : (Dict Bytes VarReference)]) : (List StackFunction)
    ;; TODO use the environment
    (map compile-function-definition (module-definitions mod)))

  (define (compile-function-definition [fun : FunctionDefinition]) : StackFunction
    (case fun
      [(function-definition name pre-type arg-names body)
       (stack-function
         name
         (cons
           ;; TODO validate this has one temporary left in it, the return addr, and then the variables.
           (stack-basic-block
             (jl->list
               (gen-state-cmds
                 (compile-expression body (gen-state (initial-variables arg-names) (empty-jl)))))
             (return (length arg-names)))
           (empty)))]))

  (define (compile-expression [body : Expression] [state : GenState]) : GenState
    (case body
      [(byte-literal v) (add-literal v state)]
      [(let-expr name expr body)
       (unscope-variable name
         (compile-expression body
           (name-temporary name
             (compile-expression expr state))))]
      [(var-expr v)
       (variable-ref v state)]
      [_ (panic #"Not yet supported expression")])))
