#:module (yaspl x86-64-assembly-printer)
#:import {
  (bytes)
  (io)
  (join-list)
  (list)
  (numbers)
  (prim)
  (set)
  (yaspl x86-64-assembly)
}
(export
  (#:types AssemblyStyle AssemblyCommand AssemblerDirective)
  (#:values write-fragments const-fragment->commands text-fragment->commands assembly-commands->bytes
            linux-assembly-style osx-assembly-style))
(types
  (define-type AssemblyStyle
    (linux-assembly-style)
    (osx-assembly-style))
  (define-type AssemblyCommand
    (directive-cmd [directive : AssemblerDirective])
    (instruction-cmd [instruction : Instruction]))
  (define-type AssemblerDirective
    (const-data-section-directive)
    (text-section-directive)
    (alignment-directive [alignment : Int] [fill : U8])
    (local-directive [label : Bytes])
    (global-directive [label : Bytes])
    (label-directive [name : Bytes])
    (quad-directive/label [label : Bytes] [addend : Int])
    (quad-directive/integer [value : Int])
    (ascii-directive [value : Bytes])))

(define (register8->bytes [reg : Register8]) : Bytes
  (case reg
    [(al) #"%al"]
    [(ah) #"%ah"]
    [(bl) #"%bl"]
    [(bh) #"%bh"]
    [(cl) #"%cl"]
    [(ch) #"%ch"]
    [(dl) #"%dl"]
    [(dh) #"%dh"]
    [(dil) #"%dil"]
    [(sil) #"%sil"]
    [(bpl) #"%bpl"]
    [(spl) #"%spl"]
    [(r8b) #"%r8b"]
    [(r9b) #"%r9b"]
    [(r10b) #"%r10b"]
    [(r11b) #"%r11b"]
    [(r12b) #"%r12b"]
    [(r13b) #"%r13b"]
    [(r14b) #"%r14b"]
    [(r15b) #"%r15b"]))

(define (register64->bytes [reg : Register64]) : Bytes
  (case reg
    [(rax) #"%rax"]
    [(rbx) #"%rbx"]
    [(rcx) #"%rcx"]
    [(rdx) #"%rdx"]
    [(rdi) #"%rdi"]
    [(rsi) #"%rsi"]
    [(rbp) #"%rbp"]
    [(rsp) #"%rsp"]
    [(r8) #"%r8"]
    [(r9) #"%r9"]
    [(r10) #"%r10"]
    [(r11) #"%r11"]
    [(r12) #"%r12"]
    [(r13) #"%r13"]
    [(r14) #"%r14"]
    [(r15) #"%r15"]))

(define (r64mi->bytes [rmi : Reg64MemImm]) : Bytes
  (case rmi
    [(r64mi-reg r) (register64->bytes r)]
    [(r64mi-mem m) (mem->bytes m)]
    [(r64mi-imm-s32 v)
     (bytes-append (varargs list #"$" (integer->decimal-bytes (s32->s64 v))))]
    [(r64mi-imm-s8 v)
     (bytes-append (varargs list #"$" (integer->decimal-bytes (s8->s64 v))))]))

(define (r64m->bytes [rm : Reg64Mem]) : Bytes
  (case rm
    [(r64m-reg r) (register64->bytes r)]
    [(r64m-mem m) (mem->bytes m)]))

(define (r8m->bytes [rm : Reg8Mem]) : Bytes
  (case rm
    [(r8m-reg r) (register8->bytes r)]
    [(r8m-mem m) (mem->bytes m)]))

(define (r8mi->bytes [rm : Reg8MemImm]) : Bytes
  (case rm
    [(r8mi-reg r) (register8->bytes r)]
    [(r8mi-mem m) (mem->bytes m)]
    [(r8mi-imm-s8 v)
     (bytes-append (varargs list #"$" (integer->decimal-bytes (s8->s64 v))))]))


(define (mem->bytes [mem : MemoryArgument]) : Bytes
  (case mem
    [(mem-direct reg)
     (bytes-append (varargs list #"(" (register64->bytes reg) #")"))]
    [(mem-sib-direct reg)
     (bytes-append (varargs list #"(" (register64->bytes reg) #")"))]
    [(mem-displaced reg displacement)
     (match-define offset
       (case displacement
         [(displacement-s8 v) (s8->s64 v)]
         [(displacement-s32 v) (s32->s64 v)]))
     (bytes-append (varargs list (integer->decimal-bytes offset)
                            #"(" (register64->bytes reg) #")"))]
    [(mem-sib-displaced reg displacement)
     (match-define offset
       (case displacement
         [(displacement-s8 v) (s8->s64 v)]
         [(displacement-s32 v) (s32->s64 v)]))
     (bytes-append (varargs list (integer->decimal-bytes offset)
                            #"(" (register64->bytes reg) #")"))]
    [(mem-scaled reg scale index displacement)
     (match-define offset
       (case displacement
         [(displacement-s8 v) (s8->s64 v)]
         [(displacement-s32 v) (s32->s64 v)]))
     (bytes-append
       (varargs list
         (integer->decimal-bytes offset)
         #"("
         (register64->bytes reg)
         #", "
         (register64->bytes index)
         #", "
         (integer->decimal-bytes
           (case scale
             [(scale-1) 1]
             [(scale-2) 2]
             [(scale-4) 4]
             [(scale-8) 8]))
         #")"))]))



;; Generates a text version of the assembly commands.
(define (assembly-commands->bytes
          [style : AssemblyStyle]
          [cmds : (List AssemblyCommand)])
  : (JoinList Bytes)
  (case cmds
    [(empty) (empty-jl)]
    [(cons cmd cmds)
     (append-jl
       (assembly-command->bytes style cmd)
       (cons-jl
         #"\n"
         (assembly-commands->bytes style cmds)))]))

(define (assembly-command->bytes [style : AssemblyStyle] [cmd : AssemblyCommand]) : (JoinList Bytes)
  (case cmd
    [(directive-cmd directive) (assembler-directive->bytes style directive)]
    [(instruction-cmd instruction) (instruction->assembly-bytes style instruction)]))

(define (assembler-directive->bytes [style : AssemblyStyle] [dir : AssemblerDirective]) : (JoinList Bytes)
  (case dir
    [(text-section-directive)
     (case style
       [(osx-assembly-style)
        (single-jl #".section __TEXT, __text")]
       [(linux-assembly-style)
        (single-jl #".section .text")])]
    [(const-data-section-directive)
     (case style
       [(osx-assembly-style)
        (single-jl #".section __TEXT, __const")]
       [(linux-assembly-style)
        (single-jl #".section .rodata")])]
    [(alignment-directive alignment fill)
     (varargs join-list #".p2align " (integer->decimal-bytes alignment)
              #", 0x" (integer->hex-bytes (u8->s64 fill)))]
    [(local-directive label)
     (case style
       [(osx-assembly-style)
        (empty-jl)]
       [(linux-assembly-style)
        (varargs join-list #".local \"" label #"\"")])]
    [(global-directive label)
     (varargs join-list #".global \"" label #"\"")]
    [(label-directive name)
     (varargs join-list #"\"" name #"\"" #":")]
    [(quad-directive/label label addend)
     (varargs join-list #".quad \"" label #"\" + " (integer->decimal-bytes addend))]
    [(quad-directive/integer value)
     (varargs join-list #".quad " (integer->decimal-bytes value))]
    [(ascii-directive value)
     (varargs append-jl*
       (single-jl #".ascii \"")
       (escape-bytes value)
       (single-jl #"\""))]))

(define (escape-bytes [src : Bytes]) : (JoinList Bytes)
  (concat-jl (bytes-map src (lambda ([v : U8])
                              (varargs join-list
                                #"\\"
                                (integer->triple-octal-bytes v))))))

(define (instruction->assembly-bytes [style : AssemblyStyle] [inst : Instruction]) : (JoinList Bytes)
  (case inst
    [(addq rmi1 rm2)
     (varargs join-list
        #"addq "
        (r64mi->bytes rmi1)
        #", "
        (r64m->bytes rm2))]
    [(andq rmi reg)
     (varargs join-list
        #"andq "
        (r64mi->bytes rmi)
        #", "
        (register64->bytes reg))]
    [(call label)
     (varargs join-list #"call " label)]
    [(call/indirect rm)
     (varargs join-list #"callq *" (r64m->bytes rm))]
    [(cld)
     (single-jl #"cld")]
    [(cmpq rmi1 rm2)
     (varargs join-list
        #"cmpq "
        (r64mi->bytes rmi1)
        #", "
        (r64m->bytes rm2))]
    [(cmpb r8mi1 r8m2)
     (varargs join-list
        #"cmpb "
        (r8mi->bytes r8mi1)
        #", "
        (r8m->bytes r8m2))]
    [(decq reg)
     (varargs join-list #"decq " (register64->bytes reg))]
    [(idivq reg)
     (varargs join-list #"idivq " (register64->bytes reg))]
    [(imulq reg1 reg2)
     (varargs join-list
        #"imulq "
        (register64->bytes reg1)
        #", "
        (register64->bytes reg2))]
    [(imulq/imm/s8 imm rm reg)
     (varargs join-list
         #"imulq "
         #"$" (integer->decimal-bytes (s8->s64 imm))
         #", "
         (r64m->bytes rm)
         #", "
         (register64->bytes reg))]
    [(imulq/imm/s32 imm rm reg)
     (varargs join-list
         #"imulq "
         #"$" (integer->decimal-bytes (s32->s64 imm))
         #", "
         (r64m->bytes rm)
         #", "
         (register64->bytes reg))]
    [(incq reg)
     (varargs join-list #"incq " (register64->bytes reg))]
    [(jb label)
     (varargs join-list #"jb" (jump-suffix style) #" " label)]
    [(jbe label)
     (varargs join-list #"jbe" (jump-suffix style) #" " label)]
    [(je label)
     (varargs join-list #"je" (jump-suffix style) #" " label)]
    [(jl label)
     (varargs join-list #"jl" (jump-suffix style) #" " label)]
    [(jg label)
     (varargs join-list #"jg" (jump-suffix style) #" " label)]
    [(jle label)
     (varargs join-list #"jle" (jump-suffix style) #" " label)]
    [(jge label)
     (varargs join-list #"jge" (jump-suffix style) #" " label)]
    [(jmp label)
     (varargs join-list #"jmp" (jump-suffix style) #" " label)]
    ;; Don't use a suffix on indirect jumps as displacements aren't currently generated.
    [(jmp/indirect rm)
     (varargs join-list #"jmp *" (r64m->bytes rm))]
    [(jne label)
     (varargs join-list #"jne" (jump-suffix style) #" " label)]
    [(jnz label)
     (varargs join-list #"jnz" (jump-suffix style) #" " label)]
    [(lahf)
     (single-jl #"lahf")]
    [(leaq mem reg)
     (varargs join-list
        #"leaq "
        (mem->bytes mem)
        #", "
        (register64->bytes reg))]
    [(leaq/rip-rel label reg)
     (varargs join-list
        #"leaq "
        label
        #"(%rip),"
        (register64->bytes reg))]
    [(movb rmi mem)
     (varargs join-list
        #"movb "
        (r8mi->bytes rmi)
        #", "
        (mem->bytes mem))]
    [(movq rmi1 rm2)
     (varargs join-list
        #"movq "
        (r64mi->bytes rmi1)
        #", "
        (r64m->bytes rm2))]
    [(movq/imm64 imm reg)
     (varargs join-list
        #"movq "
        #"$" (integer->decimal-bytes imm)
        #", "
        (register64->bytes reg))]
    [(movzbq r8m reg)
     (varargs join-list
        #"movzbq "
        (r8m->bytes r8m)
        #", "
        (register64->bytes reg))]
    [(negq reg)
     (varargs join-list #"negq " (register64->bytes reg))]
    [(nop)
     (single-jl #"nop")]
    [(notq reg)
     (varargs join-list #"notq " (register64->bytes reg))]
    [(orq reg1 reg2)
     (varargs join-list
        #"orq "
        (register64->bytes reg1)
        #", "
        (register64->bytes reg2))]
    [(popq rm)
     (varargs join-list #"popq " (r64m->bytes rm))]
    [(pushq rmi)
     (varargs join-list #"pushq " (r64mi->bytes rmi))]
    [(rep-stosb)
     (single-jl #"rep stosb")]
    [(rep-stosq)
     (single-jl #"rep stosq")]
    [(rep-movsb)
     (single-jl #"rep movsb")]
    [(rep-movsq)
     (single-jl #"rep movsq")]
    [(repe-cmpsb)
     (single-jl #"repe cmpsb")]
    [(repne-scasb)
     (single-jl #"repne scasb")]
    [(repne-scasq)
     (single-jl #"repne scasq")]
    [(ret)
     (single-jl #"ret")]
    [(sete reg)
     (varargs join-list #"sete " (register8->bytes reg))]
    [(setg reg)
     (varargs join-list #"setg " (register8->bytes reg))]
    [(setge reg)
     (varargs join-list #"setge " (register8->bytes reg))]
    [(setl reg)
     (varargs join-list #"setl " (register8->bytes reg))]
    [(setle reg)
     (varargs join-list #"setle " (register8->bytes reg))]
    [(setne reg)
     (varargs join-list #"setne " (register8->bytes reg))]
    [(shlq reg)
     (varargs join-list #"shlq %cl, " (register64->bytes reg))]
    [(shlq/imm v reg)
     (varargs join-list #"shlq $" (integer->decimal-bytes (s8->s64 v)) #", " (register64->bytes reg))]
    [(shrq reg)
     (varargs join-list #"shrq %cl, " (register64->bytes reg))]
    [(shrq/imm v reg)
     (varargs join-list #"shrq $" (integer->decimal-bytes (s8->s64 v)) #", " (register64->bytes reg))]
    [(std)
     (single-jl #"std")]
    [(subq rmi reg)
     (varargs join-list
        #"subq "
        (r64mi->bytes rmi)
        #", "
        (register64->bytes reg))]
    [(syscall)
     (single-jl #"syscall")]
    [(test reg1 reg2)
     (varargs join-list #"test " (register64->bytes reg1) #", " (register64->bytes reg2))]
    [(ud2)
     (single-jl #"ud2")]
    [(xaddq reg1 reg2)
     (varargs join-list
        #"xaddq "
        (register64->bytes reg1)
        #", "
        (register64->bytes reg2))]
    [(xorq rmi reg)
     (varargs join-list
        #"xorq "
        (r64mi->bytes rmi)
        #", "
        (register64->bytes reg))]))

(define (jump-suffix [style : AssemblyStyle]) : Bytes
  (case style
    [(osx-assembly-style) #""]
    [(linux-assembly-style) #".d32"]))

(define (write-assembly-commands
          [style : AssemblyStyle]
          [cmds : (List AssemblyCommand)]
          [output : OutputPort])
  : Void
  (write-lines (map (lambda ([cmd : AssemblyCommand]) (assembly-command->bytes style cmd)) cmds) output))

(define (line->bytes [line : (JoinList Bytes)]) : Bytes
  (case (jl->list line)
    [(empty) #""]
    [(cons entry (empty)) entry]
    [entries (bytes-append entries)]))

(define (write-lines [lines : (List (JoinList Bytes))] [output : OutputPort]) : Void
  (for-each
    (lambda ([line : (JoinList Bytes)])
      (begin
        (write-line (line->bytes line) output)))
    lines))

(define (write-fragments
          [style : AssemblyStyle]
          [fragments : AssemblyFragments]
          [output : OutputPort])
  : Void
  (write-assembly-commands style (jl->list (fragments->commands fragments)) output))

(define (fragments->commands [fragments : AssemblyFragments]) : (JoinList AssemblyCommand)
  (case fragments
    [(assembly-fragments text-fragments const-fragments)
     (match-define text-commands
       (concat-map-jl/list text-fragment->commands text-fragments))
     (match-define const-commands
       (concat-map-jl/list const-fragment->commands const-fragments))
     (match-define text-scope-commands
        (text-commands->scope-commands (jl->list text-commands)))
     (match-define const-scope-commands
        (const-commands->scope-commands (jl->list const-commands)))
     ;; TODO move the section directives here instead of per fragment
     (varargs append-jl*
       (varargs join-list
         (directive-cmd (text-section-directive))
         (directive-cmd (const-data-section-directive)))
       (list->jl text-scope-commands)
       (list->jl const-scope-commands)
       text-commands
       const-commands)]))

(define (text-fragment->commands [frag : TextFragment]) : (JoinList AssemblyCommand)
  (case frag
    [(function-fragment name sections)
     (cons-jl
       (directive-cmd (text-section-directive))
       (cons-jl
         (directive-cmd (alignment-directive 4 (u8 #xCC)))
         (cons-jl
           (directive-cmd (global-directive name))
           (sections->commands name sections))))]))

(define (const-fragment->commands [frag : ConstFragment]) : (JoinList AssemblyCommand)
  (case frag
    [(address-fragment name value addend align)
     (varargs join-list
       (directive-cmd (const-data-section-directive))
       (directive-cmd (alignment-directive align (u8 #x00)))
       (directive-cmd (global-directive name))
       (directive-cmd (label-directive name))
       (directive-cmd (quad-directive/label value addend)))]
    [(bytes-fragment name value align)
     (varargs join-list
       (directive-cmd (const-data-section-directive))
       (directive-cmd (alignment-directive align (u8 #x00)))
       (directive-cmd (global-directive name))
       (directive-cmd (label-directive name))
       (directive-cmd (ascii-directive value)))]))



(define (sections->commands [function-name : Bytes] [sections : (List Section)]) : (JoinList AssemblyCommand)
  (match-define referenced-labels (set-add (sections->referenced-labels sections) function-name))
  (foldl
    (lambda ([s : Section] [acc : (JoinList AssemblyCommand)])
      (case s
        [(section blocks)
         (append-jl
           (basic-blocks->commands blocks referenced-labels)
           acc)]))
    ;; This reverse is because the function header is added as a section instead of a block
    ;; in the first section.
    (reverse sections)
    (ann (JoinList AssemblyCommand) (empty-jl))))

(define (basic-blocks->commands [blocks : (List BasicBlock)] [referenced-labels : (Set Bytes)])
  : (JoinList AssemblyCommand)
  (case blocks
    [(empty) (empty-jl)]
    [(cons (basic-block name instructions) blocks)
     (append-jl
       (let ([commands (map-jl instruction-cmd instructions)])
         (if (set-member? referenced-labels name)
             (cons-jl
               (directive-cmd (label-directive name))
               commands)
             commands))
       (basic-blocks->commands blocks referenced-labels))]))

(define (text-commands->scope-commands [cmds : (List AssemblyCommand)]) : (List AssemblyCommand)
  (text-commands->scope-commands* cmds (empty) (make-set bytes-cmp)))

(define (text-commands->scope-commands*
          [cmds : (List AssemblyCommand)]
          [rev-commands : (List AssemblyCommand)]
          [globals : (Set Bytes)])
  : (List AssemblyCommand)
  (case cmds
    [(empty)
     (reverse rev-commands)]
    [(cons (directive-cmd (global-directive sym)) cmds)
     (text-commands->scope-commands* cmds rev-commands (set-add globals sym))]
    [(cons (directive-cmd (label-directive sym)) cmds)
     (text-commands->scope-commands*
       cmds
       (cons (directive-cmd
               (if (set-member? globals sym)
                   (global-directive sym)
                   (local-directive sym)))
             rev-commands)
       globals)]
    [(cons _ cmds)
     (text-commands->scope-commands* cmds rev-commands globals)]))

(define (const-commands->scope-commands [cmds : (List AssemblyCommand)]) : (List AssemblyCommand)
  (filter
    (lambda ([cmd : AssemblyCommand])
      (case cmd
        [(directive-cmd (global-directive _)) #t]
        [(directive-cmd (local-directive _)) #t]
        [_ #f]))
    cmds))
