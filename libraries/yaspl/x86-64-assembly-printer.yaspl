#:module (yaspl x86-64-assembly-printer)
#:import {
  (bytes)
  (io)
  (join-list)
  (list)
  (numbers)
  (prim)
  (set)
  (yaspl x86-64-assembly)
}
(export
  (#:types AssemblyCommand AssemblerDirective)
  (#:values write-fragments const-fragment->commands text-fragment->commands assembly-commands->bytes
            linux-assembly-style osx-assembly-style)
  (#:patterns))
(types
  (define-type AssemblyStyle
    (linux-assembly-style)
    (osx-assembly-style))
  (define-type AssemblyCommand
    (directive-cmd [directive : AssemblerDirective])
    (instruction-cmd [instruction : Instruction]))
  (define-type AssemblerDirective
    (section-directive [segment-name : Bytes] [section-name : Bytes])
    (alignment-directive)
    (global-directive [label : Bytes])
    (label-directive [name : Bytes])
    (quad-directive/label [label : Bytes])
    (quad-directive/integer [value : Int])
    (ascii-directive [value : Bytes])))

(define (register8->bytes [reg : Register8]) : Bytes
  (case reg
    [(al) #"%al"]
    [(ah) #"%ah"]
    [(bl) #"%bl"]
    [(bh) #"%bh"]
    [(cl) #"%cl"]
    [(ch) #"%ch"]
    [(dl) #"%dl"]
    [(dh) #"%dh"]
    [(dil) #"%dil"]
    [(sil) #"%sil"]
    [(bpl) #"%bpl"]
    [(spl) #"%spl"]
    [(r8b) #"%r8b"]
    [(r9b) #"%r9b"]
    [(r10b) #"%r10b"]
    [(r11b) #"%r11b"]
    [(r12b) #"%r12b"]
    [(r13b) #"%r13b"]
    [(r14b) #"%r14b"]
    [(r15b) #"%r15b"]))

(define (register64->bytes [reg : Register64]) : Bytes
  (case reg
    [(rax) #"%rax"]
    [(rbx) #"%rbx"]
    [(rcx) #"%rcx"]
    [(rdx) #"%rdx"]
    [(rdi) #"%rdi"]
    [(rsi) #"%rsi"]
    [(rbp) #"%rbp"]
    [(rsp) #"%rsp"]
    [(r8) #"%r8"]
    [(r9) #"%r9"]
    [(r10) #"%r10"]
    [(r11) #"%r11"]
    [(r12) #"%r12"]
    [(r13) #"%r13"]
    [(r14) #"%r14"]
    [(r15) #"%r15"]))

(define (r64mi->bytes [rmi : Reg64MemImm]) : Bytes
  (case rmi
    [(r64mi-reg r) (register64->bytes r)]
    [(r64mi-mem m) (mem->bytes m)]
    [(r64mi-imm v)
     (bytes-append (varargs list #"$" (integer->decimal-bytes (s32->s64 v))))]))

(define (r64m->bytes [rm : Reg64Mem]) : Bytes
  (case rm
    [(r64m-reg r) (register64->bytes r)]
    [(r64m-mem m) (mem->bytes m)]))

(define (r8m->bytes [rm : Reg8Mem]) : Bytes
  (case rm
    [(r8m-reg r) (register8->bytes r)]
    [(r8m-mem m) (mem->bytes m)]))

(define (r8mi->bytes [rm : Reg8MemImm]) : Bytes
  (case rm
    [(r8mi-reg r) (register8->bytes r)]
    [(r8mi-mem m) (mem->bytes m)]
    [(r8mi-imm v)
     (bytes-append (varargs list #"$" (integer->decimal-bytes (u8->s64 v))))]))


(define (mem->bytes [mem : MemoryArgument]) : Bytes
  (case mem
    [(mem-direct reg)
     (bytes-append (varargs list #"(" (register64->bytes reg) #")"))]
    [(mem-sib-direct reg)
     (bytes-append (varargs list #"(" (register64->bytes reg) #")"))]
    [(mem-displaced reg offset)
     (bytes-append (varargs list (integer->decimal-bytes (s32->s64 offset))
                            #"(" (register64->bytes reg) #")"))]
    [(mem-scaled reg scale index offset)
     (bytes-append
       (varargs list
         (integer->decimal-bytes (s32->s64 offset))
         #"("
         (register64->bytes reg)
         #", "
         (register64->bytes index)
         #", "
         (integer->decimal-bytes
           (case scale
             [(scale-1) 1]
             [(scale-2) 2]
             [(scale-4) 4]
             [(scale-8) 8]))
         #")"))]))



;; Generates a text version of the assembly commands.
(define (assembly-commands->bytes
          [style : AssemblyStyle]
          [cmds : (List AssemblyCommand)])
  : (JoinList Bytes)
  (case cmds
    [(empty) (empty-jl)]
    [(cons cmd cmds)
     (append-jl
       (assembly-command->bytes style cmd)
       (cons-jl
         #"\n"
         (assembly-commands->bytes style cmds)))]))

(define (assembly-command->bytes [style : AssemblyStyle] [cmd : AssemblyCommand]) : (JoinList Bytes)
  (case cmd
    [(directive-cmd directive) (assembler-directive->bytes style directive)]
    [(instruction-cmd instruction) (instruction->assembly-bytes style instruction)]))

(define (assembler-directive->bytes [style : AssemblyStyle] [dir : AssemblerDirective]) : (JoinList Bytes)
  (case dir
    [(section-directive seg sect)
     (case style
       [(osx-assembly-style)
        (varargs join-list #".section " seg #"," sect)]
       [(linux-assembly-style)
        (empty-jl)])]
    [(alignment-directive)
     (single-jl #".p2align 4,0")]
    [(global-directive label)
     (varargs join-list #".global \"" label #"\"")]
    [(label-directive name)
     (varargs join-list #"\"" name #"\"" #":")]
    [(quad-directive/label label)
     (varargs join-list #".quad \"" label #"\"")]
    [(quad-directive/integer value)
     (varargs join-list #".quad " (integer->decimal-bytes value))]
    [(ascii-directive value)
     (varargs append-jl*
       (single-jl #".ascii \"")
       (escape-bytes value 0 0)
       (single-jl #"\""))]))

(define (escape-bytes [src : Bytes] [start : Int] [cur : Int]) : (JoinList Bytes)
  (if (= cur (bytes-length src))
      (single-jl (subbytes src start cur))
      (let ([byte (u8->s64 (bytes-ref src cur))])
        (if (= byte 10) ;; newline
            (cons-jl
              (subbytes src start cur)
              (cons-jl #"\\n" (escape-bytes src (+ 1 cur) (+ 1 cur))))
            (if (= byte 13) ;; carriage return
                (cons-jl
                  (subbytes src start cur)
                  (cons-jl #"\\r" (escape-bytes src (+ 1 cur) (+ 1 cur))))
                (if (= byte 34) ;; double quote
                    (cons-jl
                      (subbytes src start cur)
                      (cons-jl #"\\\"" (escape-bytes src (+ 1 cur) (+ 1 cur))))
                    (if (= byte 92) ;; backslash
                        (cons-jl
                          (subbytes src start cur)
                          (cons-jl #"\\\\" (escape-bytes src (+ 1 cur) (+ 1 cur))))
                        (escape-bytes src start (+ 1 cur)))))))))


(define (instruction->assembly-bytes [style : AssemblyStyle] [inst : Instruction]) : (JoinList Bytes)
  (case inst
    [(addq rmi1 rm2)
     (varargs join-list
        #"addq "
        (r64mi->bytes rmi1)
        #", "
        (r64m->bytes rm2))]
    [(andq rmi reg)
     (varargs join-list
        #"andq "
        (r64mi->bytes rmi)
        #", "
        (register64->bytes reg))]
    [(call label)
     (varargs join-list #"call " label)]
    [(call/indirect rm)
     (varargs join-list #"callq *" (r64m->bytes rm))]
    [(cld)
     (single-jl #"cld")]
    [(cmpq rmi1 rm2)
     (varargs join-list
        #"cmpq "
        (r64mi->bytes rmi1)
        #", "
        (r64m->bytes rm2))]
    [(cmpb r8mi1 r8m2)
     (varargs join-list
        #"cmpb "
        (r8mi->bytes r8mi1)
        #", "
        (r8m->bytes r8m2))]
    [(decq reg)
     (varargs join-list #"decq " (register64->bytes reg))]
    [(idivq reg)
     (varargs join-list #"idivq " (register64->bytes reg))]
    [(imulq reg1 reg2)
     (varargs join-list
        #"imulq "
        (register64->bytes reg1)
        #", "
        (register64->bytes reg2))]
    [(imulq/imm imm rmi reg)
     (varargs join-list
         #"imulq "
         #"$" (integer->decimal-bytes (s32->s64 imm))
         #", "
         (r64mi->bytes rmi)
         #", "
         (register64->bytes reg))]
    [(incq reg)
     (varargs join-list #"incq " (register64->bytes reg))]
    [(jb label)
     (varargs join-list #"jb" (jump-suffix style) #" " label)]
    [(jbe label)
     (varargs join-list #"jbe" (jump-suffix style) #" " label)]
    [(je label)
     (varargs join-list #"je" (jump-suffix style) #" " label)]
    [(jl label)
     (varargs join-list #"jl" (jump-suffix style) #" " label)]
    [(jg label)
     (varargs join-list #"jg" (jump-suffix style) #" " label)]
    [(jle label)
     (varargs join-list #"jle" (jump-suffix style) #" " label)]
    [(jge label)
     (varargs join-list #"jge" (jump-suffix style) #" " label)]
    [(jmp label)
     (varargs join-list #"jmp" (jump-suffix style) #" " label)]
    [(jmp/indirect rm)
     (varargs join-list #"jmp" (jump-suffix style) #" *" (r64m->bytes rm))]
    [(jne label)
     (varargs join-list #"jne" (jump-suffix style) #" " label)]
    [(jnz label)
     (varargs join-list #"jnz" (jump-suffix style) #" " label)]
    [(lahf)
     (single-jl #"lahf")]
    [(leaq mem reg)
     (varargs join-list
        #"leaq "
        (mem->bytes mem)
        #", "
        (register64->bytes reg))]
    [(leaq/rip-rel label reg)
     (varargs join-list
        #"leaq "
        label
        #"(%rip),"
        (register64->bytes reg))]
    [(movb rmi mem)
     (varargs join-list
        #"movb "
        (r8mi->bytes rmi)
        #", "
        (mem->bytes mem))]
    [(movq rmi1 rm2)
     (varargs join-list
        #"movq "
        (r64mi->bytes rmi1)
        #", "
        (r64m->bytes rm2))]
    [(movq/imm imm reg)
     (varargs join-list
        #"movq "
        #"$" (integer->decimal-bytes imm)
        #", "
        (register64->bytes reg))]
    [(movzbq r8m reg)
     (varargs join-list
        #"movzbq "
        (r8m->bytes r8m)
        #", "
        (register64->bytes reg))]
    [(negq reg)
     (varargs join-list #"negq " (register64->bytes reg))]
    [(nop)
     (single-jl #"nop")]
    [(notq reg)
     (varargs join-list #"notq " (register64->bytes reg))]
    [(orq reg1 reg2)
     (varargs join-list
        #"orq "
        (register64->bytes reg1)
        #", "
        (register64->bytes reg2))]
    [(popq rm)
     (varargs join-list #"popq " (r64m->bytes rm))]
    [(pushq rmi)
     (varargs join-list #"pushq " (r64mi->bytes rmi))]
    [(rep-stosb)
     (single-jl #"rep stosb")]
    [(rep-stosq)
     (single-jl #"rep stosq")]
    [(rep-movsb)
     (single-jl #"rep movsb")]
    [(rep-movsq)
     (single-jl #"rep movsq")]
    [(repe-cmpsb)
     (single-jl #"repe cmpsb")]
    [(repne-scasb)
     (single-jl #"repne scasb")]
    [(repne-scasq)
     (single-jl #"repne scasq")]
    [(ret)
     (single-jl #"ret")]
    [(sete reg)
     (varargs join-list #"sete " (register8->bytes reg))]
    [(setg reg)
     (varargs join-list #"setg " (register8->bytes reg))]
    [(setge reg)
     (varargs join-list #"setge " (register8->bytes reg))]
    [(setl reg)
     (varargs join-list #"setl " (register8->bytes reg))]
    [(setle reg)
     (varargs join-list #"setle " (register8->bytes reg))]
    [(setne reg)
     (varargs join-list #"setne " (register8->bytes reg))]
    [(shlq reg)
     (varargs join-list #"shlq %cl, " (register64->bytes reg))]
    [(shlq/imm v reg)
     (varargs join-list #"shlq " (integer->decimal-bytes (u8->s64 v)) #", " (register64->bytes reg))]
    [(shrq reg)
     (varargs join-list #"shrq %cl, " (register64->bytes reg))]
    [(shrq/imm v reg)
     (varargs join-list #"shrq " (integer->decimal-bytes (u8->s64 v)) #", " (register64->bytes reg))]
    [(std)
     (single-jl #"std")]
    [(subq rmi reg)
     (varargs join-list
        #"subq "
        (r64mi->bytes rmi)
        #", "
        (register64->bytes reg))]
    [(syscall)
     (single-jl #"syscall")]
    [(test reg1 reg2)
     (varargs join-list #"test " (register64->bytes reg1) #", " (register64->bytes reg2))]
    [(ud2)
     (single-jl #"ud2")]
    [(xaddq reg1 reg2)
     (varargs join-list
        #"xaddq "
        (register64->bytes reg1)
        #", "
        (register64->bytes reg2))]
    [(xorq rmi reg)
     (varargs join-list
        #"xorq "
        (r64mi->bytes rmi)
        #", "
        (register64->bytes reg))]))

(define (jump-suffix [style : AssemblyStyle]) : Bytes
  (case style
    [(osx-assembly-style) #""]
    [(linux-assembly-style) #".d32"]))

(define (write-assembly-commands
          [style : AssemblyStyle]
          [cmds : (List AssemblyCommand)]
          [output : OutputPort])
  : Void
  (write-lines (map (lambda ([cmd : AssemblyCommand]) (assembly-command->bytes style cmd)) cmds) output))

(define (line->bytes [line : (JoinList Bytes)]) : Bytes
  (case (jl->list line)
    [(empty) #""]
    [(cons entry (empty)) entry]
    [entries (bytes-append entries)]))

(define (write-lines [lines : (List (JoinList Bytes))] [output : OutputPort]) : Void
  (for-each
    (lambda ([line : (JoinList Bytes)])
      (begin
        (write-line (line->bytes line) output)))
    lines))

(define (write-fragments
          [style : AssemblyStyle]
          [fragments : AssemblyFragments]
          [output : OutputPort])
  : Void
  (write-assembly-commands style (jl->list (fragments->commands fragments)) output))

(define (fragments->commands [fragments : AssemblyFragments]) : (JoinList AssemblyCommand)
  (case fragments
    [(assembly-fragments text-fragments const-fragments)
     ;; TODO move the section directives here instead of per fragment
     (append-jl
       (concat-map-jl text-fragment->commands (list->jl text-fragments))
       (concat-map-jl const-fragment->commands (list->jl const-fragments)))]))

(define (text-fragment->commands [frag : TextFragment]) : (JoinList AssemblyCommand)
  (case frag
    [(function-fragment name sections)
     (cons-jl
       (directive-cmd (section-directive #"__TEXT" #"__text"))
       (cons-jl
         (directive-cmd (alignment-directive))
         (cons-jl
           (directive-cmd (global-directive name))
           (sections->commands name sections))))]))

(define (const-fragment->commands [frag : ConstFragment]) : (JoinList AssemblyCommand)
  (case frag
    [(address-fragment name value)
     (varargs join-list
       (directive-cmd (section-directive #"__TEXT" #"__const"))
       (directive-cmd (global-directive name))
       (directive-cmd (label-directive name))
       (directive-cmd (quad-directive/label value)))]
    [(bytes-fragment name value)
     (varargs join-list
       (directive-cmd (section-directive #"__TEXT" #"__const"))
       (directive-cmd (global-directive name))
       (directive-cmd (label-directive name))
       (directive-cmd (ascii-directive value)))]))



(define (sections->commands [function-name : Bytes] [sections : (List Section)]) : (JoinList AssemblyCommand)
  (match-define referenced-labels (set-add (sections->referenced-labels sections) function-name))
  (foldl
    (lambda ([s : Section] [acc : (JoinList AssemblyCommand)])
      (case s
        [(section blocks)
         (append-jl
           (basic-blocks->commands blocks referenced-labels)
           acc)]))
    ;; This reverse is because the function header is added as a section instead of a block
    ;; in the first section.
    (reverse sections)
    (ann (JoinList AssemblyCommand) (empty-jl))))

(define (basic-blocks->commands [blocks : (List BasicBlock)] [referenced-labels : (Set Bytes)])
  : (JoinList AssemblyCommand)
  (case blocks
    [(empty) (empty-jl)]
    [(cons (basic-block name instructions) blocks)
     (append-jl
       (let ([commands (map-jl instruction-cmd instructions)])
         (if (set-member? referenced-labels name)
             (cons-jl
               (directive-cmd (label-directive name))
               commands)
             commands))
       (basic-blocks->commands blocks referenced-labels))]))
