#:module (yaspl module-environment)
#:import {
  (bytes)
  (dict)
  (intermediate-language)
  (list)
  (maybe)
  (module-name)
  (module-signature)
  (prim)
  (resolved-imports-language) {
    #:patterns
      imports
  }
  (top-level-name)
}
(export
  #:types (ModuleEnvironment)
  #:values (module-environment-tag-ref make-module-environment
            mangle-name mangled-mod-name mangle-top-level-name)
  #:patterns ())
(types
  (define-type ModuleEnvironment
    (module-environment
      [variant-bindings : (Dict Bytes VariantInfo)]))
  (define-type VariantInfo
    (variant-info [tag : Int])))

(define (module-environment-tag-ref [env : ModuleEnvironment] [name : Bytes]) : (Maybe Int)
  (case (dict-ref (module-environment-variant-bindings env) name)
    [(nothing) (nothing)]
    [(just tag) (just (variant-info-tag tag))]))


(define (make-module-environment [imod : Module]) : ModuleEnvironment
  (module-environment
    (add-all-imported-patterns
      (add-type-definitions-variant-infos/top
        (make-dict bytes-cmp) imod)
      imod)))

(define (add-all-imported-patterns [env : (Dict Bytes VariantInfo)] [imod : Module])
  : (Dict Bytes VariantInfo)
  (match-define (imports _ _ patterns _) (module-imports imod))
  (merge-dicts
    (dict-value-map
      patterns
      (lambda ([p : PatternSignature])
        (case p
          [(pattern-signature _ tag _ _ _ _)
           (variant-info tag)])))
    env))

(define (add-type-definitions-variant-infos/top [env : (Dict Bytes VariantInfo)] [imod : Module])
  : (Dict Bytes VariantInfo)
  (add-type-definitions-variant-infos env (module-types imod)))

(define (add-type-definitions-variant-infos
          [env : (Dict Bytes VariantInfo)]
          [defs : (List TypeDefinition)])
  : (Dict Bytes VariantInfo)
  (case defs
    [(empty) env]
    [(cons (type-definition _ _ _ _ variants) defs)
     (add-type-definitions-variant-infos
       (add-variant-definitions-variant-infos env variants)
       defs)]))

(define (add-variant-definitions-variant-infos
          [env : (Dict Bytes VariantInfo)]
          [defs : (List VariantDefinition)])
  : (Dict Bytes VariantInfo)
  (case defs
    [(empty) env]
    [(cons (variant-definition name tag _) defs)
     (add-variant-definitions-variant-infos
       (dict-add env name (variant-info tag))
       defs)]))

;; TODO move mangling out of this module
;; TODO remove initial y once starting with an 'l' is not an issue
(define (mangle-name [name : Bytes]) : Bytes
  (let ([len (bytes-length name)])
    (bytes-append (varargs list
                           #"y"
                           (mangle-name/helper name (make-bytes len) (- len 1))))))

(define (mangle-top-level-name [t : TopLevelName]) : Bytes
  (match-define (top-level-name m l) t)
  (mangle-name (bytes-append (varargs list (mangled-mod-name m) #"_" l))))

;; TODO Figure out how to avoid overlap in generated mangled names
(define (mangle-name/helper [orig-name : Bytes] [buf : Bytes] [index : Int]) : Bytes
  (if (> 0 index)
      buf
      (let ([byte/u8 (bytes-ref orig-name index)])
        (let ([byte (u8->s64 byte/u8)])
          (let ([new-byte
                 (if (or (= byte 45)
                         (or (= byte 42)
                             (or (= byte 62)
                                 (or (= byte 47)
                                     (or (= byte 61)
                                         (or (= byte 63)
                                             (or (= byte 60)
                                                 (= byte 33))))))))
                     (u8 95)
                     byte/u8)])
            (begin
              (bytes-set! buf index new-byte)
              (mangle-name/helper orig-name buf (- index 1))))))))

;; TODO merge this with the rest of mangling
(define (mangled-mod-name [m : ModName]) : Bytes
  (bytes-append (interleave (mod-name-parts m) #"_")))
