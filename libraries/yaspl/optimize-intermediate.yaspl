#:module (yaspl optimize-intermediate)
#:import {
  (bytes)
  (dict)
  (intermediate-expression)
  (intermediate-language)
  (join-list)
  (list)
  (maybe)
  (module-name)
  (module-signature)
  (prim)
  (resolved-imports-language) {
    #:patterns
      imports
  }
  (tuples)
  (yaspl module-environment)
}
(export
  #:types ()
  #:values (optimize-intermediate-module)
  #:patterns ())
(types
  (define-type OptimizeEnvironment
    (optimize-environment
      [inlineable : (Dict Bytes InlineableFunction)]
      [known-functions : (Dict Bytes Bytes)])))

(define (make-optimize-environment [mod : Module]) : OptimizeEnvironment
  (optimize-environment
    (add-all-imported-functions
      (make-dict bytes-cmp)
      mod)
    (add-all-datatype-known-functions
      (add-all-defined-known-functions
        (add-all-imported-known-functions
          (make-dict bytes-cmp)
          mod)
        mod)
      mod)))

(define (add-all-imported-functions [env : (Dict Bytes InlineableFunction)] [mod : Module])
  : (Dict Bytes InlineableFunction)
  (match-define (imports _ values _) (module-imports mod))
  (merge-dicts
    (dict-filter-map values
      (lambda ([k : Bytes] [v : ValueSignature])
        (case v
          [(value-signature _ symbol _ inlineable)
           inlineable])))
    env))

(define (add-all-defined-known-functions [env : (Dict Bytes Bytes)] [mod : Module])
  : (Dict Bytes Bytes)
  (match-define mod-name (module-name mod))
  (foldl
    (lambda ([closure : ClosureConstant] [acc : (Dict Bytes Bytes)])
      (case closure
        [(closure-constant name fun-name)
         (dict-add
           acc name
           (mangle-name (bytes-append (varargs list (mangled-mod-name mod-name) #"_" fun-name))))]))
    (module-closures mod)
    env))

(define (add-all-imported-known-functions [env : (Dict Bytes Bytes)] [mod : Module])
  : (Dict Bytes Bytes)
  (match-define (imports _ values _) (module-imports mod))
  (merge-dicts
    (dict-filter-map values
      (lambda ([k : Bytes] [v : ValueSignature]) : (Maybe Bytes)
        (case v
          [(value-signature _ symbol known _)
           (case known
             [(just t) (just (mangle-top-level-name t))]
             [(nothing) (nothing)])])))
    env))

(define (add-all-datatype-known-functions [env : (Dict Bytes Bytes)] [mod : Module])
  : (Dict Bytes Bytes)
  (match-define mod-name (module-name mod))
  (dict-add-all
    env
    (jl->list
      (concat-jl
        (map
          (lambda ([type-def : TypeDefinition])
            (case type-def
              [(type-definition type-name _ _ _ (cons variant (empty)))
               (cons-jl
                 (variant-definition/constructor-known-function mod-name type-name variant)
                 (variant-definition/accessor-known-functions mod-name type-name variant))]
              [(type-definition type-name _ _ _ variants)
               (list->jl
                 (map
                   (lambda ([variant : VariantDefinition])
                     (variant-definition/constructor-known-function mod-name type-name variant))
                   variants))]))
          (module-types mod))))))

(define (variant-definition/constructor-known-function
          [mod-name : ModName]
          [type-name : Bytes]
          [def : VariantDefinition]) : (Tuple2 Bytes Bytes)
  (match-define (variant-definition name variant-tag fields) def)
  (tuple2
    name
    (mangle-name (bytes-append (varargs list (mangled-mod-name mod-name) #"_" type-name #"_" name)))))


(define (variant-definition/accessor-known-functions
          [mod-name : ModName]
          [type-name : Bytes]
          [variant : VariantDefinition]) : (JoinList (Tuple2 Bytes Bytes))
  (match-define (variant-definition variant-name variant-tag fields) variant)
  (list->jl
    (map
      (lambda ([field : VariantField])
        (case field
          [(variant-field field-name _)
           (tuple2
             (bytes-append (varargs list variant-name #"-" field-name))
             (mangle-name
               (bytes-append (varargs list (mangled-mod-name mod-name) #"_" type-name #"_" variant-name
                                      #"_" field-name))))]))
      fields)))





(define (optimize-intermediate-module [mod : Module]) : Module
  (match-define (module names imports exports types definitions closures bytes) mod)
  (module names imports exports types
          (optimize-function-definitions definitions (make-optimize-environment mod))
          closures bytes))

(define (optimize-function-definitions [functions : (List FunctionDefinition)]
                                       [env : OptimizeEnvironment])
  : (List FunctionDefinition)
  (map
    (lambda ([f : FunctionDefinition]) (optimize-function-definition f env))
    functions))

(define (optimize-function-definition [function : FunctionDefinition]
                                      [env : OptimizeEnvironment])
  : FunctionDefinition
  (match-define (function-definition name type args free-vars body) function)
  (function-definition name type args free-vars (optimize-expr body env)))


(define (optimize-expr [expr : Expression] [env : OptimizeEnvironment]) : Expression
  (match-define recur (lambda ([e : Expression]) (optimize-expr e env)))
  (match-define recur-clause (lambda ([c : CaseClause]) (optimize-clause c env)))
  (case expr
    [(int-literal _) expr]
    [(boolean-literal _) expr]
    [(local-var-expr _) expr]
    [(global-var-expr _) expr]
    [(if-expr c t f)
     (if-expr (recur c) (recur t) (recur f))]
    [(begin-expr exprs last-expr)
     (begin-expr (map recur exprs) (recur last-expr))]
    [(create-closure-expr fun-name args)
     (create-closure-expr fun-name (map recur args))]
    [(call-closure-expr tail-position op args)
     (match-define opt-args (map recur args))
     (case (expr->inlineable op env)
       [(just (hoas-linear-inlineable-function f))
        (f opt-args)]
       [(nothing)
        (case (expr->known-function op env)
          [(just fun-name)
           (call-function-expr tail-position fun-name opt-args)]
          [(nothing)
           (call-closure-expr tail-position (recur op) opt-args)])])]
    [(call-function-expr tail-position fun-name args)
     (call-function-expr tail-position fun-name (map recur args))]
    [(let-expr name expr body)
     (let-expr name (recur expr) (recur body))]
    [(case-expr expr clauses)
     (case-expr (recur expr) (map recur-clause clauses))]
    [(array-expr args)
     (array-expr (map recur args))]
    [(make-array-expr size expr)
     (make-array-expr (recur size) (recur expr))]
    [(array-length-expr arr)
     (array-length-expr (recur arr))]
    [(array-ref-expr arr off)
     (array-ref-expr (recur arr) (recur off))]
    [(array-set!-expr arr off val)
     (array-set!-expr (recur arr) (recur off) (recur val))]
    [(bytes-length-expr bytes)
     (bytes-length-expr (recur bytes))]
    [(bytes-ref-expr bytes off)
     (bytes-ref-expr (recur bytes) (recur off))]
    [(bytes-set!-expr bytes off val)
     (bytes-set!-expr (recur bytes) (recur off) (recur val))]
    [(prim-numeric-bin-op op l r)
     (prim-numeric-bin-op op (recur l) (recur r))]
    [(prim-comparison-bin-op op l r)
     (prim-comparison-bin-op op (recur l) (recur r))]
    [(prim-logical-bin-op op l r)
     (prim-logical-bin-op op (recur l) (recur r))]
    [(prim-logical-unary-op op e)
     (prim-logical-unary-op op (recur e))]
    [(no-op-cast-op src dest e)
     (no-op-cast-op src dest e)]))

(define (optimize-clause [clause : CaseClause] [env : OptimizeEnvironment]) : CaseClause
  (case clause
    [(case-clause pattern expr)
     (case-clause pattern (optimize-expr expr env))]))

(define (expr->inlineable [expr : Expression] [env : OptimizeEnvironment]) : (Maybe InlineableFunction)
  (case expr
    [(global-var-expr v)
     (dict-ref (optimize-environment-inlineable env) v)]
    [_ (nothing)]))

(define (expr->known-function [expr : Expression] [env : OptimizeEnvironment]) : (Maybe Bytes)
  (case expr
    [(global-var-expr v)
     (dict-ref (optimize-environment-known-functions env) v)]
    [_ (nothing)]))
