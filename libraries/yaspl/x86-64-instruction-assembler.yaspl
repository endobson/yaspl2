#:module (yaspl x86-64-instruction-assembler)
#:import {
  (bytes)
  (join-list)
  (list)
  (maybe)
  (prim)
  (tuples)
  (yaspl x86-64-assembly)
}
(export
  (#:types MCCommand)
  (#:values instruction->mc-commands)
  (#:patterns mc-bytes mc-branch-relocation mc-call-relocation mc-load-relocation))
(types
  (define-type MCCommand
    (mc-bytes [bytes : Bytes])
    (mc-branch-relocation [symbol : Bytes])
    (mc-call-relocation [symbol : Bytes])
    (mc-load-relocation [symbol : Bytes]))
  (define-type RexRequirement
    (rex-mandatory)
    (rex-forbidden)
    (rex-optional))
  (define-type RexByte
    (no-rex-byte)
    (rex-byte [v : U8]))
  (define-type Immediate
    (imm-s32 [v : S32])
    (imm-u8 [v : U8]))
  (define-type OpCode
    (single-byte-op [v : U8])
    (double-byte-op [v : U8])))

(define (mc-bytes* [bytes : Bytes]) : (JoinList MCCommand)
  (single-jl (mc-bytes bytes)))
(define (mc-branch* [op-code : Bytes] [symbol : Bytes]) : (JoinList MCCommand)
  (varargs join-list
    (mc-bytes op-code)
    (mc-branch-relocation symbol)))

(define (single-byte-op* [v : Int]) : OpCode
  (single-byte-op (u8 v)))
(define (double-byte-op* [v : Int]) : OpCode
  (double-byte-op (u8 v)))

(define (instruction->mc-commands [inst : Instruction]) : (JoinList MCCommand)
  (case inst
    [(addq (r64mi-reg reg) (r64m-reg rm))
     (mc-bytes* (encode-op/RM/reg (single-byte-op* #x01) #t (register64 reg) (register64 rm)))]
    [(addq (r64mi-imm imm) rm)
     (mc-bytes* (single-byte-op/IM #x81 0 #t imm rm))]
    [(addq (r64mi-reg reg) (r64m-mem mem))
     (mc-bytes* (encode-op/RM/mem (single-byte-op* #x01) #t (register64 reg) mem))]
    [(addq (r64mi-mem mem) (r64m-reg reg))
     (mc-bytes* (encode-op/MR/mem (single-byte-op* #x03) #t mem (register64 reg)))]
    [(addq (r64mi-mem _) (r64m-mem _))
     (panic #"addq of two memory arguments is not valid")]
    [(andq (r64mi-reg reg1) reg2)
     (mc-bytes* (encode-op/RM/reg (single-byte-op* #x21) #t (register64 reg1) (register64 reg2)))]
    [(andq (r64mi-imm imm) reg)
     (mc-bytes* (single-byte-op/IM/reg #x81 4 #t (imm-s32 imm) (register64 reg)))]
    [(andq (r64mi-mem _) _)
     (panic #"andq of memory not yet supported")]
    [(call label)
     (varargs join-list
       (mc-bytes (bytes/1 (u8 #xE8)))
       (mc-call-relocation label))]
    [(call/indirect (r64m-reg reg))
     (mc-bytes* (encode-op/M/reg (single-byte-op* #xFF) 2 #f (register64 reg)))]
    [(call/indirect (r64m-mem mem))
     (mc-bytes* (encode-op/M/mem (single-byte-op* #xFF) 2 #f mem))]
    [(cld) (mc-bytes* (bytes/1 (u8 #xFC)))]
    [(cmpb (r8mi-imm imm) r8m)
     (mc-bytes* (single-byte-op/IM/8 #x80 7 #t imm r8m))]
    [(cmpb (r8mi-reg reg1) (r8m-reg reg2))
     (mc-bytes* (encode-op/RM/reg (single-byte-op* #x38) #t (register8 reg1) (register8 reg2)))]
    [(cmpb (r8mi-reg reg) (r8m-mem mem))
     (mc-bytes* (encode-op/RM/mem (single-byte-op* #x38) #t (register8 reg) mem))]
    [(cmpb (r8mi-mem _) _)
     (panic #"cmpb with memory left hand side not implemented")]
    [(cmpq (r64mi-imm imm) rm)
     (mc-bytes* (single-byte-op/IM #x81 7 #t imm rm))]
    [(cmpq (r64mi-reg reg1) (r64m-reg reg2))
     (mc-bytes* (encode-op/RM/reg (single-byte-op* #x39) #t (register64 reg1) (register64 reg2)))]
    [(cmpq (r64mi-reg reg) (r64m-mem mem))
     (mc-bytes* (encode-op/RM/mem (single-byte-op* #x39) #t (register64 reg) mem))]
    [(cmpq (r64mi-mem _) _)
     (panic #"cmpq with memory left hand side not implemented")]
    [(decq reg)
     (mc-bytes* (encode-op/M/reg (single-byte-op* #xFF) 1 #t (register64 reg)))]
    [(idivq reg)
     (mc-bytes* (encode-op/M/reg (single-byte-op* #xF7) 7 #t (register64 reg)))]
    [(imulq reg1 reg2)
     (mc-bytes* (encode-op/MR/reg (double-byte-op* #xAF) #t (register64 reg1) (register64 reg2)))]
    [(imulq/imm imm (r64mi-reg reg1) reg2)
     (mc-bytes* (encode-op/IMR/reg (single-byte-op* #x69) #t imm (register64 reg1) (register64 reg2)))]
    [(imulq/imm imm _ reg2)
     (panic #"imulq/imm with non register first argument not implemnted")]
    [(incq reg)
     (mc-bytes* (encode-op/M/reg (single-byte-op* #xFF) 0 #t (register64 reg)))]
    [(jb label)
     (mc-branch* (bytes/2 (u8 #x0F) (u8 #x82)) label)]
    [(jbe label)
     (mc-branch* (bytes/2 (u8 #x0F) (u8 #x86)) label)]
    [(je label)
     (mc-branch* (bytes/2 (u8 #x0F) (u8 #x84)) label)]
    [(jl label)
     (mc-branch* (bytes/2 (u8 #x0F) (u8 #x8C)) label)]
    [(jg label)
     (mc-branch* (bytes/2 (u8 #x0F) (u8 #x8F)) label)]
    [(jle label)
     (mc-branch* (bytes/2 (u8 #x0F) (u8 #x8E)) label)]
    [(jge label)
     (mc-branch* (bytes/2 (u8 #x0F) (u8 #x8D)) label)]
    [(jmp label)
     (mc-branch* (bytes/1 (u8 #xE9)) label)]
    [(jmp/indirect (r64m-reg reg))
     (mc-bytes* (encode-op/M/reg (single-byte-op* #xFF) 4 #f (register64 reg)))]
    [(jmp/indirect (r64m-mem mem))
     (mc-bytes* (encode-op/M/mem (single-byte-op* #xFF) 4 #f mem))]
    [(jne label)
     (mc-branch* (bytes/2 (u8 #x0F) (u8 #x85)) label)]
    [(jnz label)
     (mc-branch* (bytes/2 (u8 #x0F) (u8 #x85)) label)]
    [(lahf) (mc-bytes* (bytes/1 (u8 #x9F)))]
    [(leaq mem reg)
     (mc-bytes* (encode-op/MR/mem (single-byte-op* #x8D) #t mem (register64 reg)))]
    [(movb (r8mi-reg reg) mem)
     (mc-bytes* (encode-op/RM/mem (single-byte-op* #x88) #f (register8 reg) mem))]
    [(movb (r8mi-imm imm) mem)
     (mc-bytes* (single-byte-op/IM/8 #xC6 0 #f imm (r8m-mem mem)))]
    [(movb (r8mi-mem _) mem)
     (panic #"movb of two memory arguments is not valid")]
    [(movq (r64mi-imm imm) rm)
     (mc-bytes* (single-byte-op/IM #xC7 0 #t imm rm))]
    [(movq (r64mi-reg reg1) (r64m-reg reg2))
     (mc-bytes* (encode-op/RM/reg (single-byte-op* #x89) #t (register64 reg1) (register64 reg2)))]
    [(movq (r64mi-reg reg) (r64m-mem mem))
     (mc-bytes* (encode-op/RM/mem (single-byte-op* #x89) #t (register64 reg) mem))]
    [(movq (r64mi-mem mem) (r64m-reg reg))
     (mc-bytes* (encode-op/MR/mem (single-byte-op* #x8B) #t mem (register64 reg)))]
    [(movq (r64mi-mem _) (r64m-mem _))
     (panic #"movq of two memory arguments is not valid")]
    [(movq/imm imm reg)
     (mc-bytes* (single-byte-op-s64/IO #xB8 #t imm reg))]
    [(movzbq (r8m-reg reg1) reg2)
     (mc-bytes* (encode-op/MR/reg (double-byte-op* #xB6) #t (register8 reg1) (register64 reg2)))]
    [(movzbq (r8m-mem mem) reg)
     (mc-bytes* (encode-op/MR/mem (double-byte-op* #xB6) #t mem (register64 reg)))]
    [(negq reg)
     (mc-bytes* (encode-op/M/reg (single-byte-op* #xF7) 3 #t (register64 reg)))]
    [(nop) (mc-bytes* (bytes/1 (u8 #x90)))]
    [(notq reg)
     (mc-bytes* (encode-op/M/reg (single-byte-op* #xF7) 2 #t (register64 reg)))]
    [(orq reg1 reg2)
     (mc-bytes* (encode-op/RM/reg (single-byte-op* #x09) #t (register64 reg1) (register64 reg2)))]
    ;; pop defaults to 64 bits so we don't need REX.W bit to indicate that
    [(popq (r64m-reg reg))
     (mc-bytes* (single-byte-op/O #x58 reg))]
    [(popq (r64m-mem mem))
     (mc-bytes* (encode-op/M/mem (single-byte-op* #x8F) 0 #f mem))]
    ;; push defaults to 64 bits so we don't need REX.W bit to indicate that
    [(pushq (r64mi-reg reg))
     (mc-bytes* (single-byte-op/O #x50 reg))]
    [(pushq (r64mi-mem mem))
     (mc-bytes* (encode-op/M/mem (single-byte-op* #xFF) 6 #f mem))]
    [(pushq (r64mi-imm imm))
     (mc-bytes* (single-byte-op/I #x68 #f imm))]
    [(rep-movsb) (mc-bytes* (bytes/3 (u8 #xF3) (u8 #x48) (u8 #xA4)))]
    [(rep-movsq) (mc-bytes* (bytes/3 (u8 #xF3) (u8 #x48) (u8 #xA5)))]
    [(rep-stosb) (mc-bytes* (bytes/3 (u8 #xF3) (u8 #x48) (u8 #xAA)))]
    [(rep-stosq) (mc-bytes* (bytes/3 (u8 #xF3) (u8 #x48) (u8 #xAB)))]
    [(repe-cmpsb) (mc-bytes* (bytes/3 (u8 #xF3) (u8 #x48) (u8 #xA6)))]
    [(repne-scasb) (mc-bytes* (bytes/3 (u8 #xF2) (u8 #x48) (u8 #xAE)))]
    [(repne-scasq) (mc-bytes* (bytes/3 (u8 #xF2) (u8 #x48) (u8 #xAF)))]
    [(ret) (mc-bytes* (bytes/1 (u8 #xC3)))]
    [(sete reg)
     (mc-bytes* (encode-op/M/reg (double-byte-op* #x94) 0 #f (register8 reg)))]
    [(setg reg)
     (mc-bytes* (encode-op/M/reg (double-byte-op* #x9F) 0 #f (register8 reg)))]
    [(setge reg)
     (mc-bytes* (encode-op/M/reg (double-byte-op* #x9D) 0 #f (register8 reg)))]
    [(setl reg)
     (mc-bytes* (encode-op/M/reg (double-byte-op* #x9C) 0 #f (register8 reg)))]
    [(setle reg)
     (mc-bytes* (encode-op/M/reg (double-byte-op* #x9E) 0 #f (register8 reg)))]
    [(setne reg)
     (mc-bytes* (encode-op/M/reg (double-byte-op* #x95) 0 #f (register8 reg)))]
    [(shlq reg)
     (mc-bytes* (encode-op/M/reg (single-byte-op* #xD3) 4 #t (register64 reg)))]
    [(shlq/imm v reg)
     (mc-bytes* (single-byte-op/IM/reg #xC1 4 #t (imm-u8 v) (register64 reg)))]
    [(shrq reg)
     (mc-bytes* (encode-op/M/reg (single-byte-op* #xD3) 5 #t (register64 reg)))]
    [(shrq/imm v reg)
     (mc-bytes* (single-byte-op/IM/reg #xC1 5 #t (imm-u8 v) (register64 reg)))]
    [(std) (mc-bytes* (bytes/1 (u8 #xFD)))]
    [(subq (r64mi-reg reg1) reg2)
     (mc-bytes* (encode-op/RM/reg (single-byte-op* #x29) #t (register64 reg1) (register64 reg2)))]
    [(subq (r64mi-imm imm) reg)
     (mc-bytes* (single-byte-op/IM/reg #x81 5 #t (imm-s32 imm) (register64 reg)))]
    [(subq (r64mi-mem mem) reg)
     (mc-bytes* (encode-op/MR/mem (single-byte-op* #x2B) #t mem (register64 reg)))]
    [(syscall) (mc-bytes* (bytes/2 (u8 #x0F) (u8 #x05)))]
    [(test reg1 reg2)
     (mc-bytes* (encode-op/RM/reg (single-byte-op* #x85) #t (register64 reg1) (register64 reg2)))]
    [(ud2) (mc-bytes* (bytes/2 (u8 #x0F) (u8 #x0B)))]
    [(xaddq reg1 reg2)
     (mc-bytes* (encode-op/RM/reg (double-byte-op* #xC1) #t (register64 reg1) (register64 reg2)))]
    [(xorq (r64mi-reg reg1) reg2)
     (mc-bytes* (encode-op/RM/reg (single-byte-op* #x31) #t (register64 reg1) (register64 reg2)))]
    [(xorq (r64mi-imm imm) reg)
     (mc-bytes* (single-byte-op/IM/reg #x81 6 #t (imm-s32 imm) (register64 reg)))]
    [(xorq (r64mi-mem _) _)
     (panic #"xorq of memory not yet supported")]
    [(leaq/rip-rel label reg)
     (let ([reg-val (register64->byte reg)])
       (varargs join-list
         (mc-bytes (add-maybe-byte
                     (make-rex-byte #t (just (register64 reg)) (nothing) (nothing))
                     (bytes/2 (u8 #x8D) (u8 (mod-rm-byte #x00 reg-val #x05)))))
         (mc-load-relocation label)))]))

;; mod is truncated to two bits, and reg and rm are truncated to three.
(define (mod-rm-byte [mod : Int] [reg : Int] [rm : Int]) : Int
  (bitwise-ior (logical-shift-left (bitwise-and mod #x03) 6)
     (bitwise-ior (logical-shift-left (bitwise-and reg #x07) 3)
                  (bitwise-and rm #x07))))

;; TODO refine types of opcodes to be the right number of bits.
(define (single-byte-op/O [opcode : Int] [reg : Register64]) : Bytes
  (let ([reg-val (register64->byte reg)])
    (add-maybe-byte
      (make-rex-byte #f (nothing) (nothing) (just (register64 reg)))
      (bytes/1
        (u8 (bitwise-ior opcode (bitwise-and reg-val #x07)))))))

(define (single-byte-op/I [opcode : Int] [rexW : Boolean] [imm : S32]) : Bytes
  (add-maybe-byte
    (make-rex-byte rexW (nothing) (nothing) (nothing))
    (let ([v (bytes/5 (u8 opcode) (u8 0) (u8 0) (u8 0) (u8 0))])
      (begin
        (bytes-set!/s32-le v 1 imm)
        v))))

(define (single-byte-op-s64/IO [opcode : Int] [rexW : Boolean] [imm : S64] [reg : Register64]) : Bytes
  (let ([reg-val (register64->byte reg)])
    (add-maybe-byte
      (make-rex-byte rexW (nothing) (nothing) (just (register64 reg)))
      (let ([v (bytes/9
                 (u8 (bitwise-ior opcode (bitwise-and reg-val #x07)))
                 (u8 0) (u8 0) (u8 0) (u8 0) (u8 0) (u8 0) (u8 0) (u8 0))])
        (begin
          (bytes-set!/u64-le v 1 (u64 imm))
          v)))))

(define (encode-op/M/reg [op-code : OpCode] [op-ext : Int] [rexW : Boolean] [reg : Register]) : Bytes
  (let ([rm (register->byte reg)])
    (add-maybe-byte
      (make-rex-byte rexW (nothing) (nothing) (just reg))
      (bytes-append
        (varargs list
          (op-code->bytes op-code)
          (bytes/1 (u8 (mod-rm-byte #x03 op-ext rm))))))))

(define (encode-op/M/mem [op-code : OpCode] [op-ext : Int] [rexW : Boolean] [mem : MemoryArgument]) : Bytes
  (case mem
    [(mem-direct mem-reg)
     (encode-op/M/direct-mem op-code op-ext rexW mem-reg)]
    [(mem-sib-direct mem-reg)
     (encode-op/M/sib-direct-mem op-code op-ext rexW mem-reg)]
    [(mem-displaced mem-reg offset)
     (encode-op/M/displaced-mem op-code op-ext rexW mem-reg offset)]
    [(mem-scaled mem-reg scale index-reg displacement)
     (encode-op/M/scaled-mem op-code op-ext rexW mem-reg scale index-reg displacement)]))

(define (encode-op/M/direct-mem [op-code : OpCode] [op-ext : Int] [rexW : Boolean] [reg : Register64]) : Bytes
  (let ([rm (register64->byte reg)])
    (add-maybe-byte
      (make-rex-byte rexW (nothing) (nothing) (just (register64 reg)))
      (bytes-append
        (varargs list
          (op-code->bytes op-code)
          (bytes/1 (u8 (mod-rm-byte #x00 op-ext rm))))))))

(define (encode-op/M/sib-direct-mem [op-code : OpCode] [op-ext : Int] [rexW : Boolean]
                                    [reg : Register64]) : Bytes
  (let ([base (register64->byte reg)])
    (add-maybe-byte
      (make-rex-byte rexW (nothing) (nothing) (just (register64 reg)))
      (bytes-append
        (varargs list
          (op-code->bytes op-code)
          (bytes/2 (u8 (mod-rm-byte #x00 op-ext #x04)) (u8 (sib-byte (scale-1) (rsp) reg))))))))


;; Doesn't support rsp or r12. This is because the instruction set doesn't support them.
(define (encode-op/M/displaced-mem
          [op-code : OpCode] [op-ext : Int] [rexW : Boolean] [reg : Register64] [displacement : S32]) : Bytes
  (let ([rm (register64->byte reg)])
    (add-maybe-byte
      (make-rex-byte rexW (nothing) (nothing) (just (register64 reg)))
      (bytes-append
        (varargs list
          (op-code->bytes op-code)
          (bytes/1 (u8 (mod-rm-byte #x02 op-ext rm)))
          (bytes/s32-le displacement))))))

(define (encode-op/M/scaled-mem
          [op-code : OpCode] [op-ext : Int] [rexW : Boolean]
          [reg1 : Register64] [scale : Scale] [reg2 : Register64] [displacement : S32]) : Bytes
  (let ([base (register64->byte reg1)])
    (let ([index (register64->byte reg2)])
      (add-maybe-byte
        (make-rex-byte rexW (nothing) (just (register64 reg2)) (just (register64 reg1)))
        (bytes-append
          (varargs list
            (op-code->bytes op-code)
            (bytes/2 (u8 (mod-rm-byte #x02 op-ext #x04)) (u8 (sib-byte scale reg2 reg1)))
            (bytes/s32-le displacement)))))))

(define (imm->bytes [imm : Immediate]) : Bytes
  (case imm
    [(imm-s32 v) (bytes/s32-le v)]
    [(imm-u8 v) (bytes/1 v)]))

(define (single-byte-op/IM [opcode : Int] [op-ext : Int] [rexW : Boolean]
                           [val : S32] [rm : Reg64Mem]) : Bytes
  (case rm
    [(r64m-reg reg)
     (single-byte-op/IM/reg opcode op-ext rexW (imm-s32 val) (register64 reg))]
    [(r64m-mem mem)
     (single-byte-op/IM/mem opcode op-ext rexW (imm-s32 val) mem)]))

(define (single-byte-op/IM/8 [opcode : Int] [op-ext : Int] [rexW : Boolean]
                             [val : U8] [r8m : Reg8Mem]) : Bytes
  (case r8m
    [(r8m-reg reg)
     (single-byte-op/IM/reg opcode op-ext rexW (imm-u8 val) (register8 reg))]
    [(r8m-mem mem)
     (single-byte-op/IM/mem opcode op-ext rexW (imm-u8 val) mem)]))

(define (single-byte-op/IM/mem [opcode : Int] [op-ext : Int] [rexW : Boolean]
                               [val : Immediate] [mem : MemoryArgument]) : Bytes
  (case mem
    [(mem-direct mem-reg)
     (single-byte-op/IM/direct-mem opcode op-ext rexW val mem-reg)]
    [(mem-sib-direct mem-reg)
     (single-byte-op/IM/sib-direct-mem opcode op-ext rexW val mem-reg)]
    [(mem-displaced mem-reg offset)
     (single-byte-op/IM/displaced-mem opcode op-ext rexW val mem-reg offset)]
    [(mem-scaled mem-reg scale index-reg displacement)
     (single-byte-op/IM/scaled-mem opcode op-ext rexW val mem-reg scale index-reg displacement)]))

(define (single-byte-op/IM/reg [opcode : Int] [op-ext : Int] [rexW : Boolean]
                               [val : Immediate] [reg : Register]) : Bytes
  (let ([rm (register->byte reg)])
    (add-maybe-byte
      (make-rex-byte rexW (nothing) (nothing) (just reg))
      (bytes-append
        (varargs list
          (bytes/2 (u8 opcode) (u8 (mod-rm-byte #x03 op-ext rm)))
          (imm->bytes val))))))

(define (single-byte-op/IM/direct-mem [opcode : Int] [op-ext : Int] [rexW : Boolean]
                                      [val : Immediate] [reg : Register64]) : Bytes
  (let ([rm (register64->byte reg)])
    (add-maybe-byte
      (make-rex-byte rexW (nothing) (nothing) (just (register64 reg)))
      (bytes-append
        (varargs list
          (bytes/2 (u8 opcode) (u8 (mod-rm-byte #x00 op-ext rm)))
          (imm->bytes val))))))

(define (single-byte-op/IM/sib-direct-mem [opcode : Int] [op-ext : Int] [rexW : Boolean]
                                          [val : Immediate] [reg : Register64]) : Bytes
  (add-maybe-byte
    (make-rex-byte rexW (nothing) (nothing) (just (register64 reg)))
    (bytes-append
      (varargs list
        (bytes/3 (u8 opcode) (u8 (mod-rm-byte #x00 op-ext #x04))
                 (u8 (sib-byte (scale-1) (rsp) reg)))
        (imm->bytes val)))))


;; Doesn't support rsp or r12. This is because the instruction set doesn't support them.
(define (single-byte-op/IM/displaced-mem
          [opcode : Int] [op-ext : Int] [rexW : Boolean] [val : Immediate]
          [reg : Register64] [displacement : S32]) : Bytes
  (let ([rm (register64->byte reg)])
    (add-maybe-byte
      (make-rex-byte rexW (nothing) (nothing) (just (register64 reg)))
      (bytes-append
        (varargs list
          (bytes/2
            (u8 opcode)
            (u8 (mod-rm-byte #x02 op-ext rm)))
        (bytes/s32-le displacement)
        (imm->bytes val))))))

(define (single-byte-op/IM/scaled-mem
          [opcode : Int] [op-ext : Int] [rexW : Boolean] [val : Immediate]
          [reg1 : Register64] [scale : Scale] [reg2 : Register64] [displacement : S32]) : Bytes
  (add-maybe-byte
    (make-rex-byte rexW (nothing) (just (register64 reg2)) (just (register64 reg1)))
    (bytes-append
      (varargs list
        (bytes/3
          (u8 opcode)
          (u8 (mod-rm-byte #x02 op-ext #x04))
          (u8 (sib-byte scale reg2 reg1)))
        (bytes/s32-le displacement)
        (imm->bytes val)))))

(define (op-code->bytes [op-code : OpCode]) : Bytes
  (case op-code
    [(single-byte-op v) (bytes/1 v)]
    [(double-byte-op v) (bytes/2 (u8 #x0F) v)]))


(define (encode-op/RM/reg [op-code : OpCode] [rexW : Boolean] [reg1 : Register] [reg2 : Register])
  : Bytes
  (let ([reg (register->byte reg1)])
    (let ([rm (register->byte reg2)])
      (add-maybe-byte
        (make-rex-byte rexW (just reg1) (nothing) (just reg2))
        (bytes-append
          (varargs list
            (op-code->bytes op-code)
            (bytes/1 (u8 (mod-rm-byte #x03 reg rm)))))))))

(define (encode-op/MR/reg [op-code : OpCode] [rexW : Boolean] [reg1 : Register] [reg2 : Register])
  : Bytes
  (encode-op/RM/reg op-code rexW reg2 reg1))

(define (encode-op/RM/mem [op-code : OpCode] [rexW : Boolean] [reg : Register] [mem : MemoryArgument])
  : Bytes
  (case mem
    [(mem-direct mem-reg)
     (encode-op/RM/direct-mem op-code rexW reg mem-reg)]
    [(mem-sib-direct mem-reg)
     (encode-op/RM/sib-direct-mem op-code rexW reg mem-reg)]
    [(mem-displaced mem-reg offset)
     (encode-op/RM/displaced-mem op-code rexW reg mem-reg offset)]
    [(mem-scaled mem-reg scale index-reg displacement)
     (encode-op/RM/scaled-mem op-code rexW reg mem-reg scale index-reg displacement)]))

(define (encode-op/MR/mem [op-code : OpCode] [rexW : Boolean] [mem : MemoryArgument] [reg : Register])
  : Bytes
  (encode-op/RM/mem op-code rexW reg mem))


;; Doesn't support rsp, rbp, r12 or r13. This is because the instruction set doesn't support them.
(define (encode-op/RM/direct-mem [op-code : OpCode] [rexW : Boolean]
                                 [reg1 : Register] [reg2 : Register64]) : Bytes
  (let ([reg (register->byte reg1)])
    (let ([rm (register64->byte reg2)])
      (add-maybe-byte
        (make-rex-byte rexW (just reg1) (nothing) (just (register64 reg2)))
        (bytes-append
          (varargs list
            (op-code->bytes op-code)
            (bytes/1 (u8 (mod-rm-byte #x00 reg rm)))))))))

(define (encode-op/RM/sib-direct-mem [op-code : OpCode] [rexW : Boolean]
                                     [reg1 : Register] [reg2 : Register64]) : Bytes
  (let ([reg (register->byte reg1)])
    (add-maybe-byte
      (make-rex-byte rexW (just reg1) (nothing) (just (register64 reg2)))
      (bytes-append
        (varargs list
          (op-code->bytes op-code)
          (bytes/2 (u8 (mod-rm-byte #x00 reg #x04)) (u8 (sib-byte (scale-1) (rsp) reg2))))))))


;; Doesn't support rsp or r12. This is because the instruction set doesn't support them.
(define (encode-op/RM/displaced-mem
          [op-code : OpCode] [rexW : Boolean]
          [reg1 : Register]
          [reg2 : Register64] [displacement : S32]) : Bytes
  (let ([reg (register->byte reg1)])
    (let ([rm (register64->byte reg2)])
      (add-maybe-byte
        (make-rex-byte rexW (just reg1) (nothing) (just (register64 reg2)))
        (bytes-append
          (varargs list
            (op-code->bytes op-code)
            (bytes/1 (u8 (mod-rm-byte #x02 reg rm)))
            (bytes/s32-le displacement)))))))

(define (encode-op/RM/scaled-mem
          [op-code : OpCode] [rexW : Boolean]
          [reg1 : Register]
          [reg2 : Register64] [scale : Scale] [reg3 : Register64] [displacement : S32]) : Bytes
  (let ([reg (register->byte reg1)])
    (add-maybe-byte
      (make-rex-byte rexW (just reg1) (just (register64 reg3)) (just (register64 reg2)))
      (bytes-append
        (varargs list
          (op-code->bytes op-code)
          (bytes/2
            (u8 (mod-rm-byte #x02 reg #x04))
            (u8 (sib-byte scale reg3 reg2)))
          (bytes/s32-le displacement))))))

(define (encode-op/IMR/reg [op-code : OpCode] [rexW : Boolean] [imm : S32]
                           [reg1 : Register] [reg2 : Register]) : Bytes
  (let ([reg (register->byte reg2)])
    (let ([rm (register->byte reg1)])
      (add-maybe-byte
        (make-rex-byte rexW (just reg2) (nothing) (just reg1))
        (bytes-append
          (varargs list
            (op-code->bytes op-code)
            (bytes/1 (u8 (mod-rm-byte #x03 reg rm)))
            (bytes/s32-le imm)))))))

(define (add-maybe-byte [rb : RexByte] [bs : Bytes]) : Bytes
  (case rb
    [(no-rex-byte) bs]
    [(rex-byte v) (bytes-append (cons (bytes/1 v) (cons bs (empty))))]))

(define (rex-requirement [reg : Register]) : RexRequirement
  (case reg
    [(register8 r) (rex-requirement/8 r)]
    [(register64 _) (rex-optional)]))

(define (rex-requirement/8 [reg : Register8]) : RexRequirement
  (case reg
    [(ah) (rex-forbidden)]
    [(bh) (rex-forbidden)]
    [(ch) (rex-forbidden)]
    [(dh) (rex-forbidden)]
    [(dil) (rex-mandatory)]
    [(sil) (rex-mandatory)]
    [(bpl) (rex-mandatory)]
    [(spl) (rex-mandatory)]
    [(al) (rex-optional)]
    [(bl) (rex-optional)]
    [(cl) (rex-optional)]
    [(dl) (rex-optional)]
    [(r8b) (rex-optional)]
    [(r9b) (rex-optional)]
    [(r10b) (rex-optional)]
    [(r11b) (rex-optional)]
    [(r12b) (rex-optional)]
    [(r13b) (rex-optional)]
    [(r14b) (rex-optional)]
    [(r15b) (rex-optional)]))

(define (merge-rex-requirements [req1 : RexRequirement] [req2 : RexRequirement]) : RexRequirement
  (case (tuple2 req1 req2)
    [(tuple2 (rex-optional) req) req]
    [(tuple2 req (rex-optional)) req]
    [(tuple2 (rex-mandatory) (rex-mandatory)) (rex-mandatory)]
    [(tuple2 (rex-forbidden) (rex-forbidden)) (rex-forbidden)]
    [_ (panic #"Contradictory registers for rex prefix requirement")]))

(define (make-rex-byte [w : Boolean] [r : (Maybe Register)]
                       [x : (Maybe Register)] [b : (Maybe Register)])
  : RexByte
  (match-define rex-bit/maybe
    (lambda ([r : (Maybe Register)])
      (case r
        [(nothing) 0]
        [(just r) (if (>= (register->byte r) 8) 1 0)])))
  (match-define rex-requirement/maybe
    (lambda ([r : (Maybe Register)])
      (case r
        [(nothing) (rex-optional)]
        [(just r) (rex-requirement r)])))

  (match-define computed-rex
    (let ([ind (lambda ([v : Boolean]) (if v 1 0))])
      (let ([val (bitwise-ior #x40
                   (bitwise-ior (logical-shift-left (if w 1 0) 3)
                     (bitwise-ior (logical-shift-left (rex-bit/maybe r) 2)
                       (bitwise-ior (logical-shift-left (rex-bit/maybe x) 1)
                                    (rex-bit/maybe b)))))])
        (if (= val #x40)
            (no-rex-byte)
            (rex-byte (u8 val))))))

  (case (merge-rex-requirements
          (merge-rex-requirements
            (rex-requirement/maybe r)
            (rex-requirement/maybe x))
          (rex-requirement/maybe b))
    [(rex-optional) computed-rex]
    [(rex-mandatory)
     (case computed-rex
       [(no-rex-byte) (rex-byte (u8 #x40))]
       [_ computed-rex])]
    [(rex-forbidden)
     (case computed-rex
       [(no-rex-byte) (no-rex-byte)]
       [(rex-byte _) (panic #"Cannot encode rex prefix and use this register")])]))

;; TODO make this return a U8
(define (sib-byte [scale : Scale] [index : Register64] [base : Register64]) : Int
  (bitwise-ior
    (case scale
      [(scale-1) #x00]
      [(scale-2) #x40]
      [(scale-4) #x80]
      [(scale-8) #xc0])
    (bitwise-ior
      (logical-shift-left (bitwise-and (register64->byte index) #x07) 3)
      (bitwise-and (register64->byte base) #x07))))

(define (register->byte [reg : Register]) : Int
  (case reg
    [(register8 r) (register8->byte r)]
    [(register64 r) (register64->byte r)]))

;; TODO make this return a U8
(define (register8->byte [reg : Register8]) : Int
  (case reg
    [(al) 0]
    [(ah) 4]
    [(bl) 3]
    [(bh) 7]
    [(cl) 1]
    [(ch) 5]
    [(dl) 2]
    [(dh) 6]
    [(dil) 7]
    [(sil) 6]
    [(bpl) 5]
    [(spl) 4]
    [(r8b) 8]
    [(r9b) 9]
    [(r10b) 10]
    [(r11b) 11]
    [(r12b) 12]
    [(r13b) 13]
    [(r14b) 14]
    [(r15b) 15]))

;; TODO make this return a U8
(define (register64->byte [reg : Register64]) : Int
  (case reg
    [(rax) 0]
    [(rbx) 3]
    [(rcx) 1]
    [(rdx) 2]
    [(rdi) 7]
    [(rsi) 6]
    [(rbp) 5]
    [(rsp) 4]
    [(r8) 8]
    [(r9) 9]
    [(r10) 10]
    [(r11) 11]
    [(r12) 12]
    [(r13) 13]
    [(r14) 14]
    [(r15) 15]))
