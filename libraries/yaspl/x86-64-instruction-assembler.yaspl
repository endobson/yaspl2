#:module (yaspl x86-64-instruction-assembler)
#:import {
  (bytes)
  (join-list)
  (list)
  (maybe)
  (prim)
  (yaspl x86-64-assembly)
}
(export
  #:types (MCCommand)
  #:values (instruction->mc-commands)
  #:patterns (mc-bytes mc-branch-relocation mc-signed-relocation))
(types
  (define-type MCCommand
    (mc-bytes [bytes : Bytes])
    (mc-branch-relocation [symbol : Bytes])
    (mc-signed-relocation [symbol : Bytes])))

(define (mc-bytes* [bytes : Bytes]) : (JoinList MCCommand)
  (single-jl (mc-bytes bytes)))
(define (mc-branch* [op-code : Bytes] [symbol : Bytes]) : (JoinList MCCommand)
  (varargs join-list
    (mc-bytes op-code)
    (mc-branch-relocation symbol)
    (mc-bytes (varargs bytes #x00 #x00 #x00 #x00))))

(define (instruction->mc-commands [inst : Instruction]) : (JoinList MCCommand)
  (case inst
    [(addq (rmi-reg reg) rm)
     (mc-bytes* (single-byte-op/RM #x01 #t reg rm))]
    [(addq (rmi-imm imm) rm)
     (mc-bytes* (single-byte-op/IM #x81 0 #t imm rm))]
    [(addq (rmi-mem mem) (rm-reg reg))
     (mc-bytes* (single-byte-op/MR/mem #x03 #t mem reg))]
    [(addq (rmi-mem _) (rm-mem _))
     (panic #"addq of two memory arguments is not valid")]
    [(andq (rmi-reg reg1) reg2)
     (mc-bytes* (single-byte-op/RM/reg #x21 #t reg1 reg2))]
    [(andq (rmi-imm imm) reg)
     (mc-bytes* (single-byte-op/IM/reg #x81 4 #t imm reg))]
    [(andq (rmi-mem _) _)
     (panic #"andq of memory not yet supported")]
    [(call label)
     (mc-branch* (varargs bytes #xE8) label)]
    [(call/indirect (rm-reg reg))
     (mc-bytes* (single-byte-op/M #xFF 2 #f reg))]
    [(call/indirect (rm-mem mem))
     (mc-bytes* (single-byte-op/M/mem #xFF 2 #f mem))]
    [(cld) (mc-bytes* (varargs bytes #xFC))]
    [(cmpq (rmi-imm imm) rm)
     (mc-bytes* (single-byte-op/IM #x81 7 #t imm rm))]
    [(cmpq (rmi-reg reg) rm)
     (mc-bytes* (single-byte-op/RM #x39 #t reg rm))]
    [(cmpq (rmi-mem _) _)
     (panic #"cmpq with memory left hand side not implemented")]
    [(decq reg)
     (mc-bytes* (single-byte-op/M #xFF 1 #t reg))]
    [(idivq reg)
     (mc-bytes* (single-byte-op/M #xF7 7 #t reg))]
    [(imulq reg1 reg2)
     (mc-bytes* (double-byte-op/MR #xAF #t reg1 reg2))]
    [(imulq/imm imm (rmi-reg reg1) reg2)
     (mc-bytes* (single-byte-op/IMR #x69 #t imm reg1 reg2))]
    [(imulq/imm imm _ reg2)
     (panic #"imulq/imm with non register first argument not implemnted")]
    [(incq reg)
     (mc-bytes* (single-byte-op/M #xFF 0 #t reg))]
    [(jb label)
     (mc-branch* (varargs bytes #x0F #x82) label)]
    [(jbe label)
     (mc-branch* (varargs bytes #x0F #x86) label)]
    [(je label)
     (mc-branch* (varargs bytes #x0F #x84) label)]
    [(jl label)
     (mc-branch* (varargs bytes #x0F #x8C) label)]
    [(jg label)
     (mc-branch* (varargs bytes #x0F #x8F) label)]
    [(jle label)
     (mc-branch* (varargs bytes #x0F #x8E) label)]
    [(jge label)
     (mc-branch* (varargs bytes #x0F #x8D) label)]
    [(jmp label)
     (mc-branch* (varargs bytes #xE9) label)]
    [(jmp/indirect (rm-reg reg))
     (mc-bytes* (single-byte-op/M #xFF 4 #f reg))]
    [(jmp/indirect (rm-mem mem))
     (mc-bytes* (single-byte-op/M/mem #xFF 4 #f mem))]
    [(jne label)
     (mc-branch* (varargs bytes #x0F #x85) label)]
    [(jnz label)
     (mc-branch* (varargs bytes #x0F #x85) label)]
    [(lahf) (mc-bytes* (varargs bytes #x9F))]
    [(leaq mem reg)
     (mc-bytes* (single-byte-op/MR/mem #x8D #t mem reg))]
    [(movb reg1 (mem-direct reg2))
     (mc-bytes* (single-byte-op/RM/mem/8 #x88 #f reg1 reg2))]
    [(movb reg1 (mem-displaced reg2 offset))
     (mc-bytes* (single-byte-op/RM/displaced-mem/8 #x88 #f reg1 reg2 offset))]
    [(movb reg1 (mem-scaled reg2 scale reg3 offset))
     (mc-bytes* (single-byte-op/RM/scaled-mem/8 #x88 #f reg1 reg2 scale reg3 offset))]
    [(movq (rmi-imm imm) rm)
     (mc-bytes* (single-byte-op/IM #xC7 0 #t imm rm))]
    [(movq (rmi-reg reg) rm)
     (mc-bytes* (single-byte-op/RM #x89 #t reg rm))]
    [(movq (rmi-mem mem) (rm-reg reg))
     (mc-bytes* (single-byte-op/MR/mem #x8B #t mem reg))]
    [(movq (rmi-mem _) (rm-mem _))
     (panic #"movq of two memory arguments is not valid")]
    [(movq/imm imm reg)
     (mc-bytes* (single-byte-op-s64/IO #xB8 #t imm reg))]
    [(movzbq reg1 reg2)
     (mc-bytes* (double-byte-op/MR/8 #xB6 #t reg1 reg2))]
    [(movzbq/mem mem reg)
     (mc-bytes* (double-byte-op/MR/mem #xB6 #t mem reg))]
    [(negq reg)
     (mc-bytes* (single-byte-op/M #xF7 3 #t reg))]
    [(nop) (mc-bytes* (varargs bytes #x90))]
    [(notq reg)
     (mc-bytes* (single-byte-op/M #xF7 2 #t reg))]
    [(orq reg1 reg2)
     (mc-bytes* (single-byte-op/RM/reg #x09 #t reg1 reg2))]
    ;; pop defaults to 64 bits so we don't need REX.W bit to indicate that
    [(popq (rm-reg reg))
     (mc-bytes* (single-byte-op/O #x58 reg))]
    [(popq (rm-mem mem))
     (mc-bytes* (single-byte-op/M/mem #x8F 0 #f mem))]
    ;; push defaults to 64 bits so we don't need REX.W bit to indicate that
    [(pushq (rmi-reg reg))
     (mc-bytes* (single-byte-op/O #x50 reg))]
    [(pushq (rmi-mem mem))
     (mc-bytes* (single-byte-op/M/mem #xFF 6 #f mem))]
    [(pushq (rmi-imm imm))
     (mc-bytes* (single-byte-op/I #x68 #f imm))]
    [(rep-movsb) (mc-bytes* (varargs bytes #xF3 #x48 #xA4))]
    [(rep-movsq) (mc-bytes* (varargs bytes #xF3 #x48 #xA5))]
    [(rep-stosb) (mc-bytes* (varargs bytes #xF3 #x48 #xAA))]
    [(rep-stosq) (mc-bytes* (varargs bytes #xF3 #x48 #xAB))]
    [(repe-cmpsb) (mc-bytes* (varargs bytes #xF3 #x48 #xA6))]
    [(repne-scasb) (mc-bytes* (varargs bytes #xF2 #x48 #xAE))]
    [(repne-scasq) (mc-bytes* (varargs bytes #xF2 #x48 #xAF))]
    [(ret) (mc-bytes* (varargs bytes #xC3))]
    [(sete reg)
     (mc-bytes* (double-byte-op/M/8 #x94 0 #f reg))]
    [(setg reg)
     (mc-bytes* (double-byte-op/M/8 #x9F 0 #f reg))]
    [(setge reg)
     (mc-bytes* (double-byte-op/M/8 #x9D 0 #f reg))]
    [(setl reg)
     (mc-bytes* (double-byte-op/M/8 #x9C 0 #f reg))]
    [(setle reg)
     (mc-bytes* (double-byte-op/M/8 #x9E 0 #f reg))]
    [(setne reg)
     (mc-bytes* (double-byte-op/M/8 #x95 0 #f reg))]
    [(shlq reg)
     (mc-bytes* (single-byte-op/M #xD3 4 #t reg))]
    [(shlq/imm v reg)
     (mc-bytes* (single-byte-op/IM/reg/u8 #xC1 4 #t v reg))]
    [(shrq reg)
     (mc-bytes* (single-byte-op/M #xD3 5 #t reg))]
    [(shrq/imm v reg)
     (mc-bytes* (single-byte-op/IM/reg/u8 #xC1 5 #t v reg))]
    [(std) (mc-bytes* (varargs bytes #xFD))]
    [(subq (rmi-reg reg1) reg2)
     (mc-bytes* (single-byte-op/RM/reg #x29 #t reg1 reg2))]
    [(subq (rmi-imm imm) reg)
     (mc-bytes* (single-byte-op/IM/reg #x81 5 #t imm reg))]
    [(subq (rmi-mem mem) reg)
     (mc-bytes* (single-byte-op/MR/mem #x2B #t mem reg))]
    [(syscall) (mc-bytes* (varargs bytes #x0F #x05))]
    [(test reg1 reg2)
     (mc-bytes* (single-byte-op/RM/reg #x85 #t reg1 reg2))]
    [(ud2) (mc-bytes* (varargs bytes #x0F #x0B))]
    [(xaddq reg1 reg2)
     (mc-bytes* (double-byte-op/RM #xC1 #t reg1 reg2))]
    [(xorq (rmi-reg reg1) reg2)
     (mc-bytes* (single-byte-op/RM/reg #x31 #t reg1 reg2))]
    [(xorq (rmi-imm imm) reg)
     (mc-bytes* (single-byte-op/IM/reg #x81 6 #t imm reg))]
    [(xorq (rmi-mem _) _)
     (panic #"xorq of memory not yet supported")]
    [(leaq/rip-rel label reg)
     (let ([reg-val (register->byte reg)])
       (varargs join-list
         (mc-bytes (add-maybe-byte
                     (rex-byte #t (>= reg-val 8) #f #f)
                     (varargs bytes
                              #x8D
                              (mod-rm-byte #x00 reg-val #x05))))
         (mc-signed-relocation label)
         (mc-bytes (varargs bytes 0 0 0 0))))]))

;; mod is truncated to two bits, and reg and rm are truncated to three.
(define (mod-rm-byte [mod : Int] [reg : Int] [rm : Int]) : Int
  (bitwise-ior (logical-shift-left (bitwise-and mod #x03) 6)
     (bitwise-ior (logical-shift-left (bitwise-and reg #x07) 3)
                  (bitwise-and rm #x07))))

;; TODO refine types of opcodes to be the right number of bits.
(define (single-byte-op/O [opcode : Int] [reg : Register]) : Bytes
  (let ([reg-val (register->byte reg)])
    (add-maybe-byte
      (rex-byte #f #f #f (>= reg-val 8))
      (varargs bytes
        (bitwise-ior opcode (bitwise-and reg-val #x07))))))

(define (single-byte-op/M [opcode : Int] [op-ext : Int] [rexW : Boolean] [reg : Register]) : Bytes
  (let ([rm (register->byte reg)])
    (add-maybe-byte
      (rex-byte rexW #f #f (>= rm 8))
      (varargs bytes
        opcode
        (mod-rm-byte #x03 op-ext rm)))))

(define (single-byte-op/I [opcode : Int] [rexW : Boolean] [imm : S32]) : Bytes
  (add-maybe-byte
    (rex-byte rexW #f #f #f)
    (let ([v (varargs bytes opcode 0 0 0 0)])
      (begin
        (bytes-set!/s32-le v 1 imm)
        v))))

 (define (single-byte-op-s64/IO [opcode : Int] [rexW : Boolean] [imm : EightBytesLe] [reg : Register]) : Bytes
   (let ([reg-val (register->byte reg)])
     (add-maybe-byte
       (rex-byte rexW #f #f (>= reg-val 8))
       (let ([v (varargs bytes
                  (bitwise-ior opcode (bitwise-and reg-val #x07))
                  0 0 0 0 0 0 0 0)])
         (begin
           (bytes-set!/eight-bytes-le v 1 imm)
           v)))))

(define (single-byte-op/M/mem [opcode : Int] [op-ext : Int] [rexW : Boolean] [mem : MemoryArgument]) : Bytes
  (case mem
    [(mem-direct mem-reg)
     (single-byte-op/M/direct-mem opcode op-ext rexW mem-reg)]
    [(mem-displaced mem-reg offset)
     (single-byte-op/M/displaced-mem opcode op-ext rexW mem-reg offset)]
    [(mem-scaled mem-reg scale index-reg displacement)
     (single-byte-op/M/scaled-mem opcode op-ext rexW mem-reg scale index-reg displacement)]))

(define (single-byte-op/M/direct-mem [opcode : Int] [op-ext : Int] [rexW : Boolean] [reg : Register]) : Bytes
  (let ([rm (register->byte reg)])
    (add-maybe-byte
      (rex-byte rexW #f #f (>= rm 8))
      (varargs bytes
        opcode
        (mod-rm-byte #x00 op-ext rm)))))

;; Doesn't support rsp or r12. This is because the instruction set doesn't support them.
(define (single-byte-op/M/displaced-mem
          [opcode : Int] [op-ext : Int] [rexW : Boolean] [reg : Register] [displacement : S32]) : Bytes
  (let ([rm (register->byte reg)])
    (add-maybe-byte
      (rex-byte rexW #f #f (>= rm 8))
      (let ([v (varargs bytes
                 opcode
                 (mod-rm-byte #x02 op-ext rm)
                 0 0 0 0)])
        (begin
          (bytes-set!/s32-le v 2 displacement)
          v)))))

(define (single-byte-op/M/scaled-mem
          [opcode : Int] [op-ext : Int] [rexW : Boolean]
          [reg1 : Register] [scale : Scale] [reg2 : Register] [displacement : S32]) : Bytes
  (let ([base (register->byte reg1)])
    (let ([index (register->byte reg2)])
      (add-maybe-byte
        (rex-byte rexW #f (>= index 8) (>= base 8))
        (let ([v (varargs bytes
                   opcode
                   (mod-rm-byte #x02 op-ext #x04)
                   (sib-byte scale reg2 reg1)
                   0 0 0 0)])
          (begin
            (bytes-set!/s32-le v 3 displacement)
            v))))))


(define (single-byte-op/IM [opcode : Int] [op-ext : Int] [rexW : Boolean]
                           [val : S32] [rm : RegMem]) : Bytes
  (case rm
    [(rm-reg reg)
     (single-byte-op/IM/reg opcode op-ext rexW val reg)]
    [(rm-mem (mem-direct mem-reg))
     (single-byte-op/IM/direct-mem opcode op-ext rexW val mem-reg)]
    [(rm-mem (mem-displaced mem-reg offset))
     (single-byte-op/IM/displaced-mem opcode op-ext rexW val mem-reg offset)]
    [(rm-mem (mem-scaled mem-reg scale index-reg displacement))
     (single-byte-op/IM/scaled-mem opcode op-ext rexW val mem-reg scale index-reg displacement)]))

(define (single-byte-op/IM/reg [opcode : Int] [op-ext : Int] [rexW : Boolean]
                               [val : S32] [reg : Register]) : Bytes
  (let ([rm (register->byte reg)])
    (add-maybe-byte
      (rex-byte rexW #f #f (>= rm 8))
      (let ([v (varargs bytes
                 opcode
                 (mod-rm-byte #x03 op-ext rm)
                 0 0 0 0)])
        (begin
          (bytes-set!/s32-le v 2 val)
          v)))))

(define (single-byte-op/IM/reg/u8 [opcode : Int] [op-ext : Int] [rexW : Boolean]
                                  [val : U8] [reg : Register]) : Bytes
  (let ([rm (register->byte reg)])
    (add-maybe-byte
      (rex-byte rexW #f #f (>= rm 8))
      (varargs bytes
               opcode
               (mod-rm-byte #x03 op-ext rm)
               (u8->s64 val)))))

(define (single-byte-op/IM/direct-mem [opcode : Int] [op-ext : Int] [rexW : Boolean]
                                      [val : S32] [reg : Register]) : Bytes
  (let ([rm (register->byte reg)])
    (add-maybe-byte
      (rex-byte rexW #f #f (>= rm 8))
      (let ([v (varargs bytes
                 opcode
                 (mod-rm-byte #x00 op-ext rm)
                 0 0 0 0)])
        (begin
          (bytes-set!/s32-le v 2 val)
          v)))))

;; Doesn't support rsp or r12. This is because the instruction set doesn't support them.
(define (single-byte-op/IM/displaced-mem
          [opcode : Int] [op-ext : Int] [rexW : Boolean] [val : S32]
          [reg : Register] [displacement : S32]) : Bytes
  (let ([rm (register->byte reg)])
    (add-maybe-byte
      (rex-byte rexW #f #f (>= rm 8))
      (let ([v (varargs bytes
                 opcode
                 (mod-rm-byte #x02 op-ext rm)
                 0 0 0 0 0 0 0 0)])
        (begin
          (bytes-set!/s32-le v 2 displacement)
          (bytes-set!/s32-le v 6 val)
          v)))))

(define (single-byte-op/IM/scaled-mem
          [opcode : Int] [op-ext : Int] [rexW : Boolean] [val : S32]
          [reg1 : Register] [scale : Scale] [reg2 : Register] [displacement : S32]) : Bytes
  (let ([base (register->byte reg1)])
    (let ([index (register->byte reg2)])
      (add-maybe-byte
        (rex-byte rexW #f (>= index 8) (>= base 8))
        (let ([v (varargs bytes
                   opcode
                   (mod-rm-byte #x02 op-ext #x04)
                   (sib-byte scale reg2 reg1)
                   0 0 0 0 0 0 0 0)])
          (begin
            (bytes-set!/s32-le v 3 displacement)
            (bytes-set!/s32-le v 7 val)
            v))))))


(define (single-byte-op/RM [opcode : Int] [rexW : Boolean] [reg : Register] [rm : RegMem])
  : Bytes
  (case rm
    [(rm-reg reg2)
     (single-byte-op/RM/reg opcode rexW reg reg2)]
    [(rm-mem (mem-direct mem-reg))
     (single-byte-op/RM/direct-mem opcode rexW reg mem-reg)]
    [(rm-mem (mem-displaced mem-reg offset))
     (single-byte-op/RM/displaced-mem opcode rexW reg mem-reg offset)]
    [(rm-mem (mem-scaled mem-reg scale index-reg displacement))
     (single-byte-op/RM/scaled-mem opcode rexW reg mem-reg scale index-reg displacement)]))
(define (single-byte-op/MR/mem [opcode : Int] [rexW : Boolean] [mem : MemoryArgument] [reg : Register])
  : Bytes
  (single-byte-op/RM opcode rexW reg (rm-mem mem)))

(define (single-byte-op/RM/reg [opcode : Int] [rexW : Boolean] [reg1 : Register] [reg2 : Register]) : Bytes
  (let ([reg (register->byte reg1)])
    (let ([rm (register->byte reg2)])
      (add-maybe-byte
        (rex-byte rexW (>= reg 8) #f (>= rm 8))
        (varargs bytes
          opcode
          (mod-rm-byte #x03 reg rm))))))
(define (single-byte-op/MR/reg [opcode : Int] [rexW : Boolean] [reg1 : Register] [reg2 : Register]) : Bytes
  (single-byte-op/RM/reg opcode rexW reg2 reg1))


;; Doesn't support rsp, rbp, r12 or r13. This is because the instruction set doesn't support them.
(define (single-byte-op/RM/direct-mem [opcode : Int] [rexW : Boolean] [reg1 : Register] [reg2 : Register]) : Bytes
  (let ([reg (register->byte reg1)])
    (let ([rm (register->byte reg2)])
      (add-maybe-byte
        (rex-byte rexW (>= reg 8) #f (>= rm 8))
        (varargs bytes
          opcode
          (mod-rm-byte #x00 reg rm))))))

(define (single-byte-op/RM/mem/8 [opcode : Int] [rexW : Boolean] [reg1 : Register8] [reg2 : Register]) : Bytes
  (let ([reg (register8->byte reg1)])
    (let ([rm (register->byte reg2)])
      (add-maybe-byte
        (rex-byte* rexW (>= reg 8) #f (>= rm 8) reg1)
        (varargs bytes
          opcode
          (mod-rm-byte #x00 reg rm))))))

;; Doesn't support rsp or r12. This is because the instruction set doesn't support them.
(define (single-byte-op/RM/displaced-mem
          [opcode : Int] [rexW : Boolean]
          [reg1 : Register]
          [reg2 : Register] [displacement : S32]) : Bytes
  (let ([reg (register->byte reg1)])
    (let ([rm (register->byte reg2)])
      (add-maybe-byte
        (rex-byte rexW (>= reg 8) #f (>= rm 8))
        (let ([v (varargs bytes
                   opcode
                   (mod-rm-byte #x02 reg rm)
                   0 0 0 0)])
          (begin
            (bytes-set!/s32-le v 2 displacement)
            v))))))

(define (single-byte-op/RM/displaced-mem/8
          [opcode : Int] [rexW : Boolean]
          [reg1 : Register8]
          [reg2 : Register] [displacement : S32]) : Bytes
  (let ([reg (register8->byte reg1)])
    (let ([rm (register->byte reg2)])
      (add-maybe-byte
        (rex-byte* rexW (>= reg 8) #f (>= rm 8) reg1)
        (let ([v (varargs bytes
                   opcode
                   (mod-rm-byte #x02 reg rm)
                   0 0 0 0)])
          (begin
            (bytes-set!/s32-le v 2 displacement)
            v))))))

(define (single-byte-op/RM/scaled-mem
          [opcode : Int] [rexW : Boolean]
          [reg1 : Register]
          [reg2 : Register] [scale : Scale] [reg3 : Register] [displacement : S32]) : Bytes
  (let ([reg (register->byte reg1)])
    (let ([base (register->byte reg2)])
      (let ([index (register->byte reg3)])
        (add-maybe-byte
          (rex-byte rexW (>= reg 8) (>= index 8) (>= base 8))
          (let ([v (varargs bytes
                     opcode
                     (mod-rm-byte #x02 reg #x04)
                     (sib-byte scale reg3 reg2)
                     0 0 0 0)])
            (begin
              (bytes-set!/s32-le v 3 displacement)
              v)))))))

(define (single-byte-op/RM/scaled-mem/8
          [opcode : Int] [rexW : Boolean]
          [reg1 : Register8]
          [reg2 : Register] [scale : Scale] [reg3 : Register] [displacement : S32]) : Bytes
  (let ([reg (register8->byte reg1)])
    (let ([base (register->byte reg2)])
      (let ([index (register->byte reg3)])
        (add-maybe-byte
          (rex-byte* rexW (>= reg 8) (>= index 8) (>= base 8) reg1)
          (let ([v (varargs bytes
                     opcode
                     (mod-rm-byte #x02 reg #x04)
                     (sib-byte scale reg3 reg2)
                     0 0 0 0)])
            (begin
              (bytes-set!/s32-le v 3 displacement)
              v)))))))


(define (single-byte-op/IMR [opcode : Int] [rexW : Boolean] [imm : S32]
                            [reg1 : Register] [reg2 : Register]) : Bytes
  (let ([reg (register->byte reg2)])
    (let ([rm (register->byte reg1)])
      (add-maybe-byte
        (rex-byte rexW (>= reg 8) #f (>= rm 8))
        (let ([v (varargs bytes
                   opcode
                   (mod-rm-byte #x03 reg rm)
                   0 0 0 0)])
          (begin
            (bytes-set!/s32-le v 2 imm)
            v))))))

(define (double-byte-op/MR [opcode : Int] [rexW : Boolean] [reg1 : Register] [reg2 : Register]) : Bytes
  (let ([rm (register->byte reg1)])
    (let ([reg (register->byte reg2)])
      (add-maybe-byte
        (rex-byte rexW (>= reg 8) #f (>= rm 8))
        (varargs bytes
          #x0F
          opcode
          (mod-rm-byte #x03 reg rm))))))
(define (double-byte-op/RM [opcode : Int] [rexW : Boolean] [reg1 : Register] [reg2 : Register]) : Bytes
  (double-byte-op/MR opcode rexW reg2 reg1))

(define (double-byte-op/MR/8 [opcode : Int] [rexW : Boolean] [reg1 : Register8] [reg2 : Register]) : Bytes
  (let ([rm (register8->byte reg1)])
    (let ([reg (register->byte reg2)])
      (add-maybe-byte
        (rex-byte* rexW (>= reg 8) #f (>= rm 8) reg1)
        (varargs bytes
          #x0F
          opcode
          (mod-rm-byte #x03 reg rm))))))

(define (double-byte-op/MR/mem [opcode : Int] [rexW : Boolean]
                               [mem : MemoryArgument] [reg : Register]) : Bytes
  (case mem
    [(mem-direct mem-reg)
     (double-byte-op/MR/direct-mem opcode rexW mem-reg reg)]
    [(mem-displaced mem-reg offset)
     (double-byte-op/MR/displaced-mem opcode rexW mem-reg offset reg)]
    [(mem-scaled mem-reg scale index-reg displacement)
     (double-byte-op/MR/scaled-mem opcode rexW mem-reg scale index-reg displacement reg)]))

(define (double-byte-op/MR/direct-mem [opcode : Int] [rexW : Boolean] [reg1 : Register] [reg2 : Register]) : Bytes
  (let ([rm (register->byte reg1)])
    (let ([reg (register->byte reg2)])
      (add-maybe-byte
        (rex-byte rexW (>= reg 8) #f (>= rm 8))
        (varargs bytes
          #x0F
          opcode
          (mod-rm-byte #x00 reg rm))))))

(define (double-byte-op/MR/displaced-mem
          [opcode : Int] [rexW : Boolean]
          [reg1 : Register] [displacement : S32]
          [reg2 : Register]) : Bytes
  (let ([rm (register->byte reg1)])
    (let ([reg (register->byte reg2)])
      (add-maybe-byte
        (rex-byte rexW (>= reg 8) #f (>= rm 8))
        (let ([v (varargs bytes
                   #x0F
                   opcode
                   (mod-rm-byte #x02 reg rm)
                   0 0 0 0)])
          (begin
            (bytes-set!/s32-le v 3 displacement)
            v))))))

(define (double-byte-op/MR/scaled-mem
          [opcode : Int] [rexW : Boolean]
          [reg1 : Register] [scale : Scale] [reg2 : Register] [displacement : S32]
          [reg3 : Register]) : Bytes
  (let ([base (register->byte reg1)])
    (let ([index (register->byte reg2)])
      (let ([reg (register->byte reg3)])
        (add-maybe-byte
          (rex-byte rexW (>= reg 8) (>= index 8) (>= base 8))
          (let ([v (varargs bytes
                     #x0F
                     opcode
                     (mod-rm-byte #x02 reg #x04)
                     (sib-byte scale reg2 reg1)
                     0 0 0 0)])
            (begin
              (bytes-set!/s32-le v 4 displacement)
              v)))))))


(define (double-byte-op/M/8 [opcode : Int] [op-ext : Int] [rexW : Boolean] [reg : Register8]) : Bytes
  (let ([rm (register8->byte reg)])
    (add-maybe-byte
      (rex-byte* rexW #f #f (>= rm 8) reg)
      (varargs bytes
        #x0F
        opcode
        (mod-rm-byte #x03 op-ext rm)))))

;; TODO make this take a U8
(define (add-maybe-byte [mv : (Maybe Int)] [bs : Bytes]) : Bytes
  (case mv
    [(nothing) bs]
    [(just v) (bytes-append (cons (varargs bytes v) (cons bs (empty))))]))


;; TODO make this return a U8
(define (rex-byte [w : Boolean] [r : Boolean] [x : Boolean] [b : Boolean])
  : (Maybe Int)
  (let ([ind (lambda ([v : Boolean]) (if v 1 0))])
    (let ([val (bitwise-ior #x40
                 (bitwise-ior (logical-shift-left (ind w) 3)
                   (bitwise-ior (logical-shift-left (ind r) 2)
                     (bitwise-ior (logical-shift-left (ind x) 1)
                                  (ind b)))))])
      (if (= val #x40)
          (nothing)
          (just val)))))

(define (mandatory-rex [reg : Register8]) : (Maybe Boolean)
  (case reg
    [(ah) (just #f)]
    [(bh) (just #f)]
    [(ch) (just #f)]
    [(dh) (just #f)]
    [(dil) (just #t)]
    [(sil) (just #t)]
    [(bpl) (just #t)]
    [(spl) (just #t)]
    [(al) (nothing)]
    [(bl) (nothing)]
    [(cl) (nothing)]
    [(dl) (nothing)]
    [(r8b) (nothing)]
    [(r9b) (nothing)]
    [(r10b) (nothing)]
    [(r11b) (nothing)]
    [(r12b) (nothing)]
    [(r13b) (nothing)]
    [(r14b) (nothing)]
    [(r15b) (nothing)]))

(define (rex-byte* [w : Boolean] [r : Boolean] [x : Boolean] [b : Boolean] [reg : Register8])
  : (Maybe Int)
  (match-define computed-rex (rex-byte w r x b))
  (case (mandatory-rex reg)
    [(nothing) computed-rex]
    [(just b)
     (if b
         (case computed-rex
           [(just x) computed-rex]
           [(nothing) (just #x40)])
         (case computed-rex
           [(just x) (panic #"Cannot encode rex prefix and use this register")]
           [(nothing) (nothing)]))]))

;; TODO make this return a U8
(define (sib-byte [scale : Scale] [index : Register] [base : Register]) : Int
  (bitwise-ior
    (case scale
      [(scale-1) #x00]
      [(scale-2) #x40]
      [(scale-4) #x80]
      [(scale-8) #xc0])
    (bitwise-ior
      (logical-shift-left (bitwise-and (register->byte index) #x07) 3)
      (bitwise-and (register->byte base) #x07))))

;; TODO make this return a U8
(define (register8->byte [reg : Register8]) : Int
  (case reg
    [(al) 0]
    [(ah) 4]
    [(bl) 3]
    [(bh) 7]
    [(cl) 1]
    [(ch) 5]
    [(dl) 2]
    [(dh) 6]
    [(dil) 7]
    [(sil) 6]
    [(bpl) 5]
    [(spl) 4]
    [(r8b) 8]
    [(r9b) 9]
    [(r10b) 10]
    [(r11b) 11]
    [(r12b) 12]
    [(r13b) 13]
    [(r14b) 14]
    [(r15b) 15]))

;; TODO make this return a U8
(define (register->byte [reg : Register]) : Int
  (case reg
    ;; 16 bit registers
    [(ax) 0]
    [(bx) 3]
    [(cx) 1]
    [(dx) 2]
    [(di) 7]
    [(si) 6]
    [(bp) 5]
    [(sp) 4]
    [(r8w) 8]
    [(r9w) 9]
    [(r10w) 10]
    [(r11w) 11]
    [(r12w) 12]
    [(r13w) 13]
    [(r14w) 14]
    [(r15w) 15]
    ;; 32 bit registers
    [(eax) 0]
    [(ebx) 3]
    [(ecx) 1]
    [(edx) 2]
    [(edi) 7]
    [(esi) 6]
    [(ebp) 5]
    [(esp) 4]
    [(r8d) 8]
    [(r9d) 9]
    [(r10d) 10]
    [(r11d) 11]
    [(r12d) 12]
    [(r13d) 13]
    [(r14d) 14]
    [(r15d) 15]
    ;;64 bit registers
    [(rax) 0]
    [(rbx) 3]
    [(rcx) 1]
    [(rdx) 2]
    [(rdi) 7]
    [(rsi) 6]
    [(rbp) 5]
    [(rsp) 4]
    [(r8) 8]
    [(r9) 9]
    [(r10) 10]
    [(r11) 11]
    [(r12) 12]
    [(r13) 13]
    [(r14) 14]
    [(r15) 15]))
