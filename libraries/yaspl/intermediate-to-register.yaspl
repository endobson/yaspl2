#:module (yaspl intermediate-to-register)
#:import {
  (bytes)
  (dict)
  (either)
  (intermediate-expression)
  (intermediate-language)
  (intermediate-to-stack) {
    #:values
      compile-byte-constants
      compile-closures
      compile-type-definitions
  }
  (list)
  (maybe)
  (module-name)
  (numbers)
  (prim)
  (prim-language) {
    #:values
      comparison-bin-op
      logical-bin-op
      numeric-bin-op
  }
  (prim-language register-language-builder)
  (register-language) {
    #:types
      [FunctionDefinition r:FunctionDefinition]
    #:values
      [bin-op-inst r:bin-op-inst]
      boolean-not
      closure-call
      closure-convention
      compare-mem-arg-ptr
      compare-mem-arg-val
      comparison-condition
      [cond-jump r:cond-jump]
      eight-byte-mem-op
      eight-byte-scale
      [fill-memory-inst r:fill-memory-inst]
      fixed-pointer-offset
      [function-call-inst r:function-call-inst]
      [function-definition r:function-definition]
      [halt r:halt]
      [heap-allocate-inst r:heap-allocate-inst]
      [int-literal r:int-literal]
      [jump r:jump]
      memory-compare-condition
      negated-var-condition
      [numeric-op-immediate-inst r:numeric-op-immediate-inst]
      one-byte-mem-op
      one-byte-scale
      [pointer-ref-inst r:pointer-ref-inst]
      [pointer-set!-inst r:pointer-set!-inst]
      [return r:return]
      scaled-pointer-offset
      [symbol-address-inst r:symbol-address-inst]
      [tail-call r:tail-call]
      [unary-op-inst r:unary-op-inst]
  }
  (tuples)
  (types)
  (yaspl math-operations)
  (yaspl module-environment)
  (yaspl top-level-objects)
  (yaspl var)
}
(export
  #:types ()
  #:values (module-to-top-level-objects)
  #:patterns ())
(types
  (define-type Environment
    (environment
      [vars : (Dict Var Var)]
      [module-env : ModuleEnvironment])))


(define (module-to-top-level-objects [mod : Module] [env : ModuleEnvironment]) : (List TopLevelObject)
  (append
    (compile-type-definitions mod)
    (append
      (compile-closures mod)
      (append
        (compile-byte-constants mod)
        (map
          (lambda ([f : FunctionDefinition])
            (register-function-tlo (convert-function (module-name mod) f env)))
          (module-definitions mod))))))

;; TODO investigate if this can be simplified now that intermediate language has vars.
(define (env-ref [env : Environment] [name : Var]) : (Maybe Var)
  (dict-ref (environment-vars env) name))

(define (env-global-ref [env : Environment] [name : Bytes]) : (Maybe Bytes)
  (module-environment-global-ref (environment-module-env env) name))
(define (env-pattern-tag-ref [env : Environment] [name : Bytes]) : (Maybe Int)
  (module-environment-tag-ref (environment-module-env env) name))

(define (env-set [env : Environment] [name : Var] [var : Var]) : Environment
  (case env
    [(environment vars module-env)
     (environment (dict-set vars name var) module-env)]))

(define (convert-function [mod-name : ModName] [f : FunctionDefinition] [env : ModuleEnvironment]) :
  r:FunctionDefinition
  (match-define (function-definition name _ args free-vars body) f)
  (match-define arg-names (map parse-arg-name args))
  (match-define acc (block-accumulator 0 0 (make-dict int-cmp)))
  (match-define (tuple2 start-block-num acc) (fresh-block-number* acc))

  (match-define (tuple2 freshened-args acc)
    (map-state fresh-name2* arg-names acc))
  (match-define (tuple2 freshened-free-vars acc)
    (map-state fresh-name2* free-vars acc))
  (match-define freshened-args+free-vars (append freshened-args freshened-free-vars))

  (match-define acc (start-block start-block-num (map new-arg2 freshened-args+free-vars) acc))
  (match-define env (environment (make-dict var-cmp) env))
  (match-define env
    (foldl
      (lambda ([t : (Tuple2 Var Var)] [env : Environment])
        (case t
          [(tuple2 name var) (env-set env name var)]))
      freshened-args+free-vars
      env))

  (match-define (tuple2 result acc) (convert-expr body env acc))
  (match-define (block-accumulator next-var next-block blocks) (add-terminal acc (r:return result)))

  (r:function-definition
    (mangle-name (bytes-append (varargs list (mangled-mod-name mod-name) #"_" name)))
    (closure-convention (length args) start-block-num (length free-vars)) blocks next-var next-block))

(define (convert-expr [e : Expression] [env : Environment] [acc : Accumulator]) : (Tuple2 Var Accumulator)
  (case e
    [(int-literal v)
     (case (fresh-var acc #"int")
       [(tuple2 var acc)
        (tuple2 var (add-instruction acc (r:int-literal var v)))])]
    [(boolean-literal v)
     (case (fresh-var acc #"bool")
       [(tuple2 var acc)
        (tuple2 var (add-instruction acc (r:int-literal var (if v 1 0))))])]
    [(local-var-expr v)
     (case (env-ref env v)
       [(just var) (tuple2 var acc)]
       [(nothing)
        (panic (bytes-append
                 (varargs list #"Unbound local variable when converting to register: " (var->bytes v))))])]
    [(global-var-expr v)
     (case (env-global-ref env v)
       [(just sym)
        (match-define (tuple2 var acc) (fresh-var acc v))
        (tuple2 var (add-instruction acc (r:symbol-address-inst var sym)))]
       [(nothing)
        (panic (bytes-append
                 (varargs list #"Unbound global variable when converting to register: " v)))])]
    [(begin-expr es e)
     (convert-expr e env (convert-begin es env acc))]
    [(let-expr name e body)
     (match-define (tuple2 v acc) (convert-expr e env acc))
     (convert-expr body (env-set env name v) acc)]
    [(call-closure-expr tail-position op args)
     (match-define (tuple2 closure-var acc) (convert-expr op env acc))
     (match-define (tuple2 arg-vars acc) (convert-exprs args env acc))
     (match-define (tuple2 result-var acc) (fresh-var acc #"res"))
     (if tail-position
         (case (fresh-block-number acc)
           [(tuple2 dead-block-num acc)
            (match-define acc (add-terminal acc (r:tail-call (closure-call closure-var) arg-vars)))
            ;; This result var is unscoped but should never be used.
            (tuple2 result-var (start-block dead-block-num (empty) acc))])
         (tuple2
           result-var
           (add-instruction
             acc
             (r:function-call-inst result-var (closure-call closure-var) arg-vars))))]
    [(prim-numeric-bin-op op left right)
     (match-define (tuple2 left-var acc) (convert-expr left env acc))
     (match-define (tuple2 right-var acc) (convert-expr right env acc))
     (match-define (tuple2 out-var acc) (fresh-var acc #"math"))
     (tuple2
       out-var
       (add-instruction
         acc
         (r:bin-op-inst out-var (numeric-bin-op op) left-var right-var)))]
    [(prim-comparison-bin-op op l r)
     (match-define (tuple2 left-var acc) (convert-expr l env acc))
     (match-define (tuple2 right-var acc) (convert-expr r env acc))
     (match-define (tuple2 out-var acc) (fresh-var acc #"cmp"))
     (tuple2
       out-var
       (add-instruction
         acc
         (r:bin-op-inst out-var (comparison-bin-op op) left-var right-var)))]
    [(prim-logical-bin-op op l r)
     (match-define (tuple2 left-var acc) (convert-expr l env acc))
     (match-define (tuple2 right-var acc) (convert-expr r env acc))
     (match-define (tuple2 out-var acc) (fresh-var acc #"cmp"))
     (tuple2
       out-var
       (add-instruction
         acc
         (r:bin-op-inst out-var (logical-bin-op op) left-var right-var)))]
    [(prim-logical-unary-op (not-op) e)
     (match-define (tuple2 in-var acc) (convert-expr e env acc))
     (match-define (tuple2 out-var acc) (fresh-var acc #"negated"))
     (tuple2
       out-var
       (add-instruction
         acc
         (r:unary-op-inst out-var (boolean-not) in-var)))]
    [(array-expr args)
     (case (fresh-var acc #"array-size")
       [(tuple2 array-size-var acc)
         (case (fresh-var acc #"byte-size")
           [(tuple2 byte-size-var acc)
            (case (fresh-var acc #"arr")
              [(tuple2 array-var acc)
               (match-define acc
                 (add-instruction
                   (add-instruction
                     (add-instruction
                       (add-instruction
                         acc
                         (r:int-literal byte-size-var (* (+ 1 (length args)) 8)))
                       (r:heap-allocate-inst array-var byte-size-var))
                     (r:int-literal array-size-var (length args)))
                   (r:pointer-set!-inst (eight-byte-mem-op) array-var (fixed-pointer-offset 0)
                                        array-size-var)))
               (match-define acc (fill-array array-var 8 args env acc))
               (tuple2 array-var acc)])])])]
    [(make-array-expr size val)
     (match-define (tuple2 size-var acc) (convert-expr size env acc))
     (match-define (tuple2 val-var acc) (convert-expr val env acc))
     (match-define (tuple2 incr-size-var acc) (fresh-var acc #"incr-size"))
     (match-define (tuple2 byte-size-var acc) (fresh-var acc #"bytes-size"))
     (match-define (tuple2 array-var acc) (fresh-var acc #"arr"))
     (match-define acc
       (add-instruction acc (r:numeric-op-immediate-inst incr-size-var (add-op) size-var (s32 1))))
     (match-define acc
       (add-instruction acc (r:numeric-op-immediate-inst byte-size-var (mult-op) incr-size-var (s32 8))))
     (match-define acc
       (add-instruction acc (r:heap-allocate-inst array-var byte-size-var)))
     (match-define acc
       (add-instruction acc (r:pointer-set!-inst (eight-byte-mem-op) array-var
                                                 (fixed-pointer-offset 0) size-var)))
     (match-define acc
       (add-instruction acc (r:fill-memory-inst (eight-byte-mem-op) array-var 0 val-var size-var)))
     (tuple2 array-var acc)]
    [(array-length-expr array)
     (match-define (tuple2 array-var acc) (convert-expr array env acc))
     (match-define (tuple2 size-var acc) (fresh-var acc #"size"))
     (match-define acc
       (add-instruction acc (r:pointer-ref-inst size-var (eight-byte-mem-op) array-var
                                                (fixed-pointer-offset 0))))
     (tuple2 size-var acc)]
    [(array-ref-expr array index)
     (match-define (tuple2 array-var acc) (convert-expr array env acc))
     (match-define (tuple2 index-var acc) (convert-expr index env acc))
     (match-define (tuple2 val-var acc) (fresh-var acc #"val"))
     (match-define acc
       (add-instruction acc
         (r:pointer-ref-inst val-var (eight-byte-mem-op) array-var
                             (scaled-pointer-offset index-var (eight-byte-scale) 8))))
     (tuple2 val-var acc)]
    [(array-set!-expr array index val)
     (match-define (tuple2 array-var acc) (convert-expr array env acc))
     (match-define (tuple2 index-var acc) (convert-expr index env acc))
     (match-define (tuple2 val-var acc) (convert-expr val env acc))
     (match-define (tuple2 void-var acc) (fresh-var acc #"void"))
     (match-define acc
       (add-instruction acc (r:pointer-set!-inst (eight-byte-mem-op) array-var
                                                 (scaled-pointer-offset index-var (eight-byte-scale) 8)
                                                 val-var)))
     (match-define acc
       (add-instruction acc (r:int-literal void-var 0)))
     (tuple2 void-var acc)]
    [(bytes-length-expr bytes)
     (match-define (tuple2 bytes-var acc) (convert-expr bytes env acc))
     (match-define (tuple2 size-var acc) (fresh-var acc #"size"))
     (match-define acc
       (add-instruction acc (r:pointer-ref-inst size-var (eight-byte-mem-op) bytes-var
                                                (fixed-pointer-offset 0))))
     (tuple2 size-var acc)]
    [(bytes-ref-expr bytes index)
     (match-define (tuple2 bytes-var acc) (convert-expr bytes env acc))
     (match-define (tuple2 index-var acc) (convert-expr index env acc))
     (match-define (tuple2 val-var acc) (fresh-var acc #"val"))
     (match-define acc
       (add-instruction acc
         (r:pointer-ref-inst val-var (one-byte-mem-op) bytes-var
                             (scaled-pointer-offset index-var (one-byte-scale) 8))))
     (tuple2 val-var acc)]
    [(bytes-set!-expr bytes index val)
     (match-define (tuple2 bytes-var acc) (convert-expr bytes env acc))
     (match-define (tuple2 index-var acc) (convert-expr index env acc))
     (match-define (tuple2 val-var acc) (convert-expr val env acc))
     (match-define (tuple2 void-var acc) (fresh-var acc #"void"))
     (match-define acc
       (add-instruction acc (r:pointer-set!-inst (one-byte-mem-op) bytes-var
                                                 (scaled-pointer-offset index-var (one-byte-scale) 8)
                                                 val-var)))
     (match-define acc
       (add-instruction acc (r:int-literal void-var 0)))
     (tuple2 void-var acc)]
    [(no-op-cast-op src dest expr)
     (convert-expr expr env acc)]
    [(if-expr cond then else)
     (match-define (tuple2 branch-var acc)
       (convert-expr cond env acc))
     (match-define (tuple2 t-block-num acc) (fresh-block-number acc))
     (match-define (tuple2 f-block-num acc) (fresh-block-number acc))
     (match-define acc
       (add-terminal acc (r:cond-jump (negated-var-condition branch-var)
                                      f-block-num (empty)
                                      t-block-num (empty))))

     (match-define (tuple2 t-value acc)
       (convert-expr then env (start-block t-block-num (empty) acc)))
     (match-define (tuple2 t-block acc) (split-accumulator acc))
     (match-define (tuple2 f-value acc)
       (convert-expr else env (start-block f-block-num (empty) acc)))
     (match-define (tuple2 f-block acc) (split-accumulator acc))

     (match-define (tuple2 c-block-num acc) (fresh-block-number* acc))

     (match-define acc
       (add-terminal*
         (add-terminal* acc t-block (r:jump c-block-num (varargs list t-value)))
         f-block (r:jump c-block-num (varargs list f-value))))
     (match-define (tuple2 join-var acc) (fresh-var* acc #"join"))

     (tuple2
       join-var
       (start-block c-block-num (varargs list join-var) acc))]
    [(create-closure-expr name exprs)
     (case (env-global-ref env name)
       [(nothing) (panic #"No global for closure")]
       [(just symbol)
        (match-define (tuple2 size-var acc) (fresh-var acc #"size"))
        (match-define (tuple2 closure-var acc) (fresh-var acc #"clos"))
        (match-define (tuple2 symbol-var acc) (fresh-var acc #"sym"))
        (match-define acc
          (add-instructions
            acc
            (varargs list
              (r:int-literal size-var (* (+ 1 (length exprs)) 8))
              (r:heap-allocate-inst closure-var size-var)
              (r:symbol-address-inst symbol-var symbol)
              (r:pointer-set!-inst (eight-byte-mem-op) closure-var (fixed-pointer-offset 0) symbol-var))))
        (match-define acc (fill-array closure-var 8 exprs env acc))
        (tuple2 closure-var acc)])]
    [(case-expr expr clauses)
     (match-define (tuple2 value-var acc) (convert-expr expr env acc))
     (match-define (tuple2 join-block acc) (fresh-block-number acc))
     (match-define acc (convert-clauses clauses value-var join-block env acc))
     (match-define (tuple2 join-var acc) (fresh-var* acc #"join"))
     (tuple2
       join-var
       (start-block join-block (varargs list join-var) acc))]))

(define (convert-clauses [clauses : (List CaseClause)] [value : Var] [join-block : Int]
                         [env : Environment] [acc : Accumulator]) : BlockAccumulator
  (case clauses
    [(empty) (add-terminal acc (r:halt))]
    [(cons (case-clause pattern expr) clauses)
     (match-define (tuple2 fail-block acc) (fresh-block-number acc))

     (match-define (tuple2 inner-env acc) (convert-pattern pattern value fail-block env acc))
     (match-define (tuple2 value-var acc) (convert-expr expr inner-env acc))
     (match-define acc
       (start-block fail-block (empty) (add-terminal acc (r:jump join-block (varargs list value-var)))))
     (convert-clauses clauses value join-block env acc)]))

(define (convert-pattern [pattern : Pattern] [value : Var] [fail-block : Int]
                         [env : Environment] [acc : Accumulator]) : (Tuple2 Environment Accumulator)
  (case pattern
    [(ignore-pattern) (tuple2 env acc)]
    [(variable-pattern var)
     (tuple2 (env-set env var value) acc)]
    [(int-pattern exp)
     ;; TODO handle int patterns that are larger than S32
     (match-define (tuple2 continue-block acc) (fresh-block-number acc))
     (tuple2
       env
       (start-block
         continue-block
         (empty)
         (add-terminal acc (r:cond-jump (comparison-condition
                                          (not-equal-op)
                                          (compare-mem-arg-val value)
                                          (right (s32 exp)))
                                        fail-block (empty) continue-block (empty)))))]
    [(bytes-pattern name)
     (case (env-global-ref env name)
       [(nothing) (panic #"No symbol for bytes pattern")]
       [(just symbol)
        (match-define (tuple2 bytes-var acc) (fresh-var acc #"bytes"))
        (match-define (tuple2 adj-size-var acc) (fresh-var acc #"adj"))
        (match-define (tuple2 base-size-var acc) (fresh-var acc #"base-size"))
        (match-define (tuple2 size-var acc) (fresh-var acc #"size"))
        (match-define acc (add-instruction acc (r:symbol-address-inst bytes-var symbol)))
        (match-define acc
          (add-instruction acc (r:pointer-ref-inst base-size-var (eight-byte-mem-op) bytes-var
                                                   (fixed-pointer-offset 0))))
        (match-define acc (add-instruction acc (r:int-literal adj-size-var 8)))
        (match-define acc (add-instruction acc (r:bin-op-inst size-var (numeric-bin-op (add-op))
                                                              base-size-var adj-size-var)))
        (match-define (tuple2 continue-block acc) (fresh-block-number acc))
        (tuple2
          env
          (start-block
            continue-block
            (empty)
            (add-terminal acc (r:cond-jump (memory-compare-condition #t size-var bytes-var value)
                                           fail-block (empty) continue-block (empty)))))])]
    [(abstraction-pattern name patterns)
     (case (env-pattern-tag-ref env name)
       [(nothing) (panic #"No tag for abstraction")]
       [(just expected-tag)
        ;; TODO ensure that expected tag is in S32
        (match-define (tuple2 continue-block acc) (fresh-block-number acc))
        (match-define acc
          (start-block
            continue-block
            (empty)
            (add-terminal acc (r:cond-jump (comparison-condition (not-equal-op)
                                                                 (compare-mem-arg-ptr value)
                                                                 (right (s32 expected-tag)))
                                           fail-block (empty) continue-block (empty)))))
        (convert-sub-patterns patterns value 8 fail-block env acc)])]))

(define (convert-sub-patterns
          [patterns : (List Pattern)] [ptr : Var] [offset : Int] [fail-block : Int]
          [env : Environment] [acc : Accumulator]) : (Tuple2 Environment Accumulator)
  (case patterns
    [(empty) (tuple2 env acc)]
    [(cons pattern patterns)
     (match-define (tuple2 new-value acc) (fresh-var acc #"val"))
     (match-define acc
       (add-instruction acc
         (r:pointer-ref-inst new-value (eight-byte-mem-op) ptr (fixed-pointer-offset offset))))
     (match-define (tuple2 env acc) (convert-pattern pattern new-value fail-block env acc))
     (convert-sub-patterns patterns ptr (+ offset 8) fail-block env acc)]))


(define (fill-array [base : Var] [offset : Int] [exprs : (List Expression)]
                    [env : Environment] [acc : Accumulator]) : Accumulator
  (case exprs
    [(empty) acc]
    [(cons expr exprs)
     (case (convert-expr expr env acc)
       [(tuple2 value-var acc)
        (fill-array
          base
          (+ offset 8)
          exprs
          env
          (add-instruction
            acc
            (r:pointer-set!-inst (eight-byte-mem-op) base (fixed-pointer-offset offset) value-var)))])]))

(define (convert-begin [exprs : (List Expression)] [env : Environment] [acc : Accumulator])
  : Accumulator
  (case exprs
    [(empty) acc]
    [(cons expr exprs)
     (match-define (tuple2 _ acc) (convert-expr expr env acc))
     (convert-begin exprs env acc)]))

(define (convert-exprs [exprs : (List Expression)] [env : Environment] [acc : Accumulator])
  : (Tuple2 (List Var) Accumulator)
  (case exprs
    [(empty)
     (tuple2 (empty) acc)]
    [(cons expr exprs)
     (match-define (tuple2 v acc) (convert-expr expr env acc))
     (match-define (tuple2 vars acc) (convert-exprs exprs env acc))
     (tuple2 (cons v vars) acc)]))

(define (fresh-var [acc : Accumulator] [base-name : Bytes]) : (Tuple2 Var Accumulator)
  (case (fresh-name base-name acc)
    [(tuple2 (tuple2 _ v) acc) (tuple2 v acc)]))

(define (fresh-var* [acc : BlockAccumulator] [base-name : Bytes]) : (Tuple2 Var BlockAccumulator)
  (case (fresh-name* base-name acc)
    [(tuple2 (tuple2 _ v) acc) (tuple2 v acc)]))

(define (a b s) (map-state [f : (a s -> (Tuple2 b s))] [l : (List a)] [s : s]) : (Tuple2 (List b) s)
  (case l
    [(empty) (tuple2 (empty) s)]
    [(cons e l)
     (case (f e s)
       [(tuple2 v s)
        (case (map-state f l s)
          [(tuple2 vs s)
           (tuple2 (cons v vs) s)])])]))

(define (parse-arg-name [t : (Tuple2 Var Type)]) : Var
  (case t
    [(tuple2 n _) n]))
