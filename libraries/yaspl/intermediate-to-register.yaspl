#:module (yaspl intermediate-to-register)
#:import {
  (dict)
  (intermediate-language)
  (list)
  (maybe)
  (prim)
  (prim-language) {
    #:values
      numeric-bin-op
      plus
  }
  (prim-language register-language-builder)
  (register-language) {
    #:types
      Var
    #:values
      [bin-op-inst r:bin-op-inst]
      closure-call
      [cond-jump r:cond-jump]
      eight-byte-mem-op
      [function-call-inst r:function-call-inst]
      [heap-allocate-inst r:heap-allocate-inst]
      [int-literal r:int-literal]
      [jump r:jump]
      negated-var-condition
      [pointer-set!-inst r:pointer-set!-inst]
      [symbol-address-inst r:symbol-address-inst]
  }
  (tuples)
}
(export
  #:types ()
  #:values (convert-expr)
  #:patterns ())
(types
  (define-type Environment
    (environment [vars : (Dict Bytes Var)])))

(define (env-ref [env : Environment] [name : Bytes]) : Var
  (case (dict-ref (environment-vars env) name)
    [(nothing) (panic #"unbound variable")]
    [(just v) v]))

(define (env-global-ref [env : Environment] [name : Bytes]) : Bytes
  (panic #"env-global-erf is not yet implemented"))


(define (env-set [env : Environment] [name : Bytes] [var : Var]) : Environment
  (case env
    [(environment vars)
     (environment (dict-set vars name var))]))

(define (convert-expr [e : Expression] [env : Environment] [acc : Accumulator]) : (Tuple2 Var Accumulator)
  (case e
    [(int-literal v)
     (case (fresh-var acc #"int")
       [(tuple2 var acc)
        (tuple2 var (add-instruction acc (r:int-literal var v)))])]
    [(boolean-literal v)
     (case (fresh-var acc #"bool")
       [(tuple2 var acc)
        (tuple2 var (add-instruction acc (r:int-literal var (if v 1 0))))])]
    [(var-expr v)
     (tuple2 (env-ref env v) acc)]
    [(begin-expr e es)
     (convert-begin e es env acc)]
    [(let-expr name e body)
     (match-define (tuple2 v acc) (convert-expr e env acc))
     (convert-expr e (env-set env name v) acc)]
    [(call-closure-expr op args)
     (case (convert-expr op env acc)
       [(tuple2 closure-var acc)
        (case (convert-exprs args env acc)
          [(tuple2 arg-vars acc)
           (case (fresh-var acc #"res")
             [(tuple2 result-var acc)
              (tuple2
                result-var
                (add-instruction
                  acc
                  (r:function-call-inst result-var (closure-call closure-var) arg-vars)))])])])]
    [(make-array-expr args)
     (case (fresh-var acc #"size")
       [(tuple2 size-var acc)
        (case (fresh-var acc #"arr")
          [(tuple2 array-var acc)
           (match-define acc
             (add-instruction
               (add-instruction
                 (add-instruction acc (r:int-literal size-var (* (+ 1 (length args)) 8)))
                 (r:heap-allocate-inst array-var size-var))
               (r:pointer-set!-inst (eight-byte-mem-op) array-var size-var)))
           (match-define acc (fill-array array-var args env acc))
           (tuple2 array-var acc)])])]
    [(if-expr cond then else)
     (match-define (tuple2 branch-var acc)
       (convert-expr cond env acc))
     (match-define (tuple2 t-block-num acc) (fresh-block-number acc))
     (match-define (tuple2 f-block-num acc) (fresh-block-number acc))
     (match-define acc
       (add-terminal acc (r:cond-jump (negated-var-condition branch-var)
                                      f-block-num (empty)
                                      t-block-num (empty))))

     (match-define (tuple2 t-value acc)
       (convert-expr then env (start-block t-block-num (empty) acc)))
     (match-define (tuple2 t-block acc) (split-accumulator acc))
     (match-define (tuple2 f-value acc)
       (convert-expr else env (start-block f-block-num (empty) acc)))
     (match-define (tuple2 f-block acc) (split-accumulator acc))

     (match-define (tuple2 c-block-num acc) (fresh-block-number* acc))

     (match-define acc
       (add-terminal*
         (add-terminal* acc t-block (r:jump c-block-num (varargs list t-value)))
         f-block (r:jump c-block-num (varargs list f-value))))
     (match-define (tuple2 join-var acc) (fresh-var* acc #"join"))

     (tuple2
       join-var
       (start-block c-block-num (varargs list join-var) acc))]
    [(create-closure-expr name exprs)
     (match-define symbol (env-global-ref env name))
     (match-define (tuple2 size-var acc) (fresh-var acc #"size"))
     (match-define (tuple2 closure-var acc) (fresh-var acc #"clos"))
     (match-define (tuple2 symbol-var acc) (fresh-var acc #"sym"))
     (match-define acc
       (add-instructions
         acc
         (varargs list
           (r:int-literal size-var (* (+ 1 (length exprs)) 8))
           (r:heap-allocate-inst closure-var size-var)
           (r:symbol-address-inst symbol-var symbol)
           (r:pointer-set!-inst (eight-byte-mem-op) closure-var symbol-var))))
     (match-define acc (fill-array closure-var exprs env acc))
     (tuple2 closure-var acc)]
    [(case-expr _ _) (panic #"NYI")]))

(define (fill-array [last-index : Var] [exprs : (List Expression)]
                    [env : Environment] [acc : Accumulator]) : Accumulator
  (case exprs
    [(empty) acc]
    [(cons expr exprs)
     (case (convert-expr expr env acc)
       [(tuple2 value-var acc)
        (case (fresh-var acc #"delta")
          [(tuple2 delta-var acc)
           (case (fresh-var acc #"arr")
             [(tuple2 new-index acc)
              (fill-array
                new-index
                exprs
                env
                (add-instruction
                  (add-instruction
                    (add-instruction acc (r:int-literal delta-var 8))
                    (r:bin-op-inst new-index (numeric-bin-op (plus)) last-index delta-var))
                  (r:pointer-set!-inst (eight-byte-mem-op) new-index value-var)))])])])]))

(define (convert-begin [expr : Expression] [exprs : (List Expression)] [env : Environment] [acc : Accumulator])
  : (Tuple2 Var Accumulator)
  (match-define (tuple2 v acc) (convert-expr expr env acc))
  (case exprs
    [(empty)
     (tuple2 v acc)]
    [(cons expr exprs)
     (convert-begin expr exprs env acc)]))

(define (convert-exprs [exprs : (List Expression)] [env : Environment] [acc : Accumulator])
  : (Tuple2 (List Var) Accumulator)
  (case exprs
    [(empty)
     (tuple2 (empty) acc)]
    [(cons expr exprs)
     (match-define (tuple2 v acc) (convert-expr expr env acc))
     (match-define (tuple2 vars acc) (convert-exprs exprs env acc))
     (tuple2 (cons v vars) acc)]))

(define (fresh-var [acc : Accumulator] [base-name : Bytes]) : (Tuple2 Var Accumulator)
  (case (fresh-name base-name acc)
    [(tuple2 (tuple2 _ v) acc) (tuple2 v acc)]))

(define (fresh-var* [acc : BlockAccumulator] [base-name : Bytes]) : (Tuple2 Var BlockAccumulator)
  (case (fresh-name* base-name acc)
    [(tuple2 (tuple2 _ v) acc) (tuple2 v acc)]))
