#:module (yaspl intermediate-to-register)
#:import {
  (dict)
  (intermediate-language)
  (list)
  (prim)
  (register-language) {
    #:types
      BasicBlock
      Instruction
      Var
    #:values
      [int-literal r:int-literal]
      var
  }
  (tuples)
}
(export
  #:types ()
  #:values (convert-expr)
  #:patterns ())
(types
  (define-type CurrentBlock
    (current-block [args : (List Var)] [rev-instruction : (List Instruction)]))
  (define-type Accumulator
    (accumulator
      [next-var : Int]
      [next-block : Int]
      [current-block : CurrentBlock]
      [blocks : (Dict Int BasicBlock)]))
  (define-type Environment
    (environment))
  (define-type BlockAccumulator
    (block-accumulator
      [next-block : Int]
      [blocks : (Dict Int BasicBlock)])))



(define (convert-expr [e : Expression] [env : Environment] [acc : Accumulator]) : (Tuple2 Var Accumulator)
  (case e
    [(int-literal v)
     (case (fresh-var acc #"int")
       [(tuple2 var acc)
        (tuple2 var (add-instruction acc (r:int-literal var v)))])]
    [(boolean-literal v)
     (case (fresh-var acc #"bool")
       [(tuple2 var acc)
        (tuple2 var (add-instruction acc (r:int-literal var (if v 1 0))))])]
    [_ (panic #"NYI")]))

(define (fresh-var [acc : Accumulator] [base-name : Bytes]) : (Tuple2 Var Accumulator)
  (match-define (accumulator next-var next-block current-block blocks) acc)
  (tuple2
    (var base-name next-var)
    (accumulator (+ 1 next-var) next-block current-block blocks)))

(define (add-instruction [acc : Accumulator] [inst : Instruction]) : Accumulator
  (match-define (accumulator next-var next-block (current-block args rev-insts) blocks) acc)
  (accumulator next-var next-block (current-block args (cons inst rev-insts)) blocks))
