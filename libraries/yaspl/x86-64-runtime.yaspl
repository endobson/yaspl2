#:module (x86-64-runtime)
#:import {
  (bytes)
  (join-list)
  (list)
  (prim)
  (top-level-name)
  (tuples)
  (yaspl intermediate-to-register)
  (yaspl x86-64-assembly)
}
(export
  (#:types SystemAbi)
  (#:values yaspl-runtime osx-abi linux-abi)
  (#:patterns))
(types
  (define-type SystemAbi
    (osx-abi)
    (linux-abi)))

(define (yaspl-runtime [main-function-name : TopLevelName] [abi : SystemAbi]) : AssemblyFragments
  (match-define (tuple2 text-fragments const-fragments) (unzip (prim-function-fragments abi)))
  (assembly-fragments
    (append (start-function-fragments main-function-name abi) text-fragments)
    const-fragments))

(define (start-function-fragments [main-function-name : TopLevelName] [abi : SystemAbi]) : (List TextFragment)
  (varargs list
    (let ([start-name
            (case abi
              [(osx-abi) #"start"]
              [(linux-abi) #"_start"])])
      (function-fragment
        start-name
        (varargs list
          (section
            (varargs list
              (basic-block start-name
                (varargs join-list
                  (jmp #"start_break"))))))))

    (function-fragment
      #"start_break"
      (varargs list
        (section
          (varargs list
            (basic-block #"start_break"
              (varargs append-jl*
                (varargs join-list
                  ;; Allocate Heap (Call mmap)
                  ;; No fixed address desired
                  (movq (imm64/s32 0) (r64m-reg (rdi)))
                  ;; We want a large heap but cannot load more than an 32 bits
                  ;; currently so do a multiplication
                  ;; Currently this is 8k * 1MiB = 8GiB
                  ;; 2^20 = 1MiB
                  (movq (imm64/s32 #x200000) (r64m-reg (rsi)))
                  ;; 2^13 = 8k
                  (movq (imm64/s32 #x2000) (r64m-reg (rax)))
                  (imulq (rax) (rsi))
                  ;; 0x1 = PROT_READ
                  ;; 0x2 = PROT_WRITE
                  ;; 0x4 = PROT_EXEC
                  (movq (imm64/s32 #x7) (r64m-reg (rdx)))
                  (case abi
                    [(osx-abi)
                     ;; 0x0002 = MAP_PRIVATE
                     ;; 0x1000 = MAP_ANON
                     (movq (imm64/s32 #x1002) (r64m-reg (r10)))]
                    [(linux-abi)
                     ;; 0x0002 = MAP_PRIVATE
                     ;; 0x0020 = MAP_ANON
                     (movq (imm64/s32 #x0022) (r64m-reg (r10)))])
                  ;; FD = -1 for no FD
                  (movq (imm64/s32 (- 0 1)) (r64m-reg (r8)))
                  ;; offset which is ignored because of MAP_ANON
                  (movq (imm64/s32 0) (r64m-reg (r9)))
                  (case abi
                    [(osx-abi)
                     ;; 0xC5 is mmap, plus 0x2000000 because xnu
                     (movq (imm64/s32 #x20000C5) (r64m-reg (rax)))]
                    [(linux-abi)
                     ;; 0x09 is mmap
                     (movq (imm64/s32 #x09) (r64m-reg (rax)))])
                  (syscall))
                (case abi
                  [(osx-abi)
                   (single-jl (jb #"yprim_start_panic"))]
                  [(linux-abi)
                   (varargs join-list
                     (cmpq (imm64/s32 0) (r64m-reg (rax)))
                     (jl #"yprim_start_panic"))])
                (varargs join-list
                  ;; Save heap to %r15 which is our bump pointer
                  (movq (r64mi-reg (rax)) (r64m-reg (r15)))
                  ;; Save initial value to r14 for setting up the thread control block later.
                  (movq (r64mi-reg (rax)) (r64m-reg (r14)))

                  ;; Ignore number of args as we want to reuse code for environment.
                  (addq (imm64/s32 8) (r64m-reg (rsp)))
                  ;; Clear direction for all the scans that will be done when
                  (cld)

                  ;; Count number of args
                  (movq (r64mi-reg (rsp)) (r64m-reg (rdi)))
                  (movq (imm64/s32 0) (r64m-reg (rax)))
                  ;; Assumption: Strings cannot be longer than 2^64-1
                  ;; Loads treat the immediate as a 32 bit signed number, which is sign extended.
                  ;; Then repne-scasq treats it as unsigned which means -1 => 2^64-1
                  (movq (imm64/s32 (- 0 1)) (r64m-reg (rcx)))
                  (repne-scasq)
                  (notq (rcx))
                  (decq (rcx))
                  (movq (r64mi-reg (rcx)) (r64m-reg (r8)))

                  ; r10 is the array of bytes
                  (movq (r64mi-reg (r15)) (r64m-reg (r10)))
                  ; r11 is the address of the last bytes put into the array
                  (movq (r64mi-reg (r10)) (r64m-reg (r11)))

                  (movq (r64mi-reg (r8)) (r64m-mem (mem (r10) 0)))
                  (leaq (scaled (r10) (scale-8) (r8) 8) (r15))

                  (jmp #"start_copy_args_test"))))

            (basic-block #"start_copy_args_test"
              (varargs join-list
                (popq (r64m-reg (r9))) ; r9 is now the current string
                (cmpq (imm64/s32 0) (r64m-reg (r9)))
                (je #"start_copy_args_end")))

            (basic-block #"start_copy_args_body"
              (varargs join-list

                ;; Count string length
                (movq (r64mi-reg (r9)) (r64m-reg (rdi)))
                (movq (imm64/s32 0) (r64m-reg (rax)))
                ;; Assumption: Strings cannot be longer than 2^64-1
                ;; Loads treat the immediate as a 32 bit signed number, which is sign extended.
                ;; Then repne-scasb treats it as unsigned which means -1 => 2^64-1
                (movq (imm64/s32 (- 0 1)) (r64m-reg (rcx)))
                (repne-scasb)
                (notq (rcx))
                (decq (rcx))

                ;; Store where we are copying the bytes to
                (addq (imm64/s32 8) (r64m-reg (r11)))
                (movq (r64mi-reg (r15)) (r64m-mem (mem (r11) 0)))
                ;; Copy the raw bytes from r9 to a fresh tagged bytes object
                ;; TODO Write the tag
                (addq (imm64/s32 8) (r64m-reg (r15)))
                ;; Write the size
                (movq (r64mi-reg (rcx)) (r64m-mem (mem (r15) 0)))
                (addq (imm64/s32 8) (r64m-reg (r15)))
                (movq (r64mi-reg (r9)) (r64m-reg (rsi)))
                (movq (r64mi-reg (r15)) (r64m-reg (rdi)))
                (rep-movsb)
                (movq (r64mi-reg (rdi)) (r64m-reg (r15)))
                (addq (imm64/s32 7) (r64m-reg (r15)))
                (andq (imm64/s32 (- 0 8)) (r15))
                (jmp #"start_copy_args_test")))

            (basic-block #"start_copy_args_end"
              (varargs join-list

                ;; Count number of env
                (movq (r64mi-reg (rsp)) (r64m-reg (rdi)))
                (movq (imm64/s32 0) (r64m-reg (rax)))
                ;; Assumption: Strings cannot be longer than 2^64-1
                ;; Loads treat the immediate as a 32 bit signed number, which is sign extended.
                ;; Then repne-scasq treats it as unsigned which means -1 => 2^64-1
                (movq (imm64/s32 (- 0 1)) (r64m-reg (rcx)))
                (repne-scasq)
                (notq (rcx))
                (decq (rcx))
                (movq (r64mi-reg (rcx)) (r64m-reg (r8)))

                (movq (r64mi-reg (r15)) (r64m-reg (r13))) ; r13 is the array of bytes
                (movq (r64mi-reg (r13)) (r64m-reg (r11))) ; r11 is the address of the last bytes put into the array

                (movq (r64mi-reg (r8)) (r64m-mem (mem (r13) 0)))
                (leaq (scaled (r13) (scale-8) (r8) 8) (r15))

                (jmp #"start_copy_env_test")))

            (basic-block #"start_copy_env_test"
              (varargs join-list
                (popq (r64m-reg (r9))) ; r9 is now the current string
                (cmpq (imm64/s32 0) (r64m-reg (r9)))
                (je #"start_copy_env_end")))

            (basic-block #"start_copy_env_body"
              (varargs join-list

                ;; Count string length
                (movq (r64mi-reg (r9)) (r64m-reg (rdi)))
                (movq (imm64/s32 0) (r64m-reg (rax)))
                ;; Assumption: Strings cannot be longer than 2^64-1
                ;; Loads treat the immediate as a 32 bit signed number, which is sign extended.
                ;; Then repne-scasb treats it as unsigned which means -1 => 2^64-1
                (movq (imm64/s32 (- 0 1)) (r64m-reg (rcx)))
                (repne-scasb)
                (notq (rcx))
                (decq (rcx))

                ;; Copy bytes
                (addq (imm64/s32 8) (r64m-reg (r11)))
                (movq (r64mi-reg (r15)) (r64m-mem (mem (r11) 0)))
                ;; TODO copy tag bytes
                (addq (imm64/s32 8) (r64m-reg (r15)))
                (movq (r64mi-reg (rcx)) (r64m-mem (mem (r15) 0)))
                (addq (imm64/s32 8) (r64m-reg (r15)))
                (movq (r64mi-reg (r9)) (r64m-reg (rsi)))
                (movq (r64mi-reg (r15)) (r64m-reg (rdi)))
                (rep-movsb)
                (movq (r64mi-reg (rdi)) (r64m-reg (r15)))
                (addq (imm64/s32 7) (r64m-reg (r15)))
                (andq (imm64/s32 (- 0 8)) (r15))
                (jmp #"start_copy_env_test")))


            (basic-block #"start_copy_env_end"
              (varargs join-list
                (jmp #"start_call_main")))


            ;; Call main and then exit

            (basic-block #"yprim_start_panic"
              (varargs join-list
                (ud2)))))))

    (function-fragment
      #"start_call_main"
      (varargs list
        (section
          (varargs list
            (basic-block #"start_call_main"
              (varargs join-list
                ;; Set up the thread control block
                (subq (imm64/s32 #x08) (rsp))
                ;; Make our initial allocation look like 2 Mebibytes.
                (addq (imm64/s32 #x200000) (r64m-reg (r14)))
                (movq (r64mi-reg (r14)) (r64m-mem (mem (rsp) 0)))
                (movq (r64mi-reg (rsp)) (r64m-reg (r14)))


                ;; Set up initial base pointer
                (movq (imm64/s32 0) (r64m-reg (rbp)))
                (movq (r64mi-reg (r10)) (r64m-reg (rdi))) ;; Arguments
                (movq (imm64/s32 0) (r64m-reg (rsi)))
                (movq (imm64/s32 1) (r64m-reg (rdx)))
                (movq (imm64/s32 2) (r64m-reg (rcx)))
                (movq (r64mi-reg (r13)) (r64m-reg (r8))) ;; Environment
                (leaq/rip-rel (mangle-top-level-name main-function-name) (r11))
                (call/indirect (r64m-mem (mem (r11) 0)))
                ;; Closure is still on the stack
                (movq (r64mi-reg (rax)) (r64m-reg (rdi)))
                (case abi
                  [(osx-abi)
                   ;; #x01 is exit, plus 0x2000000 because xnu
                   (movq (imm64/s32 #x2000001) (r64m-reg (rax)))]
                  [(linux-abi)
                   ;; #x3C is exit
                   (movq (imm64/s32 #x3C) (r64m-reg (rax)))])
                (syscall)))))))))

(define (prim-function-fragments [abi : SystemAbi])
  : (List (Tuple2 TextFragment ConstFragment))
  (match-define prim-syscall
    (lambda ([name : Bytes] [osx-syscall-number : Int]
             [linux-syscall-number : Int] [body : (JoinList Instruction)])
      (prim-assembly-function/panic name
        (append-jl
          body
          (case abi
            [(osx-abi)
             (varargs join-list
               (movq (imm64/s32 (+ #x2000000 osx-syscall-number)) (r64m-reg (rax)))
               (syscall)
               (jb (bytes-append (varargs list #"yprim_" name #"_panic")))
               (ret))]
            [(linux-abi)
             (varargs join-list
               (movq (imm64/s32 linux-syscall-number) (r64m-reg (rax)))
               (syscall)
               (cmpq (imm64/s32 0) (r64m-reg (rax)))
               (jl (bytes-append (varargs list #"yprim_" name #"_panic")))
               (ret))])))))

  (varargs list
    ;; Standard system calls

    ;; write-bytes
    (prim-syscall #"write_bytes" #x04 #x01
      (varargs join-list
        ;; Swap %rdi and %rsi
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (movq (r64mi-reg (rsi)) (r64m-reg (rdi)))
        (movq (r64mi-reg (rax)) (r64m-reg (rsi)))

        ;; %rdi is now the file descriptor
        ;; Make %rsi the start of the buffer
        (leaq (scaled (rsi) (scale-1) (rdx) 16) (rsi))
        ;; Make %rdx the length to write
        (subq (r64mi-reg (rdx)) (rcx))
        (movq (r64mi-reg (rcx)) (r64m-reg (rdx)))))

    ;; read-bytes
    (prim-syscall #"read_bytes" #x03 #x00
      (varargs join-list
        ;; Swap %rdi and %rsi
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (movq (r64mi-reg (rsi)) (r64m-reg (rdi)))
        (movq (r64mi-reg (rax)) (r64m-reg (rsi)))

        ;; %rdi is the file descriptor
        ;; Make %rsi the start of the buffer
        (leaq (scaled (rsi) (scale-1) (rdx) 16) (rsi))
        ;; Make %rdx the length to read
        (subq (r64mi-reg (rdx)) (rcx))
        (movq (r64mi-reg (rcx)) (r64m-reg (rdx)))))

    ;; open-input-file
    (prim-syscall #"open_input_file" #x05 #x02
      (varargs join-list
        ;; Make %rdi point at start of null terminated path
        (addq (imm64/s32 16) (r64m-reg (rdi)))
        (movq (imm64/s32 0) (r64m-reg (rsi))))) ;; 0 is read only

    ;; open-output-file
    (prim-syscall #"open_output_file" #x05 #x02
      (varargs join-list
        ;; Make %rdi point at start of null terminated path
        (addq (imm64/s32 16) (r64m-reg (rdi)))
        (movq (imm64/s32 #x0a01) (r64m-reg (rsi))) ;; 0x01 is write only, 0x0a00 is exclusive create
        (movq (imm64/s32 504) (r64m-reg (rdx))))) ;; 770 for mode

    ;; close-output-port
    ;; close-input-port
    (prim-syscall #"close_port" #x06 #x03
      (empty-jl))

    ;; delete-file
    (prim-syscall #"delete_file" #x0a #x57
      (varargs join-list
        ;; Make %rdi point at start of null terminated path
        (addq (imm64/s32 16) (r64m-reg (rdi)))))

    ;; make-directory
    (prim-syscall #"make_directory" #x88 #x53
      (varargs join-list
        ;; Make %rdi point at start of null terminated path
        (addq (imm64/s32 16) (r64m-reg (rdi)))
        (movq (imm64/s32 504) (r64m-reg (rsi))))) ;; 770 for mode


    ;; set-file-or-directory-permissions
    (prim-syscall #"set_file_or_directory_permissions" #x0f #x5a
      (varargs join-list
        ;; Make %rdi point at start of null terminated path
        (addq (imm64/s32 16) (r64m-reg (rdi)))
        ;; %rsi is already the permissions
        ))

    ;; socket
    (prim-syscall #"socket" #x61 #x29
      (empty-jl
        ;; Argument 1: domain
        ;; Argument 2: type
        ;; Argument 3: protocol
        ))

    ;; bind
    (prim-syscall #"bind" #x68 #x31
      (varargs join-list
        ;; Argument 1: socket
        ;; Argument 2: sockaddr
        ;; Argument 3: length
        (addq (imm64/s32 16) (r64m-reg (rsi)))))

    ;; sendto
    (prim-syscall #"sendto" #x85 #x2c
      (varargs join-list
        ;; Argument 1: socket
        ;; Argument 2: buffer
        ;; Argument 3: buffer-length
        ;; Argument 4: flags
        ;; Argument 5: sockaddr
        ;; Argument 6: sockaddr-length
        (addq (imm64/s32 16) (r64m-reg (rsi)))
        (addq (imm64/s32 16) (r64m-reg (r8)))
        (movq (r64mi-reg (rcx)) (r64m-reg (r10)))))

    ;; recvfrom
    (prim-syscall #"recvfrom" #x1d #x2d
      (varargs join-list
        ;; Argument 1: socket
        ;; Argument 2: buffer
        ;; Argument 3: buffer-length
        ;; Argument 4: flags
        ;; Argument 5: sockaddr
        ;; Argument 6: sockaddr-length
        (addq (imm64/s32 16) (r64m-reg (rsi)))
        (addq (imm64/s32 16) (r64m-reg (r8)))
        (addq (imm64/s32 16) (r64m-reg (r9)))
        (movq (r64mi-reg (rcx)) (r64m-reg (r10)))))

    ;; connect
    (prim-syscall #"connect" #x62 #x2a
      (varargs join-list
        ;; Argument 1: socket
        ;; Argument 2: sockaddr
        ;; Argument 3: sockaddr-length
        (addq (imm64/s32 16) (r64m-reg (rsi)))))

    ;; shutdown
    (prim-syscall #"shutdown" #x86 #x30
      (empty-jl
        ;; Argument 1: socket
        ;; Argument 2: how
        ))

    ;; listen
    (prim-syscall #"listen" #x6A #x32
      (empty-jl
        ;; Argument 1: socket
        ;; Argument 2: backlog
        ))

    ;; accept
    (prim-syscall #"accept" #x1E #x2b
      (varargs join-list
        ;; Argument 1: socket
        ;; Argument 2: sockaddr
        ;; Argument 3: sockaddr-length
        (addq (imm64/s32 16) (r64m-reg (rsi)))
        (addq (imm64/s32 16) (r64m-reg (rdx)))))

    ;; setsockopt
    (prim-syscall #"setsockopt" #x69 #x36
      (varargs join-list
        ;; Argument 1: socket
        ;; Argument 2: level
        ;; Argument 3: option name
        ;; Argument 4: option value
        ;; Argument 5: option length
        (movq (r64mi-reg (rcx)) (r64m-reg (r10)))
        (addq (imm64/s32 16) (r64m-reg (r10)))))

    ;; ioctl
    (prim-syscall #"ioctl" #x36 #x10
      (varargs join-list
        ;; Make %rdx point at the actual buffer
        (addq (imm64/s32 16) (r64m-reg (rdx)))))

    ;; Mach calls

    ;; mach_task_self
    (prim-assembly-function/panic #"mach_task_self"
      (varargs join-list
        (movq (imm64/s32 #x100001c) (r64m-reg (rax)))
        (syscall)
        (cmpq (imm64/s32 0) (r64m-reg (rax)))
        (je #"yprim_mach_task_self_panic")
        (ret)))


    ;; mach_thread_self
    (prim-assembly-function/panic #"mach_thread_self"
      (varargs join-list
        (movq (imm64/s32 #x100001b) (r64m-reg (rax)))
        (syscall)
        (cmpq (imm64/s32 0) (r64m-reg (rax)))
        (je #"yprim_mach_thread_self_panic")
        (ret)))


    ;; mach_reply_port
    (prim-assembly-function/panic #"mach_reply_port"
      (varargs join-list
        (movq (imm64/s32 #x100001a) (r64m-reg (rax)))
        (syscall)
        (cmpq (imm64/s32 0) (r64m-reg (rax)))
        (je #"yprim_mach_reply_port_panic")
        (ret)))


    ;; mach_port_mod_refs
    (prim-assembly-function/panic #"mach_port_mod_refs"
      (varargs join-list
        ;; Argument 1: task
        ;; Argument 2: port
        ;; Argument 3: right
        ;; Argument 4: delta
        (movq (r64mi-reg (rcx)) (r64m-reg (r10)))
        (movq (imm64/s32 #x1000013) (r64m-reg (rax)))
        (syscall)
        (cmpq (imm64/s32 0) (r64m-reg (rax)))
        (jne #"yprim_mach_port_mod_refs_panic")
        (ret)))

    ;; mach_msg
    (prim-assembly-function/panic #"mach_msg"
      (varargs join-list
        (movq (r64mi-mem (mem (rax) 0)) (r64m-reg (rax))) ;; Notify Port
        (movq (r64mi-reg (rcx)) (r64m-reg (r10)))

        (addq (imm64/s32 16) (r64m-reg (rdi))) ;; Adjust past buffer's length field
        (pushq (r64mi-reg (rax))) ;; Push back the notify port
        (pushq (imm64/s32 0)) ;; Dummy Return Address
        (movq (imm64/s32 #x100001f) (r64m-reg (rax)))
        (syscall)
        (cmpq (imm64/s32 0) (r64m-reg (rax)))
        (jne #"yprim_mach_msg_panic")
        (addq (imm64/s32 #x10) (r64m-reg (rsp))) ;; 2 pop
        (ret)))


    ;; and
    (prim-assembly-function #"and"
      (varargs join-list
        (andq (r64mi-reg (rdi)) (rsi))
        (movq (r64mi-reg (rsi)) (r64m-reg (rax)))
        (ret)))
    ;; or
    (prim-assembly-function #"or"
      (varargs join-list
        (orq (rdi) (rsi))
        (movq (r64mi-reg (rsi)) (r64m-reg (rax)))
        (ret)))
    ;; not
    (prim-assembly-function #"not"
      (varargs join-list
        (xorq (imm64/s32 1) (rdi))
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (ret)))

    ;; make-array
    (prim-assembly-function #"make_array"
      (varargs join-list
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (imulq/imm* (s32 8) (r64m-reg (rax)) (rax))
        (addq (imm64/s32 8) (r64m-reg (rax)))
        (call #"yprim_heap_allocate")

        (movq (r64mi-reg (rax)) (r64m-reg (rdx)))
        (movq (r64mi-reg (rdi)) (r64m-mem (mem (rax) 0)))
        (movq (r64mi-reg (rdi)) (r64m-reg (rcx)))
        (movq (r64mi-reg (rax)) (r64m-reg (rdi)))
        (addq (imm64/s32 8) (r64m-reg (rdi)))
        (movq (r64mi-reg (rsi)) (r64m-reg (rax)))
        (cld)
        (rep-stosq)
        (movq (r64mi-reg (rdx)) (r64m-reg (rax)))
        (ret)))

    ;; make-bytes
    (prim-assembly-function #"make_bytes"
      (varargs join-list
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (addq (imm64/s32 23) (r64m-reg (rax)))
        (andq (imm64/s32 (- 0 8)) (rax))
        (call #"yprim_heap_allocate")
        ;; Rounded Buffer with tag and length space is in rax
        ;; Write the size
        ;; TODO write the tag
        (movq (r64mi-reg (rdi)) (r64m-mem (mem (rax) 8)))

        ;; Do a zero fill of the buffer space
        (movq (r64mi-reg (rax)) (r64m-reg (rdx)))
        (movq (r64mi-reg (rdi)) (r64m-reg (rcx)))
        (movq (r64mi-reg (rax)) (r64m-reg (rdi)))
        (addq (imm64/s32 16) (r64m-reg (rdi)))
        (movq (imm64/s32 0) (r64m-reg (rax)))
        (cld)
        (rep-stosb)
        (movq (r64mi-reg (rdx)) (r64m-reg (rax)))
        (ret)))

    ;; void
    (prim-assembly-function #"void"
      (varargs join-list
        (movq (imm64/s32 0) (r64m-reg (rax)))
        (ret)))

    ;; s8
    ;; TODO(endobson) add check that it is in the right range
    (prim-assembly-function #"s8"
      (varargs join-list
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (ret)))

    ;; u8
    ;; TODO(endobson) add check that it is in the right range
    (prim-assembly-function #"u8"
      (varargs join-list
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (ret)))

    ;; s32
    ;; TODO(endobson) add check that it is in the right range
    (prim-assembly-function #"s32"
      (varargs join-list
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (ret)))

    ;; u32
    ;; TODO(endobson) add check that it is in the right range
    (prim-assembly-function/panic #"u32"
      (varargs join-list
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (cmpq (imm64/s32 0) (r64m-reg (rdi)))
        (jl #"yprim_u32_panic")
        (ret)))

    ;; u64
    ;; TODO(endobson) add check that it is in the right range
    (prim-assembly-function/panic #"u64"
      (varargs join-list
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (cmpq (imm64/s32 0) (r64m-reg (rdi)))
        (jl #"yprim_u64_panic")
        (ret)))

    ;; u8->s64
    (prim-assembly-function #"u8_s64"
      (varargs join-list
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (ret)))

    ;; s32->s64
    (prim-assembly-function #"s32_s64"
      (varargs join-list
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (ret)))

    ;; u32->s64
    (prim-assembly-function #"u32_s64"
      (varargs join-list
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (ret)))

    ;; u64->s64
    (prim-assembly-function/panic #"u64_s64"
      (varargs join-list
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (cmpq (imm64/s32 0) (r64m-reg (rdi)))
        (jl #"yprim_u64_s64_panic")
        (ret)))


    ;; u32/le-byte#
    ;; s32/le-byte#
    (prim-assembly-function #"quad_le_byte0"
      (varargs join-list
        (movzbq (r8m-reg (dil)) (rax))
        (ret)))
    (prim-assembly-function #"quad_le_byte1"
      (varargs join-list
        (shrq/imm (s8 8) (rdi))
        (movzbq (r8m-reg (dil)) (rax))
        (ret)))
    (prim-assembly-function #"quad_le_byte2"
      (varargs join-list
        (shrq/imm (s8 16) (rdi))
        (movzbq (r8m-reg (dil)) (rax))
        (ret)))
    (prim-assembly-function #"quad_le_byte3"
      (varargs join-list
        (shrq/imm (s8 24) (rdi))
        (movzbq (r8m-reg (dil)) (rax))
        (ret)))

    ;; panic
    (prim-assembly-function #"panic"
      (varargs join-list
        (pushq (r64mi-reg (rbp)))
        (movq (r64mi-reg (rsp)) (r64m-reg (rbp)))
        (addq (imm64/s32 16) (r64m-reg (rdi)))
        (ud2)))

    ;; These are not native functions, but just native subroutines
    ;; They do not follow standard calling conventions
    (tuple2
      (function-fragment
        #"yprim_heap_allocate"
        (varargs list
          (section
            (varargs list
              (basic-block #"yprim_heap_allocate"
                (varargs join-list
                  (xaddq (rax) (r15))
                  (cmpq (r64mi-reg (r15)) (r64m-mem (mem (r14) 0)))
                  (jbe #"yprim_heap_allocate_slow")
                  (ret)))
              (basic-block #"yprim_heap_allocate_slow"
                (varargs join-list
                 ;; Reverse the xadd
                 (subq (r64mi-reg (r15)) (rax))
                 (negq (rax))
                 ;; 'allocate' 2MiB more
                 (movq (r64mi-mem (mem (r14) 0)) (r64m-reg (r15)))
                 (addq (imm64/s32 #x200000) (r64m-mem (mem (r14) 0)))
                 (jmp #"yprim_heap_allocate")))))))
      (address-fragment
        #"yprim_heap_allocate_closure"
        #"yprim_heap_allocate"))

    ;; variant-panic
    (prim-assembly-function #"variant_panic"
      (varargs join-list
        (ud2)))

    ;; fill-stack
    (prim-assembly-function #"fill_stack"
      (varargs join-list
        (pushq (r64mi-reg (rbp)))
        (movq (r64mi-reg (rsp)) (r64m-reg (rbp)))
        (movq (r64mi-reg (rbp)) (r64m-reg (rdx)))
        (call #"yprim_fill_stack_inner")
        (popq (r64m-reg (rbp)))
        (ret)))


    ;; thread_bootstrap
    (prim-assembly-function #"thread_bootstrap"
      (varargs join-list
        (pushq (r64mi-reg (rax)))
        (movq (r64mi-reg (rax)) (r64m-reg (r11)))
        (call/indirect (r64m-mem (mem (rax) 0)))
        ;; Closure is still on the stack
        (ud2)))))

(define (prim-assembly-function
          [name : Bytes]
          [instructions : (JoinList Instruction)]) : (Tuple2 TextFragment ConstFragment)
  (prim-assembly-function* name instructions #f))
(define (prim-assembly-function/panic
          [name : Bytes]
          [instructions : (JoinList Instruction)]) : (Tuple2 TextFragment ConstFragment)
  (prim-assembly-function* name instructions #t))

(define (prim-assembly-function*
          [name : Bytes]
          [instructions : (JoinList Instruction)]
          [panic : Boolean]) : (Tuple2 TextFragment ConstFragment)
  (tuple2
    (function-fragment (bytes-append (varargs list #"yprim_" name))
      (let ([main-block
             (basic-block (bytes-append (varargs list #"yprim_" name))
               instructions)])
      (varargs list
        (section
          (if panic
              (varargs list
                main-block
                (basic-block (bytes-append (varargs list #"yprim_" name #"_panic"))
                  (varargs join-list (ud2))))
              (varargs list main-block))))))
    (address-fragment
      (bytes-append (varargs list #"yprim_" name #"_closure"))
      (bytes-append (varargs list #"yprim_" name)))))
