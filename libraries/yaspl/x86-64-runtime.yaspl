#:module (x86-64-runtime)
#:import {
  (bytes)
  (join-list)
  (list)
  (prim)
  (top-level-name)
  (tuples)
  (yaspl intermediate-to-register)
  (yaspl x86-64-assembly)
}
(export
  (#:types)
  (#:values yaspl-runtime)
  (#:patterns))
(types)

(define (yaspl-runtime [main-function-name : TopLevelName]) : AssemblyFragments
  (match-define (tuple2 text-fragments const-fragments) (unzip (prim-function-fragments)))
  (assembly-fragments
    (append (start-function-fragments main-function-name) text-fragments)
    const-fragments))

(define (start-function-fragments [main-function-name : TopLevelName]) : (List TextFragment)
  (varargs list
    (function-fragment
      #"start"
      (varargs list
        (section
          (varargs list
            (basic-block #"start"
              (varargs join-list
                (jmp #"start_break")))))))

    (function-fragment
      #"start_break"
      (varargs list
        (section
          (varargs list
            (basic-block #"start_break"
              (varargs join-list
                ;; Allocate Heap (Call mmap)
                ;; No fixed address desired
                (movq (imm64/s32 0) (r64m-reg (rdi)))
                ;; We want a large heap but cannot load more than an 32 bits
                ;; currently so do a multiplication
                ;; Currently this is 8 * 1024 * 1MiB = 8GiB
                ;; 2^20 = 1MiB
                (movq (imm64/s32 #x100000) (r64m-reg (rsi)))
                ;; 2^13 = 8k
                (movq (imm64/s32 #x2000) (r64m-reg (rax)))
                (imulq (rax) (rsi))
                ;; 0x1 = PROT_READ
                ;; 0x2 = PROT_WRITE
                ;; 0x4 = PROT_EXEC
                (movq (imm64/s32 #x7) (r64m-reg (rdx)))
                ;; 0x0002 = MAP_SHARED
                ;; 0x1000 = MAP_ANON
                (movq (imm64/s32 #x1002) (r64m-reg (r10)))
                ;; FD = -1 for no FD
                (movq (imm64/s32 (- 0 1)) (r64m-reg (r8)))
                ;; offset which is ignored because of MAP_ANON
                (movq (imm64/s32 0) (r64m-reg (r9)))
                ;; 0xC5 is mmap, plus 0x2000000 because xnu
                (movq (imm64/s32 #x20000C5) (r64m-reg (rax)))
                (syscall)
                (jb #"yprim_start_panic")
                ;; Save heap to %r15 which is our bump pointer
                (movq (r64mi-reg (rax)) (r64m-reg (r15)))
                ;; Save initial value to r14 for setting up the thread control block later.
                (movq (r64mi-reg (rax)) (r64m-reg (r14)))

                ;; Ignore number of args as we want to reuse code for environment.
                (addq (imm64/s32 8) (r64m-reg (rsp)))
                ;; Clear direction for all the scans that will be done when
                (cld)

                ;; Count number of args
                (movq (r64mi-reg (rsp)) (r64m-reg (rdi)))
                (movq (imm64/s32 0) (r64m-reg (rax)))
                ;; Assumption: Strings cannot be longer than 2^64-1
                ;; Loads treat the immediate as a 32 bit signed number, which is sign extended.
                ;; Then repne-scasq treats it as unsigned which means -1 => 2^64-1
                (movq (imm64/s32 (- 0 1)) (r64m-reg (rcx)))
                (repne-scasq)
                (notq (rcx))
                (decq (rcx))
                (movq (r64mi-reg (rcx)) (r64m-reg (r8)))


                (movq (r64mi-reg (r15)) (r64m-reg (r10))) ; r10 is the array of bytes
                (movq (r64mi-reg (r10)) (r64m-reg (r11))) ; r11 is the address of the last bytes put into the array

                (movq (r64mi-reg (r8)) (r64m-mem (mem (r10) 0)))
                (leaq (scaled (r10) (scale-8) (r8) 8) (r15))

                (jmp #"start_copy_args_test")))

            (basic-block #"start_copy_args_test"
              (varargs join-list
                (popq (r64m-reg (r9))) ; r9 is now the current string
                (cmpq (imm64/s32 0) (r64m-reg (r9)))
                (je #"start_copy_args_end")))

            (basic-block #"start_copy_args_body"
              (varargs join-list

                ;; Count string length
                (movq (r64mi-reg (r9)) (r64m-reg (rdi)))
                (movq (imm64/s32 0) (r64m-reg (rax)))
                ;; Assumption: Strings cannot be longer than 2^64-1
                ;; Loads treat the immediate as a 32 bit signed number, which is sign extended.
                ;; Then repne-scasb treats it as unsigned which means -1 => 2^64-1
                (movq (imm64/s32 (- 0 1)) (r64m-reg (rcx)))
                (repne-scasb)
                (notq (rcx))
                (decq (rcx))

                ;; Store where we are copying the bytes to
                (addq (imm64/s32 8) (r64m-reg (r11)))
                (movq (r64mi-reg (r15)) (r64m-mem (mem (r11) 0)))
                ;; Copy the raw bytes from r9 to a fresh tagged bytes object
                ;; TODO Write the tag
                (addq (imm64/s32 8) (r64m-reg (r15)))
                ;; Write the size
                (movq (r64mi-reg (rcx)) (r64m-mem (mem (r15) 0)))
                (addq (imm64/s32 8) (r64m-reg (r15)))
                (movq (r64mi-reg (r9)) (r64m-reg (rsi)))
                (movq (r64mi-reg (r15)) (r64m-reg (rdi)))
                (rep-movsb)
                (movq (r64mi-reg (rdi)) (r64m-reg (r15)))
                (addq (imm64/s32 7) (r64m-reg (r15)))
                (andq (imm64/s32 (- 0 8)) (r15))
                (jmp #"start_copy_args_test")))

            (basic-block #"start_copy_args_end"
              (varargs join-list

                ;; Count number of env
                (movq (r64mi-reg (rsp)) (r64m-reg (rdi)))
                (movq (imm64/s32 0) (r64m-reg (rax)))
                ;; Assumption: Strings cannot be longer than 2^64-1
                ;; Loads treat the immediate as a 32 bit signed number, which is sign extended.
                ;; Then repne-scasq treats it as unsigned which means -1 => 2^64-1
                (movq (imm64/s32 (- 0 1)) (r64m-reg (rcx)))
                (repne-scasq)
                (notq (rcx))
                (decq (rcx))
                (movq (r64mi-reg (rcx)) (r64m-reg (r8)))

                (movq (r64mi-reg (r15)) (r64m-reg (r13))) ; r13 is the array of bytes
                (movq (r64mi-reg (r13)) (r64m-reg (r11))) ; r11 is the address of the last bytes put into the array

                (movq (r64mi-reg (r8)) (r64m-mem (mem (r13) 0)))
                (leaq (scaled (r13) (scale-8) (r8) 8) (r15))

                (jmp #"start_copy_env_test")))

            (basic-block #"start_copy_env_test"
              (varargs join-list
                (popq (r64m-reg (r9))) ; r9 is now the current string
                (cmpq (imm64/s32 0) (r64m-reg (r9)))
                (je #"start_copy_env_end")))

            (basic-block #"start_copy_env_body"
              (varargs join-list

                ;; Count string length
                (movq (r64mi-reg (r9)) (r64m-reg (rdi)))
                (movq (imm64/s32 0) (r64m-reg (rax)))
                ;; Assumption: Strings cannot be longer than 2^64-1
                ;; Loads treat the immediate as a 32 bit signed number, which is sign extended.
                ;; Then repne-scasb treats it as unsigned which means -1 => 2^64-1
                (movq (imm64/s32 (- 0 1)) (r64m-reg (rcx)))
                (repne-scasb)
                (notq (rcx))
                (decq (rcx))

                ;; Copy bytes
                (addq (imm64/s32 8) (r64m-reg (r11)))
                (movq (r64mi-reg (r15)) (r64m-mem (mem (r11) 0)))
                ;; TODO copy tag bytes
                (addq (imm64/s32 8) (r64m-reg (r15)))
                (movq (r64mi-reg (rcx)) (r64m-mem (mem (r15) 0)))
                (addq (imm64/s32 8) (r64m-reg (r15)))
                (movq (r64mi-reg (r9)) (r64m-reg (rsi)))
                (movq (r64mi-reg (r15)) (r64m-reg (rdi)))
                (rep-movsb)
                (movq (r64mi-reg (rdi)) (r64m-reg (r15)))
                (addq (imm64/s32 7) (r64m-reg (r15)))
                (andq (imm64/s32 (- 0 8)) (r15))
                (jmp #"start_copy_env_test")))


            (basic-block #"start_copy_env_end"
              (varargs join-list
                (jmp #"start_call_main")))


            ;; Call main and then exit

            (basic-block #"yprim_start_panic"
              (varargs join-list
                (ud2)))))))

    (function-fragment
      #"start_call_main"
      (varargs list
        (section
          (varargs list
            (basic-block #"start_call_main"
              (varargs join-list
                ;; Set up the thread control block
                (subq (imm64/s32 #x08) (rsp))
                ;; Make our initial allocation look like 2 Mebibytes.
                (addq (imm64/s32 #x200000) (r64m-reg (r14)))
                (movq (r64mi-reg (r14)) (r64m-mem (mem (rsp) 0)))
                (movq (r64mi-reg (rsp)) (r64m-reg (r14)))


                ;; Set up initial base pointer
                (movq (imm64/s32 0) (r64m-reg (rbp)))
                (movq (r64mi-reg (r10)) (r64m-reg (rdi))) ;; Arguments
                (movq (imm64/s32 0) (r64m-reg (rsi)))
                (movq (imm64/s32 1) (r64m-reg (rdx)))
                (movq (imm64/s32 2) (r64m-reg (rcx)))
                (movq (r64mi-reg (r13)) (r64m-reg (r8))) ;; Environment
                (leaq/rip-rel (mangle-top-level-name main-function-name) (r11))
                (call/indirect (r64m-mem (mem (r11) 0)))
                ;; Closure is still on the stack
                (movq (r64mi-reg (rax)) (r64m-reg (rdi)))
                (movq (imm64/s32 #x2000001) (r64m-reg (rax)))
                (syscall)))))))))

(define (prim-function-fragments) : (List (Tuple2 TextFragment ConstFragment))
  (varargs list
    ;; write-bytes
    (prim-assembly-function/panic #"write_bytes"
      (varargs list
        ;; Swap %rdi and %rsi
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (movq (r64mi-reg (rsi)) (r64m-reg (rdi)))
        (movq (r64mi-reg (rax)) (r64m-reg (rsi)))

        ;; %rdi is now the file descriptor
        ;; Make %rsi the start of the buffer
        (leaq (scaled (rsi) (scale-1) (rdx) 16) (rsi))
        ;; Make %rdx the length to write
        (subq (r64mi-reg (rdx)) (rcx))
        (movq (r64mi-reg (rcx)) (r64m-reg (rdx)))
        (movq (imm64/s32 #x2000004) (r64m-reg (rax)))
        (syscall)
        (jb #"yprim_write_bytes_panic")
        (ret)))

    ;; read-bytes
    (prim-assembly-function/panic #"read_bytes"
      (varargs list
        ;; Swap %rdi and %rsi
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (movq (r64mi-reg (rsi)) (r64m-reg (rdi)))
        (movq (r64mi-reg (rax)) (r64m-reg (rsi)))

        ;; %rdi is the file descriptor
        ;; Make %rsi the start of the buffer
        (leaq (scaled (rsi) (scale-1) (rdx) 16) (rsi))
        ;; Make %rdx the length to read
        (subq (r64mi-reg (rdx)) (rcx))
        (movq (r64mi-reg (rcx)) (r64m-reg (rdx)))
        (movq (imm64/s32 #x2000003) (r64m-reg (rax)))
        (syscall)
        (jb #"yprim_read_bytes_panic")
        (ret)))

    ;; open-input-file
    (prim-assembly-function/panic #"open_input_file"
      (varargs list
        ;; Make %rdi point at start of null terminated path
        (addq (imm64/s32 16) (r64m-reg (rdi)))
        (movq (imm64/s32 0) (r64m-reg (rsi))) ;; 0 is read only
        (movq (imm64/s32 #x2000005) (r64m-reg (rax)))
        (syscall)
        (jb #"yprim_open_input_file_panic")
        (ret)))

    ;; open-output-file
    (prim-assembly-function/panic #"open_output_file"
      (varargs list
        ;; Make %rdi point at start of null terminated path
        (addq (imm64/s32 16) (r64m-reg (rdi)))
        (movq (imm64/s32 #x0a01) (r64m-reg (rsi))) ;; 0x01 is write only, 0x0a00 is exclusive create
        (movq (imm64/s32 504) (r64m-reg (rdx))) ;; 770 for mode
        (movq (imm64/s32 #x2000005) (r64m-reg (rax)))
        (syscall)
        (jb #"yprim_open_output_file_panic")
        (ret)))

    ;; close-output-port
    ;; close-input-port
    (prim-assembly-function/panic #"close_port"
      (varargs list
        (movq (imm64/s32 #x2000006) (r64m-reg (rax)))
        (syscall)
        (jb #"yprim_close_port_panic")
        (ret)))

    ;; delete-file
    (prim-assembly-function/panic #"delete_file"
      (varargs list
        ;; Make %rdi point at start of null terminated path
        (addq (imm64/s32 16) (r64m-reg (rdi)))
        (movq (imm64/s32 #x200000a) (r64m-reg (rax)))
        (syscall)
        (jb #"yprim_delete_file_panic")
        (ret)))

    ;; make-directory
    (prim-assembly-function/panic #"make_directory"
      (varargs list
        ;; Make %rdi point at start of null terminated path
        (addq (imm64/s32 16) (r64m-reg (rdi)))
        (movq (imm64/s32 504) (r64m-reg (rsi))) ;; 770 for mode
        (movq (imm64/s32 #x2000088) (r64m-reg (rax)))
        (syscall)
        (jb #"yprim_delete_file_panic")
        (ret)))


    ;; set-file-or-directory-permissions
    (prim-assembly-function/panic #"set_file_or_directory_permissions"
      (varargs list
        ;; Make %rdi point at start of null terminated path
        (addq (imm64/s32 16) (r64m-reg (rdi)))
        ;; %rsi is already the permissions
        (movq (imm64/s32 #x200000f) (r64m-reg (rax)))
        (syscall)
        (jb #"yprim_set_file_or_directory_permissions_panic")
        (ret)))


    ;; socket
    (prim-assembly-function/panic #"socket"
      (varargs list
        ;; Argument 1: domain
        ;; Argument 2: type
        ;; Argument 3: protocol
        (movq (imm64/s32 #x2000061) (r64m-reg (rax)))
        (syscall)
        (jb #"yprim_socket_panic")
        (ret)))

    ;; bind
    (prim-assembly-function/panic #"bind"
      (varargs list
        ;; Argument 1: socket
        ;; Argument 2: sockaddr
        ;; Argument 3: length
        (addq (imm64/s32 16) (r64m-reg (rsi)))
        (movq (imm64/s32 #x2000068) (r64m-reg (rax)))
        (syscall)
        (jb #"yprim_bind_panic")
        (ret)))

    ;; sendto
    (prim-assembly-function/panic #"sendto"
      (varargs list
        ;; Argument 1: socket
        ;; Argument 2: buffer
        ;; Argument 3: buffer-length
        ;; Argument 4: flags
        ;; Argument 5: sockaddr
        ;; Argument 6: sockaddr-length
        (addq (imm64/s32 16) (r64m-reg (rsi)))
        (addq (imm64/s32 16) (r64m-reg (r8)))
        (movq (r64mi-reg (rcx)) (r64m-reg (r10)))
        (movq (imm64/s32 #x2000085) (r64m-reg (rax)))
        (syscall)
        (jb #"yprim_sendto_panic")
        (ret)))

    ;; recvfrom
    (prim-assembly-function/panic #"recvfrom"
      (varargs list
        ;; Argument 1: socket
        ;; Argument 2: buffer
        ;; Argument 3: buffer-length
        ;; Argument 4: flags
        ;; Argument 5: sockaddr
        ;; Argument 6: sockaddr-length
        (addq (imm64/s32 16) (r64m-reg (rsi)))
        (addq (imm64/s32 16) (r64m-reg (r8)))
        (addq (imm64/s32 16) (r64m-reg (r9)))
        (movq (r64mi-reg (rcx)) (r64m-reg (r10)))
        (movq (imm64/s32 #x200001d) (r64m-reg (rax)))
        (syscall)
        (jb #"yprim_recvfrom_panic")
        (ret)))

    ;; connect
    (prim-assembly-function/panic #"connect"
      (varargs list
        ;; Argument 1: socket
        ;; Argument 2: sockaddr
        ;; Argument 3: sockaddr-length
        (addq (imm64/s32 16) (r64m-reg (rsi)))
        (movq (imm64/s32 #x2000062) (r64m-reg (rax)))
        (syscall)
        (jb #"yprim_connect_panic")
        (ret)))

    ;; shutdown
    (prim-assembly-function/panic #"shutdown"
      (varargs list
        ;; Argument 1: socket
        ;; Argument 2: how
        (movq (imm64/s32 #x2000086) (r64m-reg (rax)))
        (syscall)
        (jb #"yprim_shutdown_panic")
        (ret)))


    ;; listen
    (prim-assembly-function/panic #"listen"
      (varargs list
        ;; Argument 1: socket
        ;; Argument 2: backlog
        (movq (imm64/s32 #x200006A) (r64m-reg (rax)))
        (syscall)
        (jb #"yprim_listen_panic")
        (ret)))

    ;; accept
    (prim-assembly-function/panic #"accept"
      (varargs list
        ;; Argument 1: socket
        ;; Argument 2: sockaddr
        ;; Argument 3: sockaddr-length
        (addq (imm64/s32 16) (r64m-reg (rsi)))
        (addq (imm64/s32 16) (r64m-reg (rdx)))
        (movq (imm64/s32 #x200001E) (r64m-reg (rax)))
        (syscall)
        (jb #"yprim_accept_panic")
        (ret)))


    ;; setsockopt
    (prim-assembly-function/panic #"setsockopt"
      (varargs list
        ;; Argument 1: socket
        ;; Argument 2: level
        ;; Argument 3: option name
        ;; Argument 4: option value
        ;; Argument 5: option length
        (movq (r64mi-reg (rcx)) (r64m-reg (r10)))
        (addq (imm64/s32 16) (r64m-reg (r10)))
        (movq (imm64/s32 #x2000069) (r64m-reg (rax)))
        (syscall)
        (jb #"yprim_setsockopt_panic")
        (ret)))


    ;; mach_task_self
    (prim-assembly-function/panic #"mach_task_self"
      (varargs list
        (movq (imm64/s32 #x100001c) (r64m-reg (rax)))
        (syscall)
        (cmpq (imm64/s32 0) (r64m-reg (rax)))
        (je #"yprim_mach_task_self_panic")
        (ret)))


    ;; mach_thread_self
    (prim-assembly-function/panic #"mach_thread_self"
      (varargs list
        (movq (imm64/s32 #x100001b) (r64m-reg (rax)))
        (syscall)
        (cmpq (imm64/s32 0) (r64m-reg (rax)))
        (je #"yprim_mach_thread_self_panic")
        (ret)))


    ;; mach_reply_port
    (prim-assembly-function/panic #"mach_reply_port"
      (varargs list
        (movq (imm64/s32 #x100001a) (r64m-reg (rax)))
        (syscall)
        (cmpq (imm64/s32 0) (r64m-reg (rax)))
        (je #"yprim_mach_reply_port_panic")
        (ret)))


    ;; mach_port_mod_refs
    (prim-assembly-function/panic #"mach_port_mod_refs"
      (varargs list
        ;; Argument 1: task
        ;; Argument 2: port
        ;; Argument 3: right
        ;; Argument 4: delta
        (movq (r64mi-reg (rcx)) (r64m-reg (r10)))
        (movq (imm64/s32 #x1000013) (r64m-reg (rax)))
        (syscall)
        (cmpq (imm64/s32 0) (r64m-reg (rax)))
        (jne #"yprim_mach_port_mod_refs_panic")
        (ret)))

    ;; mach_msg
    (prim-assembly-function/panic #"mach_msg"
      (varargs list
        (movq (r64mi-mem (mem (rax) 0)) (r64m-reg (rax))) ;; Notify Port
        (movq (r64mi-reg (rcx)) (r64m-reg (r10)))

        (addq (imm64/s32 16) (r64m-reg (rdi))) ;; Adjust past buffer's length field
        (pushq (r64mi-reg (rax))) ;; Push back the notify port
        (pushq (imm64/s32 0)) ;; Dummy Return Address
        (movq (imm64/s32 #x100001f) (r64m-reg (rax)))
        (syscall)
        (cmpq (imm64/s32 0) (r64m-reg (rax)))
        (jne #"yprim_mach_msg_panic")
        (addq (imm64/s32 #x10) (r64m-reg (rsp))) ;; 2 pop
        (ret)))


    ;; and
    (prim-assembly-function #"and"
      (varargs list
        (andq (r64mi-reg (rdi)) (rsi))
        (movq (r64mi-reg (rsi)) (r64m-reg (rax)))
        (ret)))
    ;; or
    (prim-assembly-function #"or"
      (varargs list
        (orq (rdi) (rsi))
        (movq (r64mi-reg (rsi)) (r64m-reg (rax)))
        (ret)))
    ;; not
    (prim-assembly-function #"not"
      (varargs list
        (xorq (imm64/s32 1) (rdi))
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (ret)))

    ;; make-array
    (prim-assembly-function #"make_array"
      (varargs list
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (imulq/imm* (s32 8) (r64m-reg (rax)) (rax))
        (addq (imm64/s32 8) (r64m-reg (rax)))
        (call #"yprim_heap_allocate")

        (movq (r64mi-reg (rax)) (r64m-reg (rdx)))
        (movq (r64mi-reg (rdi)) (r64m-mem (mem (rax) 0)))
        (movq (r64mi-reg (rdi)) (r64m-reg (rcx)))
        (movq (r64mi-reg (rax)) (r64m-reg (rdi)))
        (addq (imm64/s32 8) (r64m-reg (rdi)))
        (movq (r64mi-reg (rsi)) (r64m-reg (rax)))
        (cld)
        (rep-stosq)
        (movq (r64mi-reg (rdx)) (r64m-reg (rax)))
        (ret)))

    ;; make-bytes
    (prim-assembly-function #"make_bytes"
      (varargs list
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (addq (imm64/s32 23) (r64m-reg (rax)))
        (andq (imm64/s32 (- 0 8)) (rax))
        (call #"yprim_heap_allocate")
        ;; Rounded Buffer with tag and length space is in rax
        ;; Write the size
        ;; TODO write the tag
        (movq (r64mi-reg (rdi)) (r64m-mem (mem (rax) 8)))

        ;; Do a zero fill of the buffer space
        (movq (r64mi-reg (rax)) (r64m-reg (rdx)))
        (movq (r64mi-reg (rdi)) (r64m-reg (rcx)))
        (movq (r64mi-reg (rax)) (r64m-reg (rdi)))
        (addq (imm64/s32 16) (r64m-reg (rdi)))
        (movq (imm64/s32 0) (r64m-reg (rax)))
        (cld)
        (rep-stosb)
        (movq (r64mi-reg (rdx)) (r64m-reg (rax)))
        (ret)))

    ;; void
    (prim-assembly-function #"void"
      (varargs list
        (movq (imm64/s32 0) (r64m-reg (rax)))
        (ret)))

    ;; s8
    ;; TODO(endobson) add check that it is in the right range
    (prim-assembly-function #"s8"
      (varargs list
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (ret)))

    ;; u8
    ;; TODO(endobson) add check that it is in the right range
    (prim-assembly-function #"u8"
      (varargs list
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (ret)))

    ;; s32
    ;; TODO(endobson) add check that it is in the right range
    (prim-assembly-function #"s32"
      (varargs list
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (ret)))

    ;; u32
    ;; TODO(endobson) add check that it is in the right range
    (prim-assembly-function/panic #"u32"
      (varargs list
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (cmpq (imm64/s32 0) (r64m-reg (rdi)))
        (jl #"yprim_u32_panic")
        (ret)))

    ;; u64
    ;; TODO(endobson) add check that it is in the right range
    (prim-assembly-function/panic #"u64"
      (varargs list
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (cmpq (imm64/s32 0) (r64m-reg (rdi)))
        (jl #"yprim_u64_panic")
        (ret)))

    ;; u8->s64
    (prim-assembly-function #"u8_s64"
      (varargs list
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (ret)))

    ;; s32->s64
    (prim-assembly-function #"s32_s64"
      (varargs list
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (ret)))

    ;; u32->s64
    (prim-assembly-function #"u32_s64"
      (varargs list
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (ret)))

    ;; u64->s64
    (prim-assembly-function/panic #"u64_s64"
      (varargs list
        (movq (r64mi-reg (rdi)) (r64m-reg (rax)))
        (cmpq (imm64/s32 0) (r64m-reg (rdi)))
        (jl #"yprim_u64_s64_panic")
        (ret)))


    ;; u32/le-byte#
    ;; s32/le-byte#
    (prim-assembly-function #"quad_le_byte0"
      (varargs list
        (movzbq (r8m-reg (dil)) (rax))
        (ret)))
    (prim-assembly-function #"quad_le_byte1"
      (varargs list
        (shrq/imm (s8 8) (rdi))
        (movzbq (r8m-reg (dil)) (rax))
        (ret)))
    (prim-assembly-function #"quad_le_byte2"
      (varargs list
        (shrq/imm (s8 16) (rdi))
        (movzbq (r8m-reg (dil)) (rax))
        (ret)))
    (prim-assembly-function #"quad_le_byte3"
      (varargs list
        (shrq/imm (s8 24) (rdi))
        (movzbq (r8m-reg (dil)) (rax))
        (ret)))

    (prim-assembly-function/panic #"ioctl"
      (varargs list
        ;; Make %rdx point at the actual buffer
        (addq (imm64/s32 16) (r64m-reg (rdx)))
        (movq (imm64/s32 #x2000036) (r64m-reg (rax)))
        (syscall)
        (jb #"yprim_ioctl_panic")
        (ret)))

    ;; panic
    (prim-assembly-function #"panic"
      (varargs list
        (pushq (r64mi-reg (rbp)))
        (movq (r64mi-reg (rsp)) (r64m-reg (rbp)))
        (addq (imm64/s32 16) (r64m-reg (rdi)))
        (ud2)))

    ;; These are not native functions, but just native subroutines
    ;; They do not follow standard calling conventions
    (tuple2
      (function-fragment
        #"yprim_heap_allocate"
        (varargs list
          (section
            (varargs list
              (basic-block #"yprim_heap_allocate"
                (varargs join-list
                  (xaddq (rax) (r15))
                  (cmpq (r64mi-reg (r15)) (r64m-mem (mem (r14) 0)))
                  (jbe #"yprim_heap_allocate_slow")
                  (ret)))
              (basic-block #"yprim_heap_allocate_slow"
                (varargs join-list
                 ;; Reverse the xadd
                 (subq (r64mi-reg (r15)) (rax))
                 (negq (rax))
                 ;; 'allocate' 2MiB more
                 (movq (r64mi-mem (mem (r14) 0)) (r64m-reg (r15)))
                 (addq (imm64/s32 #x200000) (r64m-mem (mem (r14) 0)))
                 (jmp #"yprim_heap_allocate")))))))
      (address-fragment
        #"yprim_heap_allocate_closure"
        #"yprim_heap_allocate"))

    ;; variant-panic
    (prim-assembly-function #"variant_panic"
      (varargs list
        (ud2)))

    ;; fill-stack
    (prim-assembly-function #"fill_stack"
      (varargs list
        (pushq (r64mi-reg (rbp)))
        (movq (r64mi-reg (rsp)) (r64m-reg (rbp)))
        (movq (r64mi-reg (rbp)) (r64m-reg (rdx)))
        (call #"yprim_fill_stack_inner")
        (popq (r64m-reg (rbp)))
        (ret)))


    ;; thread_bootstrap
    (prim-assembly-function #"thread_bootstrap"
      (varargs list
        (pushq (r64mi-reg (rax)))
        (movq (r64mi-reg (rax)) (r64m-reg (r11)))
        (call/indirect (r64m-mem (mem (rax) 0)))
        ;; Closure is still on the stack
        (ud2)))))

(define (prim-assembly-function
          [name : Bytes]
          [instructions : (List Instruction)]) : (Tuple2 TextFragment ConstFragment)
  (prim-assembly-function* name instructions #f))
(define (prim-assembly-function/panic
          [name : Bytes]
          [instructions : (List Instruction)]) : (Tuple2 TextFragment ConstFragment)
  (prim-assembly-function* name instructions #t))

(define (prim-assembly-function*
          [name : Bytes]
          [instructions : (List Instruction)]
          [panic : Boolean]) : (Tuple2 TextFragment ConstFragment)
  (tuple2
    (function-fragment (bytes-append (varargs list #"yprim_" name))
      (let ([main-block
             (basic-block (bytes-append (varargs list #"yprim_" name))
               (list->jl instructions))])
      (varargs list
        (section
          (if panic
              (varargs list
                main-block
                (basic-block (bytes-append (varargs list #"yprim_" name #"_panic"))
                  (varargs join-list (ud2))))
              (varargs list main-block))))))
    (address-fragment
      (bytes-append (varargs list #"yprim_" name #"_closure"))
      (bytes-append (varargs list #"yprim_" name)))))
