#:module (source-language-test)
#:import {
  (bytes)
  (data source-location)
  (either)
  (list)
  (maybe)
  (prim)
  (sexp-parser)
  (source-language)
  (yunit)
}
(export)
(types)

(define (check-expr-parses [expr : Bytes]) : (-> (Maybe FailedAssertion))
  (lambda ()
    (case (parse-single-sexp (sourced-bytes (unnamed-source) expr))
      [(left v) (just (failure v))]
      [(right sexp)
       (case (parse-expression #f sexp)
         [(left v) (just (failure v))]
         [(right _)
          (nothing)])])))

(define (check-expr-error [expr : Bytes] [substr : Bytes])
  : (-> (Maybe FailedAssertion))
  (lambda ()
    (case (parse-single-sexp (sourced-bytes (unnamed-source) expr))
      [(left v) (just (failure v))]
      [(right sexp)
       (case (parse-expression #f sexp)
         [(right _) (just (failure #"Expression succesfully parsed (instead of producing an error"))]
         [(left v)
          (if (starts-with? v substr)
              (nothing)
              (just (failure v)))])])))



(define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Int
  (yunit/main stderr
    (varargs list
      (new-test-case #"let: simple-parse"
        (check-expr-parses #"(let ([x 1]) x)"))
      (new-test-case #"let: 0 parts"
        (check-expr-error #"(let)" #"Let: not enough subparts"))
      (new-test-case #"let: 1 part"
        (check-expr-error #"(let ([x 1]))" #"Let: not enough subparts"))
      (new-test-case #"let: 3 part"
        (check-expr-error #"(let ([x 1]) x x)" #"Let: too many subparts"))
      (new-test-case #"let: 3 part"
        (check-expr-error #"(let x x)" #"Let bindings: couldn't be parsed"))
      (new-test-case #"let: 3 part"
        (check-expr-error #"(let (x) x)" #"Let bindings: couldn't be parsed"))
    )))
