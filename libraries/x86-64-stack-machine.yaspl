(module x86-64-stack-machine
  (import
    (prim
      #:types (Bytes Byte InputPort OutputPort Void Array Boolean)
      #:values (bytes-length bytes-ref * + - = <= >= panic void > <
                bitwise-and bitwise-ior logical-shift-left or)
      #:patterns ())
    (prim-implementation prim-implementation)
    (list
      #:types (List)
      #:values (cons-head append list map empty cons)
      #:patterns (empty cons))
    (tuples
      #:types (Tuple2)
      #:values (tuple2)
      #:patterns (tuple2))
    (maybe
      #:types (Maybe)
      #:values (just nothing)
      #:patterns (just nothing))
    (numbers integer->decimal-bytes integer->hex-bytes)
    (io read-all-bytes write-all-bytes newline write-line)
    (join-list
      #:types (JoinList)
      #:values (jl->list single-jl join-list empty-jl cons-jl append-jl append-jl* map-jl list->jl)
      #:patterns ())
    (sexp-parser
      #:types (Sexp)
      #:values (parse-sexp)
      #:patterns ())
    (bytes bytes-copy! subbytes bytes-append bytes bytes-set!/octo-le bytes-set!/quad-le)
    (stack-machine
      #:types (StackFunction StackBasicBlock StackCmd StackTerminal VariantCases TopLevelObject)
      #:values (stack-function-blocks stack-basic-block-cmds)
      #:patterns (stack-function stack-basic-block return
                  swap-cmd dup-cmd pop-cmd num-lit-cmd create-closure-cmd fun-call-cmd known-fun-call-cmd
                  boolean-lit-cmd uncond-jmp boolean-jmp alloc-variant-cmd
                  variant-ref-cmd variant-switch bytes-cmp-cmd load-global-cmd
                  no-catch-all-case catch-all-case variant-case
                  bin-math-cmd bin-add-op bin-sub-op bin-mult-op bin-quotient-op bin-remainder-op
                  bin-bitwise-and-op bin-bitwise-ior-op
                  bin-logical-shift-left-op bin-logical-shift-right-op
                  bin-logic-math-cmd less-than-op less-than-or-equal-op equal-op
                  greater-than-or-equal-op greater-than-op
                  make-array-cmd array-length-cmd array-ref-cmd array-set!-cmd
                  make-array-from-stack-cmd dup-free-var-cmd function-tlo trivial-closure-tlo
                  bytes-tlo))
    (either
      #:types (Either)
      #:values ()
      #:patterns (left right)))
  (export
    #:types ()
    #:values (compile-stack-machine write-fragments convert-objects fragment->commands assembly-commands->bytes
              write-start)
    #:patterns ())
  (types


    (define-type AssemblyFragment
      (function-fragment [name Bytes] [blocks (List BasicBlock)])
      (address-fragment [name Bytes] [value Bytes])
      (bytes-fragment [name Bytes] [value Bytes]))
    (define-type BasicBlock
      (basic-block [name Bytes] [instructions (JoinList Instruction)]))


    (define-type MCJumpType
      (mcj-call)
      (mcj-jb)
      (mcj-je)
      (mcj-jmp)
      (mcj-jne)
      (mcj-jnz))

    (define-type MCCommand
      (mc-bytes [bytes Bytes])
      (mc-jump [type MCJumpType] [symbol Bytes])
      (mc-ref [symbol Bytes]))

    (define-type AssemblyCommand
      (directive-cmd [directive AssemblerDirective])
      (instruction-cmd [instruction Instruction]))
    (define-type AssemblerDirective
      (section-directive [segment-name Bytes] [section-name Bytes])
      (global-directive [label Bytes])
      (label-directive [name Bytes])
      (quad-directive/label [label Bytes])
      (quad-directive/integer [value Byte])
      (ascii-directive [value Bytes]))
    (define-type Instruction
      (addq [rmi RegMemImm] [reg Register])
      (andq [reg1 RegMemImm] [reg2 Register])
      (call [label Bytes])
      (call/indirect [reg Register])
      (cld)
      (cmpq [rmi1 RegMemImm] [rmi2 RegMemImm])
      (decq [reg Register])
      (idivq [reg Register])
      (imulq [reg Register])
      (incq [reg Register])
      (jb [label Bytes])
      (je [label Bytes])
      (jmp [label Bytes])
      (jne [label Bytes])
      (jnz [label Bytes])
      (leaq [rmi RegMemImm] [reg Register])
      (leaq/rel [label Bytes] [reg1 Register] [reg2 Register])
      (lahf)
      (movb [rmi1 RegMemImm] [rmi2 RegMemImm])
      (movq [rmi1 RegMemImm] [rmi2 RegMemImm])
      (movzbq [rmi RegMemImm] [r Register])
      (nop)
      (notq [reg Register])
      (orq [reg1 Register] [reg2 Register])
      (popq [rmi RegMemImm])
      (pushq [rmi RegMemImm])
      (rep-movsb)
      (rep-movsq)
      (rep-stosb)
      (rep-stosq)
      (repe-cmpsb)
      (repne-scasb)
      (ret)
      (sete [reg Register])
      (setg [reg Register])
      (setge [reg Register])
      (setl [reg Register])
      (setle [reg Register])
      (shlq [reg Register])
      (shrq [reg Register])
      (std)
      (subq [rmi RegMemImm] [reg Register])
      (syscall)
      (ud2))
    (define-type Register
      ;; 8 Bit registers
      (al)
      (ah)
      (bl)
      (bh)
      (cl)
      (ch)
      (dl)
      (dh)
      (dil)
      (sil)
      (bpl)
      (spl)
      (r8b)
      (r9b)
      (r10b)
      (r11b)
      (r12b)
      (r13b)
      (r14b)
      (r15b)
      ;; 16 bit registers
      (ax)
      (bx)
      (cx)
      (dx)
      (di)
      (si)
      (bp)
      (sp)
      (r8w)
      (r9w)
      (r10w)
      (r11w)
      (r12w)
      (r13w)
      (r14w)
      (r15w)
      ;; 32 bit registers
      (eax)
      (ebx)
      (ecx)
      (edx)
      (edi)
      (esi)
      (ebp)
      (esp)
      (r8d)
      (r9d)
      (r10d)
      (r11d)
      (r12d)
      (r13d)
      (r14d)
      (r15d)
      ;;64 bit registers
      (rax)
      (rbx)
      (rcx)
      (rdx)
      (rdi)
      (rsi)
      (rbp)
      (rsp)
      (r8)
      (r9)
      (r10)
      (r11)
      (r12)
      (r13)
      (r14)
      (r15)
      (rip))
    (define-type RegMemImm
      (rmi-register [r Register])
      (rmi-direct-memory [reg Register])
      (rmi-displaced-memory [reg Register] [offset Byte])
      (rmi-scaled-memory [reg Register] [scale Byte] [index-reg Register] [offset Byte])
      (rmi-immediate [v Byte])))

  (define (compile-stack-machine
            [main-function-name : Bytes]
            [objects : (List TopLevelObject)]
            [output : OutputPort]) : Void
    (begin
      (write-start main-function-name output)
      (write-fragments (convert-objects objects) output)))


  (define (assembly-commands->bytes [cmds : (List AssemblyCommand)]) : (JoinList Bytes)
    (case cmds
      [(empty) (empty-jl)]
      [(cons cmd cmds)
       (append-jl
         (assembly-command->bytes cmd)
         (cons-jl
           #"\n"
           (assembly-commands->bytes cmds)))]))


  (define (assembly-command->bytes [cmd : AssemblyCommand]) : (JoinList Bytes)
    (case cmd
      [(directive-cmd directive) (assembler-directive->bytes directive)]
      [(instruction-cmd instruction) (instruction->assembly-bytes/transition instruction)]))

  (define (assembler-directive->bytes [dir : AssemblerDirective]) : (JoinList Bytes)
    (case dir
      [(section-directive seg sect)
       (varargs join-list #".section " seg #"," sect)]
      [(global-directive label)
       (varargs join-list #".global " label)]
      [(label-directive name)
       (varargs join-list name #":")]
      [(quad-directive/label label)
       (varargs join-list #".quad " label)]
      [(quad-directive/integer value)
       (varargs join-list #".quad " (integer->decimal-bytes value))]
      [(ascii-directive value)
       (varargs append-jl*
         (single-jl #".ascii \"")
         (escape-bytes value 0 0)
         (single-jl #"\""))]))

  (define (escape-bytes [src : Bytes] [start : Byte] [cur : Byte]) : (JoinList Bytes)
    (if (= cur (bytes-length src))
        (single-jl (subbytes src start cur))
        (let ([byte (bytes-ref src cur)])
          (if (= byte 10) ;; newline
              (cons-jl
                (subbytes src start cur)
                (cons-jl #"\\n" (escape-bytes src (+ 1 cur) (+ 1 cur))))
              (if (= byte 13) ;; carriage return
                  (cons-jl
                    (subbytes src start cur)
                    (cons-jl #"\\r" (escape-bytes src (+ 1 cur) (+ 1 cur))))
                  (if (= byte 34) ;; double quote
                      (cons-jl
                        (subbytes src start cur)
                        (cons-jl #"\\\"" (escape-bytes src (+ 1 cur) (+ 1 cur))))
                      (if (= byte 92) ;; backslash
                          (cons-jl
                            (subbytes src start cur)
                            (cons-jl #"\\\\" (escape-bytes src (+ 1 cur) (+ 1 cur))))
                          (escape-bytes src start (+ 1 cur)))))))))


  (define (instruction->assembly-bytes/transition [inst : Instruction]) : (JoinList Bytes)
    (case (instruction->mc-command inst)
      [(just (mc-bytes v)) (mc-bytes->assembly v)]
      [(just (mc-jump (mcj-call) label)) (varargs join-list #"call " label)]
      [(just (mc-jump (mcj-jb) label)) (varargs join-list #"jb " label)]
      [(just (mc-jump (mcj-je) label)) (varargs join-list #"je " label)]
      [(just (mc-jump (mcj-jmp) label)) (varargs join-list #"jmp " label)]
      [(just (mc-jump (mcj-jne) label)) (varargs join-list #"jne " label)]
      [(just (mc-jump (mcj-jnz) label)) (varargs join-list #"jnz " label)]
      [_ (instruction->assembly-bytes inst)]))

  ;; TODO(endobson) Make this not maybe
  (define (instruction->mc-command [inst : Instruction]) : (Maybe MCCommand)
    (case inst
      [(addq (rmi-register reg1) reg2)
       (just (mc-bytes (single-byte-op/RM #x01 #t reg1 reg2)))]
      [(addq (rmi-immediate imm) reg)
       (just (mc-bytes (single-byte-op/IM #x81 0 #t imm reg)))]
      [(addq (rmi-direct-memory reg1) reg2)
       (just (mc-bytes (single-byte-op/MR/mem #x03 #t reg1 reg2)))]
      [(addq (rmi-displaced-memory _ _) _)
       (nothing)]
      [(addq (rmi-scaled-memory _ _ _ _) _)
       (nothing)]
      [(andq (rmi-register reg1) reg2)
       (just (mc-bytes (single-byte-op/RM #x21 #t reg1 reg2)))]
      [(andq (rmi-immediate _) _)
       (panic #"andq of immediate not yet supported")]
      [(andq (rmi-direct-memory _) _)
       (panic #"andq of direct memory not yet supported")]
      [(andq (rmi-displaced-memory _ _) _)
       (panic #"andq of displaced memory not yet supported")]
      [(andq (rmi-scaled-memory _ _ _ _) _)
       (panic #"andq of scaled memory not yet supported")]
      [(call label)
       (just (mc-jump (mcj-call) label))]
      [(call/indirect reg)
       (just (mc-bytes (single-byte-op/M #xFF 2 #f reg)))]
      [(cld) (just (mc-bytes (varargs bytes #xFC)))]
      [(cmpq (rmi-immediate imm) (rmi-register reg))
       (just (mc-bytes (single-byte-op/IM #x81 7 #t imm reg)))]
      [(cmpq (rmi-register reg1) (rmi-register reg2))
       (just (mc-bytes (single-byte-op/MR #x3B #t reg1 reg2)))]
      [(cmpq _ (rmi-immediate imm))
       (panic #"cmpq with immediate second argument is not allowed")]
      [(cmpq _ _)
       (nothing)]
      [(decq reg)
       (just (mc-bytes (single-byte-op/M #xFF 1 #t reg)))]
      [(idivq reg)
       (just (mc-bytes (single-byte-op/M #xF7 7 #t reg)))]
      [(imulq reg)
       (just (mc-bytes (single-byte-op/M #xF7 5 #t reg)))]
      [(incq reg)
       (just (mc-bytes (single-byte-op/M #xFF 0 #t reg)))]
      [(jb label)
       (just (mc-jump (mcj-jb) label))]
      [(je label)
       (just (mc-jump (mcj-je) label))]
      [(jmp label)
       (just (mc-jump (mcj-jmp) label))]
      [(jne label)
       (just (mc-jump (mcj-jne) label))]
      [(jnz label)
       (just (mc-jump (mcj-jnz) label))]
      [(lahf) (just (mc-bytes (varargs bytes #x9F)))]
      [(leaq (rmi-direct-memory _) _)
       (panic #"leaq of direct memory not yet supported")]
      [(leaq (rmi-displaced-memory _ _) _)
       (nothing)]
      [(leaq (rmi-scaled-memory _ _ _ _) _)
       (nothing)]
      [(leaq (rmi-register _) _)
       (panic #"leaq of register is non sensical")]
      [(leaq (rmi-immediate _) _)
       (panic #"leaq of register is non sensical")]
      [(movb (rmi-immediate imm) (rmi-register reg))
       (just (mc-bytes (single-byte-op/IO #xB0 #f imm reg)))]
      [(movb (rmi-register reg) (rmi-scaled-memory _ _ _ _))
       (nothing)]
      [(movb _ (rmi-immediate imm))
       (panic #"movb to immediate is nonsensical")]
      [(movb _ _)
       (panic #"movb variant is not yet supported")]
      [(movq (rmi-immediate imm) (rmi-register reg))
       (just (mc-bytes (single-byte-op/IM #xC7 0 #t imm reg)))]
      [(movq (rmi-register _) (rmi-register _))
       (nothing)]
      [(movq (rmi-register _) (rmi-direct-memory _))
       (panic #"movq to direct memory not yet supported")]
      [(movq (rmi-register _) (rmi-displaced-memory _ _))
       (nothing)]
      [(movq (rmi-register _) (rmi-scaled-memory _ _ _ _))
       (nothing)]
      [(movq (rmi-direct-memory reg1) (rmi-register reg2))
       (just (mc-bytes (single-byte-op/MR/mem #x8B #t reg1 reg2)))]
      [(movq (rmi-displaced-memory _ _) (rmi-register _))
       (nothing)]
      [(movq (rmi-immediate imm) (rmi-displaced-memory _ _))
       (nothing)]
      [(movq _ (rmi-immediate imm))
       (panic #"movq to immediate is nonsensical")]
      [(movq _ _)
       (panic #"movq variant is not yet supported")]
      [(movzbq (rmi-register reg1) reg2)
       (just (mc-bytes (double-byte-op/MR #xB6 #t reg1 reg2)))]
      [(movzbq (rmi-immediate _) _)
       (panic #"movzbq of immediate is not allowed")]
      [(movzbq (rmi-direct-memory _) _)
       (panic #"movzbq of direct memory not yet supported")]
      [(movzbq (rmi-displaced-memory _ _) _)
       (panic #"movzbq of displaced memory not yet supported")]
      [(movzbq (rmi-scaled-memory _ _ _ _) _)
       (nothing)]
      [(nop) (just (mc-bytes (varargs bytes #x90)))]
      [(notq reg)
       (just (mc-bytes (single-byte-op/M #xF7 2 #t reg)))]
      [(orq reg1 reg2)
       (just (mc-bytes (single-byte-op/MR #x0B #t reg1 reg2)))]
      [(popq (rmi-register reg))
       (just (mc-bytes (single-byte-op/O #x58 reg)))]
      [(popq (rmi-direct-memory reg))
       (just (mc-bytes (single-byte-op-mem/M #x8F 0 #f reg)))]
      [(popq (rmi-displaced-memory _ _))
       (nothing)]
      [(popq (rmi-immediate _))
       (panic #"popq of immediate is nonsensical")]
      [(popq (rmi-scaled-memory _ _ _ _))
       (panic #"popq of scaled memory not yet supported")]
      [(pushq (rmi-register reg))
       (just (mc-bytes (single-byte-op/O #x50 reg)))]
      [(pushq (rmi-direct-memory reg))
       (just (mc-bytes (single-byte-op-mem/M #xFF 6 #f reg)))]
      [(pushq (rmi-displaced-memory _ _))
       (nothing)]
      [(pushq (rmi-scaled-memory _ _ _ _))
       (nothing)]
      [(pushq (rmi-immediate _))
       (nothing)]
      [(rep-movsb) (just (mc-bytes (varargs bytes #xF3 #x48 #xA4)))]
      [(rep-movsq) (just (mc-bytes (varargs bytes #xF3 #x48 #xA5)))]
      [(rep-stosb) (just (mc-bytes (varargs bytes #xF3 #x48 #xAA)))]
      [(rep-stosq) (just (mc-bytes (varargs bytes #xF3 #x48 #xAB)))]
      [(repe-cmpsb) (just (mc-bytes (varargs bytes #xF3 #x48 #xA6)))]
      [(repne-scasb) (just (mc-bytes (varargs bytes #xF2 #x48 #xAE)))]
      [(ret) (just (mc-bytes (varargs bytes #xC3)))]
      [(sete reg)
       (just (mc-bytes (double-byte-op/M #x94 0 #f reg)))]
      [(setg reg)
       (just (mc-bytes (double-byte-op/M #x9F 0 #f reg)))]
      [(setge reg)
       (just (mc-bytes (double-byte-op/M #x9D 0 #f reg)))]
      [(setl reg)
       (just (mc-bytes (double-byte-op/M #x9C 0 #f reg)))]
      [(setle reg)
       (just (mc-bytes (double-byte-op/M #x9E 0 #f reg)))]
      [(shlq reg)
       (just (mc-bytes (single-byte-op/M #xD3 4 #t reg)))]
      [(shrq reg)
       (just (mc-bytes (single-byte-op/M #xD3 5 #t reg)))]
      [(std) (just (mc-bytes (varargs bytes #xFD)))]
      [(subq (rmi-register reg1) reg2)
       (just (mc-bytes (single-byte-op/RM #x29 #t reg1 reg2)))]
      [(subq (rmi-immediate imm) reg)
       (just (mc-bytes (single-byte-op/IM #x81 5 #t imm reg)))]
      [(subq (rmi-direct-memory reg1) reg2)
       (just (mc-bytes (single-byte-op/MR/mem #x2B #t reg1 reg2)))]
      [(subq (rmi-displaced-memory _ _) _)
       (panic #"subq of displaced memory not yet supported")]
      [(subq (rmi-scaled-memory _ _ _ _) _)
       (panic #"subq of scaled memory not yet supported")]
      [(syscall) (just (mc-bytes (varargs bytes #x0F #x05)))]
      [(ud2) (just (mc-bytes (varargs bytes #x0F #x0B)))]
      ;; Not yet implemented
      [(leaq/rel _ _ _) (nothing)]))

  (define (single-byte-op/O [opcode : Byte] [reg : Register]) : Bytes
    (let ([reg-val (register->byte reg)])
      (add-maybe-byte
        (rex-byte #f #f #f (>= reg-val 8))
        (varargs bytes
          (bitwise-ior opcode (bitwise-and reg-val #x07))))))

  (define (single-byte-op/IO [opcode : Byte] [rexW : Boolean] [imm : Byte] [reg : Register]) : Bytes
    (let ([reg-val (register->byte reg)])
      (add-maybe-byte
        (rex-byte rexW #f #f (>= reg-val 8))
        (varargs bytes
          (bitwise-ior opcode (bitwise-and reg-val #x07))
          imm))))

  (define (single-byte-op/M [opcode : Byte] [op-ext : Byte] [rexW : Boolean] [reg : Register]) : Bytes
    (let ([rm (register->byte reg)])
      (add-maybe-byte
        (rex-byte rexW #f #f (>= rm 8))
        (varargs bytes
          opcode
          (bitwise-ior (logical-shift-left #x03 6)
             (bitwise-ior (logical-shift-left op-ext 3)
                          (bitwise-and rm #x07)))))))

  (define (single-byte-op-mem/M [opcode : Byte] [op-ext : Byte] [rexW : Boolean] [reg : Register]) : Bytes
    (let ([rm (register->byte reg)])
      (add-maybe-byte
        (rex-byte rexW #f #f (>= rm 8))
        (varargs bytes
          opcode
          (bitwise-ior (logical-shift-left #x00 6)
             (bitwise-ior (logical-shift-left op-ext 3)
                          (bitwise-and rm #x07)))))))

  ;; This currently assumes that the r/m register does not need indirection.
  ;; Assumes the intermediate is 32 bits
  (define (single-byte-op/IM [opcode : Byte] [op-ext : Byte] [rexW : Boolean]
                             [val : Byte] [reg : Register]) : Bytes
    (let ([rm (register->byte reg)])
      (add-maybe-byte
        (rex-byte rexW #f #f (>= rm 8))
        (let ([v (varargs bytes
                   opcode
                   (bitwise-ior (logical-shift-left #x03 6)
                      (bitwise-ior (logical-shift-left (bitwise-and op-ext #x07) 3)
                                   (bitwise-and rm #x07)))
                   0 0 0 0)])
          (begin
            (bytes-set!/quad-le v 2 val)
            v)))))

  ;; This currently assumes that the r/m register does not need indirection.
  (define (single-byte-op/RM [opcode : Byte] [rexW : Boolean] [reg1 : Register] [reg2 : Register]) : Bytes
    (let ([reg (register->byte reg1)])
      (let ([rm (register->byte reg2)])
        (add-maybe-byte
          (rex-byte rexW (>= reg 8) #f (>= rm 8))
          (varargs bytes
            opcode
            (bitwise-ior (logical-shift-left #x03 6)
               (bitwise-ior (logical-shift-left (bitwise-and reg #x07) 3)
                            (bitwise-and rm #x07))))))))

  ;; This currently assumes that the r/m register does not need indirection.
  (define (single-byte-op/MR [opcode : Byte] [rexW : Boolean] [reg1 : Register] [reg2 : Register]) : Bytes
    (let ([rm (register->byte reg1)])
      (let ([reg (register->byte reg2)])
        (add-maybe-byte
          (rex-byte rexW (>= reg 8) #f (>= rm 8))
          (varargs bytes
            opcode
            (bitwise-ior (logical-shift-left #x03 6)
               (bitwise-ior (logical-shift-left (bitwise-and reg #x07) 3)
                            (bitwise-and rm #x07))))))))

  ;; Doesn't support rsp, rbp, r12, r13. This is because the instruction set doesn't support them.
  (define (single-byte-op/MR/mem [opcode : Byte] [rexW : Boolean] [reg1 : Register] [reg2 : Register]) : Bytes
    (let ([rm (register->byte reg1)])
      (let ([reg (register->byte reg2)])
        (add-maybe-byte
          (rex-byte rexW (>= reg 8) #f (>= rm 8))
          (varargs bytes
            opcode
            (bitwise-ior (logical-shift-left #x00 6)
               (bitwise-ior (logical-shift-left (bitwise-and reg #x07) 3)
                            (bitwise-and rm #x07))))))))



  (define (double-byte-op/MR [opcode : Byte] [rexW : Boolean] [reg1 : Register] [reg2 : Register]) : Bytes
    (let ([rm (register->byte reg1)])
      (let ([reg (register->byte reg2)])
        (add-maybe-byte
          (rex-byte rexW (>= reg 8) #f (>= rm 8))
          (varargs bytes
            #x0F
            opcode
            (bitwise-ior (logical-shift-left #x03 6)
               (bitwise-ior (logical-shift-left (bitwise-and reg #x07) 3)
                            (bitwise-and rm #x07))))))))

  (define (double-byte-op/M [opcode : Byte] [op-ext : Byte] [rexW : Boolean] [reg : Register]) : Bytes
    (let ([rm (register->byte reg)])
      (add-maybe-byte
        (rex-byte rexW #f #f (>= rm 8))
        (varargs bytes
          #x0F
          opcode
          (bitwise-ior (logical-shift-left #x03 6)
             (bitwise-ior (logical-shift-left op-ext 3)
                          (bitwise-and rm #x07)))))))

  (define (add-maybe-byte [mv : (Maybe Byte)] [bs : Bytes]) : Bytes
    (case mv
      [(nothing) bs]
      [(just v) (bytes-append (cons (varargs bytes v) (cons bs (empty))))]))


  (define (rex-byte [w : Boolean] [r : Boolean] [x : Boolean] [b : Boolean])
    : (Maybe Byte)
    (let ([ind (lambda ([v : Boolean]) (if v 1 0))])
      (let ([val (bitwise-ior #x40
                   (bitwise-ior (logical-shift-left (ind w) 3)
                     (bitwise-ior (logical-shift-left (ind r) 2)
                       (bitwise-ior (logical-shift-left (ind x) 1)
                                    (ind b)))))])
        (if (= val #x40)
            (nothing)
            (just val)))))

  (define (register->byte [reg : Register]) : Byte
    (case reg
      ;; 8 Bit registers
      [(al) 0]
      [(ah) 4]
      [(bl) 3]
      [(bh) 7]
      [(cl) 1]
      [(ch) 5]
      [(dl) 2]
      [(dh) 6]
      [(dil) 7]
      [(sil) 6]
      [(bpl) 5]
      [(spl) 4]
      [(r8b) 8]
      [(r9b) 9]
      [(r10b) 10]
      [(r11b) 11]
      [(r12b) 12]
      [(r13b) 13]
      [(r14b) 14]
      [(r15b) 15]
      ;; 16 bit registers
      [(ax) 0]
      [(bx) 3]
      [(cx) 1]
      [(dx) 2]
      [(di) 7]
      [(si) 6]
      [(bp) 5]
      [(sp) 4]
      [(r8w) 8]
      [(r9w) 9]
      [(r10w) 10]
      [(r11w) 11]
      [(r12w) 12]
      [(r13w) 13]
      [(r14w) 14]
      [(r15w) 15]
      ;; 32 bit registers
      [(eax) 0]
      [(ebx) 3]
      [(ecx) 1]
      [(edx) 2]
      [(edi) 7]
      [(esi) 6]
      [(ebp) 5]
      [(esp) 4]
      [(r8d) 8]
      [(r9d) 9]
      [(r10d) 10]
      [(r11d) 11]
      [(r12d) 12]
      [(r13d) 13]
      [(r14d) 14]
      [(r15d) 15]
      ;;64 bit registers
      [(rax) 0]
      [(rbx) 3]
      [(rcx) 1]
      [(rdx) 2]
      [(rdi) 7]
      [(rsi) 6]
      [(rbp) 5]
      [(rsp) 4]
      [(r8) 8]
      [(r9) 9]
      [(r10) 10]
      [(r11) 11]
      [(r12) 12]
      [(r13) 13]
      [(r14) 14]
      [(r15) 15]
      [(rip) (panic #"Not valid register")]))



  (define (mc-bytes->assembly [bytes : Bytes]) : (JoinList Bytes)
    (list->jl
      (cons
        #".byte "
        (interleave #", " (extract-hex-bytes bytes 0)))))

  (define (a) (interleave [sep : a] [xs : (List a)]) : (List a)
    (case xs
      [(empty) (empty)]
      [(cons x (empty)) (cons x (empty))]
      [(cons x xs) (cons x (cons sep (interleave sep xs)))]))

  (define (extract-hex-bytes [bytes : Bytes] [offset : Byte]) : (List Bytes)
    (if (= offset (bytes-length bytes))
        (empty)
        (cons
          (bytes-append (cons #"0x" (cons (integer->hex-bytes (bytes-ref bytes offset)) (empty))))
          (extract-hex-bytes bytes (+ 1 offset)))))



  (define (instruction->assembly-bytes [inst : Instruction]) : (JoinList Bytes)
    (case inst
      [(addq rmi reg)
       (varargs join-list
          #"addq "
          (rmi->bytes rmi)
          #", "
          (register->bytes reg))]
      [(andq rmi reg)
       (varargs join-list
          #"andq "
          (rmi->bytes rmi)
          #", "
          (register->bytes reg))]
      [(call label)
       (varargs join-list #"call " label)]
      [(call/indirect reg)
       (varargs join-list #"callq *" (register->bytes reg))]
      [(cld)
       (single-jl #"cld")]
      [(cmpq rmi1 rmi2)
       (varargs join-list
          #"cmpq "
          (rmi->bytes rmi1)
          #", "
          (rmi->bytes rmi2))]
      [(decq reg)
       (varargs join-list #"decq " (register->bytes reg))]
      [(idivq reg)
       (varargs join-list #"idivq " (register->bytes reg))]
      [(imulq reg)
       (varargs join-list #"imulq " (register->bytes reg))]
      [(incq reg)
       (varargs join-list #"incq " (register->bytes reg))]
      [(jb label)
       (varargs join-list #"jb " label)]
      [(je label)
       (varargs join-list #"je " label)]
      [(jmp label)
       (varargs join-list #"jmp " label)]
      [(jne label)
       (varargs join-list #"jne " label)]
      [(jnz label)
       (varargs join-list #"jnz " label)]
      [(lahf)
       (single-jl #"lahf")]
      [(leaq rmi reg)
       (varargs join-list
          #"leaq "
          (rmi->bytes rmi)
          #", "
          (register->bytes reg))]
      [(leaq/rel label reg1 reg2)
       (varargs join-list
          #"leaq "
          label
          #"("
          (register->bytes reg1)
          #"), "
          (register->bytes reg2))]
      [(movb rmi1 rmi2)
       (varargs join-list
          #"movb "
          (rmi->bytes rmi1)
          #", "
          (rmi->bytes rmi2))]
      [(movq rmi1 rmi2)
       (varargs join-list
          #"movq "
          (rmi->bytes rmi1)
          #", "
          (rmi->bytes rmi2))]
      [(movzbq rmi reg)
       (varargs join-list
          #"movzbq "
          (rmi->bytes rmi)
          #", "
          (register->bytes reg))]
      [(nop)
       (single-jl #"nop")]
      [(notq reg)
       (varargs join-list #"notq " (register->bytes reg))]
      [(orq reg1 reg2)
       (varargs join-list
          #"orq "
          (register->bytes reg1)
          #", "
          (register->bytes reg2))]
      [(popq rmi)
       (varargs join-list #"popq " (rmi->bytes rmi))]
      [(pushq rmi)
       (varargs join-list #"pushq " (rmi->bytes rmi))]
      [(rep-stosb)
       (single-jl #"rep stosb")]
      [(rep-stosq)
       (single-jl #"rep stosq")]
      [(rep-movsb)
       (single-jl #"rep movsb")]
      [(rep-movsq)
       (single-jl #"rep movsq")]
      [(repe-cmpsb)
       (single-jl #"repe cmpsb")]
      [(repne-scasb)
       (single-jl #"repne scasb")]
      [(ret)
       (single-jl #"ret")]
      [(sete reg)
       (varargs join-list #"sete " (register->bytes reg))]
      [(setg reg)
       (varargs join-list #"setg " (register->bytes reg))]
      [(setge reg)
       (varargs join-list #"setge " (register->bytes reg))]
      [(setl reg)
       (varargs join-list #"setl " (register->bytes reg))]
      [(setle reg)
       (varargs join-list #"setle " (register->bytes reg))]
      [(shlq reg)
       (varargs join-list #"shlq %cl, " (register->bytes reg))]
      [(shrq reg)
       (varargs join-list #"shrq %cl, " (register->bytes reg))]
      [(std)
       (single-jl #"std")]
      [(subq rmi reg)
       (varargs join-list
          #"subq "
          (rmi->bytes rmi)
          #", "
          (register->bytes reg))]
      [(syscall)
       (single-jl #"syscall")]
      [(ud2)
       (single-jl #"ud2")]))

  (define (register->bytes [reg : Register]) : Bytes
    (case reg
      ;; 8 bit
      [(al) #"%al"]
      [(ah) #"%ah"]
      [(bl) #"%bl"]
      [(bh) #"%bh"]
      [(cl) #"%cl"]
      [(ch) #"%ch"]
      [(dl) #"%dl"]
      [(dh) #"%dh"]
      [(dil) #"%dli"]
      [(sil) #"%sil"]
      [(bpl) #"%bpl"]
      [(spl) #"%spl"]
      [(r8b) #"%r8b"]
      [(r9b) #"%r9b"]
      [(r10b) #"%r10b"]
      [(r11b) #"%r11b"]
      [(r12b) #"%r12b"]
      [(r13b) #"%r13b"]
      [(r14b) #"%r14b"]
      [(r15b) #"%r15b"]
      ;; 16 bit
      [(ax) #"%ax"]
      [(bx) #"%bx"]
      [(cx) #"%cx"]
      [(dx) #"%dx"]
      [(di) #"%di"]
      [(si) #"%si"]
      [(bp) #"%bp"]
      [(sp) #"%sp"]
      [(r8w) #"%r8w"]
      [(r9w) #"%r9w"]
      [(r10w) #"%r10w"]
      [(r11w) #"%r11w"]
      [(r12w) #"%r12w"]
      [(r13w) #"%r13w"]
      [(r14w) #"%r14w"]
      [(r15w) #"%r15w"]
      ;; 32 bit
      [(eax) #"%eax"]
      [(ebx) #"%ebx"]
      [(ecx) #"%ecx"]
      [(edx) #"%edx"]
      [(edi) #"%edi"]
      [(esi) #"%esi"]
      [(ebp) #"%ebp"]
      [(esp) #"%esp"]
      [(r8d) #"%r8d"]
      [(r9d) #"%r9d"]
      [(r10d) #"%r10d"]
      [(r11d) #"%r11d"]
      [(r12d) #"%r12d"]
      [(r13d) #"%r13d"]
      [(r14d) #"%r14d"]
      [(r15d) #"%r15d"]
      ;; 64 bit
      [(rax) #"%rax"]
      [(rbx) #"%rbx"]
      [(rcx) #"%rcx"]
      [(rdx) #"%rdx"]
      [(rdi) #"%rdi"]
      [(rsi) #"%rsi"]
      [(rbp) #"%rbp"]
      [(rsp) #"%rsp"]
      [(r8) #"%r8"]
      [(r9) #"%r9"]
      [(r10) #"%r10"]
      [(r11) #"%r11"]
      [(r12) #"%r12"]
      [(r13) #"%r13"]
      [(r14) #"%r14"]
      [(r15) #"%r15"]
      [(rip) #"%rip"]))

  (define (rmi->bytes [rmi : RegMemImm]) : Bytes
    (case rmi
      [(rmi-register r) (register->bytes r)]
      [(rmi-direct-memory reg)
       (bytes-append (varargs list #"(" (register->bytes reg) #")"))]
      [(rmi-displaced-memory reg offset)
       (bytes-append (varargs list (integer->decimal-bytes offset) #"(" (register->bytes reg) #")"))]
      [(rmi-scaled-memory reg scale index offset)
       (bytes-append
         (varargs list
           (integer->decimal-bytes offset)
           #"("
           (register->bytes reg)
           #", "
           (register->bytes index)
           #", "
           (integer->decimal-bytes scale)
           #")"))]
      [(rmi-immediate v)
       (bytes-append (varargs list #"$" (integer->decimal-bytes v)))]))

  (define (reg [r : Register]) : RegMemImm
    (rmi-register r))
  (define (mem [r : Register] [offset : Byte]) : RegMemImm
    (if (= offset 0)
        (case r
          [(rsp) (rmi-displaced-memory r offset)]
          [(rbp) (rmi-displaced-memory r offset)]
          [(r12) (rmi-displaced-memory r offset)]
          [(r13) (rmi-displaced-memory r offset)]
          [(rip) (rmi-displaced-memory r offset)]
          [_ (rmi-direct-memory r)])
        (rmi-displaced-memory r offset)))
  (define (imm [v : Byte]) : RegMemImm
    (rmi-immediate v))
  (define (scaled [r : Register] [scale : Byte] [index : Register] [offset : Byte]) : RegMemImm
    (rmi-scaled-memory r scale index offset))

  (define (write-assembly-commands [cmds : (List AssemblyCommand)] [output : OutputPort]) : Void
    (write-lines (map assembly-command->bytes cmds) output))

  (define (write-prim-assembly-function
            [name : Bytes]
            [output : OutputPort]
            [instructions : (List Instruction)]) : Void
    (write-assembly-commands
      (append
        (varargs list
          (directive-cmd (section-directive #"__TEXT" #"__const"))
          (directive-cmd (global-directive (bytes-append (varargs list #"prim_" name #"_closure"))))
          (directive-cmd (label-directive (bytes-append (varargs list #"prim_" name #"_closure"))))
          (directive-cmd (quad-directive/label (bytes-append (varargs list #"prim_" name))))
          (directive-cmd (section-directive #"__TEXT" #"__text"))
          (directive-cmd (global-directive (bytes-append (varargs list #"prim_" name))))
          (directive-cmd (label-directive (bytes-append (varargs list #"prim_" name)))))
        (map instruction-cmd instructions))
      output))

  (define (write-prim-assembly-function/panic
            [name : Bytes]
            [output : OutputPort]
            [instructions : (List Instruction)]) : Void
    (begin
      (write-prim-assembly-function name output instructions)
      (write-assembly-commands
        (varargs list
          (directive-cmd (global-directive (bytes-append (varargs list #"prim_" name #"_panic"))))
          (directive-cmd (label-directive (bytes-append (varargs list #"prim_" name #"_panic"))))
          (instruction-cmd (ud2)))
        output)))

  (define (write-block
            [name : Bytes]
            [output : OutputPort]
            [instructions : (List Instruction)]) : Void
    (write-assembly-commands
      (append
        (varargs list
          (directive-cmd (section-directive #"__TEXT" #"__text"))
          (directive-cmd (global-directive name))
          (directive-cmd (label-directive name)))
        (map instruction-cmd instructions))
      output))




  (define (write-start [main-function-name : Bytes] [output : OutputPort]) : Void
    (begin
      (write-assembly-commands
        (varargs list
          (directive-cmd (global-directive #"start")))
        output)

      (write-block #"start" output
        (varargs list
          (nop)))

      (write-block #"start_break" output
        (varargs list
          ;; Allocate Heap (Call mmap)
          ;; No fixed address desired
          (movq (imm 0) (reg (rdi)))
          ;; We want a large heap
          (movq (imm #x20000000) (reg (rsi)))
          ;; 0x1 = PROT_READ
          ;; 0x2 = PROT_WRITE
          ;; 0x4 = PROT_EXEC
          (movq (imm #x7) (reg (rdx)))
          ;; 0x0002 = MAP_SHARED
          ;; 0x1000 = MAP_ANON
          (movq (imm #x1002) (reg (r10)))
          ;; FD = -1 for no flags
          (movq (imm (- 0 1)) (reg (r8)))
          ;; offset which is ignored because of MAP_ANON
          (movq (imm 0) (reg (r9)))
          ;; 0xC5 is mmap, plus 0x2000000 because xnu
          (movq (imm #x20000C5) (reg (rax)))
          (syscall)
          (jb #"prim_start_panic")
          ;; Save heap to %rbp which is our bump pointer
          (movq (reg (rax)) (reg (rbp)))

          ;; Construct args
          (popq (reg (r8))) ; r8 is the number of c strings
          (movq (reg (rbp)) (reg (r10))) ; r10 is the array of bytes
          (movq (imm 0) (reg (r11))) ; r11 is the index of the current string

          (movq (reg (r8)) (mem (rbp) 0))
          (leaq (scaled (rbp) 8 (r8) 8) (rbp))

          (cmpq (reg (r11)) (reg (r8)))
          (je #"start_copy_args_end")
          (cld)))

      (write-block #"start_copy_args_start" output
        (varargs list
          (popq (reg (r9))) ; r9 is now the current string

          ;; Count string length
          (movq (reg (r9)) (reg (rdi)))
          (movb (imm 0) (reg (al)))
          (movq (imm (- 0 1)) (reg (rcx)))
          (repne-scasb)
          (notq (rcx))
          (decq (rcx))

          ;; Copy bytes
          (movq (reg (rbp)) (scaled (r10) 8 (r11) 8))
          (movq (reg (rcx)) (mem (rbp) 0))
          (addq (imm 8) (rbp))
          (movq (reg (r9)) (reg (rsi)))
          (movq (reg (rbp)) (reg (rdi)))
          (rep-movsb)
          (movq (reg (rdi)) (reg (rbp)))
          (incq (r11))
          (cmpq (reg (r11)) (reg (r8)))
          (jne #"start_copy_args_start")))



      ;; Call main and then exit
      (write-block #"start_copy_args_end" output
        (varargs list
          (movq (reg (r10)) (reg (rdi)))
          (pushq (reg (rdi)))
          (movq (imm 0) (reg (rsi)))
          (pushq (reg (rsi)))
          (movq (imm 1) (reg (rdx)))
          (pushq (reg (rdx)))
          (movq (imm 2) (reg (rcx)))
          (pushq (reg (rcx)))
          (pushq (imm 0)) ;; Bogus closure
          (call (bytes-append (varargs list main-function-name #"_code")))
          ;; Closure is still on the stack
          (movq (reg (rax)) (reg (rdi)))
          (movq (imm #x2000001) (reg (rax)))
          (syscall)))
      (write-block #"prim_start_panic" output
        (varargs list
          (ud2)))



      ;; write-bytes
      (write-prim-assembly-function/panic #"write_bytes" output
        (varargs list
          ;; Swap %rdi and %rsi
          (movq (reg (rdi)) (reg (rax)))
          (movq (reg (rsi)) (reg (rdi)))
          (movq (reg (rax)) (reg (rsi)))

          ;; %rdi is now the file descriptor
          ;; Make %rsi the start of the buffer
          (leaq (scaled (rsi) 1 (rdx) 8) (rsi))
          ;; Make %rdx the length to write
          (subq (reg (rdx)) (rcx))
          (movq (reg (rcx)) (reg (rdx)))
          (movq (imm #x2000004) (reg (rax)))
          (syscall)
          (jb #"prim_write_bytes_panic")
          (ret)))

      ;; read-bytes
      (write-prim-assembly-function/panic #"read_bytes" output
        (varargs list
          ;; Swap %rdi and %rsi
          (movq (reg (rdi)) (reg (rax)))
          (movq (reg (rsi)) (reg (rdi)))
          (movq (reg (rax)) (reg (rsi)))

          ;; %rdi is the file descriptor
          ;; Make %rsi the start of the buffer
          (leaq (scaled (rsi) 1 (rdx) 8) (rsi))
          ;; Make %rdx the length to read
          (subq (reg (rdx)) (rcx))
          (movq (reg (rcx)) (reg (rdx)))
          (movq (imm #x2000003) (reg (rax)))
          (syscall)
          (jb #"prim_read_bytes_panic")
          (ret)))

      ;; open-input-file
      (write-prim-assembly-function/panic #"open_input_file" output
        (varargs list
          ;; Make %rdi point at start of null terminated path
          (addq (imm 8) (rdi))
          (movq (imm 0) (reg (rsi))) ;; 0 is read only
          (movq (imm #x2000005) (reg (rax)))
          (syscall)
          (jb #"prim_open_input_file_panic")
          (ret)))

      ;; open-output-file
      (write-prim-assembly-function/panic #"open_output_file" output
        (varargs list
          ;; Make %rdi point at start of null terminated path
          (addq (imm 8) (rdi))
          (movq (imm 513) (reg (rsi))) ;; 1 is write only, 512 is create
          (movq (imm 504) (reg (rdx))) ;; 770 for mode
          (movq (imm #x2000005) (reg (rax)))
          (syscall)
          (jb #"prim_open_output_file_panic")
          (ret)))


      ;; close-output-port
      ;; close-input-port
      (write-prim-assembly-function/panic #"close_port" output
        (varargs list
          (movq (imm #x2000006) (reg (rax)))
          (syscall)
          (jb #"prim_close_port_panic")
          (ret)))

      ;; socket
      (write-prim-assembly-function/panic #"socket" output
        (varargs list
          ;; Argument 1: domain
          ;; Argument 2: type
          ;; Argument 3: protocol
          (movq (imm #x2000061) (reg (rax)))
          (syscall)
          (jb #"prim_socket_panic")
          (ret)))

      ;; bind
      (write-prim-assembly-function/panic #"bind" output
        (varargs list
          ;; Argument 1: socket
          ;; Argument 2: sockaddr
          ;; Argument 3: length
          (addq (imm 8) (rsi))
          (movq (imm #x2000068) (reg (rax)))
          (syscall)
          (jb #"prim_bind_panic")
          (ret)))

      ;; sendto
      (write-prim-assembly-function/panic #"sendto" output
        (varargs list
          ;; Argument 1: socket
          ;; Argument 2: buffer
          ;; Argument 3: buffer-length
          ;; Argument 4: flags
          ;; Argument 5: sockaddr
          ;; Argument 6: sockaddr-length
          (addq (imm 8) (rsi))
          (addq (imm 8) (r8))
          (movq (reg (rcx)) (reg (r10)))
          (movq (imm #x2000085) (reg (rax)))
          (syscall)
          (jb #"prim_sendto_panic")
          (ret)))

      ;; recvfrom
      (write-prim-assembly-function/panic #"recvfrom" output
        (varargs list
          ;; Argument 1: socket
          ;; Argument 2: buffer
          ;; Argument 3: buffer-length
          ;; Argument 4: flags
          ;; Argument 5: sockaddr
          ;; Argument 6: sockaddr-length
          (addq (imm 8) (rsi))
          (addq (imm 8) (r8))
          (addq (imm 8) (r9))
          (movq (reg (rcx)) (reg (r10)))
          (movq (imm #x200001d) (reg (rax)))
          (syscall)
          (jb #"prim_recvfrom_panic")
          (ret)))

      ;; connect
      (write-prim-assembly-function/panic #"connect" output
        (varargs list
          ;; Argument 1: socket
          ;; Argument 2: sockaddr
          ;; Argument 3: sockaddr-length
          (addq (imm 8) (rsi))
          (movq (imm #x2000062) (reg (rax)))
          (syscall)
          (jb #"prim_connect_panic")
          (ret)))

      ;; shutdown
      (write-prim-assembly-function/panic #"shutdown" output
        (varargs list
          ;; Argument 1: socket
          ;; Argument 2: how
          (movq (imm #x2000086) (reg (rax)))
          (syscall)
          (jb #"prim_shutdown_panic")
          (ret)))


      ;; listen
      (write-prim-assembly-function/panic #"listen" output
        (varargs list
          ;; Argument 1: socket
          ;; Argument 2: backlog
          (movq (imm #x200006A) (reg (rax)))
          (syscall)
          (jb #"prim_listen_panic")
          (ret)))

      ;; accept
      (write-prim-assembly-function/panic #"accept" output
        (varargs list
          ;; Argument 1: socket
          ;; Argument 2: sockaddr
          ;; Argument 3: sockaddr-length
          (addq (imm 8) (rsi))
          (addq (imm 8) (rdx))
          (movq (imm #x200001E) (reg (rax)))
          (syscall)
          (jb #"prim_accept_panic")
          (ret)))


      ;; setsockopt
      (write-prim-assembly-function/panic #"setsockopt" output
        (varargs list
          ;; Argument 1: socket
          ;; Argument 2: level
          ;; Argument 3: option name
          ;; Argument 4: option value
          ;; Argument 5: option length
          (movq (reg (rcx)) (reg (r10)))
          (addq (imm 8) (r10))
          (movq (imm #x2000069) (reg (rax)))
          (syscall)
          (jb #"prim_setsockopt_panic")
          (ret)))


      ;; mach_task_self
      (write-prim-assembly-function/panic #"mach_task_self" output
        (varargs list
          (movq (imm #x100001c) (reg (rax)))
          (syscall)
          (cmpq (imm 0) (reg (rax)))
          (je #"prim_mach_task_self_panic")
          (ret)))


      ;; mach_thread_self
      (write-prim-assembly-function/panic #"mach_thread_self" output
        (varargs list
          (movq (imm #x100001b) (reg (rax)))
          (syscall)
          (cmpq (imm 0) (reg (rax)))
          (je #"prim_mach_thread_self_panic")
          (ret)))


      ;; mach_reply_port
      (write-prim-assembly-function/panic #"mach_reply_port" output
        (varargs list
          (movq (imm #x100001a) (reg (rax)))
          (syscall)
          (cmpq (imm 0) (reg (rax)))
          (je #"prim_mach_reply_port_panic")
          (ret)))


      ;; mach_port_mod_refs
      (write-prim-assembly-function/panic #"mach_port_mod_refs" output
        (varargs list
          (addq (imm 32) (rsp)) ;; 4 arguments
          ;; Argument 1: task
          ;; Argument 2: port
          ;; Argument 3: right
          ;; Argument 4: delta
          (movq (reg (rcx)) (reg (r10)))
          (movq (imm #x1000013) (reg (rax)))
          (syscall)
          (cmpq (imm 0) (reg (rax)))
          (jne #"prim_mach_port_mod_refs_panic")
          (ret)))

      ;; mach_msg
      (write-prim-assembly-function/panic #"mach_msg" output
        (varargs list
          (movq (mem (r10) 0) (reg (rax))) ;; Notify Port
          (movq (reg (rcx)) (reg (r10)))

          (addq (imm 8) (rdi)) ;; Adjust past buffer's length field
          (pushq (reg (rax))) ;; Push back the notify port
          (pushq (imm 0)) ;; Dummy Return Address
          (movq (imm #x100001f) (reg (rax)))
          (syscall)
          (cmpq (imm 0) (reg (rax)))
          (jne #"prim_mach_msg_panic")
          (addq (imm #x10) (rsp)) ;; 2 pop
          (ret)))

      ;; and
      (write-prim-assembly-function #"and" output
        (varargs list
          (andq (reg (rdi)) (rsi))
          (movq (reg (rsi)) (reg (rax)))
          (ret)))
      ;; or
      (write-prim-assembly-function #"or" output
        (varargs list
          (orq (rdi) (rsi))
          (movq (reg (rsi)) (reg (rax)))
          (ret)))


      ;; bytes-ref
      (write-prim-assembly-function #"bytes_ref" output
        (varargs list
          (movzbq (scaled (rdi) 1 (rsi) 8) (rax))
          (ret)))
      ;; make-bytes
      (write-prim-assembly-function #"make_bytes" output
        (varargs list
          (movq (reg (rbp)) (reg (rdx)))
          (movq (reg (rdi)) (mem (rbp) 0))
          (movq (reg (rdi)) (reg (rcx)))
          (addq (imm 8) (rbp))
          (movb (imm 0) (reg (al)))
          (movq (reg (rbp)) (reg (rdi)))
          (cld)
          (rep-stosb)
          (movq (reg (rdi)) (reg (rbp)))
          (movq (reg (rdx)) (reg (rax)))
          (ret)))

      ;; bytes-set!
      (write-prim-assembly-function #"bytes_set" output
        (varargs list
          (movb (reg (dl)) (scaled (rdi) 1 (rsi) 8))
          (movq (imm 0) (reg (rax)))
          (ret)))
      ;; bytes-length
      (write-prim-assembly-function #"bytes_length" output
        (varargs list
          (movq (mem (rdi) 0) (reg (rax)))
          (ret)))

      ;; void
      (write-prim-assembly-function #"void" output
        (varargs list
          (movq (imm 0) (reg (rax)))
          (ret)))

      ;; panic
      (write-prim-assembly-function #"panic" output
        (varargs list
          (movq (mem (rsp) 0) (reg (rax)))
          (addq (imm 8) (rax))
          (ud2)))

      ;; These are not native functions, but just native subroutines
      ;; They do not follow standard calling conventions


      ;; variant-panic
      (write-block #"prim_variant_panic" output
        (varargs list
          (ud2)))

      ;; thread_bootstrap
      (write-block #"prim_thread_bootstrap" output
        (varargs list
          (pushq (reg (rax)))
          (movq (reg (rax)) (reg (r11)))
          (movq (mem (rax) 0) (reg (rax)))
          (call/indirect (rax))
          ;; Closure is still on the stack
          (ud2)))))



  (define (convert-objects [objects : (List TopLevelObject)]) : (List AssemblyFragment)
    (map (lambda ([object : TopLevelObject])
           (case object
             [(function-tlo fun) (convert-function fun)]
             [(bytes-tlo name value) (bytes-fragment name value)]
             [(trivial-closure-tlo name fun-name)
              (address-fragment name fun-name)]))
      objects))

  (define (convert-function [fun : StackFunction]) : AssemblyFragment
    (case fun
      [(stack-function name num-args blocks)
       (function-fragment name
         (cons
           (basic-block name
             (varargs append-jl*
               (if (>= num-args 1)
                   (single-jl (pushq (reg (rdi))))
                   (empty-jl))
               (if (>= num-args 2)
                   (single-jl (pushq (reg (rsi))))
                   (empty-jl))
               (if (>= num-args 3)
                   (single-jl (pushq (reg (rdx))))
                   (empty-jl))
               (if (>= num-args 4)
                   (single-jl (pushq (reg (rcx))))
                   (empty-jl))
               (if (>= num-args 5)
                   (single-jl (pushq (reg (r8))))
                   (empty-jl))
               (if (>= num-args 6)
                   (single-jl (pushq (reg (r9))))
                   (empty-jl))
               (if (>= num-args 7)
                   (install-extra-arguments 0 (- num-args 6))
                   (empty-jl))))
           (convert-basic-blocks name 0 blocks)))]))

  (define (write-fragments [fragments : (List AssemblyFragment)] [output : OutputPort]) : Void
    (write-assembly-commands (jl->list (fragments->commands fragments)) output))

  (define (fragments->commands [fragments : (List AssemblyFragment)]) : (JoinList AssemblyCommand)
    (case fragments
      [(empty) (empty-jl)]
      [(cons fragment fragments)
       (append-jl
         (fragment->commands fragment)
         (fragments->commands fragments))]))

  (define (fragment->commands [frag : AssemblyFragment]) : (JoinList AssemblyCommand)
    (case frag
      [(function-fragment _ blocks)
       (cons-jl
         (directive-cmd (section-directive #"__TEXT" #"__text"))
         (basic-blocks->commands blocks))]
      [(address-fragment name value)
       (varargs join-list
         (directive-cmd (section-directive #"__TEXT" #"__const"))
         (directive-cmd (global-directive name))
         (directive-cmd (label-directive name))
         (directive-cmd (quad-directive/label value)))]
      [(bytes-fragment name value)
       (varargs join-list
         (directive-cmd (section-directive #"__TEXT" #"__const"))
         (directive-cmd (global-directive name))
         (directive-cmd (label-directive name))
         (directive-cmd (quad-directive/integer (bytes-length value)))
         (directive-cmd (ascii-directive value)))]))

  (define (basic-blocks->commands [blocks : (List BasicBlock)]) : (JoinList AssemblyCommand)
    (case blocks
      [(empty) (empty-jl)]
      [(cons (basic-block name instructions) blocks)
       (cons-jl
         (directive-cmd (global-directive name))
         (cons-jl
           (directive-cmd (label-directive name))
           (append-jl
             (map-jl instruction-cmd instructions)
             (basic-blocks->commands blocks))))]))


  (define (convert-basic-blocks [fun-name : Bytes] [index : Byte] [blocks : (List StackBasicBlock)])
    : (List BasicBlock)
    (case blocks
      [(empty) (empty)]
      [(cons block blocks)
       (cons
         (convert-basic-block fun-name index block)
         (convert-basic-blocks fun-name (+ index 1) blocks))]))

  (define (convert-basic-block [fun-name : Bytes] [index : Byte] [block : StackBasicBlock])
    : BasicBlock
    (case block
      [(stack-basic-block cmds terminal)
       (basic-block
         (bytes-append (varargs list fun-name #"_" (integer->decimal-bytes index)))
         (append-jl
           (convert-commands cmds)
           (convert-terminal fun-name terminal)))]))


  (define (a) (for-each [f : (a -> Void)] [l : (List a)]) : Void
    (case l
      [(empty) (void)]
      [(cons e l)
       (begin
         (f e)
         (for-each f l))]))

  (define (line->bytes [line : (JoinList Bytes)]) : Bytes
    (case (jl->list line)
      [(empty) #""]
      [(cons entry (empty)) entry]
      [entries (bytes-append entries)]))

  (define (write-lines [lines : (List (JoinList Bytes))] [output : OutputPort]) : Void
    (for-each
      (lambda ([line : (JoinList Bytes)])
        (begin
          (write-line (line->bytes line) output)))
      lines))

  (define (convert-terminal [fun-name : Bytes] [terminal : StackTerminal]) : (JoinList Instruction)
    (case terminal
      [(return num-args)
       (varargs join-list
         (popq (reg (rax)))
         (addq (imm (* 8 num-args)) (rsp))
         (ret))]
      [(uncond-jmp index)
       (single-jl (jmp (bytes-append (varargs list fun-name #"_" (integer->decimal-bytes index)))))]
      [(boolean-jmp true-index false-index)
       (varargs join-list
         (popq (reg (rax)))
         (cmpq (imm 0) (reg (rax)))
         (jne (bytes-append (varargs list fun-name #"_" (integer->decimal-bytes true-index))))
         (jmp (bytes-append (varargs list fun-name #"_" (integer->decimal-bytes false-index)))))]
      [(variant-switch cases)
       (cons-jl
         (movq (mem (rsp) 0) (reg (rax)))
         (convert-variant-switch fun-name cases))]))

  ;; The current value is in %rax.
  (define (convert-variant-switch [fun-name : Bytes] [cases : VariantCases]) : (JoinList Instruction)
    (case cases
      [(no-catch-all-case)
       (single-jl (ud2))]
      [(catch-all-case block)
       (single-jl (jmp (bytes-append (varargs list fun-name #"_" (integer->decimal-bytes block)))))]
      [(variant-case tag block cases)
       (cons-jl
         (cmpq (imm tag) (mem (rax) 0))
         (cons-jl
           (je (bytes-append (varargs list fun-name #"_" (integer->decimal-bytes block))))
           (convert-variant-switch fun-name cases)))]))

  (define (convert-commands [cmds : (List StackCmd)]) : (JoinList Instruction)
    (case cmds
      [(empty) (empty-jl)]
      [(cons cmd cmds)
       (append-jl
         (convert-command cmd)
         (convert-commands cmds))]))


  (define (convert-command [cmd : StackCmd]) : (JoinList Instruction)
    (case cmd
      [(dup-cmd offset)
       (varargs join-list
         (pushq (mem (rsp) (* offset 8))))]
      [(dup-free-var-cmd offset index)
       (varargs join-list
         (pushq (mem (r11) (* (+ 1 index) 8))))]
      [(swap-cmd)
       (varargs join-list
         (popq (reg (rax)))
         (popq (reg (rbx)))
         (pushq (reg (rax)))
         (pushq (reg (rbx))))]
      [(pop-cmd)
       (varargs join-list
         (popq (reg (rax))))]
      [(num-lit-cmd v)
       ;; TODO fix when yaspl supports larger literals
       (let ([max-lit
              (bitwise-ior (logical-shift-left #xFF 0)
                (bitwise-ior (logical-shift-left #xFF 8)
                  (bitwise-ior (logical-shift-left #xFF 16)
                               (logical-shift-left #xFF 24))))])
         (if #t ;; (or (> v max-lit) (< v 0))
             (varargs join-list
               (movq (imm v) (reg (rax)))
               (pushq (reg (rax))))
             (varargs join-list
               (pushq (imm v)))))]
      [(boolean-lit-cmd v)
       (varargs join-list
         (pushq (imm (if v 1 0))))]
      ;; TODO put the bytes not directly in the instruction stream
      [(bytes-cmp-cmd)
       (varargs join-list
         (popq (reg (rdi))) ;; Argument 2
         (popq (reg (rsi))) ;; Argument 1
         (movq (mem (rsi) 0) (reg (rcx)))
         (addq (imm 8) (rcx))
         (repe-cmpsb)
         (sete (al))
         (movzbq (reg (al)) (rax))
         (pushq (reg (rax))))]

      [(load-global-cmd name)
       (varargs join-list
         (leaq/rel name (rip) (rax))
         (pushq (reg (rax))))]

      [(create-closure-cmd n)
       (varargs append-jl*
         (single-jl (movq (reg (rbp)) (reg (rax))))
         (copy-objects (+ n 1))
         (single-jl (pushq (reg (rax)))))]
      [(fun-call-cmd n)
       (varargs append-jl*
         (if (>= n 1)
             (single-jl (movq (mem (rsp) (- (* 8 n) #x00)) (reg (rdi))))
             (empty-jl))
         (if (>= n 2)
             (single-jl (movq (mem (rsp) (- (* 8 n) #x08)) (reg (rsi))))
             (empty-jl))
         (if (>= n 3)
             (single-jl (movq (mem (rsp) (- (* 8 n) #x10)) (reg (rdx))))
             (empty-jl))
         (if (>= n 4)
             (single-jl (movq (mem (rsp) (- (* 8 n) #x18)) (reg (rcx))))
             (empty-jl))
         (if (>= n 5)
             (single-jl (movq (mem (rsp) (- (* 8 n) #x20)) (reg (r8))))
             (empty-jl))
         (if (>= n 6)
             (single-jl (movq (mem (rsp) (- (* 8 n) #x28)) (reg (r9))))
             (empty-jl))
         (if (>= n 7)
             (cons-jl
               (movq (reg (rbp)) (reg (r10)))
               (copy-extra-arguments 6 n))
             (empty-jl))
         (varargs join-list
           (movq (mem (rsp) 0) (reg (rax)))
           (movq (reg (rax)) (mem (rsp) (* 8 n)))
           (addq (imm (* 8 n)) (rsp))
           (movq (mem (rsp) 0) (reg (rax)))
           (movq (reg (r11)) (mem (rsp) 0))
           (movq (reg (rax)) (reg (r11)))
           (movq (mem (rax) 0) (reg (rax)))
           (call/indirect (rax))
           ;; Read back the closure and then overwrite it
           (movq (mem (rsp) 0) (reg (r11)))
           (movq (reg (rax)) (mem (rsp) 0))))]
      [(known-fun-call-cmd name n)
       (varargs append-jl*
         (if (>= n 1)
             (single-jl (movq (mem (rsp) (- (* 8 n) #x08)) (reg (rdi))))
             (empty-jl))
         (if (>= n 2)
             (single-jl (movq (mem (rsp) (- (* 8 n) #x10)) (reg (rsi))))
             (empty-jl))
         (if (>= n 3)
             (single-jl (movq (mem (rsp) (- (* 8 n) #x18)) (reg (rdx))))
             (empty-jl))
         (if (>= n 4)
             (single-jl (movq (mem (rsp) (- (* 8 n) #x20)) (reg (rcx))))
             (empty-jl))
         (if (>= n 5)
             (single-jl (movq (mem (rsp) (- (* 8 n) #x28)) (reg (r8))))
             (empty-jl))
         (if (>= n 6)
             (single-jl (movq (mem (rsp) (- (* 8 n) #x30)) (reg (r9))))
             (empty-jl))
         (if (>= n 7)
             (cons-jl
               (movq (reg (rbp)) (reg (r10)))
               (copy-extra-arguments* 6 n))
             (empty-jl))
         (varargs join-list
           (addq (imm (* 8 n)) (rsp))
           (pushq (reg (r11)))
           (call name)
           ;; Read back the closure and then overwrite it
           (movq (mem (rsp) 0) (reg (r11)))
           (movq (reg (rax)) (mem (rsp) 0))))]

      [(make-array-cmd)
       (varargs join-list
         (popq (reg (rax)))
         (popq (reg (rcx)))
         (movq (reg (rbp)) (reg (rdx)))
         (movq (reg (rcx)) (mem (rbp) 0))
         (addq (imm 8) (rbp))
         (movq (reg (rbp)) (reg (rdi)))
         (rep-stosq)
         (movq (reg (rdi)) (reg (rbp)))
         (pushq (reg (rdx))))]
      [(make-array-from-stack-cmd num-args)
       (varargs join-list
         (movq (imm num-args) (reg (rcx)))
         (movq (reg (rsp)) (reg (rsi)))
         (movq (reg (rbp)) (reg (rax)))
         (leaq (scaled (rsp) 8 (rcx) 0) (rsp))
         (movq (reg (rcx)) (mem (rbp) 0))
         (leaq (mem (rbp) 8) (rdi))
         (leaq (scaled (rbp) 8 (rcx) 8) (rbp))
         (cld)
         (rep-movsq)
         (pushq (reg (rax))))]
      [(array-length-cmd)
       (varargs join-list
         (popq (reg (rax)))
         (pushq (mem (rax) 0)))]
      [(array-ref-cmd)
       (varargs join-list
         (popq (reg (rcx)))
         (popq (reg (rax)))
         (pushq (scaled (rax) 8 (rcx) 8)))]
      [(array-set!-cmd)
       (varargs join-list
         (popq (reg (rdx)))
         (popq (reg (rcx)))
         (popq (reg (rax)))
         (movq (reg (rdx)) (scaled (rax) 8 (rcx) 8))
         (pushq (imm 0)))]

      [(bin-logic-math-cmd op)
       (varargs join-list
         (popq (reg (rax))) ;; Argument 2
         (popq (reg (rcx))) ;; Argument 1
         (cmpq (reg (rax)) (reg (rcx)))
         (case op
           [(less-than-op)
            (setl (al))]
           [(less-than-or-equal-op)
            (setle (al))]
           [(equal-op)
            (sete (al))]
           [(greater-than-or-equal-op)
            (setge (al))]
           [(greater-than-op)
            (setg (al))])
         (movzbq (reg (al)) (rax))
         (pushq (reg (rax))))]
      [(bin-math-cmd (bin-add-op))
       (varargs join-list
         (popq (reg (rax)))
         (popq (reg (rcx)))
         (addq (reg (rcx)) (rax))
         (pushq (reg (rax))))]
      [(bin-math-cmd (bin-sub-op))
       (varargs join-list
         (popq (reg (rcx)))
         (popq (reg (rax)))
         (subq (reg (rcx)) (rax))
         (pushq (reg (rax))))]
      [(bin-math-cmd (bin-mult-op))
       (varargs join-list
         (popq (reg (rax)))
         (popq (reg (rcx)))
         (imulq (rcx))
         (pushq (reg (rax))))]
      [(bin-math-cmd (bin-quotient-op))
       (varargs join-list
         (popq (reg (rcx)))
         (popq (reg (rax)))
         (movq (imm 0) (reg (rdx)))
         (idivq (rcx))
         (pushq (reg (rax))))]
      [(bin-math-cmd (bin-remainder-op))
       (varargs join-list
         (popq (reg (rcx)))
         (popq (reg (rax)))
         (movq (imm 0) (reg (rdx)))
         (idivq (rcx))
         (pushq (reg (rdx))))]
      [(bin-math-cmd (bin-bitwise-and-op))
       (varargs join-list
         (popq (reg (rcx)))
         (popq (reg (rax)))
         (andq (reg (rcx)) (rax))
         (pushq (reg (rax))))]
      [(bin-math-cmd (bin-bitwise-ior-op))
       (varargs join-list
         (popq (reg (rcx)))
         (popq (reg (rax)))
         (orq (rcx) (rax))
         (pushq (reg (rax))))]
      ;; TODO check shift amount is valid value
      [(bin-math-cmd (bin-logical-shift-left-op))
       (varargs join-list
         (popq (reg (rcx)))
         (popq (reg (rax)))
         (shlq (rax))
         (pushq (reg (rax))))]
      [(bin-math-cmd (bin-logical-shift-right-op))
       (varargs join-list
         (popq (reg (rcx)))
         (popq (reg (rax)))
         (shrq (rax))
         (pushq (reg (rax))))]
      [(alloc-variant-cmd tag fields)
       (varargs append-jl*
         (single-jl (movq (reg (rbp)) (reg (rax))))
         (single-jl (movq (imm tag) (mem (rbp) 0)))
         (single-jl (addq (imm 8) (rbp)))
         (copy-objects fields)
         (single-jl (pushq (reg (rax)))))]
      [(variant-ref-cmd tag field)
       (varargs join-list
         (popq (reg (rax)))
         (cmpq (imm tag) (mem (rax) 0))
         (jne #"prim_variant_panic")
         (pushq (mem (rax) (+ (* 8 field) 8))))]))


  ;; Generates assembly to copy `args` arguments from the top of the stack to the
  ;; memory starting at %rbp. %rbp ends up pointing right after after the last argument written.
  ;; Dirties %rax
  (define (copy-extra-arguments [arg : Byte] [args : Byte]) : (JoinList Instruction)
    (if (= arg args)
        (empty-jl)
        (cons-jl
          (movq (mem (rsp) (* (- args arg) 8)) (reg (rax)))
          (cons-jl
            (movq (reg (rax)) (mem (rbp) 0))
            (cons-jl
              (addq (imm 8) (rbp))
              (copy-extra-arguments (+ 1 arg) args))))))

  ;; Generates assembly to copy `args` arguments from the top of the stack to the
  ;; memory starting at %rbp. %rbp ends up pointing right after after the last argument written.
  ;; Dirties %rax
  (define (copy-extra-arguments* [arg : Byte] [args : Byte]) : (JoinList Instruction)
    (if (= arg args)
        (empty-jl)
        (cons-jl
          (movq (mem (rsp) (* (- args (+ arg 1)) 8)) (reg (rax)))
          (cons-jl
            (movq (reg (rax)) (mem (rbp) 0))
            (cons-jl
              (addq (imm 8) (rbp))
              (copy-extra-arguments* (+ 1 arg) args))))))


  ;; Generates assembly to install `args` arguments from %r10 ontop of the stack
  (define (install-extra-arguments [arg : Byte] [args : Byte]) : (JoinList Instruction)
    (if (= arg args)
        (empty-jl)
        (cons-jl
          (pushq (mem (r10) (* arg 8)))
          (install-extra-arguments (+ 1 arg) args))))


  ;; Generates assembly to copy n objects from the top of the stack to the
  ;; memory starting at %rbp. %rbp ends up pointing right after after the last object written.
  (define (copy-objects [n : Byte]) : (JoinList Instruction)
    (if (> n 0)
        (cons-jl
          (popq (mem (rbp) 0))
          (cons-jl
            (addq (imm 8) (rbp))
            (copy-objects (- n 1))))
        (empty-jl)))



  ;; TODO switch to a polymorphic one when it works
  (define (a) (extract-either [either : (Either Bytes a)]) : a
    (case either
      [(right v) v]
      [(left v) (panic v)])))
