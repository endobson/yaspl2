#:module (x86-64-stack-machine)
#:import {
  (bytes)
  (join-list)
  (list)
  (numbers)
  (prim)
  (stack-machine)
  (yaspl math-operations)
  (yaspl x86-64-assembly)
}
(export
  #:types ()
  #:values (convert-function)
  #:patterns ())
(types)

(define (convert-function [fun : StackFunction]) : TextFragment
  (case fun
    [(stack-function name num-args blocks)
     (function-fragment name
       (cons
         (section
           (varargs list
             (basic-block name
               (varargs append-jl*
                 (varargs join-list
                   (pushq (reg (rbp)))
                   (movq (reg (rsp)) (reg (rbp))))
                 (if (>= num-args 1)
                     (single-jl (pushq (reg (rdi))))
                     (empty-jl))
                 (if (>= num-args 2)
                     (single-jl (pushq (reg (rsi))))
                     (empty-jl))
                 (if (>= num-args 3)
                     (single-jl (pushq (reg (rdx))))
                     (empty-jl))
                 (if (>= num-args 4)
                     (single-jl (pushq (reg (rcx))))
                     (empty-jl))
                 (if (>= num-args 5)
                     (single-jl (pushq (reg (r8))))
                     (empty-jl))
                 (if (>= num-args 6)
                     (single-jl (pushq (reg (r9))))
                     (empty-jl))
                 (if (>= num-args 7)
                     (install-extra-arguments 0 (- num-args 6))
                     (empty-jl))))))
           (convert-basic-blocks name 0 blocks)))]))

(define (convert-basic-blocks [fun-name : Bytes] [index : Int] [blocks : (List StackBasicBlock)])
  : (List Section)
  (case blocks
    [(empty) (empty)]
    [(cons block blocks)
     (cons
       (convert-basic-block fun-name index block)
       (convert-basic-blocks fun-name (+ index 1) blocks))]))

(define (convert-basic-block [fun-name : Bytes] [index : Int] [block : StackBasicBlock])
  : Section
  (case block
    [(stack-basic-block cmds terminal)
     (section
       (varargs list
         (basic-block
           (bytes-append (varargs list fun-name #"_" (integer->decimal-bytes index)))
           (append-jl
             (convert-commands cmds)
             (convert-terminal fun-name terminal)))))]))

(define (convert-terminal [fun-name : Bytes] [terminal : StackTerminal]) : (JoinList Instruction)
  (case terminal
    [(return num-cleanup)
     (varargs join-list
       (popq (reg (rax)))
       (addq (imm (* 8 num-cleanup)) (rsp))
       (popq (reg (rbp)))
       (ret))]
    [(tail-call n num-cleanup)
     (if (> n 6)
         (panic #"large tail call not implemented")
         (varargs append-jl*
           (if (>= n 1)
               (single-jl (movq (mem (rsp) (- (* 8 n) #x00)) (reg (rdi))))
               (empty-jl))
           (if (>= n 2)
               (single-jl (movq (mem (rsp) (- (* 8 n) #x08)) (reg (rsi))))
               (empty-jl))
           (if (>= n 3)
               (single-jl (movq (mem (rsp) (- (* 8 n) #x10)) (reg (rdx))))
               (empty-jl))
           (if (>= n 4)
               (single-jl (movq (mem (rsp) (- (* 8 n) #x18)) (reg (rcx))))
               (empty-jl))
           (if (>= n 5)
               (single-jl (movq (mem (rsp) (- (* 8 n) #x20)) (reg (r8))))
               (empty-jl))
           (if (>= n 6)
               (single-jl (movq (mem (rsp) (- (* 8 n) #x28)) (reg (r9))))
               (empty-jl))
           (varargs join-list
             (movq (mem (rsp) 0) (reg (r11)))
             (movq (reg (r11)) (mem (rsp) (* 8 n)))
             (addq (imm (* 8 (+ (+ num-cleanup 1) n))) (rsp))
             (popq (reg (rbp)))
             (jmp/indirect (mem (r11) 0)))))]
    [(known-tail-call name n num-cleanup)
     (if (> n 6)
         (panic #"large tail call not implemented")
         (varargs append-jl*
           (if (>= n 1)
               (single-jl (movq (mem (rsp) (- (* 8 n) #x08)) (reg (rdi))))
               (empty-jl))
           (if (>= n 2)
               (single-jl (movq (mem (rsp) (- (* 8 n) #x10)) (reg (rsi))))
               (empty-jl))
           (if (>= n 3)
               (single-jl (movq (mem (rsp) (- (* 8 n) #x18)) (reg (rdx))))
               (empty-jl))
           (if (>= n 4)
               (single-jl (movq (mem (rsp) (- (* 8 n) #x20)) (reg (rcx))))
               (empty-jl))
           (if (>= n 5)
               (single-jl (movq (mem (rsp) (- (* 8 n) #x28)) (reg (r8))))
               (empty-jl))
           (if (>= n 6)
               (single-jl (movq (mem (rsp) (- (* 8 n) #x30)) (reg (r9))))
               (empty-jl))
           (varargs join-list
             (addq (imm (* 8 (+ n num-cleanup))) (rsp))
             (popq (reg (rbp)))
             (jmp name))))]
    [(uncond-jmp index)
     (single-jl (jmp (bytes-append (varargs list fun-name #"_" (integer->decimal-bytes index)))))]
    [(boolean-jmp true-index false-index)
     (varargs join-list
       (popq (reg (rax)))
       (cmpq (imm 0) (reg (rax)))
       (jne (bytes-append (varargs list fun-name #"_" (integer->decimal-bytes true-index))))
       (jmp (bytes-append (varargs list fun-name #"_" (integer->decimal-bytes false-index)))))]
    [(variant-switch cases)
     (cons-jl
       (movq (mem (rsp) 0) (reg (rax)))
       (convert-variant-switch fun-name cases))]))

;; The current value is in %rax.
(define (convert-variant-switch [fun-name : Bytes] [cases : VariantCases]) : (JoinList Instruction)
  (case cases
    [(no-catch-all-case)
     (single-jl (ud2))]
    [(catch-all-case block)
     (single-jl (jmp (bytes-append (varargs list fun-name #"_" (integer->decimal-bytes block)))))]
    [(variant-case tag block cases)
     (cons-jl
       (cmpq (imm tag) (mem (rax) 0))
       (cons-jl
         (je (bytes-append (varargs list fun-name #"_" (integer->decimal-bytes block))))
         (convert-variant-switch fun-name cases)))]))

(define (convert-commands [cmds : (List StackCmd)]) : (JoinList Instruction)
  (case cmds
    [(empty) (empty-jl)]
    [(cons cmd cmds)
     (append-jl
       (convert-command cmd)
       (convert-commands cmds))]))


(define (convert-command [cmd : StackCmd]) : (JoinList Instruction)
  (case cmd
    [(dup-cmd offset)
     (varargs join-list
       (pushq (mem (rsp) (* offset 8))))]
    [(dup-free-var-cmd offset index)
     (varargs join-list
       (pushq (mem (r11) (* (+ 1 index) 8))))]
    [(swap-cmd)
     (varargs join-list
       (popq (reg (rax)))
       (popq (reg (rbx)))
       (pushq (reg (rax)))
       (pushq (reg (rbx))))]
    [(pop-cmd)
     (varargs join-list
       (popq (reg (rax))))]
    [(num-lit-cmd v)
     (varargs join-list
       (movq/imm (int->eight-bytes-le v) (rax))
       (pushq (reg (rax))))]
    [(boolean-lit-cmd v)
     (varargs join-list
       (pushq (imm (if v 1 0))))]
    [(bytes-cmp-cmd)
     (varargs join-list
       (popq (reg (rdi))) ;; Argument 2
       (popq (reg (rsi))) ;; Argument 1
       (movq (mem (rsi) 0) (reg (rcx)))
       (addq (imm 8) (rcx))
       (repe-cmpsb)
       (sete (al))
       (movzbq (reg (al)) (rax))
       (pushq (reg (rax))))]

    [(load-global-cmd name)
     (varargs join-list
       (leaq/rip-rel name (rax))
       (pushq (reg (rax))))]

    [(create-closure-cmd symbol n)
     (varargs append-jl*
       (varargs join-list
         (movq (reg (r15)) (reg (rax)))
         (leaq/rip-rel symbol (rcx))
         (movq (reg (rcx)) (mem (r15) 0))
         (addq (imm 8) (r15)))
       (copy-objects n)
       (single-jl (pushq (reg (rax)))))]
    [(fun-call-cmd n)
     (varargs append-jl*
       (if (>= n 1)
           (single-jl (movq (mem (rsp) (- (* 8 n) #x00)) (reg (rdi))))
           (empty-jl))
       (if (>= n 2)
           (single-jl (movq (mem (rsp) (- (* 8 n) #x08)) (reg (rsi))))
           (empty-jl))
       (if (>= n 3)
           (single-jl (movq (mem (rsp) (- (* 8 n) #x10)) (reg (rdx))))
           (empty-jl))
       (if (>= n 4)
           (single-jl (movq (mem (rsp) (- (* 8 n) #x18)) (reg (rcx))))
           (empty-jl))
       (if (>= n 5)
           (single-jl (movq (mem (rsp) (- (* 8 n) #x20)) (reg (r8))))
           (empty-jl))
       (if (>= n 6)
           (single-jl (movq (mem (rsp) (- (* 8 n) #x28)) (reg (r9))))
           (empty-jl))
       (if (>= n 7)
           (cons-jl
             (movq (reg (r15)) (reg (r10)))
             (copy-extra-arguments 6 n))
           (empty-jl))
       (varargs join-list
         (movq (mem (rsp) 0) (reg (rax)))
         (movq (reg (rax)) (mem (rsp) (* 8 n)))
         (addq (imm (* 8 n)) (rsp))
         (movq (mem (rsp) 0) (reg (rax)))
         (movq (reg (r11)) (mem (rsp) 0))
         (movq (reg (rax)) (reg (r11)))
         (call/indirect (mem (rax) 0))
         ;; Read back the closure and then overwrite it
         (movq (mem (rsp) 0) (reg (r11)))
         (movq (reg (rax)) (mem (rsp) 0))))]
    [(known-fun-call-cmd name n)
     (varargs append-jl*
       (if (>= n 1)
           (single-jl (movq (mem (rsp) (- (* 8 n) #x08)) (reg (rdi))))
           (empty-jl))
       (if (>= n 2)
           (single-jl (movq (mem (rsp) (- (* 8 n) #x10)) (reg (rsi))))
           (empty-jl))
       (if (>= n 3)
           (single-jl (movq (mem (rsp) (- (* 8 n) #x18)) (reg (rdx))))
           (empty-jl))
       (if (>= n 4)
           (single-jl (movq (mem (rsp) (- (* 8 n) #x20)) (reg (rcx))))
           (empty-jl))
       (if (>= n 5)
           (single-jl (movq (mem (rsp) (- (* 8 n) #x28)) (reg (r8))))
           (empty-jl))
       (if (>= n 6)
           (single-jl (movq (mem (rsp) (- (* 8 n) #x30)) (reg (r9))))
           (empty-jl))
       (if (>= n 7)
           (cons-jl
             (movq (reg (r15)) (reg (r10)))
             (copy-extra-arguments* 6 n))
           (empty-jl))
       (varargs join-list
         (addq (imm (* 8 n)) (rsp))
         (pushq (reg (r11)))
         (call name)
         ;; Read back the closure and then overwrite it
         (movq (mem (rsp) 0) (reg (r11)))
         (movq (reg (rax)) (mem (rsp) 0))))]

    [(make-array-cmd)
     (varargs join-list
       (popq (reg (rax)))
       (popq (reg (rcx)))
       (movq (reg (r15)) (reg (rdx)))
       (movq (reg (rcx)) (mem (r15) 0))
       (addq (imm 8) (r15))
       (movq (reg (r15)) (reg (rdi)))
       (rep-stosq)
       (movq (reg (rdi)) (reg (r15)))
       (pushq (reg (rdx))))]
    [(make-array-from-stack-cmd num-args)
     (varargs join-list
       (movq (imm num-args) (reg (rcx)))
       (movq (reg (rsp)) (reg (rsi)))
       (movq (reg (r15)) (reg (rax)))
       (leaq (scaled (rsp) (scale-8) (rcx) 0) (rsp))
       (movq (reg (rcx)) (mem (r15) 0))
       (leaq (mem (r15) 8) (rdi))
       (leaq (scaled (r15) (scale-8) (rcx) 8) (r15))
       (cld)
       (rep-movsq)
       (pushq (reg (rax))))]
    [(array-length-cmd)
     (varargs join-list
       (popq (reg (rax)))
       (pushq (mem (rax) 0)))]
    [(array-ref-cmd)
     (varargs join-list
       (popq (reg (rcx)))
       (popq (reg (rax)))
       (pushq (scaled (rax) (scale-8) (rcx) 8)))]
    [(array-set!-cmd)
     (varargs join-list
       (popq (reg (rdx)))
       (popq (reg (rcx)))
       (popq (reg (rax)))
       (movq (reg (rdx)) (scaled (rax) (scale-8) (rcx) 8))
       (pushq (imm 0)))]

    [(bin-comparison-cmd op)
     (varargs join-list
       (popq (reg (rax))) ;; Argument 2
       (popq (reg (rcx))) ;; Argument 1
       (cmpq (reg (rax)) (reg (rcx)))
       (case op
         [(less-than-op)
          (setl (al))]
         [(less-than-or-equal-op)
          (setle (al))]
         [(equal-op)
          (sete (al))]
         [(not-equal-op)
          (setne (al))]
         [(greater-than-or-equal-op)
          (setge (al))]
         [(greater-than-op)
          (setg (al))])
       (movzbq (reg (al)) (rax))
       (pushq (reg (rax))))]
    [(bin-numeric-cmd (add-op))
     (varargs join-list
       (popq (reg (rax)))
       (popq (reg (rcx)))
       (addq (reg (rcx)) (rax))
       (pushq (reg (rax))))]
    [(bin-numeric-cmd (sub-op))
     (varargs join-list
       (popq (reg (rcx)))
       (popq (reg (rax)))
       (subq (reg (rcx)) (rax))
       (pushq (reg (rax))))]
    [(bin-numeric-cmd (mult-op))
     (varargs join-list
       (popq (reg (rax)))
       (popq (reg (rcx)))
       (imulq (rcx) (rax))
       (pushq (reg (rax))))]
    [(bin-numeric-cmd (quotient-op))
     (varargs join-list
       (popq (reg (rcx)))
       (popq (reg (rax)))
       (movq (imm 0) (reg (rdx)))
       (idivq (rcx))
       (pushq (reg (rax))))]
    [(bin-numeric-cmd (remainder-op))
     (varargs join-list
       (popq (reg (rcx)))
       (popq (reg (rax)))
       (movq (imm 0) (reg (rdx)))
       (idivq (rcx))
       (pushq (reg (rdx))))]
    [(bin-numeric-cmd (bitwise-and-op))
     (varargs join-list
       (popq (reg (rcx)))
       (popq (reg (rax)))
       (andq (reg (rcx)) (rax))
       (pushq (reg (rax))))]
    [(bin-numeric-cmd (bitwise-ior-op))
     (varargs join-list
       (popq (reg (rcx)))
       (popq (reg (rax)))
       (orq (rcx) (rax))
       (pushq (reg (rax))))]
    ;; TODO check shift amount is valid value
    [(bin-numeric-cmd (logical-shift-left-op))
     (varargs join-list
       (popq (reg (rcx)))
       (popq (reg (rax)))
       (shlq (rax))
       (pushq (reg (rax))))]
    [(bin-numeric-cmd (logical-shift-right-op))
     (varargs join-list
       (popq (reg (rcx)))
       (popq (reg (rax)))
       (shrq (rax))
       (pushq (reg (rax))))]
    [(alloc-variant-cmd tag fields)
     (varargs append-jl*
       (single-jl (movq (reg (r15)) (reg (rax))))
       (single-jl (movq (imm tag) (mem (r15) 0)))
       (single-jl (addq (imm 8) (r15)))
       (copy-objects fields)
       (single-jl (pushq (reg (rax)))))]
    [(variant-ref-cmd tag field)
     (varargs join-list
       (popq (reg (rax)))
       (cmpq (imm tag) (mem (rax) 0))
       (jne #"prim_variant_panic")
       (pushq (mem (rax) (+ (* 8 field) 8))))]))


;; Generates assembly to copy `args` arguments from the top of the stack to the
;; memory starting at %r15 %r15 ends up pointing right after after the last argument written.
;; Dirties %rax
(define (copy-extra-arguments [arg : Int] [args : Int]) : (JoinList Instruction)
  (if (= arg args)
      (empty-jl)
      (cons-jl
        (movq (mem (rsp) (* (- args arg) 8)) (reg (rax)))
        (cons-jl
          (movq (reg (rax)) (mem (r15) 0))
          (cons-jl
            (addq (imm 8) (r15))
            (copy-extra-arguments (+ 1 arg) args))))))

;; Generates assembly to copy `args` arguments from the top of the stack to the
;; memory starting at %r15 %r15 ends up pointing right after after the last argument written.
;; Dirties %rax
(define (copy-extra-arguments* [arg : Int] [args : Int]) : (JoinList Instruction)
  (if (= arg args)
      (empty-jl)
      (cons-jl
        (movq (mem (rsp) (* (- args (+ arg 1)) 8)) (reg (rax)))
        (cons-jl
          (movq (reg (rax)) (mem (r15) 0))
          (cons-jl
            (addq (imm 8) (r15))
            (copy-extra-arguments* (+ 1 arg) args))))))


;; Generates assembly to install `args` arguments from %r10 ontop of the stack
(define (install-extra-arguments [arg : Int] [args : Int]) : (JoinList Instruction)
  (if (= arg args)
      (empty-jl)
      (cons-jl
        (pushq (mem (r10) (* arg 8)))
        (install-extra-arguments (+ 1 arg) args))))


;; Generates assembly to copy n objects from the top of the stack to the
;; memory starting at %r15 %r15 ends up pointing right after after the last object written.
(define (copy-objects [n : Int]) : (JoinList Instruction)
  (if (> n 0)
      (cons-jl
        (popq (mem (r15) 0))
        (cons-jl
          (addq (imm 8) (r15))
          (copy-objects (- n 1))))
      (empty-jl)))
