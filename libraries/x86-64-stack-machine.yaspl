(module x86-64-stack-machine
  (import
    (prim
      #:types (Bytes Byte InputPort OutputPort Void Array)
      #:values (bytes-length make-bytes * + - = <= >= panic void > bytes-set!)
      #:patterns ())
    (prim-implementation prim-implementation)
    (list
      #:types (List)
      #:values (cons-head append list map)
      #:patterns (empty cons))
    (numbers integer->decimal-bytes)
    (io read-all-bytes write-all-bytes newline write-line)
    (join-list
      #:types (JoinList)
      #:values (jl->list single-jl join-list empty-jl cons-jl append-jl*)
      #:patterns ())
    (sexp-parser
      #:types (Sexp)
      #:values (parse-sexp)
      #:patterns ())
    (bytes bytes-copy! subbytes bytes-append)
    (stack-machine
      #:types (StackFunction StackBasicBlock StackCmd StackTerminal VariantCases TopLevelObject)
      #:values (stack-function-blocks stack-basic-block-cmds)
      #:patterns (stack-function stack-basic-block return
                  swap-cmd dup-cmd pop-cmd num-lit-cmd create-closure-cmd fun-call-cmd known-fun-call-cmd
                  bytes-lit-cmd boolean-lit-cmd uncond-jmp boolean-jmp alloc-variant-cmd
                  variant-ref-cmd variant-switch bytes-cmp-cmd load-global-cmd
                  no-catch-all-case catch-all-case variant-case
                  bin-math-cmd bin-add-op bin-sub-op bin-mult-op bin-quotient-op bin-remainder-op
                  bin-logic-math-cmd less-than-op less-than-or-equal-op equal-op
                  greater-than-or-equal-op greater-than-op
                  make-array-cmd array-length-cmd array-ref-cmd array-set!-cmd
                  make-array-from-stack-cmd dup-free-var-cmd function-tlo trivial-closure-tlo
                  bytes-tlo))
    (either
      #:types (Either)
      #:values ()
      #:patterns (left right)))
  (export compile-stack-machine)
  (types
    (define-type AssemblyCommand
      (directive-cmd [directive AssemblerDirective])
      (instruction-cmd [instruction Instruction]))
    (define-type AssemblerDirective
      (section-directive [segment-name Bytes] [section-name Bytes])
      (global-directive [label Bytes])
      (label-directive [name Bytes])
      (quad-directive [label Bytes]))
    (define-type Instruction
      (add [rmi RegMemImm] [reg Register])
      (and [reg1 RegMemImm] [reg2 Register])
      (call [label Bytes])
      (call/indirect [rmi RegMemImm])
      (cld)
      (cmovz [rmi RegMemImm] [reg Register])
      (cmpq [rmi1 RegMemImm] [rmi2 RegMemImm])
      (dec [reg Register])
      (idivq [reg Register])
      (imulq [reg Register])
      (inc [reg Register])
      (jb [label Bytes])
      (je [label Bytes])
      (jne [label Bytes])
      (jnz [label Bytes])
      (leaq [rmi RegMemImm] [reg Register])
      (leaq/rel [label Bytes] [reg1 Register] [reg2 Register])
      (lahf)
      (movb [rmi1 RegMemImm] [rmi2 RegMemImm])
      (movq [rmi1 RegMemImm] [rmi2 RegMemImm])
      (movzb [rmi RegMemImm] [r Register])
      (neg (rmi RegMemImm))
      (nop)
      (not [reg Register])
      (or [reg1 Register] [reg2 Register])
      (pop [rmi RegMemImm])
      (pushq [rmi RegMemImm])
      (rep-movsb)
      (rep-movsq)
      (rep-stosb)
      (rep-stosq)
      (repe-cmpsb)
      (repne-scasb)
      (ret)
      (sete [reg Register])
      (setg [reg Register])
      (setge [reg Register])
      (setl [reg Register])
      (setle [reg Register])
      (shr [reg1 Register] [reg2 Register])
      (std)
      (sub [rmi RegMemImm] [reg Register])
      (syscall)
      (ud2))
    (define-type Register
      ;; 8 Bit registers
      (al)
      (ah)
      (bl)
      (bh)
      (cl)
      (ch)
      (dl)
      (dh)
      (dil)
      (sil)
      (bpl)
      (spl)
      (r8b)
      (r9b)
      (r10b)
      (r11b)
      (r12b)
      (r13b)
      (r14b)
      (r15b)
      ;; 16 bit registers
      (ax)
      (bx)
      (cx)
      (dx)
      (di)
      (si)
      (bp)
      (sp)
      (r8w)
      (r9w)
      (r10w)
      (r11w)
      (r12w)
      (r13w)
      (r14w)
      (r15w)
      ;; 32 bit registers
      (eax)
      (ebx)
      (ecx)
      (edx)
      (edi)
      (esi)
      (ebp)
      (esp)
      (r8d)
      (r9d)
      (r10d)
      (r11d)
      (r12d)
      (r13d)
      (r14d)
      (r15d)
      ;;64 bit registers
      (rax)
      (rbx)
      (rcx)
      (rdx)
      (rdi)
      (rsi)
      (rbp)
      (rsp)
      (r8)
      (r9)
      (r10)
      (r11)
      (r12)
      (r13)
      (r14)
      (r15)
      (rip))
    (define-type RegMemImm
      (rmi-register [r Register])
      (rmi-direct-memory [reg Register] [offset Byte])
      (rmi-scaled-memory [reg Register] [scale Byte] [index-reg Register] [offset Byte])
      (rmi-immediate [v Byte])))

  (define (compile-stack-machine
            [main-function-name : Bytes]
            [objects : (List TopLevelObject)]
            [output : OutputPort]) : Void
    (begin
      (write-start main-function-name output)
      (write-objects objects output)))

  (define (assembly-command->bytes [cmd : AssemblyCommand]) : (JoinList Bytes)
    (case cmd
      [(directive-cmd directive) (assembler-directive->bytes directive)]
      [(instruction-cmd instruction) (instruction->assembly-bytes instruction)]))

  (define (assembler-directive->bytes [dir : AssemblerDirective]) : (JoinList Bytes)
    (case dir
      [(section-directive seg sect)
       (varargs join-list #".section " seg #"," sect)]
      [(global-directive label)
       (varargs join-list #".global " label)]
      [(label-directive name)
       (varargs join-list name #":")]
      [(quad-directive label)
       (varargs join-list #".quad " label)]))

  (define (instruction->assembly-bytes [inst : Instruction]) : (JoinList Bytes)
    (case inst
      [(add rmi reg)
       (varargs join-list
          #"add "
          (rmi->bytes rmi)
          #", "
          (register->bytes reg))]
      [(and rmi reg)
       (varargs join-list
          #"and "
          (rmi->bytes rmi)
          #", "
          (register->bytes reg))]
      [(call label)
       (varargs join-list #"call " label)]
      [(call/indirect rmi)
       (varargs join-list #"callq *" (rmi->bytes rmi))]
      [(cld)
       (single-jl #"cld")]
      [(cmovz rmi reg)
       (varargs join-list
          #"cmovz "
          (rmi->bytes rmi)
          #", "
          (register->bytes reg))]
      [(cmpq rmi1 rmi2)
       (varargs join-list
          #"cmpq "
          (rmi->bytes rmi1)
          #", "
          (rmi->bytes rmi2))]
      [(dec reg)
       (varargs join-list #"dec " (register->bytes reg))]
      [(idivq reg)
       (varargs join-list #"idivq " (register->bytes reg))]
      [(imulq reg)
       (varargs join-list #"imulq " (register->bytes reg))]
      [(inc reg)
       (varargs join-list #"inc " (register->bytes reg))]
      [(jb label)
       (varargs join-list #"jb " label)]
      [(je label)
       (varargs join-list #"je " label)]
      [(jne label)
       (varargs join-list #"jne " label)]
      [(jnz label)
       (varargs join-list #"jnz " label)]
      [(lahf)
       (single-jl #"lahf")]
      [(leaq rmi reg)
       (varargs join-list
          #"leaq "
          (rmi->bytes rmi)
          #", "
          (register->bytes reg))]
      [(leaq/rel label reg1 reg2)
       (varargs join-list
          #"leaq "
          label
          #"("
          (register->bytes reg1)
          #"), "
          (register->bytes reg2))]
      [(movb rmi1 rmi2)
       (varargs join-list
          #"movb "
          (rmi->bytes rmi1)
          #", "
          (rmi->bytes rmi2))]
      [(movq rmi1 rmi2)
       (varargs join-list
          #"movq "
          (rmi->bytes rmi1)
          #", "
          (rmi->bytes rmi2))]
      [(movzb rmi reg)
       (varargs join-list
          #"movzb "
          (rmi->bytes rmi)
          #", "
          (register->bytes reg))]
      [(neg rmi)
       (varargs join-list #"not " (rmi->bytes rmi))]
      [(nop)
       (single-jl #"nop")]
      [(not reg)
       (varargs join-list #"not " (register->bytes reg))]
      [(or reg1 reg2)
       (varargs join-list
          #"or "
          (register->bytes reg1)
          #", "
          (register->bytes reg2))]
      [(pop rmi)
       (varargs join-list #"pop " (rmi->bytes rmi))]
      [(pushq rmi)
       (varargs join-list #"pushq " (rmi->bytes rmi))]
      [(rep-stosb)
       (single-jl #"rep stosb")]
      [(rep-stosq)
       (single-jl #"rep stosq")]
      [(rep-movsb)
       (single-jl #"rep movsb")]
      [(rep-movsq)
       (single-jl #"rep movsq")]
      [(repe-cmpsb)
       (single-jl #"repe cmpsb")]
      [(repne-scasb)
       (single-jl #"repne scasb")]
      [(ret)
       (single-jl #"ret")]
      [(sete reg)
       (varargs join-list #"sete " (register->bytes reg))]
      [(setg reg)
       (varargs join-list #"setg " (register->bytes reg))]
      [(setge reg)
       (varargs join-list #"setge " (register->bytes reg))]
      [(setl reg)
       (varargs join-list #"setl " (register->bytes reg))]
      [(setle reg)
       (varargs join-list #"setle " (register->bytes reg))]
      [(shr reg1 reg2)
       (varargs join-list
          #"shr "
          (register->bytes reg1)
          #", "
          (register->bytes reg2))]
      [(std)
       (single-jl #"std")]
      [(sub rmi reg)
       (varargs join-list
          #"sub "
          (rmi->bytes rmi)
          #", "
          (register->bytes reg))]
      [(syscall)
       (single-jl #"syscall")]
      [(ud2)
       (single-jl #"ud2")]))

  (define (register->bytes [reg : Register]) : Bytes
    (case reg
      ;; 8 bit
      [(al) #"%al"]
      [(ah) #"%ah"]
      [(bl) #"%bl"]
      [(bh) #"%bh"]
      [(cl) #"%cl"]
      [(ch) #"%ch"]
      [(dl) #"%dl"]
      [(dh) #"%dh"]
      [(dil) #"%dli"]
      [(sil) #"%sil"]
      [(bpl) #"%bpl"]
      [(spl) #"%spl"]
      [(r8b) #"%r8b"]
      [(r9b) #"%r9b"]
      [(r10b) #"%r10b"]
      [(r11b) #"%r11b"]
      [(r12b) #"%r12b"]
      [(r13b) #"%r13b"]
      [(r14b) #"%r14b"]
      [(r15b) #"%r15b"]
      ;; 16 bit
      [(ax) #"%ax"]
      [(bx) #"%bx"]
      [(cx) #"%cx"]
      [(dx) #"%dx"]
      [(di) #"%di"]
      [(si) #"%si"]
      [(bp) #"%bp"]
      [(sp) #"%sp"]
      [(r8w) #"%r8w"]
      [(r9w) #"%r9w"]
      [(r10w) #"%r10w"]
      [(r11w) #"%r11w"]
      [(r12w) #"%r12w"]
      [(r13w) #"%r13w"]
      [(r14w) #"%r14w"]
      [(r15w) #"%r15w"]
      ;; 32 bit
      [(eax) #"%eax"]
      [(ebx) #"%ebx"]
      [(ecx) #"%ecx"]
      [(edx) #"%edx"]
      [(edi) #"%edi"]
      [(esi) #"%esi"]
      [(ebp) #"%ebp"]
      [(esp) #"%esp"]
      [(r8d) #"%r8d"]
      [(r9d) #"%r9d"]
      [(r10d) #"%r10d"]
      [(r11d) #"%r11d"]
      [(r12d) #"%r12d"]
      [(r13d) #"%r13d"]
      [(r14d) #"%r14d"]
      [(r15d) #"%r15d"]
      ;; 64 bit
      [(rax) #"%rax"]
      [(rbx) #"%rbx"]
      [(rcx) #"%rcx"]
      [(rdx) #"%rdx"]
      [(rdi) #"%rdi"]
      [(rsi) #"%rsi"]
      [(rbp) #"%rbp"]
      [(rsp) #"%rsp"]
      [(r8) #"%r8"]
      [(r9) #"%r9"]
      [(r10) #"%r10"]
      [(r11) #"%r11"]
      [(r12) #"%r12"]
      [(r13) #"%r13"]
      [(r14) #"%r14"]
      [(r15) #"%r15"]
      [(rip) #"%rip"]))

  (define (rmi->bytes [rmi : RegMemImm]) : Bytes
    (case rmi
      [(rmi-register r) (register->bytes r)]
      [(rmi-direct-memory reg offset)
       (bytes-append (varargs list (integer->decimal-bytes offset) #"(" (register->bytes reg) #")"))]
      [(rmi-scaled-memory reg scale index offset)
       (bytes-append
         (varargs list
           (integer->decimal-bytes offset)
           #"("
           (register->bytes reg)
           #", "
           (register->bytes index)
           #", "
           (integer->decimal-bytes scale)
           #")"))]
      [(rmi-immediate v)
       (bytes-append (varargs list #"$" (integer->decimal-bytes v)))]))

  (define (reg [r : Register]) : RegMemImm
    (rmi-register r))
  (define (mem [r : Register] [offset : Byte]) : RegMemImm
    (rmi-direct-memory r offset))
  (define (imm [v : Byte]) : RegMemImm
    (rmi-immediate v))
  (define (scaled [r : Register] [scale : Byte] [index : Register] [offset : Byte]) : RegMemImm
    (rmi-scaled-memory r scale index offset))

  (define (write-assembly-commands [cmds : (List AssemblyCommand)] [output : OutputPort]) : Void
    (write-lines (map assembly-command->bytes cmds) output))
  (define (write-instructions [output : OutputPort] [instructions : (List Instruction)]) : Void
    (write-lines (map instruction->assembly-bytes instructions) output))

  (define (write-prim-assembly-function
            [name : Bytes]
            [output : OutputPort]
            [instructions : (List Instruction)]) : Void
    (write-assembly-commands
      (append
        (varargs list
          (directive-cmd (section-directive #"__TEXT" #"__const"))
          (directive-cmd (label-directive (bytes-append (varargs list #"prim_" name #"_closure"))))
          (directive-cmd (quad-directive (bytes-append (varargs list #"prim_" name))))
          (directive-cmd (section-directive #"__TEXT" #"__text"))
          (directive-cmd (label-directive (bytes-append (varargs list #"prim_" name)))))
        (map instruction-cmd instructions))
      output))

  (define (write-prim-assembly-function/panic
            [name : Bytes]
            [output : OutputPort]
            [instructions : (List Instruction)]) : Void
    (begin
      (write-prim-assembly-function name output instructions)
      (write-assembly-commands
        (varargs list
          (directive-cmd (label-directive (bytes-append (varargs list #"prim_" name #"_panic"))))
          (instruction-cmd (ud2)))
        output)))

  (define (write-block
            [name : Bytes]
            [output : OutputPort]
            [instructions : (List Instruction)]) : Void
    (write-assembly-commands
      (append
        (varargs list
          (directive-cmd (section-directive #"__TEXT" #"__text"))
          (directive-cmd (label-directive name)))
        (map instruction-cmd instructions))
      output))




  (define (write-start [main-function-name : Bytes] [output : OutputPort]) : Void
    (begin
      (write-assembly-commands
        (varargs list
          (directive-cmd (global-directive #"start")))
        output)

      (write-block #"start" output
        (varargs list
          (nop)))

      (write-block #"start_break" output
        (varargs list
          ;; Allocate Heap (Call mmap)
          ;; No fixed address desired
          (movq (imm 0) (reg (rdi)))
          ;; We want a large heap
          (movq (imm #x20000000) (reg (rsi)))
          ;; 0x1 = PROT_READ
          ;; 0x2 = PROT_WRITE
          ;; 0x4 = PROT_EXEC
          (movq (imm #x7) (reg (rdx)))
          ;; 0x0002 = MAP_SHARED
          ;; 0x1000 = MAP_ANON
          (movq (imm #x1002) (reg (r10)))
          ;; FD = -1 for no flags
          (movq (imm (- 0 1)) (reg (r8)))
          ;; offset which is ignored because of MAP_ANON
          (movq (imm 0) (reg (r9)))
          ;; 0xC5 is mmap, plus 0x2000000 because xnu
          (movq (imm #x20000C5) (reg (rax)))
          (syscall)
          (jb #"prim_start_panic")
          ;; Save heap to %rbp which is our bump pointer
          (movq (reg (rax)) (reg (rbp)))

          ;; Construct args
          (pop (reg (r8))) ; r8 is the number of c strings
          (movq (reg (rbp)) (reg (r10))) ; r10 is the array of bytes
          (movq (imm 0) (reg (r11))) ; r11 is the index of the current string

          (movq (reg (r8)) (mem (rbp) 0))
          (leaq (scaled (rbp) 8 (r8) 8) (rbp))

          (cmpq (reg (r11)) (reg (r8)))
          (je #"start_copy_args_end")
          (cld)))

      (write-block #"start_copy_args_start" output
        (varargs list
          (pop (reg (r9))) ; r9 is now the current string

          ;; Count string length
          (movq (reg (r9)) (reg (rdi)))
          (movb (imm 0) (reg (al)))
          (movq (imm (- 0 1)) (reg (rcx)))
          (repne-scasb)
          (not (rcx))
          (dec (rcx))

          ;; Copy bytes
          (movq (reg (rbp)) (scaled (r10) 8 (r11) 8))
          (movq (reg (rcx)) (mem (rbp) 0))
          (add (imm 8) (rbp))
          (movq (reg (r9)) (reg (rsi)))
          (movq (reg (rbp)) (reg (rdi)))
          (rep-movsb)
          (movq (reg (rdi)) (reg (rbp)))
          (inc (r11))
          (cmpq (reg (r11)) (reg (r8)))
          (jne #"start_copy_args_start")))



      ;; Call main and then exit
      (write-block #"start_copy_args_end" output
        (varargs list
          (movq (reg (r10)) (reg (rdi)))
          (pushq (reg (rdi)))
          (movq (imm 0) (reg (rsi)))
          (pushq (reg (rsi)))
          (movq (imm 1) (reg (rdx)))
          (pushq (reg (rdx)))
          (movq (imm 2) (reg (rcx)))
          (pushq (reg (rcx)))
          (pushq (imm 0)) ;; Bogus closure
          (call (bytes-append (varargs list main-function-name #"_code")))
          ;; Closure is still on the stack
          (movq (reg (rax)) (reg (rdi)))
          (movq (imm #x2000001) (reg (rax)))
          (syscall)))
      (write-block #"prim_start_panic" output
        (varargs list
          (ud2)))



      ;; write-bytes
      (write-prim-assembly-function/panic #"write_bytes" output
        (varargs list
          ;; Swap %rdi and %rsi
          (movq (reg (rdi)) (reg (rax)))
          (movq (reg (rsi)) (reg (rdi)))
          (movq (reg (rax)) (reg (rsi)))

          ;; %rdi is now the file descriptor
          ;; Make %rsi the start of the buffer
          (leaq (scaled (rsi) 1 (rdx) 8) (rsi))
          ;; Make %rdx the length to write
          (sub (reg (rdx)) (rcx))
          (movq (reg (rcx)) (reg (rdx)))
          (movq (imm #x2000004) (reg (rax)))
          (syscall)
          (jb #"prim_write_bytes_panic")
          (ret)))

      ;; read-bytes
      (write-prim-assembly-function/panic #"read_bytes" output
        (varargs list
          ;; Swap %rdi and %rsi
          (movq (reg (rdi)) (reg (rax)))
          (movq (reg (rsi)) (reg (rdi)))
          (movq (reg (rax)) (reg (rsi)))

          ;; %rdi is the file descriptor
          ;; Make %rsi the start of the buffer
          (leaq (scaled (rsi) 1 (rdx) 8) (rsi))
          ;; Make %rdx the length to read
          (sub (reg (rdx)) (rcx))
          (movq (reg (rcx)) (reg (rdx)))
          (movq (imm #x2000003) (reg (rax)))
          (syscall)
          (jb #"prim_read_bytes_panic")
          (ret)))

      ;; open-input-file
      (write-prim-assembly-function/panic #"open_input_file" output
        (varargs list
          ;; Make %rdi point at start of null terminated path
          (add (imm 8) (rdi))
          (movq (imm 0) (reg (rsi))) ;; 0 is read only
          (movq (imm #x2000005) (reg (rax)))
          (syscall)
          (jb #"prim_open_input_file_panic")
          (ret)))

      ;; open-output-file
      (write-prim-assembly-function/panic #"open_output_file" output
        (varargs list
          ;; Make %rdi point at start of null terminated path
          (add (imm 8) (rdi))
          (movq (imm 513) (reg (rsi))) ;; 1 is write only, 512 is create
          (movq (imm 504) (reg (rdx))) ;; 770 for mode
          (movq (imm #x2000005) (reg (rax)))
          (syscall)
          (jb #"prim_open_output_file_panic")
          (ret)))


      ;; close-output-port
      ;; close-input-port
      (write-prim-assembly-function/panic #"close_port" output
        (varargs list
          (movq (imm #x2000006) (reg (rax)))
          (syscall)
          (jb #"prim_close_port_panic")
          (ret)))

      ;; socket
      (write-prim-assembly-function/panic #"socket" output
        (varargs list
          ;; Argument 1: domain
          ;; Argument 2: type
          ;; Argument 3: protocol
          (movq (imm #x2000061) (reg (rax)))
          (syscall)
          (jb #"prim_socket_panic")
          (ret)))

      ;; bind
      (write-prim-assembly-function/panic #"bind" output
        (varargs list
          ;; Argument 1: socket
          ;; Argument 2: sockaddr
          ;; Argument 3: length
          (add (imm 8) (rsi))
          (movq (imm #x2000068) (reg (rax)))
          (syscall)
          (jb #"prim_bind_panic")
          (ret)))

      ;; sendto
      (write-prim-assembly-function/panic #"sendto" output
        (varargs list
          ;; Argument 1: socket
          ;; Argument 2: buffer
          ;; Argument 3: buffer-length
          ;; Argument 4: flags
          ;; Argument 5: sockaddr
          ;; Argument 6: sockaddr-length
          (add (imm 8) (rsi))
          (add (imm 8) (r8))
          (movq (reg (rcx)) (reg (r10)))
          (movq (imm #x2000085) (reg (rax)))
          (syscall)
          (jb #"prim_sendto_panic")
          (ret)))

      ;; recvfrom
      (write-prim-assembly-function/panic #"recvfrom" output
        (varargs list
          ;; Argument 1: socket
          ;; Argument 2: buffer
          ;; Argument 3: buffer-length
          ;; Argument 4: flags
          ;; Argument 5: sockaddr
          ;; Argument 6: sockaddr-length
          (add (imm 8) (rsi))
          (add (imm 8) (r8))
          (add (imm 8) (r9))
          (movq (reg (rcx)) (reg (r10)))
          (movq (imm #x200001d) (reg (rax)))
          (syscall)
          (jb #"prim_recvfrom_panic")
          (ret)))

      ;; connect
      (write-prim-assembly-function/panic #"connect" output
        (varargs list
          ;; Argument 1: socket
          ;; Argument 2: sockaddr
          ;; Argument 3: sockaddr-length
          (add (imm 8) (rsi))
          (movq (imm #x2000062) (reg (rax)))
          (syscall)
          (jb #"prim_connect_panic")
          (ret)))

      ;; shutdown
      (write-prim-assembly-function/panic #"shutdown" output
        (varargs list
          ;; Argument 1: socket
          ;; Argument 2: how
          (movq (imm #x2000086) (reg (rax)))
          (syscall)
          (jb #"prim_shutdown_panic")
          (ret)))


      ;; listen
      (write-prim-assembly-function/panic #"listen" output
        (varargs list
          ;; Argument 1: socket
          ;; Argument 2: backlog
          (movq (imm #x200006A) (reg (rax)))
          (syscall)
          (jb #"prim_listen_panic")
          (ret)))

      ;; accept
      (write-prim-assembly-function/panic #"accept" output
        (varargs list
          ;; Argument 1: socket
          ;; Argument 2: sockaddr
          ;; Argument 3: sockaddr-length
          (add (imm 8) (rsi))
          (add (imm 8) (rdx))
          (movq (imm #x200001E) (reg (rax)))
          (syscall)
          (jb #"prim_accept_panic")
          (ret)))


      ;; setsockopt
      (write-prim-assembly-function/panic #"setsockopt" output
        (varargs list
          ;; Argument 1: socket
          ;; Argument 2: level
          ;; Argument 3: option name
          ;; Argument 4: option value
          ;; Argument 5: option length
          (movq (reg (rcx)) (reg (r10)))
          (add (imm 8) (r10))
          (movq (imm #x2000069) (reg (rax)))
          (syscall)
          (jb #"prim_setsockopt_panic")
          (ret)))


      ;; mach_task_self
      (write-prim-assembly-function/panic #"mach_task_self" output
        (varargs list
          (movq (imm #x100001c) (reg (rax)))
          (syscall)
          (cmpq (imm 0) (reg (rax)))
          (je #"prim_mach_task_self_panic")
          (ret)))


      ;; mach_thread_self
      (write-prim-assembly-function/panic #"mach_thread_self" output
        (varargs list
          (movq (imm #x100001b) (reg (rax)))
          (syscall)
          (cmpq (imm 0) (reg (rax)))
          (je #"prim_mach_thread_self_panic")
          (ret)))


      ;; mach_reply_port
      (write-prim-assembly-function/panic #"mach_reply_port" output
        (varargs list
          (movq (imm #x100001a) (reg (rax)))
          (syscall)
          (cmpq (imm 0) (reg (rax)))
          (je #"prim_mach_reply_port_panic")
          (ret)))


      ;; mach_port_mod_refs
      (write-prim-assembly-function/panic #"mach_port_mod_refs" output
        (varargs list
          (add (imm 32) (rsp)) ;; 4 arguments
          ;; Argument 1: task
          ;; Argument 2: port
          ;; Argument 3: right
          ;; Argument 4: delta
          (movq (reg (rcx)) (reg (r10)))
          (movq (imm #x1000013) (reg (rax)))
          (syscall)
          (cmpq (imm 0) (reg (rax)))
          (jne #"prim_mach_port_mod_refs_panic")
          (ret)))

      ;; mach_msg
      (write-prim-assembly-function/panic #"mach_msg" output
        (varargs list
          (movq (mem (r10) 0) (reg (rax))) ;; Notify Port
          (movq (reg (rcx)) (reg (r10)))

          (add (imm 8) (rdi)) ;; Adjust past buffer's length field
          (pushq (reg (rax))) ;; Push back the notify port
          (pushq (imm 0)) ;; Dummy Return Address
          (movq (imm #x100001f) (reg (rax)))
          (syscall)
          (cmpq (imm 0) (reg (rax)))
          (jne #"prim_mach_msg_panic")
          (add (imm #x10) (rsp)) ;; 2 pop
          (ret)))

      ;; and
      (write-prim-assembly-function #"and" output
        (varargs list
          (and (reg (rdi)) (rsi))
          (movq (reg (rsi)) (reg (rax)))
          (ret)))
      ;; or
      (write-prim-assembly-function #"or" output
        (varargs list
          (or (rdi) (rsi))
          (movq (reg (rsi)) (reg (rax)))
          (ret)))


      ;; bytes-ref
      (write-prim-assembly-function #"bytes_ref" output
        (varargs list
          (movzb (scaled (rdi) 1 (rsi) 8) (rax))
          (ret)))
      ;; make-bytes
      (write-prim-assembly-function #"make_bytes" output
        (varargs list
          (movq (reg (rbp)) (reg (rdx)))
          (movq (reg (rdi)) (mem (rbp) 0))
          (movq (reg (rdi)) (reg (rcx)))
          (add (imm 8) (rbp))
          (movb (imm 0) (reg (al)))
          (movq (reg (rbp)) (reg (rdi)))
          (cld)
          (rep-stosb)
          (movq (reg (rdi)) (reg (rbp)))
          (movq (reg (rdx)) (reg (rax)))
          (ret)))

      ;; bytes-set!
      (write-prim-assembly-function #"bytes_set" output
        (varargs list
          (movb (reg (dl)) (scaled (rdi) 1 (rsi) 8))
          (movq (imm 0) (reg (rax)))
          (ret)))
      ;; bytes-length
      (write-prim-assembly-function #"bytes_length" output
        (varargs list
          (movq (mem (rdi) 0) (reg (rax)))
          (ret)))

      ;; void
      (write-prim-assembly-function #"void" output
        (varargs list
          (movq (imm 0) (reg (rax)))
          (ret)))

      ;; panic
      (write-prim-assembly-function #"panic" output
        (varargs list
          (movq (mem (rsp) 0) (reg (rax)))
          (add (imm 8) (rax))
          (ud2)))

      ;; These are not native functions, but just native subroutines
      ;; They do not follow standard calling conventions


      ;; variant-panic
      (write-block #"prim_variant_panic" output
        (varargs list
          (ud2)))

      ;; thread_bootstrap
      (write-block #"prim_thread_bootstrap" output
        (varargs list
          (pushq (reg (rax)))
          (movq (reg (rax)) (reg (r11)))
          (movq (mem (rax) 0) (reg (rax)))
          (call/indirect (reg (rax)))
          ;; Closure is still on the stack
          (ud2)))))



  (define (write-objects [objects : (List TopLevelObject)] [output : OutputPort]) : Void
    (case objects
      [(empty) (void)]
      [(cons (function-tlo fun) objects)
       (begin
         (write-function fun output)
         (write-objects objects output))]
      [(cons (bytes-tlo name value) objects)
       (begin
         (write-bytes-constant name value output)
         (write-objects objects output))]
      [(cons (trivial-closure-tlo name fun-name) objects)
       (begin
         (write-trivial-closure name fun-name output)
         (write-objects objects output))]))

  (define (write-trivial-closure [name : Bytes] [fun-name : Bytes] [output : OutputPort]) : Void
    (begin
      (write-line #".section __TEXT,__const" output)
      (write-all-bytes name output)
      (write-all-bytes #":" output)
      (newline output)
      (write-all-bytes #".quad " output)
      (write-all-bytes fun-name output)
      (newline output)))

  (define (write-bytes-constant [name : Bytes] [value : Bytes] [output : OutputPort]) : Void
    (begin
      (write-line #".section __DATA,__data" output)
      (write-all-bytes name output)
      (write-all-bytes #":" output)
      (newline output)
      (let ([quote (let ([buf (make-bytes 1)]) (begin (bytes-set! buf 0 34) buf))])
        (begin
          (write-all-bytes #".ascii " output)
          (write-all-bytes quote output)
          (write-all-bytes value output)
          (write-all-bytes quote output)))
      (newline output)))

  (define (write-function [fun : StackFunction] [output : OutputPort]) : Void
    (case fun
      [(stack-function name num-args blocks)
       (begin
         (write-line #".section __TEXT,__text" output)
         (write-all-bytes name output)
         (write-all-bytes #":" output)
         (newline output)
         (write-instructions output
           (jl->list
             (varargs append-jl*
               (if (>= num-args 1)
                   (single-jl (pushq (reg (rdi))))
                   (empty-jl))
               (if (>= num-args 2)
                   (single-jl (pushq (reg (rsi))))
                   (empty-jl))
               (if (>= num-args 3)
                   (single-jl (pushq (reg (rdx))))
                   (empty-jl))
               (if (>= num-args 4)
                   (single-jl (pushq (reg (rcx))))
                   (empty-jl))
               (if (>= num-args 5)
                   (single-jl (pushq (reg (r8))))
                   (empty-jl))
               (if (>= num-args 6)
                   (single-jl (pushq (reg (r9))))
                   (empty-jl))
               (if (>= num-args 7)
                   (install-extra-arguments 0 (- num-args 6))
                   (empty-jl)))))
         (write-basic-blocks name 0 blocks output))]))

  (define (write-basic-blocks [fun-name : Bytes] [index : Byte] [blocks : (List StackBasicBlock)] [output : OutputPort]) : Void
    (case blocks
      [(empty) (void)]
      [(cons block blocks)
       (begin
         (write-basic-block fun-name index block output)
         (write-basic-blocks fun-name (+ index 1) blocks output))]))

  (define (write-basic-block [fun-name : Bytes] [index : Byte] [block : StackBasicBlock] [output : OutputPort]) : Void
    (case block
      [(stack-basic-block cmds terminal)
       (begin
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes index) output)
         (write-all-bytes #":" output)
         (newline output)
         (write-commands cmds output)
         (write-terminal fun-name terminal output))]))

  (define (a) (for-each [f : (a -> Void)] [l : (List a)]) : Void
    (case l
      [(empty) (void)]
      [(cons e l)
       (begin
         (f e)
         (for-each f l))]))

  (define (write-lines [lines : (List (JoinList Bytes))] [output : OutputPort]) : Void
    (for-each
      (lambda ([line : (JoinList Bytes)])
        (begin
          (for-each
            (lambda ([bytes : Bytes]) (write-all-bytes bytes output))
            (jl->list line))
          (newline output)))
      lines))

  (define (write-terminal [fun-name : Bytes] [terminal : StackTerminal] [output : OutputPort]) : Void
    (case terminal
      [(return num-args)
       (begin
         (write-line #"pop %rax" output) ;; Return value
         (write-pop-function-arguments num-args output)
         (write-line #"ret" output))]
      [(uncond-jmp index)
       (begin
         (write-all-bytes #"jmp " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes index) output)
         (newline output))]
      [(boolean-jmp true-index false-index)
       (begin
         (write-line #"pop %rax" output)
         (write-line #"cmpq $0, %rax" output)
         (write-all-bytes #"jne " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes true-index) output)
         (newline output)
         (write-all-bytes #"jmp " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes false-index) output)
         (newline output))]
      [(variant-switch cases)
       (begin
         (write-line #"mov (%rsp), %rax" output)
         (write-variant-switch fun-name cases output))]))

  ;; The current value is in %rax.
  (define (write-variant-switch
            [fun-name : Bytes]
            [cases : VariantCases]
            [output : OutputPort]) : Void
    (case cases
      [(no-catch-all-case)
       (write-line #"ud2" output)]
      [(catch-all-case block)
       (begin
         (write-all-bytes #"jmp " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes block) output)
         (newline output))]
      [(variant-case tag block cases)
       (begin
         (write-all-bytes #"cmpq $" output)
         (write-all-bytes (integer->decimal-bytes tag) output)
         (write-all-bytes #", (%rax)" output)
         (newline output)
         (write-all-bytes #"je " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes block) output)
         (newline output)
         (write-variant-switch fun-name cases output))]))


  (define (write-pop-function-arguments [num-args : Byte] [output : OutputPort]) : Void
    (if (= 0 num-args)
        (void)
        (begin
          (write-line #"pop %rcx" output)
          (write-pop-function-arguments (- num-args 1) output))))

  (define (write-commands [cmds : (List StackCmd)] [output : OutputPort]) : Void
    (case cmds
      [(empty) (void)]
      [(cons cmd cmds)
       (begin
         (write-command cmd output)
         (write-commands cmds output))]))


  (define (write-command [cmd : StackCmd] [output : OutputPort]) : Void
    (case cmd
      [(dup-cmd offset)
       (write-instructions output
         (varargs list
           (pushq (mem (rsp) (* offset 8)))))]
      [(dup-free-var-cmd offset index)
       (write-instructions output
         (varargs list
           (pushq (mem (r11) (* (+ 1 index) 8)))))]
      [(swap-cmd)
       (write-instructions output
         (varargs list
           (pop (reg (rax)))
           (pop (reg (rbx)))
           (pushq (reg (rax)))
           (pushq (reg (rbx)))))]
      [(pop-cmd)
       (write-instructions output
         (varargs list
           (pop (reg (rax)))))]
      [(num-lit-cmd v)
       ;; TODO fix when yaspl supports larger literals
       (write-instructions output
         (let ([max-lit
                (let ([shift (+ #xFF 1)])
                  (+ (* shift (+ (* shift (+ (* shift #xFF) #xFF)) #xFF)) #xFF))])
           (if (> v max-lit)
               (varargs list
                 (movq (imm v) (reg (rax)))
                 (pushq (reg (rax))))
               (varargs list
                 (pushq (imm v))))))]
      [(boolean-lit-cmd v)
       (write-instructions output
         (varargs list
           (pushq (imm (if v 1 0)))))]
      ;; TODO put the bytes not directly in the instruction stream
      [(bytes-lit-cmd v)
       (begin
         (write-line #".byte 0xe9" output)
         (write-all-bytes #".long " output)
         (write-all-bytes (integer->decimal-bytes (+ 8 (bytes-length v))) output)
         (newline output)
         (write-all-bytes #".8byte " output)
         (write-all-bytes (integer->decimal-bytes (bytes-length v)) output)
         (newline output)
         (let ([quote (let ([buf (make-bytes 1)]) (begin (bytes-set! buf 0 34) buf))])
           (begin
             (write-all-bytes #".ascii " output)
             (write-all-bytes quote output)
             (write-all-bytes v output)
             (write-all-bytes quote output)))
         (newline output)
         ;; Need to account for the 7 bytes of leaq
         (write-all-bytes #"leaq -" output)
         (write-all-bytes (integer->decimal-bytes (+ 15 (bytes-length v))) output)
         (write-line #"(%rip), %rax" output)
         (write-line #"push %rax" output))]
      [(bytes-cmp-cmd)
       (write-instructions output
         (varargs list
           (pop (reg (rdi))) ;; Argument 2
           (pop (reg (rsi))) ;; Argument 1
           (movq (mem (rsi) 0) (reg (rcx)))
           (add (imm 8) (rcx))
           (repe-cmpsb)
           (sete (al))
           (movzb (reg (al)) (rax))
           (pushq (reg (rax)))))]

      [(load-global-cmd name)
       (write-instructions output
         (varargs list
           (leaq/rel name (rip) (rax))
           (pushq (reg (rax)))))]

      [(create-closure-cmd n)
       (write-instructions output
         (jl->list
           (varargs append-jl*
             (single-jl (movq (reg (rbp)) (reg (rax))))
             (copy-objects (+ n 1))
             (single-jl (pushq (reg (rax)))))))]
      [(fun-call-cmd n)
       (write-instructions output
         (jl->list
           (varargs append-jl*
             (if (>= n 1)
                 (single-jl (movq (mem (rsp) (- (* 8 n) #x00)) (reg (rdi))))
                 (empty-jl))
             (if (>= n 2)
                 (single-jl (movq (mem (rsp) (- (* 8 n) #x08)) (reg (rsi))))
                 (empty-jl))
             (if (>= n 3)
                 (single-jl (movq (mem (rsp) (- (* 8 n) #x10)) (reg (rdx))))
                 (empty-jl))
             (if (>= n 4)
                 (single-jl (movq (mem (rsp) (- (* 8 n) #x18)) (reg (rcx))))
                 (empty-jl))
             (if (>= n 5)
                 (single-jl (movq (mem (rsp) (- (* 8 n) #x20)) (reg (r8))))
                 (empty-jl))
             (if (>= n 6)
                 (single-jl (movq (mem (rsp) (- (* 8 n) #x28)) (reg (r9))))
                 (empty-jl))
             (if (>= n 7)
                 (cons-jl
                   (movq (reg (rbp)) (reg (r10)))
                   (copy-extra-arguments 6 n))
                 (empty-jl))
             (varargs join-list
               (movq (mem (rsp) 0) (reg (rax)))
               (movq (reg (rax)) (mem (rsp) (* 8 n)))
               (add (imm (* 8 n)) (rsp))
               (movq (mem (rsp) 0) (reg (rax)))
               (movq (reg (r11)) (mem (rsp) 0))
               (movq (reg (rax)) (reg (r11)))
               (movq (mem (rax) 0) (reg (rax)))
               (call/indirect (reg (rax)))
               ;; Read back the closure and then overwrite it
               (movq (mem (rsp) 0) (reg (r11)))
               (movq (reg (rax)) (mem (rsp) 0))))))]
      [(known-fun-call-cmd name _)
       (write-instructions output
         (varargs list
           (pushq (reg (r11)))
           (call name)
           (movq (mem (rsp) 0) (reg (r11)))
           (movq (reg (rax)) (mem (rsp) 0))))]

      [(make-array-cmd)
       (write-instructions output
         (varargs list
           (pop (reg (rax)))
           (pop (reg (rcx)))
           (movq (reg (rbp)) (reg (rdx)))
           (movq (reg (rcx)) (mem (rbp) 0))
           (add (imm 8) (rbp))
           (movq (reg (rbp)) (reg (rdi)))
           (rep-stosq)
           (movq (reg (rdi)) (reg (rbp)))
           (pushq (reg (rdx)))))]
      [(make-array-from-stack-cmd num-args)
       (write-instructions output
         (varargs list
           (movq (imm num-args) (reg (rcx)))
           (movq (reg (rsp)) (reg (rsi)))
           (movq (reg (rbp)) (reg (rax)))
           (leaq (scaled (rsp) 8 (rcx) 0) (rsp))
           (movq (reg (rcx)) (mem (rbp) 0))
           (leaq (mem (rbp) 8) (rdi))
           (leaq (scaled (rbp) 8 (rcx) 8) (rbp))
           (cld)
           (rep-movsq)
           (pushq (reg (rax)))))]
      [(array-length-cmd)
       (write-instructions output
         (varargs list
           (pop (reg (rax)))
           (pushq (mem (rax) 0))))]
      [(array-ref-cmd)
       (write-instructions output
         (varargs list
           (pop (reg (rcx)))
           (pop (reg (rax)))
           (pushq (scaled (rax) 8 (rcx) 8))))]
      [(array-set!-cmd)
       (write-instructions output
         (varargs list
           (pop (reg (rdx)))
           (pop (reg (rcx)))
           (pop (reg (rax)))
           (movq (reg (rdx)) (scaled (rax) 8 (rcx) 8))
           (pushq (imm 0))))]

      [(bin-logic-math-cmd op)
       (write-instructions output
         (varargs list
           (pop (reg (rax))) ;; Argument 2
           (pop (reg (rcx))) ;; Argument 1
           (cmpq (reg (rax)) (reg (rcx)))
           (case op
             [(less-than-op)
              (setl (al))]
             [(less-than-or-equal-op)
              (setle (al))]
             [(equal-op)
              (sete (al))]
             [(greater-than-or-equal-op)
              (setge (al))]
             [(greater-than-op)
              (setg (al))])
           (movzb (reg (al)) (rax))
           (pushq (reg (rax)))))]
      [(bin-math-cmd (bin-add-op))
       (write-instructions output
         (varargs list
           (pop (reg (rax)))
           (pop (reg (rcx)))
           (add (reg (rcx)) (rax))
           (pushq (reg (rax)))))]
      [(bin-math-cmd (bin-sub-op))
       (write-instructions output
         (varargs list
           (pop (reg (rcx)))
           (pop (reg (rax)))
           (sub (reg (rcx)) (rax))
           (pushq (reg (rax)))))]
      [(bin-math-cmd (bin-mult-op))
       (write-instructions output
         (varargs list
           (pop (reg (rax)))
           (pop (reg (rcx)))
           (imulq (rcx))
           (pushq (reg (rax)))))]
      [(bin-math-cmd (bin-quotient-op))
       (write-instructions output
         (varargs list
           (pop (reg (rcx)))
           (pop (reg (rax)))
           (movq (imm 0) (reg (rdx)))
           (idivq (rcx))
           (pushq (reg (rax)))))]
      [(bin-math-cmd (bin-remainder-op))
       (write-instructions output
         (varargs list
           (pop (reg (rcx)))
           (pop (reg (rax)))
           (movq (imm 0) (reg (rdx)))
           (idivq (rcx))
           (pushq (reg (rdx)))))]
      [(alloc-variant-cmd tag fields)
       (write-instructions output
         (jl->list
           (varargs append-jl*
             (single-jl (movq (reg (rbp)) (reg (rax))))
             (single-jl (movq (imm tag) (mem (rbp) 0)))
             (single-jl (add (imm 8) (rbp)))
             (copy-objects fields)
             (single-jl (pushq (reg (rax)))))))]
      [(variant-ref-cmd tag field)
       (write-instructions output
         (varargs list
           (pop (reg (rax)))
           (cmpq (imm tag) (mem (rax) 0))
           (jne #"prim_variant_panic")
           (pushq (mem (rax) (+ (* 8 field) 8)))))]))


  ;; Generates assembly to copy `args` arguments from the top of the stack to the
  ;; memory starting at %rbp. %rbp ends up pointing right after after the last argument written.
  ;; Dirties %rax
  (define (copy-extra-arguments [arg : Byte] [args : Byte]) : (JoinList Instruction)
    (if (= arg args)
        (empty-jl)
        (cons-jl
          (movq (mem (rsp) (* (- args arg) 8)) (reg (rax)))
          (cons-jl
            (movq (reg (rax)) (mem (rbp) 0))
            (cons-jl
              (add (imm 8) (rbp))
              (copy-extra-arguments (+ 1 arg) args))))))

  ;; Generates assembly to install `args` arguments from %r10 ontop of the stack
  (define (install-extra-arguments [arg : Byte] [args : Byte]) : (JoinList Instruction)
    (if (= arg args)
        (empty-jl)
        (cons-jl
          (pushq (mem (r10) (* arg 8)))
          (install-extra-arguments (+ 1 arg) args))))


  ;; Generates assembly to copy n objects from the top of the stack to the
  ;; memory starting at %rbp. %rbp ends up pointing right after after the last object written.
  (define (copy-objects [n : Byte]) : (JoinList Instruction)
    (if (> n 0)
        (cons-jl
          (pop (mem (rbp) 0))
          (cons-jl
            (add (imm 8) (rbp))
            (copy-objects (- n 1))))
        (empty-jl)))



  ;; TODO switch to a polymorphic one when it works
  (define (a) (extract-either [either : (Either Bytes a)]) : a
    (case either
      [(right v) v]
      [(left v) (panic v)])))
