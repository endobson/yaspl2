#:module (x86-64-stack-machine)
#:import {
  (bytes)
  (io)
  (join-list)
  (list)
  (maybe)
  (numbers)
  (prim)
  (stack-machine)
}
(export
  #:types (Section BasicBlock Instruction Register MCCommand AssemblyFragments
           TextFragment ConstFragment)
  #:values (write-fragments convert-objects assembly-commands->bytes
            instruction->mc-commands instruction->assembly-bytes function-fragment rax rdi
            rsi rdx rcx r8 r9 imm-s32 rmi-imm movq reg addq subq orq andq al dil sil dl cl r8b r9b
            r10b r11b bpl
            cmpq sete movzbq setne setle setge setl setg imulq jne imm jmp ret
            syscall call rsp mem leaq/rip-rel r15 pushq je jl jg jle jge r10 jb scale-1 scaled leaq
            address-fragment call/indirect r11 ud2 shrq movb rep-stosb cld rbp nop r14
            rep-movsb repne-scasb popq scale-8 decq notq repne-scasq
            section-blocks basic-block section test assembly-fragments
            text-fragment->commands const-fragment->commands)
  #:patterns (function-fragment address-fragment bytes-fragment mc-bytes
              assembly-fragments))
(types
  (define-type AssemblyFragments
    (assembly-fragments
      [text-fragments : (List TextFragment)]
      [const-fragments : (List ConstFragment)]))

  (define-type TextFragment
    (function-fragment [name : Bytes] [sections : (List Section)]))
  (define-type ConstFragment
    (address-fragment [name : Bytes] [value : Bytes])
    (bytes-fragment [name : Bytes] [value : Bytes]))

  (define-type Section
    (section [blocks : (List BasicBlock)]))
  (define-type BasicBlock
    (basic-block [name : Bytes] [instructions : (JoinList Instruction)]))

  (define-type MCCommand
    (mc-bytes [bytes : Bytes])
    (mc-branch-relocation [symbol : Bytes])
    (mc-signed-relocation [symbol : Bytes]))

  (define-type AssemblyCommand
    (directive-cmd [directive : AssemblerDirective])
    (instruction-cmd [instruction : Instruction]))
  (define-type AssemblerDirective
    (section-directive [segment-name : Bytes] [section-name : Bytes])
    (global-directive [label : Bytes])
    (label-directive [name : Bytes])
    (quad-directive/label [label : Bytes])
    (quad-directive/integer [value : Int])
    (ascii-directive [value : Bytes]))
  (define-type Instruction
    (addq [rmi : RegMemImm] [reg : Register])
    (andq [reg1 : RegMemImm] [reg2 : Register])
    (call [label : Bytes])
    (call/indirect [reg : Register])
    (cld)
    (cmpq [rmi1 : RegMemImm] [rmi2 : RegMemImm])
    (decq [reg : Register])
    (idivq [reg : Register])
    (imulq [reg1 : Register] [reg2 : Register])
    (incq [reg : Register])
    (jb [label : Bytes])
    (je [label : Bytes])
    (jl [label : Bytes])
    (jg [label : Bytes])
    (jle [label : Bytes])
    (jge [label : Bytes])
    (jmp [label : Bytes])
    (jmp/indirect [reg : Register])
    (jne [label : Bytes])
    (jnz [label : Bytes])
    (leaq [rmi : RegMemImm] [reg : Register])
    (leaq/rip-rel [label : Bytes] [reg : Register])
    (lahf)
    (movb [rmi1 : RegMemImm] [rmi2 : RegMemImm])
    (movq [rmi1 : RegMemImm] [rmi2 : RegMemImm])
    (movzbq [rmi : RegMemImm] [r : Register])
    (nop)
    (notq [reg : Register])
    (orq [reg1 : Register] [reg2 : Register])
    (popq [rmi : RegMemImm])
    (pushq [rmi : RegMemImm])
    (rep-movsb)
    (rep-movsq)
    (rep-stosb)
    (rep-stosq)
    (repe-cmpsb)
    (repne-scasb)
    (repne-scasq)
    (ret)
    (sete [reg : Register])
    (setg [reg : Register])
    (setge [reg : Register])
    (setl [reg : Register])
    (setle [reg : Register])
    (setne [reg : Register])
    (shlq [reg : Register])
    (shrq [reg : Register])
    (std)
    (subq [rmi : RegMemImm] [reg : Register])
    (syscall)
    (test [rmi1 : RegMemImm] [rmi2 : RegMemImm])
    (ud2))
  (define-type Register
    ;; 8 Bit registers
    (al)
    (ah)
    (bl)
    (bh)
    (cl)
    (ch)
    (dl)
    (dh)
    (dil)
    (sil)
    (bpl)
    (spl)
    (r8b)
    (r9b)
    (r10b)
    (r11b)
    (r12b)
    (r13b)
    (r14b)
    (r15b)
    ;; 16 bit registers
    (ax)
    (bx)
    (cx)
    (dx)
    (di)
    (si)
    (bp)
    (sp)
    (r8w)
    (r9w)
    (r10w)
    (r11w)
    (r12w)
    (r13w)
    (r14w)
    (r15w)
    ;; 32 bit registers
    (eax)
    (ebx)
    (ecx)
    (edx)
    (edi)
    (esi)
    (ebp)
    (esp)
    (r8d)
    (r9d)
    (r10d)
    (r11d)
    (r12d)
    (r13d)
    (r14d)
    (r15d)
    ;;64 bit registers
    (rax)
    (rbx)
    (rcx)
    (rdx)
    (rdi)
    (rsi)
    (rbp)
    (rsp)
    (r8)
    (r9)
    (r10)
    (r11)
    (r12)
    (r13)
    (r14)
    (r15))
  (define-type RegMemImm
    (rmi-register [r : Register])
    (rmi-direct-memory [reg : Register])
    (rmi-displaced-memory [reg : Register] [offset : S32])
    (rmi-scaled-memory [reg : Register] [scale : Scale] [index-reg : Register] [offset : S32])
    (rmi-imm [v : Immediate]))
  (define-type Immediate
    (imm-s32 [v : S32])
    (imm-s64 [v : EightBytesLe]))
  (define-type Scale
    (scale-1)
    (scale-2)
    (scale-4)
    (scale-8)))


;; Generates a text version of the assembly commands.
(define (assembly-commands->bytes [cmds : (List AssemblyCommand)]) : (JoinList Bytes)
  (case cmds
    [(empty) (empty-jl)]
    [(cons cmd cmds)
     (append-jl
       (assembly-command->bytes cmd)
       (cons-jl
         #"\n"
         (assembly-commands->bytes cmds)))]))

(define (assembly-command->bytes [cmd : AssemblyCommand]) : (JoinList Bytes)
  (case cmd
    [(directive-cmd directive) (assembler-directive->bytes directive)]
    [(instruction-cmd instruction) (instruction->assembly-bytes instruction)]))

(define (assembler-directive->bytes [dir : AssemblerDirective]) : (JoinList Bytes)
  (case dir
    [(section-directive seg sect)
     (varargs join-list #".section " seg #"," sect)]
    [(global-directive label)
     (varargs join-list #".global \"" label #"\"")]
    [(label-directive name)
     (varargs join-list #"\"" name #"\"" #":")]
    [(quad-directive/label label)
     (varargs join-list #".quad \"" label #"\"")]
    [(quad-directive/integer value)
     (varargs join-list #".quad " (integer->decimal-bytes value))]
    [(ascii-directive value)
     (varargs append-jl*
       (single-jl #".ascii \"")
       (escape-bytes value 0 0)
       (single-jl #"\""))]))

(define (escape-bytes [src : Bytes] [start : Int] [cur : Int]) : (JoinList Bytes)
  (if (= cur (bytes-length src))
      (single-jl (subbytes src start cur))
      (let ([byte (bytes-ref src cur)])
        (if (= byte 10) ;; newline
            (cons-jl
              (subbytes src start cur)
              (cons-jl #"\\n" (escape-bytes src (+ 1 cur) (+ 1 cur))))
            (if (= byte 13) ;; carriage return
                (cons-jl
                  (subbytes src start cur)
                  (cons-jl #"\\r" (escape-bytes src (+ 1 cur) (+ 1 cur))))
                (if (= byte 34) ;; double quote
                    (cons-jl
                      (subbytes src start cur)
                      (cons-jl #"\\\"" (escape-bytes src (+ 1 cur) (+ 1 cur))))
                    (if (= byte 92) ;; backslash
                        (cons-jl
                          (subbytes src start cur)
                          (cons-jl #"\\\\" (escape-bytes src (+ 1 cur) (+ 1 cur))))
                        (escape-bytes src start (+ 1 cur)))))))))

(define (mc-bytes* [bytes : Bytes]) : (JoinList MCCommand)
  (single-jl (mc-bytes bytes)))
(define (mc-branch* [op-code : Bytes] [symbol : Bytes]) : (JoinList MCCommand)
  (varargs join-list
    (mc-bytes op-code)
    (mc-branch-relocation symbol)
    (mc-bytes (varargs bytes #x00 #x00 #x00 #x00))))

(define (instruction->mc-commands [inst : Instruction]) : (JoinList MCCommand)
  (case inst
    [(addq (rmi-register reg1) reg2)
     (mc-bytes* (single-byte-op/RM #x01 #t reg1 reg2))]
    [(addq (rmi-imm (imm-s32 imm)) reg)
     (mc-bytes* (single-byte-op/IM #x81 0 #t imm reg))]
    [(addq (rmi-imm _) reg)
     (panic #"addq of non-s32 immediate not supported")]
    [(addq (rmi-direct-memory reg1) reg2)
     (mc-bytes* (single-byte-op/MR/mem #x03 #t reg1 reg2))]
    [(addq (rmi-displaced-memory reg1 offset) reg2)
     (panic #"addq of displaced-memory not supported")]
    [(addq (rmi-scaled-memory reg1 scale reg2 offset) reg3)
     (mc-bytes* (single-byte-op/MR/scaled-mem #x03 #t reg1 scale reg2 offset reg3))]
    [(andq (rmi-register reg1) reg2)
     (mc-bytes* (single-byte-op/RM #x21 #t reg1 reg2))]
    [(andq (rmi-imm (imm-s32 imm)) reg)
     (mc-bytes* (single-byte-op/IM #x81 4 #t imm reg))]
    [(andq (rmi-imm _) reg)
     (panic #"andq of non-s32 immediate not supported")]
    [(andq (rmi-direct-memory _) _)
     (panic #"andq of direct memory not yet supported")]
    [(andq (rmi-displaced-memory _ _) _)
     (panic #"andq of displaced memory not yet supported")]
    [(andq (rmi-scaled-memory _ _ _ _) _)
     (panic #"andq of scaled memory not yet supported")]
    [(call label)
     (mc-branch* (varargs bytes #xE8) label)]
    [(call/indirect reg)
     (mc-bytes* (single-byte-op/M #xFF 2 #f reg))]
    [(cld) (mc-bytes* (varargs bytes #xFC))]
    [(cmpq (rmi-imm (imm-s32 imm)) (rmi-register reg))
     (mc-bytes* (single-byte-op/IM #x81 7 #t imm reg))]
    [(cmpq (rmi-imm (imm-s32 imm)) (rmi-direct-memory reg))
     (mc-bytes* (single-byte-op/IM/mem #x81 7 #t imm reg))]
    [(cmpq (rmi-register reg1) (rmi-register reg2))
     (mc-bytes* (single-byte-op/MR #x3B #t reg1 reg2))]
    [(cmpq _ (rmi-imm imm))
     (panic #"cmpq with immediate second argument is not allowed")]
    [(cmpq _ _)
     (panic #"cmpq variant not supported")]
    [(decq reg)
     (mc-bytes* (single-byte-op/M #xFF 1 #t reg))]
    [(idivq reg)
     (mc-bytes* (single-byte-op/M #xF7 7 #t reg))]
    [(imulq reg1 reg2)
     (mc-bytes* (double-byte-op/MR #xAF #t reg1 reg2))]
    [(incq reg)
     (mc-bytes* (single-byte-op/M #xFF 0 #t reg))]
    [(jb label)
     (mc-branch* (varargs bytes #x0F #x82) label)]
    [(je label)
     (mc-branch* (varargs bytes #x0F #x84) label)]
    [(jl label)
     (mc-branch* (varargs bytes #x0F #x8C) label)]
    [(jg label)
     (mc-branch* (varargs bytes #x0F #x8F) label)]
    [(jle label)
     (mc-branch* (varargs bytes #x0F #x8E) label)]
    [(jge label)
     (mc-branch* (varargs bytes #x0F #x8D) label)]
    [(jmp label)
     (mc-branch* (varargs bytes #xE9) label)]
    [(jmp/indirect reg)
     (mc-bytes* (single-byte-op/M #xFF 4 #f reg))]
    [(jne label)
     (mc-branch* (varargs bytes #x0F #x85) label)]
    [(jnz label)
     (mc-branch* (varargs bytes #x0F #x85) label)]
    [(lahf) (mc-bytes* (varargs bytes #x9F))]
    [(leaq (rmi-direct-memory _) _)
     (panic #"leaq of direct memory not yet supported")]
    [(leaq (rmi-displaced-memory reg1 offset) reg2)
     (mc-bytes* (single-byte-op/MR/displaced-mem #x8D #t reg1 offset reg2))]
    [(leaq (rmi-scaled-memory reg1 scale reg2 offset) reg3)
     (mc-bytes* (single-byte-op/MR/scaled-mem #x8D #t reg1 scale reg2 offset reg3))]
    [(leaq (rmi-register _) _)
     (panic #"leaq of register is non sensical")]
    [(leaq (rmi-imm _) _)
     (panic #"leaq of immediate is non sensical")]
    [(movb (rmi-register reg1) (rmi-scaled-memory reg2 scale reg3 offset))
     (mc-bytes* (single-byte-op/RM/scaled-mem #x88 #f reg1 reg2 scale reg3 offset))]
    [(movb _ (rmi-imm _))
     (panic #"movb to immediate is nonsensical")]
    [(movb _ _)
     (panic #"movb variant is not yet supported")]
    [(movq (rmi-imm (imm-s32 imm)) (rmi-register reg))
     (mc-bytes* (single-byte-op/IM #xC7 0 #t imm reg))]
    [(movq (rmi-imm (imm-s32 imm)) (rmi-direct-memory reg))
     (mc-bytes* (single-byte-op/IM/mem #xC7 0 #t imm reg))]
    [(movq (rmi-imm (imm-s32 imm)) (rmi-displaced-memory reg offset))
     (mc-bytes* (single-byte-op/IM/displaced-mem #xC7 0 #t imm reg offset))]
    [(movq (rmi-imm _) (rmi-displaced-memory _ _))
     (panic #"movq of non-s32 to displaced memory not yet supported")]
    [(movq (rmi-imm (imm-s64 imm)) (rmi-register reg))
     (mc-bytes* (single-byte-op-s64/IO #xB8 #t imm reg))]
    [(movq (rmi-register reg1) (rmi-register reg2))
     (mc-bytes* (single-byte-op/MR #x8B #t reg1 reg2))]
    [(movq (rmi-scaled-memory reg1 scale reg2 offset) (rmi-register reg3))
     (mc-bytes* (single-byte-op/MR/scaled-mem #x8B #t reg1 scale reg2 offset reg3))]
    [(movq (rmi-register reg1) (rmi-direct-memory reg2))
     (mc-bytes* (single-byte-op/RM/mem #x89 #t reg1 reg2))]
    [(movq (rmi-register reg1) (rmi-displaced-memory reg2 offset))
     (mc-bytes* (single-byte-op/RM/displaced-mem #x89 #t reg1 reg2 offset))]
    [(movq (rmi-register reg1) (rmi-scaled-memory reg2 scale reg3 offset))
     (mc-bytes* (single-byte-op/RM/scaled-mem #x89 #t reg1 reg2 scale reg3 offset))]
    [(movq (rmi-direct-memory reg1) (rmi-register reg2))
     (mc-bytes* (single-byte-op/MR/mem #x8B #t reg1 reg2))]
    [(movq (rmi-displaced-memory reg1 offset) (rmi-register reg2))
     (mc-bytes* (single-byte-op/MR/displaced-mem #x8B #t reg1 offset reg2))]
    [(movq _ (rmi-imm _))
     (panic #"movq to immediate is nonsensical")]
    [(movq _ _)
     (panic #"movq variant is not yet supported")]
    [(movzbq (rmi-register reg1) reg2)
     (mc-bytes* (double-byte-op/MR #xB6 #t reg1 reg2))]
    [(movzbq (rmi-imm _) _)
     (panic #"movzbq of immediate is not allowed")]
    [(movzbq (rmi-direct-memory _) _)
     (panic #"movzbq of direct memory not yet supported")]
    [(movzbq (rmi-displaced-memory _ _) _)
     (panic #"movzbq of displaced memory not yet supported")]
    [(movzbq (rmi-scaled-memory reg1 scale reg2 offset) reg3)
     (mc-bytes* (double-byte-op/MR/scaled-mem #xB6 #t reg1 scale reg2 offset reg3))]
    [(nop) (mc-bytes* (varargs bytes #x90))]
    [(notq reg)
     (mc-bytes* (single-byte-op/M #xF7 2 #t reg))]
    [(orq reg1 reg2)
     (mc-bytes* (single-byte-op/MR #x0B #t reg1 reg2))]
    ;; pop defaults to 64 bits so we don't need REX.W bit to indicate that
    [(popq (rmi-register reg))
     (mc-bytes* (single-byte-op/O #x58 reg))]
    [(popq (rmi-direct-memory reg))
     (mc-bytes* (single-byte-op/M/mem #x8F 0 #f reg))]
    [(popq (rmi-displaced-memory reg offset))
     (mc-bytes* (single-byte-op/M/displaced-mem #x8F 0 #f reg offset))]
    [(popq (rmi-imm _))
     (panic #"popq of immediate is nonsensical")]
    [(popq (rmi-scaled-memory _ _ _ _))
     (panic #"popq of scaled memory not yet supported")]
    ;; push defaults to 64 bits so we don't need REX.W bit to indicate that
    [(pushq (rmi-register reg))
     (mc-bytes* (single-byte-op/O #x50 reg))]
    [(pushq (rmi-direct-memory reg))
     (mc-bytes* (single-byte-op/M/mem #xFF 6 #f reg))]
    [(pushq (rmi-displaced-memory reg offset))
     (mc-bytes* (single-byte-op/M/displaced-mem #xFF 6 #f reg offset))]
    [(pushq (rmi-scaled-memory reg1 scale reg2 offset))
     (mc-bytes* (single-byte-op/M/scaled-mem #xFF 6 #f reg1 scale reg2 offset))]
    [(pushq (rmi-imm (imm-s32 imm)))
     (mc-bytes* (single-byte-op/I #x68 #f imm))]
    [(pushq (rmi-imm _))
     (panic #"pushq of non-s32 immediates not yet supported")]
    [(rep-movsb) (mc-bytes* (varargs bytes #xF3 #x48 #xA4))]
    [(rep-movsq) (mc-bytes* (varargs bytes #xF3 #x48 #xA5))]
    [(rep-stosb) (mc-bytes* (varargs bytes #xF3 #x48 #xAA))]
    [(rep-stosq) (mc-bytes* (varargs bytes #xF3 #x48 #xAB))]
    [(repe-cmpsb) (mc-bytes* (varargs bytes #xF3 #x48 #xA6))]
    [(repne-scasb) (mc-bytes* (varargs bytes #xF2 #x48 #xAE))]
    [(repne-scasq) (mc-bytes* (varargs bytes #xF2 #x48 #xAF))]
    [(ret) (mc-bytes* (varargs bytes #xC3))]
    [(sete reg)
     (mc-bytes* (double-byte-op/M #x94 0 #f reg))]
    [(setg reg)
     (mc-bytes* (double-byte-op/M #x9F 0 #f reg))]
    [(setge reg)
     (mc-bytes* (double-byte-op/M #x9D 0 #f reg))]
    [(setl reg)
     (mc-bytes* (double-byte-op/M #x9C 0 #f reg))]
    [(setle reg)
     (mc-bytes* (double-byte-op/M #x9E 0 #f reg))]
    [(setne reg)
     (mc-bytes* (double-byte-op/M #x95 0 #f reg))]
    [(shlq reg)
     (mc-bytes* (single-byte-op/M #xD3 4 #t reg))]
    [(shrq reg)
     (mc-bytes* (single-byte-op/M #xD3 5 #t reg))]
    [(std) (mc-bytes* (varargs bytes #xFD))]
    [(subq (rmi-register reg1) reg2)
     (mc-bytes* (single-byte-op/RM #x29 #t reg1 reg2))]
    [(subq (rmi-imm (imm-s32 imm)) reg)
     (mc-bytes* (single-byte-op/IM #x81 5 #t imm reg))]
    [(subq (rmi-imm _) reg)
     (panic #"subq of non-s32 immediate not supported")]
    [(subq (rmi-direct-memory reg1) reg2)
     (mc-bytes* (single-byte-op/MR/mem #x2B #t reg1 reg2))]
    [(subq (rmi-displaced-memory _ _) _)
     (panic #"subq of displaced memory not yet supported")]
    [(subq (rmi-scaled-memory _ _ _ _) _)
     (panic #"subq of scaled memory not yet supported")]
    [(syscall) (mc-bytes* (varargs bytes #x0F #x05))]
    [(test (rmi-register reg1) (rmi-register reg2))
     (mc-bytes* (single-byte-op/RM #x85 #t reg1 reg2))]
    [(test _ _)
     (panic #"test of non registers not yet supported")]
    [(ud2) (mc-bytes* (varargs bytes #x0F #x0B))]
    [(leaq/rip-rel label reg)
     (let ([reg-val (register->byte reg)])
       (varargs join-list
         (mc-bytes (add-maybe-byte
                     (rex-byte #t (>= reg-val 8) #f #f)
                     (varargs bytes
                              #x8D
                              (mod-rm-byte #x00 reg-val #x05))))
         (mc-signed-relocation label)
         (mc-bytes (varargs bytes 0 0 0 0))))]))

;; mod is truncated to two bits, and reg and rm are truncated to three.
(define (mod-rm-byte [mod : Int] [reg : Int] [rm : Int]) : Int
  (bitwise-ior (logical-shift-left (bitwise-and mod #x03) 6)
     (bitwise-ior (logical-shift-left (bitwise-and reg #x07) 3)
                  (bitwise-and rm #x07))))

;; TODO refine types of opcodes to be the right number of bits.
(define (single-byte-op/O [opcode : Int] [reg : Register]) : Bytes
  (let ([reg-val (register->byte reg)])
    (add-maybe-byte
      (rex-byte #f #f #f (>= reg-val 8))
      (varargs bytes
        (bitwise-ior opcode (bitwise-and reg-val #x07))))))

(define (single-byte-op/M [opcode : Int] [op-ext : Int] [rexW : Boolean] [reg : Register]) : Bytes
  (let ([rm (register->byte reg)])
    (add-maybe-byte
      (rex-byte rexW #f #f (>= rm 8))
      (varargs bytes
        opcode
        (mod-rm-byte #x03 op-ext rm)))))

(define (single-byte-op/I [opcode : Int] [rexW : Boolean] [imm : S32]) : Bytes
  (add-maybe-byte
    (rex-byte rexW #f #f #f)
    (let ([v (varargs bytes opcode 0 0 0 0)])
      (begin
        (bytes-set!/s32-le v 1 imm)
        v))))

 (define (single-byte-op-s64/IO [opcode : Int] [rexW : Boolean] [imm : EightBytesLe] [reg : Register]) : Bytes
   (let ([reg-val (register->byte reg)])
     (add-maybe-byte
       (rex-byte rexW #f #f (>= reg-val 8))
       (let ([v (varargs bytes
                  (bitwise-ior opcode (bitwise-and reg-val #x07))
                  0 0 0 0 0 0 0 0)])
         (begin
           (bytes-set!/eight-bytes-le v 1 imm)
           v)))))

(define (single-byte-op/M/mem [opcode : Int] [op-ext : Int] [rexW : Boolean] [reg : Register]) : Bytes
  (let ([rm (register->byte reg)])
    (add-maybe-byte
      (rex-byte rexW #f #f (>= rm 8))
      (varargs bytes
        opcode
        (mod-rm-byte #x00 op-ext rm)))))

;; Doesn't support rsp or r12. This is because the instruction set doesn't support them.
(define (single-byte-op/M/displaced-mem
          [opcode : Int] [op-ext : Int] [rexW : Boolean] [reg : Register] [displacement : S32]) : Bytes
  (let ([rm (register->byte reg)])
    (add-maybe-byte
      (rex-byte rexW #f #f (>= rm 8))
      (let ([v (varargs bytes
                 opcode
                 (mod-rm-byte #x02 op-ext rm)
                 0 0 0 0)])
        (begin
          (bytes-set!/s32-le v 2 displacement)
          v)))))

(define (single-byte-op/M/scaled-mem
          [opcode : Int] [op-ext : Int] [rexW : Boolean]
          [reg1 : Register] [scale : Scale] [reg2 : Register] [displacement : S32]) : Bytes
  (let ([base (register->byte reg1)])
    (let ([index (register->byte reg2)])
      (add-maybe-byte
        (rex-byte rexW #f (>= index 8) (>= base 8))
        (let ([v (varargs bytes
                   opcode
                   (mod-rm-byte #x02 op-ext #x04)
                   (sib-byte scale reg2 reg1)
                   0 0 0 0)])
          (begin
            (bytes-set!/s32-le v 3 displacement)
            v))))))


(define (single-byte-op/IM [opcode : Int] [op-ext : Int] [rexW : Boolean]
                           [val : S32] [reg : Register]) : Bytes
  (let ([rm (register->byte reg)])
    (add-maybe-byte
      (rex-byte rexW #f #f (>= rm 8))
      (let ([v (varargs bytes
                 opcode
                 (mod-rm-byte #x03 op-ext rm)
                 0 0 0 0)])
        (begin
          (bytes-set!/s32-le v 2 val)
          v)))))

(define (single-byte-op/IM/mem [opcode : Int] [op-ext : Int] [rexW : Boolean]
                               [val : S32] [reg : Register]) : Bytes
  (let ([rm (register->byte reg)])
    (add-maybe-byte
      (rex-byte rexW #f #f (>= rm 8))
      (let ([v (varargs bytes
                 opcode
                 (mod-rm-byte #x00 op-ext rm)
                 0 0 0 0)])
        (begin
          (bytes-set!/s32-le v 2 val)
          v)))))

;; Doesn't support rsp or r12. This is because the instruction set doesn't support them.
(define (single-byte-op/IM/displaced-mem
          [opcode : Int] [op-ext : Int] [rexW : Boolean] [val : S32]
          [reg : Register] [displacement : S32]) : Bytes
  (let ([rm (register->byte reg)])
    (add-maybe-byte
      (rex-byte rexW #f #f (>= rm 8))
      (let ([v (varargs bytes
                 opcode
                 (mod-rm-byte #x02 op-ext rm)
                 0 0 0 0 0 0 0 0)])
        (begin
          (bytes-set!/s32-le v 2 displacement)
          (bytes-set!/s32-le v 6 val)
          v)))))

(define (single-byte-op/RM [opcode : Int] [rexW : Boolean] [reg1 : Register] [reg2 : Register]) : Bytes
  (let ([reg (register->byte reg1)])
    (let ([rm (register->byte reg2)])
      (add-maybe-byte
        (rex-byte rexW (>= reg 8) #f (>= rm 8))
        (varargs bytes
          opcode
          (mod-rm-byte #x03 reg rm))))))
(define (single-byte-op/MR [opcode : Int] [rexW : Boolean] [reg1 : Register] [reg2 : Register]) : Bytes
  (single-byte-op/RM opcode rexW reg2 reg1))

;; Doesn't support rsp, rbp, r12 or r13. This is because the instruction set doesn't support them.
(define (single-byte-op/RM/mem [opcode : Int] [rexW : Boolean] [reg1 : Register] [reg2 : Register]) : Bytes
  (let ([reg (register->byte reg1)])
    (let ([rm (register->byte reg2)])
      (add-maybe-byte
        (rex-byte rexW (>= reg 8) #f (>= rm 8))
        (varargs bytes
          opcode
          (mod-rm-byte #x00 reg rm))))))
(define (single-byte-op/MR/mem [opcode : Int] [rexW : Boolean] [reg1 : Register] [reg2 : Register]) : Bytes
  (single-byte-op/RM/mem opcode rexW reg2 reg1))

;; Doesn't support rsp or r12. This is because the instruction set doesn't support them.
(define (single-byte-op/RM/displaced-mem
          [opcode : Int] [rexW : Boolean]
          [reg1 : Register]
          [reg2 : Register] [displacement : S32]) : Bytes
  (let ([reg (register->byte reg1)])
    (let ([rm (register->byte reg2)])
      (add-maybe-byte
        (rex-byte rexW (>= reg 8) #f (>= rm 8))
        (let ([v (varargs bytes
                   opcode
                   (mod-rm-byte #x02 reg rm)
                   0 0 0 0)])
          (begin
            (bytes-set!/s32-le v 2 displacement)
            v))))))
(define (single-byte-op/MR/displaced-mem
          [opcode : Int] [rexW : Boolean]
          [reg1 : Register] [displacement : S32]
          [reg2 : Register]) : Bytes
  (single-byte-op/RM/displaced-mem opcode rexW reg2 reg1 displacement))

(define (single-byte-op/RM/scaled-mem
          [opcode : Int] [rexW : Boolean]
          [reg1 : Register]
          [reg2 : Register] [scale : Scale] [reg3 : Register] [displacement : S32]) : Bytes
  (let ([reg (register->byte reg1)])
    (let ([base (register->byte reg2)])
      (let ([index (register->byte reg3)])
        (add-maybe-byte
          (rex-byte rexW (>= reg 8) (>= index 8) (>= base 8))
          (let ([v (varargs bytes
                     opcode
                     (mod-rm-byte #x02 reg #x04)
                     (sib-byte scale reg3 reg2)
                     0 0 0 0)])
            (begin
              (bytes-set!/s32-le v 3 displacement)
              v)))))))
(define (single-byte-op/MR/scaled-mem
          [opcode : Int] [rexW : Boolean]
          [reg1 : Register] [scale : Scale] [reg2 : Register] [displacement : S32]
          [reg3 : Register]) : Bytes
  (single-byte-op/RM/scaled-mem opcode rexW reg3 reg1 scale reg2 displacement))

(define (double-byte-op/MR [opcode : Int] [rexW : Boolean] [reg1 : Register] [reg2 : Register]) : Bytes
  (let ([rm (register->byte reg1)])
    (let ([reg (register->byte reg2)])
      (add-maybe-byte
        (rex-byte rexW (>= reg 8) #f (>= rm 8))
        (varargs bytes
          #x0F
          opcode
          (mod-rm-byte #x03 reg rm))))))

(define (double-byte-op/MR/scaled-mem
          [opcode : Int] [rexW : Boolean]
          [reg1 : Register] [scale : Scale] [reg2 : Register] [displacement : S32]
          [reg3 : Register]) : Bytes
  (let ([base (register->byte reg1)])
    (let ([index (register->byte reg2)])
      (let ([reg (register->byte reg3)])
        (add-maybe-byte
          (rex-byte rexW (>= reg 8) (>= index 8) (>= base 8))
          (let ([v (varargs bytes
                     #x0F
                     opcode
                     (mod-rm-byte #x02 reg #x04)
                     (sib-byte scale reg2 reg1)
                     0 0 0 0)])
            (begin
              (bytes-set!/s32-le v 4 displacement)
              v)))))))


(define (double-byte-op/M [opcode : Int] [op-ext : Int] [rexW : Boolean] [reg : Register]) : Bytes
  (let ([rm (register->byte reg)])
    (add-maybe-byte
      (rex-byte rexW #f #f (>= rm 8))
      (varargs bytes
        #x0F
        opcode
        (mod-rm-byte #x03 op-ext rm)))))

;; TODO make this take a U8
(define (add-maybe-byte [mv : (Maybe Int)] [bs : Bytes]) : Bytes
  (case mv
    [(nothing) bs]
    [(just v) (bytes-append (cons (varargs bytes v) (cons bs (empty))))]))


;; TODO make this return a U8
(define (rex-byte [w : Boolean] [r : Boolean] [x : Boolean] [b : Boolean])
  : (Maybe Int)
  (let ([ind (lambda ([v : Boolean]) (if v 1 0))])
    (let ([val (bitwise-ior #x40
                 (bitwise-ior (logical-shift-left (ind w) 3)
                   (bitwise-ior (logical-shift-left (ind r) 2)
                     (bitwise-ior (logical-shift-left (ind x) 1)
                                  (ind b)))))])
      (if (= val #x40)
          (nothing)
          (just val)))))

;; TODO make this return a U8
(define (sib-byte [scale : Scale] [index : Register] [base : Register]) : Int
  (bitwise-ior
    (case scale
      [(scale-1) #x00]
      [(scale-2) #x40]
      [(scale-4) #x80]
      [(scale-8) #xc0])
    (bitwise-ior
      (logical-shift-left (bitwise-and (register->byte index) #x07) 3)
      (bitwise-and (register->byte base) #x07))))

;; TODO make this return a U8
(define (register->byte [reg : Register]) : Int
  (case reg
    ;; 8 Bit registers
    [(al) 0]
    [(ah) 4]
    [(bl) 3]
    [(bh) 7]
    [(cl) 1]
    [(ch) 5]
    [(dl) 2]
    [(dh) 6]
    [(dil) 7]
    [(sil) 6]
    [(bpl) 5]
    [(spl) 4]
    [(r8b) 8]
    [(r9b) 9]
    [(r10b) 10]
    [(r11b) 11]
    [(r12b) 12]
    [(r13b) 13]
    [(r14b) 14]
    [(r15b) 15]
    ;; 16 bit registers
    [(ax) 0]
    [(bx) 3]
    [(cx) 1]
    [(dx) 2]
    [(di) 7]
    [(si) 6]
    [(bp) 5]
    [(sp) 4]
    [(r8w) 8]
    [(r9w) 9]
    [(r10w) 10]
    [(r11w) 11]
    [(r12w) 12]
    [(r13w) 13]
    [(r14w) 14]
    [(r15w) 15]
    ;; 32 bit registers
    [(eax) 0]
    [(ebx) 3]
    [(ecx) 1]
    [(edx) 2]
    [(edi) 7]
    [(esi) 6]
    [(ebp) 5]
    [(esp) 4]
    [(r8d) 8]
    [(r9d) 9]
    [(r10d) 10]
    [(r11d) 11]
    [(r12d) 12]
    [(r13d) 13]
    [(r14d) 14]
    [(r15d) 15]
    ;;64 bit registers
    [(rax) 0]
    [(rbx) 3]
    [(rcx) 1]
    [(rdx) 2]
    [(rdi) 7]
    [(rsi) 6]
    [(rbp) 5]
    [(rsp) 4]
    [(r8) 8]
    [(r9) 9]
    [(r10) 10]
    [(r11) 11]
    [(r12) 12]
    [(r13) 13]
    [(r14) 14]
    [(r15) 15]))


(define (instruction->assembly-bytes [inst : Instruction]) : (JoinList Bytes)
  (case inst
    [(addq rmi reg)
     (varargs join-list
        #"addq "
        (rmi->bytes rmi)
        #", "
        (register->bytes reg))]
    [(andq rmi reg)
     (varargs join-list
        #"andq "
        (rmi->bytes rmi)
        #", "
        (register->bytes reg))]
    [(call label)
     (varargs join-list #"call " label)]
    [(call/indirect reg)
     (varargs join-list #"callq *" (register->bytes reg))]
    [(cld)
     (single-jl #"cld")]
    [(cmpq rmi1 rmi2)
     (varargs join-list
        #"cmpq "
        (rmi->bytes rmi1)
        #", "
        (rmi->bytes rmi2))]
    [(decq reg)
     (varargs join-list #"decq " (register->bytes reg))]
    [(idivq reg)
     (varargs join-list #"idivq " (register->bytes reg))]
    [(imulq reg1 reg2)
     (varargs join-list
       #"imulq "
       (register->bytes reg1)
        #", "
       (register->bytes reg2))]
    [(incq reg)
     (varargs join-list #"incq " (register->bytes reg))]
    [(jb label)
     (varargs join-list #"jb " label)]
    [(je label)
     (varargs join-list #"je " label)]
    [(jl label)
     (varargs join-list #"jl " label)]
    [(jg label)
     (varargs join-list #"jg " label)]
    [(jle label)
     (varargs join-list #"jle " label)]
    [(jge label)
     (varargs join-list #"jge " label)]
    [(jmp label)
     (varargs join-list #"jmp " label)]
    [(jmp/indirect reg)
     (varargs join-list #"jmp *" (register->bytes reg))]
    [(jne label)
     (varargs join-list #"jne " label)]
    [(jnz label)
     (varargs join-list #"jnz " label)]
    [(lahf)
     (single-jl #"lahf")]
    [(leaq rmi reg)
     (varargs join-list
        #"leaq "
        (rmi->bytes rmi)
        #", "
        (register->bytes reg))]
    [(leaq/rip-rel label reg)
     (varargs join-list
        #"leaq "
        label
        #"(%rip),"
        (register->bytes reg))]
    [(movb rmi1 rmi2)
     (varargs join-list
        #"movb "
        (rmi->bytes rmi1)
        #", "
        (rmi->bytes rmi2))]
    [(movq rmi1 rmi2)
     (varargs join-list
        #"movq "
        (rmi->bytes rmi1)
        #", "
        (rmi->bytes rmi2))]
    [(movzbq rmi reg)
     (varargs join-list
        #"movzbq "
        (rmi->bytes rmi)
        #", "
        (register->bytes reg))]
    [(nop)
     (single-jl #"nop")]
    [(notq reg)
     (varargs join-list #"notq " (register->bytes reg))]
    [(orq reg1 reg2)
     (varargs join-list
        #"orq "
        (register->bytes reg1)
        #", "
        (register->bytes reg2))]
    [(popq rmi)
     (varargs join-list #"popq " (rmi->bytes rmi))]
    [(pushq rmi)
     (varargs join-list #"pushq " (rmi->bytes rmi))]
    [(rep-stosb)
     (single-jl #"rep stosb")]
    [(rep-stosq)
     (single-jl #"rep stosq")]
    [(rep-movsb)
     (single-jl #"rep movsb")]
    [(rep-movsq)
     (single-jl #"rep movsq")]
    [(repe-cmpsb)
     (single-jl #"repe cmpsb")]
    [(repne-scasb)
     (single-jl #"repne scasb")]
    [(repne-scasq)
     (single-jl #"repne scasq")]
    [(ret)
     (single-jl #"ret")]
    [(sete reg)
     (varargs join-list #"sete " (register->bytes reg))]
    [(setg reg)
     (varargs join-list #"setg " (register->bytes reg))]
    [(setge reg)
     (varargs join-list #"setge " (register->bytes reg))]
    [(setl reg)
     (varargs join-list #"setl " (register->bytes reg))]
    [(setle reg)
     (varargs join-list #"setle " (register->bytes reg))]
    [(setne reg)
     (varargs join-list #"setne " (register->bytes reg))]
    [(shlq reg)
     (varargs join-list #"shlq %cl, " (register->bytes reg))]
    [(shrq reg)
     (varargs join-list #"shrq %cl, " (register->bytes reg))]
    [(std)
     (single-jl #"std")]
    [(subq rmi reg)
     (varargs join-list
        #"subq "
        (rmi->bytes rmi)
        #", "
        (register->bytes reg))]
    [(syscall)
     (single-jl #"syscall")]
    [(test rmi1 rmi2)
     (varargs join-list #"test " (rmi->bytes rmi1) #" " (rmi->bytes rmi2))]
    [(ud2)
     (single-jl #"ud2")]))

(define (register->bytes [reg : Register]) : Bytes
  (case reg
    ;; 8 bit
    [(al) #"%al"]
    [(ah) #"%ah"]
    [(bl) #"%bl"]
    [(bh) #"%bh"]
    [(cl) #"%cl"]
    [(ch) #"%ch"]
    [(dl) #"%dl"]
    [(dh) #"%dh"]
    [(dil) #"%dli"]
    [(sil) #"%sil"]
    [(bpl) #"%bpl"]
    [(spl) #"%spl"]
    [(r8b) #"%r8b"]
    [(r9b) #"%r9b"]
    [(r10b) #"%r10b"]
    [(r11b) #"%r11b"]
    [(r12b) #"%r12b"]
    [(r13b) #"%r13b"]
    [(r14b) #"%r14b"]
    [(r15b) #"%r15b"]
    ;; 16 bit
    [(ax) #"%ax"]
    [(bx) #"%bx"]
    [(cx) #"%cx"]
    [(dx) #"%dx"]
    [(di) #"%di"]
    [(si) #"%si"]
    [(bp) #"%bp"]
    [(sp) #"%sp"]
    [(r8w) #"%r8w"]
    [(r9w) #"%r9w"]
    [(r10w) #"%r10w"]
    [(r11w) #"%r11w"]
    [(r12w) #"%r12w"]
    [(r13w) #"%r13w"]
    [(r14w) #"%r14w"]
    [(r15w) #"%r15w"]
    ;; 32 bit
    [(eax) #"%eax"]
    [(ebx) #"%ebx"]
    [(ecx) #"%ecx"]
    [(edx) #"%edx"]
    [(edi) #"%edi"]
    [(esi) #"%esi"]
    [(ebp) #"%ebp"]
    [(esp) #"%esp"]
    [(r8d) #"%r8d"]
    [(r9d) #"%r9d"]
    [(r10d) #"%r10d"]
    [(r11d) #"%r11d"]
    [(r12d) #"%r12d"]
    [(r13d) #"%r13d"]
    [(r14d) #"%r14d"]
    [(r15d) #"%r15d"]
    ;; 64 bit
    [(rax) #"%rax"]
    [(rbx) #"%rbx"]
    [(rcx) #"%rcx"]
    [(rdx) #"%rdx"]
    [(rdi) #"%rdi"]
    [(rsi) #"%rsi"]
    [(rbp) #"%rbp"]
    [(rsp) #"%rsp"]
    [(r8) #"%r8"]
    [(r9) #"%r9"]
    [(r10) #"%r10"]
    [(r11) #"%r11"]
    [(r12) #"%r12"]
    [(r13) #"%r13"]
    [(r14) #"%r14"]
    [(r15) #"%r15"]))

(define (rmi->bytes [rmi : RegMemImm]) : Bytes
  (case rmi
    [(rmi-register r) (register->bytes r)]
    [(rmi-direct-memory reg)
     (bytes-append (varargs list #"(" (register->bytes reg) #")"))]
    [(rmi-displaced-memory reg offset)
     (bytes-append (varargs list (integer->decimal-bytes (s32->s64 offset)) #"(" (register->bytes reg) #")"))]
    [(rmi-scaled-memory reg scale index offset)
     (bytes-append
       (varargs list
         (integer->decimal-bytes (s32->s64 offset))
         #"("
         (register->bytes reg)
         #", "
         (register->bytes index)
         #", "
         (integer->decimal-bytes
           (case scale
             [(scale-1) 1]
             [(scale-2) 2]
             [(scale-4) 4]
             [(scale-8) 8]))
         #")"))]
    [(rmi-imm (imm-s32 v))
     (bytes-append (varargs list #"$" (integer->decimal-bytes (s32->s64 v))))]
    [(rmi-imm (imm-s64 v))
     (bytes-append (varargs list #"$" (integer->decimal-bytes (eight-bytes-le->int v))))]))

(define (reg [r : Register]) : RegMemImm
  (rmi-register r))
(define (mem [r : Register] [offset : Int]) : RegMemImm
  (case r
    ;; rsp as the index means 0 index
    [(rsp) (rmi-scaled-memory r (scale-1) (rsp) (s32 offset))]
    [(r12) (rmi-scaled-memory r (scale-1) (rsp) (s32 offset))]
    [(rbp) (rmi-displaced-memory r (s32 offset))]
    [(r13) (rmi-displaced-memory r (s32 offset))]
    [_ (if (= offset 0)
           (rmi-direct-memory r)
           (rmi-displaced-memory r (s32 offset)))]))
(define (imm [v : Int]) : RegMemImm
  (rmi-imm (imm-s32 (s32 v))))
(define (scaled [r : Register] [scale : Scale] [index : Register] [offset : Int]) : RegMemImm
  (rmi-scaled-memory r scale index (s32 offset)))

(define (write-assembly-commands [cmds : (List AssemblyCommand)] [output : OutputPort]) : Void
  (write-lines (map assembly-command->bytes cmds) output))



(define (convert-objects [objects : (List TopLevelObject)]) : AssemblyFragments
  (assembly-fragments
    (filter-map
      (lambda ([object : TopLevelObject]) : (Maybe TextFragment)
         (case object
           [(function-tlo fun) (just (convert-function fun))]
           [(bytes-tlo name value) (nothing)]
           [(trivial-closure-tlo name fun-name) (nothing)]))
      objects)
    (filter-map
      (lambda ([object : TopLevelObject]) : (Maybe ConstFragment)
         (case object
           [(function-tlo fun) (nothing)]
           [(bytes-tlo name value) (just (bytes-fragment name value))]
           [(trivial-closure-tlo name fun-name) (just (address-fragment name fun-name))]))
      objects)))

(define (convert-function [fun : StackFunction]) : TextFragment
  (case fun
    [(stack-function name num-args blocks)
     (function-fragment name
       (cons
         (section
           (varargs list
             (basic-block name
               (varargs append-jl*
                 (varargs join-list
                   (pushq (reg (rbp)))
                   (movq (reg (rsp)) (reg (rbp))))
                 (if (>= num-args 1)
                     (single-jl (pushq (reg (rdi))))
                     (empty-jl))
                 (if (>= num-args 2)
                     (single-jl (pushq (reg (rsi))))
                     (empty-jl))
                 (if (>= num-args 3)
                     (single-jl (pushq (reg (rdx))))
                     (empty-jl))
                 (if (>= num-args 4)
                     (single-jl (pushq (reg (rcx))))
                     (empty-jl))
                 (if (>= num-args 5)
                     (single-jl (pushq (reg (r8))))
                     (empty-jl))
                 (if (>= num-args 6)
                     (single-jl (pushq (reg (r9))))
                     (empty-jl))
                 (if (>= num-args 7)
                     (install-extra-arguments 0 (- num-args 6))
                     (empty-jl))))))
           (convert-basic-blocks name 0 blocks)))]))

(define (write-fragments [fragments : AssemblyFragments] [output : OutputPort]) : Void
  (write-assembly-commands (jl->list (fragments->commands fragments)) output))

(define (fragments->commands [fragments : AssemblyFragments]) : (JoinList AssemblyCommand)
  (case fragments
    [(assembly-fragments text-fragments const-fragments)
     ;; TODO move the section directives here instead of per fragment
     (append-jl
       (concat-map-jl text-fragment->commands (list->jl text-fragments))
       (concat-map-jl const-fragment->commands (list->jl const-fragments)))]))

(define (text-fragment->commands [frag : TextFragment]) : (JoinList AssemblyCommand)
  (case frag
    [(function-fragment _ sections)
     (cons-jl
       (directive-cmd (section-directive #"__TEXT" #"__text"))
       (sections->commands sections))]))

(define (const-fragment->commands [frag : ConstFragment]) : (JoinList AssemblyCommand)
  (case frag
    [(address-fragment name value)
     (varargs join-list
       (directive-cmd (section-directive #"__TEXT" #"__const"))
       (directive-cmd (global-directive name))
       (directive-cmd (label-directive name))
       (directive-cmd (quad-directive/label value)))]
    [(bytes-fragment name value)
     (varargs join-list
       (directive-cmd (section-directive #"__TEXT" #"__const"))
       (directive-cmd (global-directive name))
       (directive-cmd (label-directive name))
       (directive-cmd (quad-directive/integer (bytes-length value)))
       (directive-cmd (ascii-directive value)))]))



(define (sections->commands [sections : (List Section)]) : (JoinList AssemblyCommand)
  (case sections
    [(empty) (empty-jl)]
    [(cons (section blocks) sections)
     (append-jl
       (basic-blocks->commands blocks)
       (sections->commands sections))]))

(define (basic-blocks->commands [blocks : (List BasicBlock)]) : (JoinList AssemblyCommand)
  (case blocks
    [(empty) (empty-jl)]
    [(cons (basic-block name instructions) blocks)
     (cons-jl
       (directive-cmd (global-directive name))
       (cons-jl
         (directive-cmd (label-directive name))
         (append-jl
           (map-jl instruction-cmd instructions)
           (basic-blocks->commands blocks))))]))


(define (convert-basic-blocks [fun-name : Bytes] [index : Int] [blocks : (List StackBasicBlock)])
  : (List Section)
  (case blocks
    [(empty) (empty)]
    [(cons block blocks)
     (cons
       (convert-basic-block fun-name index block)
       (convert-basic-blocks fun-name (+ index 1) blocks))]))

(define (convert-basic-block [fun-name : Bytes] [index : Int] [block : StackBasicBlock])
  : Section
  (case block
    [(stack-basic-block cmds terminal)
     (section
       (varargs list
         (basic-block
           (bytes-append (varargs list fun-name #"_" (integer->decimal-bytes index)))
           (append-jl
             (convert-commands cmds)
             (convert-terminal fun-name terminal)))))]))


(define (line->bytes [line : (JoinList Bytes)]) : Bytes
  (case (jl->list line)
    [(empty) #""]
    [(cons entry (empty)) entry]
    [entries (bytes-append entries)]))

(define (write-lines [lines : (List (JoinList Bytes))] [output : OutputPort]) : Void
  (for-each
    (lambda ([line : (JoinList Bytes)])
      (begin
        (write-line (line->bytes line) output)))
    lines))

(define (convert-terminal [fun-name : Bytes] [terminal : StackTerminal]) : (JoinList Instruction)
  (case terminal
    [(return num-cleanup)
     (varargs join-list
       (popq (reg (rax)))
       (addq (imm (* 8 num-cleanup)) (rsp))
       (popq (reg (rbp)))
       (ret))]
    [(tail-call n num-cleanup)
     (if (> n 6)
         (panic #"large tail call not implemented")
         (varargs append-jl*
           (if (>= n 1)
               (single-jl (movq (mem (rsp) (- (* 8 n) #x00)) (reg (rdi))))
               (empty-jl))
           (if (>= n 2)
               (single-jl (movq (mem (rsp) (- (* 8 n) #x08)) (reg (rsi))))
               (empty-jl))
           (if (>= n 3)
               (single-jl (movq (mem (rsp) (- (* 8 n) #x10)) (reg (rdx))))
               (empty-jl))
           (if (>= n 4)
               (single-jl (movq (mem (rsp) (- (* 8 n) #x18)) (reg (rcx))))
               (empty-jl))
           (if (>= n 5)
               (single-jl (movq (mem (rsp) (- (* 8 n) #x20)) (reg (r8))))
               (empty-jl))
           (if (>= n 6)
               (single-jl (movq (mem (rsp) (- (* 8 n) #x28)) (reg (r9))))
               (empty-jl))
           (varargs join-list
             (movq (mem (rsp) 0) (reg (r11)))
             (movq (reg (r11)) (mem (rsp) (* 8 n)))
             (movq (mem (r11) 0) (reg (rax)))
             (addq (imm (* 8 (+ (+ num-cleanup 1) n))) (rsp))
             (popq (reg (rbp)))
             (jmp/indirect (rax)))))]
    [(known-tail-call name n num-cleanup)
     (if (> n 6)
         (panic #"large tail call not implemented")
         (varargs append-jl*
           (if (>= n 1)
               (single-jl (movq (mem (rsp) (- (* 8 n) #x08)) (reg (rdi))))
               (empty-jl))
           (if (>= n 2)
               (single-jl (movq (mem (rsp) (- (* 8 n) #x10)) (reg (rsi))))
               (empty-jl))
           (if (>= n 3)
               (single-jl (movq (mem (rsp) (- (* 8 n) #x18)) (reg (rdx))))
               (empty-jl))
           (if (>= n 4)
               (single-jl (movq (mem (rsp) (- (* 8 n) #x20)) (reg (rcx))))
               (empty-jl))
           (if (>= n 5)
               (single-jl (movq (mem (rsp) (- (* 8 n) #x28)) (reg (r8))))
               (empty-jl))
           (if (>= n 6)
               (single-jl (movq (mem (rsp) (- (* 8 n) #x30)) (reg (r9))))
               (empty-jl))
           (varargs join-list
             (addq (imm (* 8 (+ n num-cleanup))) (rsp))
             (popq (reg (rbp)))
             (jmp name))))]
    [(uncond-jmp index)
     (single-jl (jmp (bytes-append (varargs list fun-name #"_" (integer->decimal-bytes index)))))]
    [(boolean-jmp true-index false-index)
     (varargs join-list
       (popq (reg (rax)))
       (cmpq (imm 0) (reg (rax)))
       (jne (bytes-append (varargs list fun-name #"_" (integer->decimal-bytes true-index))))
       (jmp (bytes-append (varargs list fun-name #"_" (integer->decimal-bytes false-index)))))]
    [(variant-switch cases)
     (cons-jl
       (movq (mem (rsp) 0) (reg (rax)))
       (convert-variant-switch fun-name cases))]))

;; The current value is in %rax.
(define (convert-variant-switch [fun-name : Bytes] [cases : VariantCases]) : (JoinList Instruction)
  (case cases
    [(no-catch-all-case)
     (single-jl (ud2))]
    [(catch-all-case block)
     (single-jl (jmp (bytes-append (varargs list fun-name #"_" (integer->decimal-bytes block)))))]
    [(variant-case tag block cases)
     (cons-jl
       (cmpq (imm tag) (mem (rax) 0))
       (cons-jl
         (je (bytes-append (varargs list fun-name #"_" (integer->decimal-bytes block))))
         (convert-variant-switch fun-name cases)))]))

(define (convert-commands [cmds : (List StackCmd)]) : (JoinList Instruction)
  (case cmds
    [(empty) (empty-jl)]
    [(cons cmd cmds)
     (append-jl
       (convert-command cmd)
       (convert-commands cmds))]))


(define (convert-command [cmd : StackCmd]) : (JoinList Instruction)
  (case cmd
    [(dup-cmd offset)
     (varargs join-list
       (pushq (mem (rsp) (* offset 8))))]
    [(dup-free-var-cmd offset index)
     (varargs join-list
       (pushq (mem (r11) (* (+ 1 index) 8))))]
    [(swap-cmd)
     (varargs join-list
       (popq (reg (rax)))
       (popq (reg (rbx)))
       (pushq (reg (rax)))
       (pushq (reg (rbx))))]
    [(pop-cmd)
     (varargs join-list
       (popq (reg (rax))))]
    [(num-lit-cmd v)
     (varargs join-list
       (movq (rmi-imm (imm-s64 (int->eight-bytes-le v))) (reg (rax)))
       (pushq (reg (rax))))]
    [(boolean-lit-cmd v)
     (varargs join-list
       (pushq (imm (if v 1 0))))]
    ;; TODO put the bytes not directly in the instruction stream
    [(bytes-cmp-cmd)
     (varargs join-list
       (popq (reg (rdi))) ;; Argument 2
       (popq (reg (rsi))) ;; Argument 1
       (movq (mem (rsi) 0) (reg (rcx)))
       (addq (imm 8) (rcx))
       (repe-cmpsb)
       (sete (al))
       (movzbq (reg (al)) (rax))
       (pushq (reg (rax))))]

    [(load-global-cmd name)
     (varargs join-list
       (leaq/rip-rel name (rax))
       (pushq (reg (rax))))]

    [(create-closure-cmd n)
     (varargs append-jl*
       (single-jl (movq (reg (r15)) (reg (rax))))
       (copy-objects (+ n 1))
       (single-jl (pushq (reg (rax)))))]
    [(fun-call-cmd n)
     (varargs append-jl*
       (if (>= n 1)
           (single-jl (movq (mem (rsp) (- (* 8 n) #x00)) (reg (rdi))))
           (empty-jl))
       (if (>= n 2)
           (single-jl (movq (mem (rsp) (- (* 8 n) #x08)) (reg (rsi))))
           (empty-jl))
       (if (>= n 3)
           (single-jl (movq (mem (rsp) (- (* 8 n) #x10)) (reg (rdx))))
           (empty-jl))
       (if (>= n 4)
           (single-jl (movq (mem (rsp) (- (* 8 n) #x18)) (reg (rcx))))
           (empty-jl))
       (if (>= n 5)
           (single-jl (movq (mem (rsp) (- (* 8 n) #x20)) (reg (r8))))
           (empty-jl))
       (if (>= n 6)
           (single-jl (movq (mem (rsp) (- (* 8 n) #x28)) (reg (r9))))
           (empty-jl))
       (if (>= n 7)
           (cons-jl
             (movq (reg (r15)) (reg (r10)))
             (copy-extra-arguments 6 n))
           (empty-jl))
       (varargs join-list
         (movq (mem (rsp) 0) (reg (rax)))
         (movq (reg (rax)) (mem (rsp) (* 8 n)))
         (addq (imm (* 8 n)) (rsp))
         (movq (mem (rsp) 0) (reg (rax)))
         (movq (reg (r11)) (mem (rsp) 0))
         (movq (reg (rax)) (reg (r11)))
         (movq (mem (rax) 0) (reg (rax)))
         (call/indirect (rax))
         ;; Read back the closure and then overwrite it
         (movq (mem (rsp) 0) (reg (r11)))
         (movq (reg (rax)) (mem (rsp) 0))))]
    [(known-fun-call-cmd name n)
     (varargs append-jl*
       (if (>= n 1)
           (single-jl (movq (mem (rsp) (- (* 8 n) #x08)) (reg (rdi))))
           (empty-jl))
       (if (>= n 2)
           (single-jl (movq (mem (rsp) (- (* 8 n) #x10)) (reg (rsi))))
           (empty-jl))
       (if (>= n 3)
           (single-jl (movq (mem (rsp) (- (* 8 n) #x18)) (reg (rdx))))
           (empty-jl))
       (if (>= n 4)
           (single-jl (movq (mem (rsp) (- (* 8 n) #x20)) (reg (rcx))))
           (empty-jl))
       (if (>= n 5)
           (single-jl (movq (mem (rsp) (- (* 8 n) #x28)) (reg (r8))))
           (empty-jl))
       (if (>= n 6)
           (single-jl (movq (mem (rsp) (- (* 8 n) #x30)) (reg (r9))))
           (empty-jl))
       (if (>= n 7)
           (cons-jl
             (movq (reg (r15)) (reg (r10)))
             (copy-extra-arguments* 6 n))
           (empty-jl))
       (varargs join-list
         (addq (imm (* 8 n)) (rsp))
         (pushq (reg (r11)))
         (call name)
         ;; Read back the closure and then overwrite it
         (movq (mem (rsp) 0) (reg (r11)))
         (movq (reg (rax)) (mem (rsp) 0))))]

    [(make-array-cmd)
     (varargs join-list
       (popq (reg (rax)))
       (popq (reg (rcx)))
       (movq (reg (r15)) (reg (rdx)))
       (movq (reg (rcx)) (mem (r15) 0))
       (addq (imm 8) (r15))
       (movq (reg (r15)) (reg (rdi)))
       (rep-stosq)
       (movq (reg (rdi)) (reg (r15)))
       (pushq (reg (rdx))))]
    [(make-array-from-stack-cmd num-args)
     (varargs join-list
       (movq (imm num-args) (reg (rcx)))
       (movq (reg (rsp)) (reg (rsi)))
       (movq (reg (r15)) (reg (rax)))
       (leaq (scaled (rsp) (scale-8) (rcx) 0) (rsp))
       (movq (reg (rcx)) (mem (r15) 0))
       (leaq (mem (r15) 8) (rdi))
       (leaq (scaled (r15) (scale-8) (rcx) 8) (r15))
       (cld)
       (rep-movsq)
       (pushq (reg (rax))))]
    [(array-length-cmd)
     (varargs join-list
       (popq (reg (rax)))
       (pushq (mem (rax) 0)))]
    [(array-ref-cmd)
     (varargs join-list
       (popq (reg (rcx)))
       (popq (reg (rax)))
       (pushq (scaled (rax) (scale-8) (rcx) 8)))]
    [(array-set!-cmd)
     (varargs join-list
       (popq (reg (rdx)))
       (popq (reg (rcx)))
       (popq (reg (rax)))
       (movq (reg (rdx)) (scaled (rax) (scale-8) (rcx) 8))
       (pushq (imm 0)))]

    [(bin-logic-math-cmd op)
     (varargs join-list
       (popq (reg (rax))) ;; Argument 2
       (popq (reg (rcx))) ;; Argument 1
       (cmpq (reg (rax)) (reg (rcx)))
       (case op
         [(less-than-op)
          (setl (al))]
         [(less-than-or-equal-op)
          (setle (al))]
         [(equal-op)
          (sete (al))]
         [(greater-than-or-equal-op)
          (setge (al))]
         [(greater-than-op)
          (setg (al))])
       (movzbq (reg (al)) (rax))
       (pushq (reg (rax))))]
    [(bin-math-cmd (bin-add-op))
     (varargs join-list
       (popq (reg (rax)))
       (popq (reg (rcx)))
       (addq (reg (rcx)) (rax))
       (pushq (reg (rax))))]
    [(bin-math-cmd (bin-sub-op))
     (varargs join-list
       (popq (reg (rcx)))
       (popq (reg (rax)))
       (subq (reg (rcx)) (rax))
       (pushq (reg (rax))))]
    [(bin-math-cmd (bin-mult-op))
     (varargs join-list
       (popq (reg (rax)))
       (popq (reg (rcx)))
       (imulq (rcx) (rax))
       (pushq (reg (rax))))]
    [(bin-math-cmd (bin-quotient-op))
     (varargs join-list
       (popq (reg (rcx)))
       (popq (reg (rax)))
       (movq (imm 0) (reg (rdx)))
       (idivq (rcx))
       (pushq (reg (rax))))]
    [(bin-math-cmd (bin-remainder-op))
     (varargs join-list
       (popq (reg (rcx)))
       (popq (reg (rax)))
       (movq (imm 0) (reg (rdx)))
       (idivq (rcx))
       (pushq (reg (rdx))))]
    [(bin-math-cmd (bin-bitwise-and-op))
     (varargs join-list
       (popq (reg (rcx)))
       (popq (reg (rax)))
       (andq (reg (rcx)) (rax))
       (pushq (reg (rax))))]
    [(bin-math-cmd (bin-bitwise-ior-op))
     (varargs join-list
       (popq (reg (rcx)))
       (popq (reg (rax)))
       (orq (rcx) (rax))
       (pushq (reg (rax))))]
    ;; TODO check shift amount is valid value
    [(bin-math-cmd (bin-logical-shift-left-op))
     (varargs join-list
       (popq (reg (rcx)))
       (popq (reg (rax)))
       (shlq (rax))
       (pushq (reg (rax))))]
    [(bin-math-cmd (bin-logical-shift-right-op))
     (varargs join-list
       (popq (reg (rcx)))
       (popq (reg (rax)))
       (shrq (rax))
       (pushq (reg (rax))))]
    [(alloc-variant-cmd tag fields)
     (varargs append-jl*
       (single-jl (movq (reg (r15)) (reg (rax))))
       (single-jl (movq (imm tag) (mem (r15) 0)))
       (single-jl (addq (imm 8) (r15)))
       (copy-objects fields)
       (single-jl (pushq (reg (rax)))))]
    [(variant-ref-cmd tag field)
     (varargs join-list
       (popq (reg (rax)))
       (cmpq (imm tag) (mem (rax) 0))
       (jne #"prim_variant_panic")
       (pushq (mem (rax) (+ (* 8 field) 8))))]))


;; Generates assembly to copy `args` arguments from the top of the stack to the
;; memory starting at %r15 %r15 ends up pointing right after after the last argument written.
;; Dirties %rax
(define (copy-extra-arguments [arg : Int] [args : Int]) : (JoinList Instruction)
  (if (= arg args)
      (empty-jl)
      (cons-jl
        (movq (mem (rsp) (* (- args arg) 8)) (reg (rax)))
        (cons-jl
          (movq (reg (rax)) (mem (r15) 0))
          (cons-jl
            (addq (imm 8) (r15))
            (copy-extra-arguments (+ 1 arg) args))))))

;; Generates assembly to copy `args` arguments from the top of the stack to the
;; memory starting at %r15 %r15 ends up pointing right after after the last argument written.
;; Dirties %rax
(define (copy-extra-arguments* [arg : Int] [args : Int]) : (JoinList Instruction)
  (if (= arg args)
      (empty-jl)
      (cons-jl
        (movq (mem (rsp) (* (- args (+ arg 1)) 8)) (reg (rax)))
        (cons-jl
          (movq (reg (rax)) (mem (r15) 0))
          (cons-jl
            (addq (imm 8) (r15))
            (copy-extra-arguments* (+ 1 arg) args))))))


;; Generates assembly to install `args` arguments from %r10 ontop of the stack
(define (install-extra-arguments [arg : Int] [args : Int]) : (JoinList Instruction)
  (if (= arg args)
      (empty-jl)
      (cons-jl
        (pushq (mem (r10) (* arg 8)))
        (install-extra-arguments (+ 1 arg) args))))


;; Generates assembly to copy n objects from the top of the stack to the
;; memory starting at %r15 %r15 ends up pointing right after after the last object written.
(define (copy-objects [n : Int]) : (JoinList Instruction)
  (if (> n 0)
      (cons-jl
        (popq (mem (r15) 0))
        (cons-jl
          (addq (imm 8) (r15))
          (copy-objects (- n 1))))
      (empty-jl)))
