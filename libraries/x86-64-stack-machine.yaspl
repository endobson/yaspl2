(module x86-64-stack-machine
  (import
    (prim
      #:types (Bytes OutputPort Void Boolean S32 Int)
      #:values (bytes-length bytes-ref * + - = >= panic >
                bitwise-and bitwise-ior logical-shift-left s32 s32->s64)
      #:patterns ())
    (list
      #:types (List)
      #:values (append list map empty cons for-each)
      #:patterns (empty cons))
    (maybe
      #:types (Maybe)
      #:values (just nothing)
      #:patterns (just nothing))
    (numbers integer->decimal-bytes integer->hex-bytes)
    (io write-line)
    (join-list
      #:types (JoinList)
      #:values (jl->list single-jl join-list empty-jl cons-jl append-jl append-jl* map-jl list->jl)
      #:patterns ())
    (bytes
      #:types (EightBytesLe)
      #:values (subbytes bytes-append bytes bytes-set!/s32-le
                eight-bytes-le->int int->eight-bytes-le bytes-set!/eight-bytes-le)
      #:patterns ())
    (stack-machine
      #:types (StackFunction StackBasicBlock StackCmd StackTerminal VariantCases TopLevelObject)
      #:values ()
      #:patterns (stack-function stack-basic-block return
                  tail-call known-tail-call
                  swap-cmd dup-cmd pop-cmd num-lit-cmd create-closure-cmd fun-call-cmd known-fun-call-cmd
                  boolean-lit-cmd uncond-jmp boolean-jmp alloc-variant-cmd
                  variant-ref-cmd variant-switch bytes-cmp-cmd load-global-cmd
                  no-catch-all-case catch-all-case variant-case
                  bin-math-cmd bin-add-op bin-sub-op bin-mult-op bin-quotient-op bin-remainder-op
                  bin-bitwise-and-op bin-bitwise-ior-op
                  bin-logical-shift-left-op bin-logical-shift-right-op
                  bin-logic-math-cmd less-than-op less-than-or-equal-op equal-op
                  greater-than-or-equal-op greater-than-op
                  make-array-cmd array-length-cmd array-ref-cmd array-set!-cmd
                  make-array-from-stack-cmd dup-free-var-cmd function-tlo trivial-closure-tlo
                  bytes-tlo))
    (either
      #:types (Either)
      #:values ()
      #:patterns (left right)))
  (export
    #:types (AssemblyFragment BasicBlock Instruction)
    #:values (compile-stack-machine write-fragments convert-objects fragment->commands assembly-commands->bytes
              instruction->mc-command)
    #:patterns (function-fragment address-fragment bytes-fragment basic-block mc-bytes mc-jump
                mcj-jb mcj-je mcj-jne mcj-jnz mcj-jmp mcj-call))
  (types


    (define-type AssemblyFragment
      (function-fragment [name Bytes] [blocks (List BasicBlock)])
      (address-fragment [name Bytes] [value Bytes])
      (bytes-fragment [name Bytes] [value Bytes]))
    (define-type BasicBlock
      (basic-block [name Bytes] [instructions (JoinList Instruction)]))


    (define-type MCJumpType
      (mcj-call)
      (mcj-jb)
      (mcj-je)
      (mcj-jmp)
      (mcj-jne)
      (mcj-jnz))

    (define-type MCCommand
      (mc-bytes [bytes Bytes])
      (mc-jump [type MCJumpType] [symbol Bytes])
      (mc-leaq/rel [symbol Bytes] [reg1 Register] [reg2 Register]))

    (define-type AssemblyCommand
      (directive-cmd [directive AssemblerDirective])
      (instruction-cmd [instruction Instruction]))
    (define-type AssemblerDirective
      (section-directive [segment-name Bytes] [section-name Bytes])
      (global-directive [label Bytes])
      (label-directive [name Bytes])
      (quad-directive/label [label Bytes])
      (quad-directive/integer [value Int])
      (ascii-directive [value Bytes]))
    (define-type Instruction
      (addq [rmi RegMemImm] [reg Register])
      (andq [reg1 RegMemImm] [reg2 Register])
      (call [label Bytes])
      (call/indirect [reg Register])
      (cld)
      (cmpq [rmi1 RegMemImm] [rmi2 RegMemImm])
      (decq [reg Register])
      (idivq [reg Register])
      (imulq [reg Register])
      (incq [reg Register])
      (jb [label Bytes])
      (je [label Bytes])
      (jmp [label Bytes])
      (jmp/indirect [reg Register])
      (jne [label Bytes])
      (jnz [label Bytes])
      (leaq [rmi RegMemImm] [reg Register])
      (leaq/rel [label Bytes] [reg1 Register] [reg2 Register])
      (lahf)
      (movb [rmi1 RegMemImm] [rmi2 RegMemImm])
      (movq [rmi1 RegMemImm] [rmi2 RegMemImm])
      (movzbq [rmi RegMemImm] [r Register])
      (nop)
      (notq [reg Register])
      (orq [reg1 Register] [reg2 Register])
      (popq [rmi RegMemImm])
      (pushq [rmi RegMemImm])
      (rep-movsb)
      (rep-movsq)
      (rep-stosb)
      (rep-stosq)
      (repe-cmpsb)
      (repne-scasb)
      (repne-scasq)
      (ret)
      (sete [reg Register])
      (setg [reg Register])
      (setge [reg Register])
      (setl [reg Register])
      (setle [reg Register])
      (shlq [reg Register])
      (shrq [reg Register])
      (std)
      (subq [rmi RegMemImm] [reg Register])
      (syscall)
      (ud2))
    (define-type Register
      ;; 8 Bit registers
      (al)
      (ah)
      (bl)
      (bh)
      (cl)
      (ch)
      (dl)
      (dh)
      (dil)
      (sil)
      (bpl)
      (spl)
      (r8b)
      (r9b)
      (r10b)
      (r11b)
      (r12b)
      (r13b)
      (r14b)
      (r15b)
      ;; 16 bit registers
      (ax)
      (bx)
      (cx)
      (dx)
      (di)
      (si)
      (bp)
      (sp)
      (r8w)
      (r9w)
      (r10w)
      (r11w)
      (r12w)
      (r13w)
      (r14w)
      (r15w)
      ;; 32 bit registers
      (eax)
      (ebx)
      (ecx)
      (edx)
      (edi)
      (esi)
      (ebp)
      (esp)
      (r8d)
      (r9d)
      (r10d)
      (r11d)
      (r12d)
      (r13d)
      (r14d)
      (r15d)
      ;;64 bit registers
      (rax)
      (rbx)
      (rcx)
      (rdx)
      (rdi)
      (rsi)
      (rbp)
      (rsp)
      (r8)
      (r9)
      (r10)
      (r11)
      (r12)
      (r13)
      (r14)
      (r15)
      (rip))
    (define-type RegMemImm
      (rmi-register [r Register])
      (rmi-direct-memory [reg Register])
      (rmi-displaced-memory [reg Register] [offset S32])
      (rmi-scaled-memory [reg Register] [scale Scale] [index-reg Register] [offset S32])
      (rmi-imm [v Immediate]))
    (define-type Immediate
      (imm-s32 [v S32])
      (imm-s64 [v EightBytesLe]))
    (define-type Scale
      (scale-1)
      (scale-2)
      (scale-4)
      (scale-8)))


  (define (compile-stack-machine
            [main-function-name : Bytes]
            [objects : (List TopLevelObject)]) : (List AssemblyFragment)
    (append (start-function-fragments main-function-name)
          (append (jl->list (prim-function-fragments))
                  (convert-objects objects))))

  (define (assembly-commands->bytes [cmds : (List AssemblyCommand)]) : (JoinList Bytes)
    (case cmds
      [(empty) (empty-jl)]
      [(cons cmd cmds)
       (append-jl
         (assembly-command->bytes cmd)
         (cons-jl
           #"\n"
           (assembly-commands->bytes cmds)))]))


  (define (assembly-command->bytes [cmd : AssemblyCommand]) : (JoinList Bytes)
    (case cmd
      [(directive-cmd directive) (assembler-directive->bytes directive)]
      [(instruction-cmd instruction) (instruction->assembly-bytes/transition instruction)]))

  (define (assembler-directive->bytes [dir : AssemblerDirective]) : (JoinList Bytes)
    (case dir
      [(section-directive seg sect)
       (varargs join-list #".section " seg #"," sect)]
      [(global-directive label)
       (varargs join-list #".global " label)]
      [(label-directive name)
       (varargs join-list name #":")]
      [(quad-directive/label label)
       (varargs join-list #".quad " label)]
      [(quad-directive/integer value)
       (varargs join-list #".quad " (integer->decimal-bytes value))]
      [(ascii-directive value)
       (varargs append-jl*
         (single-jl #".ascii \"")
         (escape-bytes value 0 0)
         (single-jl #"\""))]))

  (define (escape-bytes [src : Bytes] [start : Int] [cur : Int]) : (JoinList Bytes)
    (if (= cur (bytes-length src))
        (single-jl (subbytes src start cur))
        (let ([byte (bytes-ref src cur)])
          (if (= byte 10) ;; newline
              (cons-jl
                (subbytes src start cur)
                (cons-jl #"\\n" (escape-bytes src (+ 1 cur) (+ 1 cur))))
              (if (= byte 13) ;; carriage return
                  (cons-jl
                    (subbytes src start cur)
                    (cons-jl #"\\r" (escape-bytes src (+ 1 cur) (+ 1 cur))))
                  (if (= byte 34) ;; double quote
                      (cons-jl
                        (subbytes src start cur)
                        (cons-jl #"\\\"" (escape-bytes src (+ 1 cur) (+ 1 cur))))
                      (if (= byte 92) ;; backslash
                          (cons-jl
                            (subbytes src start cur)
                            (cons-jl #"\\\\" (escape-bytes src (+ 1 cur) (+ 1 cur))))
                          (escape-bytes src start (+ 1 cur)))))))))


  (define (instruction->assembly-bytes/transition [inst : Instruction]) : (JoinList Bytes)
    (case (instruction->mc-command inst)
      [(mc-bytes v) (mc-bytes->assembly v)]
      [(mc-jump (mcj-call) label) (varargs join-list #"call " label)]
      [(mc-jump (mcj-jb) label) (varargs join-list #"jb " label)]
      [(mc-jump (mcj-je) label) (varargs join-list #"je " label)]
      [(mc-jump (mcj-jmp) label) (varargs join-list #"jmp " label)]
      [(mc-jump (mcj-jne) label) (varargs join-list #"jne " label)]
      [(mc-jump (mcj-jnz) label) (varargs join-list #"jnz " label)]
      [(mc-leaq/rel label reg1 reg2)
       (varargs join-list
         #"leaq "
         label
         #"("
         (register->bytes reg1)
         #"), "
         (register->bytes reg2))]))

  (define (instruction->mc-command [inst : Instruction]) : MCCommand
    (case inst
      [(addq (rmi-register reg1) reg2)
       (mc-bytes (single-byte-op/RM #x01 #t reg1 reg2))]
      [(addq (rmi-imm (imm-s32 imm)) reg)
       (mc-bytes (single-byte-op/IM #x81 0 #t imm reg))]
      [(addq (rmi-imm _) reg)
       (panic #"addq of non-s32 immediate not supported")]
      [(addq (rmi-direct-memory reg1) reg2)
       (mc-bytes (single-byte-op/MR/mem #x03 #t reg1 reg2))]
      [(addq (rmi-displaced-memory reg1 offset) reg2)
       (panic #"addq of displaced-memory not supported")]
      [(addq (rmi-scaled-memory reg1 scale reg2 offset) reg3)
       (mc-bytes (single-byte-op/MR/scaled-mem #x03 #t reg1 scale reg2 offset reg3))]
      [(andq (rmi-register reg1) reg2)
       (mc-bytes (single-byte-op/RM #x21 #t reg1 reg2))]
      [(andq (rmi-imm (imm-s32 imm)) reg)
       (mc-bytes (single-byte-op/IM #x81 4 #t imm reg))]
      [(andq (rmi-imm _) reg)
       (panic #"andq of non-s32 immediate not supported")]
      [(andq (rmi-direct-memory _) _)
       (panic #"andq of direct memory not yet supported")]
      [(andq (rmi-displaced-memory _ _) _)
       (panic #"andq of displaced memory not yet supported")]
      [(andq (rmi-scaled-memory _ _ _ _) _)
       (panic #"andq of scaled memory not yet supported")]
      [(call label)
       (mc-jump (mcj-call) label)]
      [(call/indirect reg)
       (mc-bytes (single-byte-op/M #xFF 2 #f reg))]
      [(cld) (mc-bytes (varargs bytes #xFC))]
      [(cmpq (rmi-imm (imm-s32 imm)) (rmi-register reg))
       (mc-bytes (single-byte-op/IM #x81 7 #t imm reg))]
      [(cmpq (rmi-imm (imm-s32 imm)) (rmi-direct-memory reg))
       (mc-bytes (single-byte-op/IM/mem #x81 7 #t imm reg))]
      [(cmpq (rmi-register reg1) (rmi-register reg2))
       (mc-bytes (single-byte-op/MR #x3B #t reg1 reg2))]
      [(cmpq _ (rmi-imm imm))
       (panic #"cmpq with immediate second argument is not allowed")]
      [(cmpq _ _)
       (panic #"cmpq variant not supported")]
      [(decq reg)
       (mc-bytes (single-byte-op/M #xFF 1 #t reg))]
      [(idivq reg)
       (mc-bytes (single-byte-op/M #xF7 7 #t reg))]
      [(imulq reg)
       (mc-bytes (single-byte-op/M #xF7 5 #t reg))]
      [(incq reg)
       (mc-bytes (single-byte-op/M #xFF 0 #t reg))]
      [(jb label)
       (mc-jump (mcj-jb) label)]
      [(je label)
       (mc-jump (mcj-je) label)]
      [(jmp label)
       (mc-jump (mcj-jmp) label)]
      [(jmp/indirect reg)
       (mc-bytes (single-byte-op/M #xFF 4 #f reg))]
      [(jne label)
       (mc-jump (mcj-jne) label)]
      [(jnz label)
       (mc-jump (mcj-jnz) label)]
      [(lahf) (mc-bytes (varargs bytes #x9F))]
      [(leaq (rmi-direct-memory _) _)
       (panic #"leaq of direct memory not yet supported")]
      [(leaq (rmi-displaced-memory reg1 offset) reg2)
       (mc-bytes (single-byte-op/MR/displaced-mem #x8D #t reg1 offset reg2))]
      [(leaq (rmi-scaled-memory reg1 scale reg2 offset) reg3)
       (mc-bytes (single-byte-op/MR/scaled-mem #x8D #t reg1 scale reg2 offset reg3))]
      [(leaq (rmi-register _) _)
       (panic #"leaq of register is non sensical")]
      [(leaq (rmi-imm _) _)
       (panic #"leaq of immediate is non sensical")]
      [(movb (rmi-register reg1) (rmi-scaled-memory reg2 scale reg3 offset))
       (mc-bytes (single-byte-op/RM/scaled-mem #x88 #f reg1 reg2 scale reg3 offset))]
      [(movb _ (rmi-imm _))
       (panic #"movb to immediate is nonsensical")]
      [(movb _ _)
       (panic #"movb variant is not yet supported")]
      [(movq (rmi-imm (imm-s32 imm)) (rmi-register reg))
       (mc-bytes (single-byte-op/IM #xC7 0 #t imm reg))]
      [(movq (rmi-imm (imm-s32 imm)) (rmi-direct-memory reg))
       (mc-bytes (single-byte-op/IM/mem #xC7 0 #t imm reg))]
      [(movq (rmi-imm (imm-s32 imm)) (rmi-displaced-memory reg offset))
       (mc-bytes (single-byte-op/IM/displaced-mem #xC7 0 #t imm reg offset))]
      [(movq (rmi-imm _) (rmi-displaced-memory _ _))
       (panic #"movq of non-s32 to displaced memory not yet supported")]
      [(movq (rmi-imm (imm-s64 imm)) (rmi-register reg))
       (mc-bytes (single-byte-op-s64/IO #xB8 #t imm reg))]
      [(movq (rmi-register reg1) (rmi-register reg2))
       (mc-bytes (single-byte-op/MR #x8B #t reg1 reg2))]
      [(movq (rmi-scaled-memory reg1 scale reg2 offset) (rmi-register reg3))
       (mc-bytes (single-byte-op/MR/scaled-mem #x8B #t reg1 scale reg2 offset reg3))]
      [(movq (rmi-register reg1) (rmi-direct-memory reg2))
       (mc-bytes (single-byte-op/RM/mem #x89 #t reg1 reg2))]
      [(movq (rmi-register reg1) (rmi-displaced-memory reg2 offset))
       (mc-bytes (single-byte-op/RM/displaced-mem #x89 #t reg1 reg2 offset))]
      [(movq (rmi-register reg1) (rmi-scaled-memory reg2 scale reg3 offset))
       (mc-bytes (single-byte-op/RM/scaled-mem #x89 #t reg1 reg2 scale reg3 offset))]
      [(movq (rmi-direct-memory reg1) (rmi-register reg2))
       (mc-bytes (single-byte-op/MR/mem #x8B #t reg1 reg2))]
      [(movq _ (rmi-imm _))
       (panic #"movq to immediate is nonsensical")]
      [(movq _ _)
       (panic #"movq variant is not yet supported")]
      [(movzbq (rmi-register reg1) reg2)
       (mc-bytes (double-byte-op/MR #xB6 #t reg1 reg2))]
      [(movzbq (rmi-imm _) _)
       (panic #"movzbq of immediate is not allowed")]
      [(movzbq (rmi-direct-memory _) _)
       (panic #"movzbq of direct memory not yet supported")]
      [(movzbq (rmi-displaced-memory _ _) _)
       (panic #"movzbq of displaced memory not yet supported")]
      [(movzbq (rmi-scaled-memory reg1 scale reg2 offset) reg3)
       (mc-bytes (double-byte-op/MR/scaled-mem #xB6 #t reg1 scale reg2 offset reg3))]
      [(nop) (mc-bytes (varargs bytes #x90))]
      [(notq reg)
       (mc-bytes (single-byte-op/M #xF7 2 #t reg))]
      [(orq reg1 reg2)
       (mc-bytes (single-byte-op/MR #x0B #t reg1 reg2))]
      ;; pop defaults to 64 bits so we don't need REX.W bit to indicate that
      [(popq (rmi-register reg))
       (mc-bytes (single-byte-op/O #x58 reg))]
      [(popq (rmi-direct-memory reg))
       (mc-bytes (single-byte-op/M/mem #x8F 0 #f reg))]
      [(popq (rmi-displaced-memory reg offset))
       (mc-bytes (single-byte-op/M/displaced-mem #x8F 0 #f reg offset))]
      [(popq (rmi-imm _))
       (panic #"popq of immediate is nonsensical")]
      [(popq (rmi-scaled-memory _ _ _ _))
       (panic #"popq of scaled memory not yet supported")]
      ;; push defaults to 64 bits so we don't need REX.W bit to indicate that
      [(pushq (rmi-register reg))
       (mc-bytes (single-byte-op/O #x50 reg))]
      [(pushq (rmi-direct-memory reg))
       (mc-bytes (single-byte-op/M/mem #xFF 6 #f reg))]
      [(pushq (rmi-displaced-memory reg offset))
       (mc-bytes (single-byte-op/M/displaced-mem #xFF 6 #f reg offset))]
      [(pushq (rmi-scaled-memory reg1 scale reg2 offset))
       (mc-bytes (single-byte-op/M/scaled-mem #xFF 6 #f reg1 scale reg2 offset))]
      [(pushq (rmi-imm (imm-s32 imm)))
       (mc-bytes (single-byte-op/I #x68 #f imm))]
      [(pushq (rmi-imm _))
       (panic #"pushq of non-s32 immediates not yet supported")]
      [(rep-movsb) (mc-bytes (varargs bytes #xF3 #x48 #xA4))]
      [(rep-movsq) (mc-bytes (varargs bytes #xF3 #x48 #xA5))]
      [(rep-stosb) (mc-bytes (varargs bytes #xF3 #x48 #xAA))]
      [(rep-stosq) (mc-bytes (varargs bytes #xF3 #x48 #xAB))]
      [(repe-cmpsb) (mc-bytes (varargs bytes #xF3 #x48 #xA6))]
      [(repne-scasb) (mc-bytes (varargs bytes #xF2 #x48 #xAE))]
      [(repne-scasq) (mc-bytes (varargs bytes #xF2 #x48 #xAF))]
      [(ret) (mc-bytes (varargs bytes #xC3))]
      [(sete reg)
       (mc-bytes (double-byte-op/M #x94 0 #f reg))]
      [(setg reg)
       (mc-bytes (double-byte-op/M #x9F 0 #f reg))]
      [(setge reg)
       (mc-bytes (double-byte-op/M #x9D 0 #f reg))]
      [(setl reg)
       (mc-bytes (double-byte-op/M #x9C 0 #f reg))]
      [(setle reg)
       (mc-bytes (double-byte-op/M #x9E 0 #f reg))]
      [(shlq reg)
       (mc-bytes (single-byte-op/M #xD3 4 #t reg))]
      [(shrq reg)
       (mc-bytes (single-byte-op/M #xD3 5 #t reg))]
      [(std) (mc-bytes (varargs bytes #xFD))]
      [(subq (rmi-register reg1) reg2)
       (mc-bytes (single-byte-op/RM #x29 #t reg1 reg2))]
      [(subq (rmi-imm (imm-s32 imm)) reg)
       (mc-bytes (single-byte-op/IM #x81 5 #t imm reg))]
      [(subq (rmi-imm _) reg)
       (panic #"subq of non-s32 immediate not supported")]
      [(subq (rmi-direct-memory reg1) reg2)
       (mc-bytes (single-byte-op/MR/mem #x2B #t reg1 reg2))]
      [(subq (rmi-displaced-memory _ _) _)
       (panic #"subq of displaced memory not yet supported")]
      [(subq (rmi-scaled-memory _ _ _ _) _)
       (panic #"subq of scaled memory not yet supported")]
      [(syscall) (mc-bytes (varargs bytes #x0F #x05))]
      [(ud2) (mc-bytes (varargs bytes #x0F #x0B))]
      ;; Not yet implemented
      [(leaq/rel label reg1 reg2)
       (mc-leaq/rel label reg1 reg2)]))

  ;; TODO refine types of opcodes to be the right number of bits.
  (define (single-byte-op/O [opcode : Int] [reg : Register]) : Bytes
    (let ([reg-val (register->byte reg)])
      (add-maybe-byte
        (rex-byte #f #f #f (>= reg-val 8))
        (varargs bytes
          (bitwise-ior opcode (bitwise-and reg-val #x07))))))

  (define (single-byte-op/M [opcode : Int] [op-ext : Int] [rexW : Boolean] [reg : Register]) : Bytes
    (let ([rm (register->byte reg)])
      (add-maybe-byte
        (rex-byte rexW #f #f (>= rm 8))
        (varargs bytes
          opcode
          (bitwise-ior (logical-shift-left #x03 6)
             (bitwise-ior (logical-shift-left op-ext 3)
                          (bitwise-and rm #x07)))))))

  (define (single-byte-op/I [opcode : Int] [rexW : Boolean] [imm : S32]) : Bytes
    (add-maybe-byte
      (rex-byte rexW #f #f #f)
      (let ([v (varargs bytes opcode 0 0 0 0)])
        (begin
          (bytes-set!/s32-le v 1 imm)
          v))))

   (define (single-byte-op-s64/IO [opcode : Int] [rexW : Boolean] [imm : EightBytesLe] [reg : Register]) : Bytes
     (let ([reg-val (register->byte reg)])
       (add-maybe-byte
         (rex-byte rexW #f #f (>= reg-val 8))
         (let ([v (varargs bytes
                    (bitwise-ior opcode (bitwise-and reg-val #x07))
                    0 0 0 0 0 0 0 0)])
           (begin
             (bytes-set!/eight-bytes-le v 1 imm)
             v)))))

  (define (single-byte-op/M/mem [opcode : Int] [op-ext : Int] [rexW : Boolean] [reg : Register]) : Bytes
    (let ([rm (register->byte reg)])
      (add-maybe-byte
        (rex-byte rexW #f #f (>= rm 8))
        (varargs bytes
          opcode
          (bitwise-ior (logical-shift-left #x00 6)
             (bitwise-ior (logical-shift-left op-ext 3)
                          (bitwise-and rm #x07)))))))

  ;; Doesn't support rsp or r12. This is because the instruction set doesn't support them.
  (define (single-byte-op/M/displaced-mem
            [opcode : Int] [op-ext : Int] [rexW : Boolean] [reg : Register] [displacement : S32]) : Bytes
    (let ([rm (register->byte reg)])
      (add-maybe-byte
        (rex-byte rexW #f #f (>= rm 8))
        (let ([v (varargs bytes
                   opcode
                   (bitwise-ior (logical-shift-left #x02 6)
                      (bitwise-ior (logical-shift-left (bitwise-and op-ext #x07) 3)
                                   (bitwise-and rm #x07)))
                   0 0 0 0)])
          (begin
            (bytes-set!/s32-le v 2 displacement)
            v)))))

  (define (single-byte-op/M/scaled-mem
            [opcode : Int] [op-ext : Int] [rexW : Boolean]
            [reg1 : Register] [scale : Scale] [reg2 : Register] [displacement : S32]) : Bytes
    (let ([base (register->byte reg1)])
      (let ([index (register->byte reg2)])
        (add-maybe-byte
          (rex-byte rexW #f (>= index 8) (>= base 8))
          (let ([v (varargs bytes
                     opcode
                     (bitwise-ior (logical-shift-left #x02 6)
                        (bitwise-ior (logical-shift-left (bitwise-and op-ext #x07) 3)
                                     #x04))
                     (sib-byte scale reg2 reg1)
                     0 0 0 0)])
            (begin
              (bytes-set!/s32-le v 3 displacement)
              v))))))


  (define (single-byte-op/IM [opcode : Int] [op-ext : Int] [rexW : Boolean]
                             [val : S32] [reg : Register]) : Bytes
    (let ([rm (register->byte reg)])
      (add-maybe-byte
        (rex-byte rexW #f #f (>= rm 8))
        (let ([v (varargs bytes
                   opcode
                   (bitwise-ior (logical-shift-left #x03 6)
                      (bitwise-ior (logical-shift-left (bitwise-and op-ext #x07) 3)
                                   (bitwise-and rm #x07)))
                   0 0 0 0)])
          (begin
            (bytes-set!/s32-le v 2 val)
            v)))))

  (define (single-byte-op/IM/mem [opcode : Int] [op-ext : Int] [rexW : Boolean]
                                 [val : S32] [reg : Register]) : Bytes
    (let ([rm (register->byte reg)])
      (add-maybe-byte
        (rex-byte rexW #f #f (>= rm 8))
        (let ([v (varargs bytes
                   opcode
                   (bitwise-ior (logical-shift-left #x00 6)
                      (bitwise-ior (logical-shift-left (bitwise-and op-ext #x07) 3)
                                   (bitwise-and rm #x07)))
                   0 0 0 0)])
          (begin
            (bytes-set!/s32-le v 2 val)
            v)))))

  ;; Doesn't support rsp or r12. This is because the instruction set doesn't support them.
  (define (single-byte-op/IM/displaced-mem
            [opcode : Int] [op-ext : Int] [rexW : Boolean] [val : S32]
            [reg : Register] [displacement : S32]) : Bytes
    (let ([rm (register->byte reg)])
      (add-maybe-byte
        (rex-byte rexW #f #f (>= rm 8))
        (let ([v (varargs bytes
                   opcode
                   (bitwise-ior (logical-shift-left #x02 6)
                      (bitwise-ior (logical-shift-left (bitwise-and op-ext #x07) 3)
                                   (bitwise-and rm #x07)))
                   0 0 0 0 0 0 0 0)])
          (begin
            (bytes-set!/s32-le v 2 displacement)
            (bytes-set!/s32-le v 6 val)
            v)))))

  (define (single-byte-op/RM [opcode : Int] [rexW : Boolean] [reg1 : Register] [reg2 : Register]) : Bytes
    (let ([reg (register->byte reg1)])
      (let ([rm (register->byte reg2)])
        (add-maybe-byte
          (rex-byte rexW (>= reg 8) #f (>= rm 8))
          (varargs bytes
            opcode
            (bitwise-ior (logical-shift-left #x03 6)
               (bitwise-ior (logical-shift-left (bitwise-and reg #x07) 3)
                            (bitwise-and rm #x07))))))))

  ;; Doesn't support rsp, rbp, r12 or r13. This is because the instruction set doesn't support them.
  (define (single-byte-op/RM/mem [opcode : Int] [rexW : Boolean] [reg1 : Register] [reg2 : Register]) : Bytes
    (let ([reg (register->byte reg1)])
      (let ([rm (register->byte reg2)])
        (add-maybe-byte
          (rex-byte rexW (>= reg 8) #f (>= rm 8))
          (varargs bytes
            opcode
            (bitwise-ior (logical-shift-left #x00 6)
               (bitwise-ior (logical-shift-left (bitwise-and reg #x07) 3)
                            (bitwise-and rm #x07))))))))


  ;; Doesn't support rsp or r12. This is because the instruction set doesn't support them.
  (define (single-byte-op/RM/displaced-mem
            [opcode : Int] [rexW : Boolean]
            [reg1 : Register]
            [reg2 : Register] [displacement : S32]) : Bytes
    (let ([reg (register->byte reg1)])
      (let ([rm (register->byte reg2)])
        (add-maybe-byte
          (rex-byte rexW (>= reg 8) #f (>= rm 8))
          (let ([v (varargs bytes
                     opcode
                     (bitwise-ior (logical-shift-left #x02 6)
                        (bitwise-ior (logical-shift-left (bitwise-and reg #x07) 3)
                                     (bitwise-and rm #x07)))
                     0 0 0 0)])
            (begin
              (bytes-set!/s32-le v 2 displacement)
              v))))))

  (define (single-byte-op/RM/scaled-mem
            [opcode : Int] [rexW : Boolean]
            [reg1 : Register]
            [reg2 : Register] [scale : Scale] [reg3 : Register] [displacement : S32]) : Bytes
    (let ([reg (register->byte reg1)])
      (let ([base (register->byte reg2)])
        (let ([index (register->byte reg3)])
          (add-maybe-byte
            (rex-byte rexW (>= reg 8) (>= index 8) (>= base 8))
            (let ([v (varargs bytes
                       opcode
                       (bitwise-ior (logical-shift-left #x02 6)
                          (bitwise-ior (logical-shift-left (bitwise-and reg #x07) 3)
                                       #x04))
                       (sib-byte scale reg3 reg2)
                       0 0 0 0)])
              (begin
                (bytes-set!/s32-le v 3 displacement)
                v)))))))


  (define (single-byte-op/MR [opcode : Int] [rexW : Boolean] [reg1 : Register] [reg2 : Register]) : Bytes
    (let ([rm (register->byte reg1)])
      (let ([reg (register->byte reg2)])
        (add-maybe-byte
          (rex-byte rexW (>= reg 8) #f (>= rm 8))
          (varargs bytes
            opcode
            (bitwise-ior (logical-shift-left #x03 6)
               (bitwise-ior (logical-shift-left (bitwise-and reg #x07) 3)
                            (bitwise-and rm #x07))))))))

  ;; Doesn't support rsp or r12. This is because the instruction set doesn't support them.
  (define (single-byte-op/MR/displaced-mem
            [opcode : Int] [rexW : Boolean]
            [reg1 : Register] [displacement : S32]
            [reg2 : Register]) : Bytes
    (let ([rm (register->byte reg1)])
      (let ([reg (register->byte reg2)])
        (add-maybe-byte
          (rex-byte rexW (>= reg 8) #f (>= rm 8))
          (let ([v (varargs bytes
                     opcode
                     (bitwise-ior (logical-shift-left #x02 6)
                        (bitwise-ior (logical-shift-left (bitwise-and reg #x07) 3)
                                     (bitwise-and rm #x07)))
                     0 0 0 0)])
            (begin
              (bytes-set!/s32-le v 2 displacement)
              v))))))


  ;; Doesn't support rsp, rbp, r12 or r13. This is because the instruction set doesn't support them.
  (define (single-byte-op/MR/mem [opcode : Int] [rexW : Boolean] [reg1 : Register] [reg2 : Register]) : Bytes
    (let ([rm (register->byte reg1)])
      (let ([reg (register->byte reg2)])
        (add-maybe-byte
          (rex-byte rexW (>= reg 8) #f (>= rm 8))
          (varargs bytes
            opcode
            (bitwise-ior (logical-shift-left #x00 6)
               (bitwise-ior (logical-shift-left (bitwise-and reg #x07) 3)
                            (bitwise-and rm #x07))))))))

  (define (single-byte-op/MR/scaled-mem
            [opcode : Int] [rexW : Boolean]
            [reg1 : Register] [scale : Scale] [reg2 : Register] [displacement : S32]
            [reg3 : Register]) : Bytes
    (let ([base (register->byte reg1)])
      (let ([index (register->byte reg2)])
        (let ([reg (register->byte reg3)])
          (add-maybe-byte
            (rex-byte rexW (>= reg 8) (>= index 8) (>= base 8))
            (let ([v (varargs bytes
                       opcode
                       (bitwise-ior (logical-shift-left #x02 6)
                          (bitwise-ior (logical-shift-left (bitwise-and reg #x07) 3)
                                       #x04))
                       (sib-byte scale reg2 reg1)
                       0 0 0 0)])
              (begin
                (bytes-set!/s32-le v 3 displacement)
                v)))))))


  (define (double-byte-op/MR [opcode : Int] [rexW : Boolean] [reg1 : Register] [reg2 : Register]) : Bytes
    (let ([rm (register->byte reg1)])
      (let ([reg (register->byte reg2)])
        (add-maybe-byte
          (rex-byte rexW (>= reg 8) #f (>= rm 8))
          (varargs bytes
            #x0F
            opcode
            (bitwise-ior (logical-shift-left #x03 6)
               (bitwise-ior (logical-shift-left (bitwise-and reg #x07) 3)
                            (bitwise-and rm #x07))))))))

  (define (double-byte-op/MR/scaled-mem
            [opcode : Int] [rexW : Boolean]
            [reg1 : Register] [scale : Scale] [reg2 : Register] [displacement : S32]
            [reg3 : Register]) : Bytes
    (let ([base (register->byte reg1)])
      (let ([index (register->byte reg2)])
        (let ([reg (register->byte reg3)])
          (add-maybe-byte
            (rex-byte rexW (>= reg 8) (>= index 8) (>= base 8))
            (let ([v (varargs bytes
                       #x0F
                       opcode
                       (bitwise-ior (logical-shift-left #x02 6)
                          (bitwise-ior (logical-shift-left (bitwise-and reg #x07) 3)
                                       #x04))
                       (sib-byte scale reg2 reg1)
                       0 0 0 0)])
              (begin
                (bytes-set!/s32-le v 4 displacement)
                v)))))))


  (define (double-byte-op/M [opcode : Int] [op-ext : Int] [rexW : Boolean] [reg : Register]) : Bytes
    (let ([rm (register->byte reg)])
      (add-maybe-byte
        (rex-byte rexW #f #f (>= rm 8))
        (varargs bytes
          #x0F
          opcode
          (bitwise-ior (logical-shift-left #x03 6)
             (bitwise-ior (logical-shift-left op-ext 3)
                          (bitwise-and rm #x07)))))))

  ;; TODO make this take a U8
  (define (add-maybe-byte [mv : (Maybe Int)] [bs : Bytes]) : Bytes
    (case mv
      [(nothing) bs]
      [(just v) (bytes-append (cons (varargs bytes v) (cons bs (empty))))]))


  ;; TODO make this return a U8
  (define (rex-byte [w : Boolean] [r : Boolean] [x : Boolean] [b : Boolean])
    : (Maybe Int)
    (let ([ind (lambda ([v : Boolean]) (if v 1 0))])
      (let ([val (bitwise-ior #x40
                   (bitwise-ior (logical-shift-left (ind w) 3)
                     (bitwise-ior (logical-shift-left (ind r) 2)
                       (bitwise-ior (logical-shift-left (ind x) 1)
                                    (ind b)))))])
        (if (= val #x40)
            (nothing)
            (just val)))))

  ;; TODO make this return a U8
  (define (sib-byte [scale : Scale] [index : Register] [base : Register]) : Int
    (bitwise-ior
      (case scale
        [(scale-1) #x00]
        [(scale-2) #x40]
        [(scale-4) #x80]
        [(scale-8) #xc0])
      (bitwise-ior
        (logical-shift-left (bitwise-and (register->byte index) #x07) 3)
        (bitwise-and (register->byte base) #x07))))

  ;; TODO make this return a U8
  (define (register->byte [reg : Register]) : Int
    (case reg
      ;; 8 Bit registers
      [(al) 0]
      [(ah) 4]
      [(bl) 3]
      [(bh) 7]
      [(cl) 1]
      [(ch) 5]
      [(dl) 2]
      [(dh) 6]
      [(dil) 7]
      [(sil) 6]
      [(bpl) 5]
      [(spl) 4]
      [(r8b) 8]
      [(r9b) 9]
      [(r10b) 10]
      [(r11b) 11]
      [(r12b) 12]
      [(r13b) 13]
      [(r14b) 14]
      [(r15b) 15]
      ;; 16 bit registers
      [(ax) 0]
      [(bx) 3]
      [(cx) 1]
      [(dx) 2]
      [(di) 7]
      [(si) 6]
      [(bp) 5]
      [(sp) 4]
      [(r8w) 8]
      [(r9w) 9]
      [(r10w) 10]
      [(r11w) 11]
      [(r12w) 12]
      [(r13w) 13]
      [(r14w) 14]
      [(r15w) 15]
      ;; 32 bit registers
      [(eax) 0]
      [(ebx) 3]
      [(ecx) 1]
      [(edx) 2]
      [(edi) 7]
      [(esi) 6]
      [(ebp) 5]
      [(esp) 4]
      [(r8d) 8]
      [(r9d) 9]
      [(r10d) 10]
      [(r11d) 11]
      [(r12d) 12]
      [(r13d) 13]
      [(r14d) 14]
      [(r15d) 15]
      ;;64 bit registers
      [(rax) 0]
      [(rbx) 3]
      [(rcx) 1]
      [(rdx) 2]
      [(rdi) 7]
      [(rsi) 6]
      [(rbp) 5]
      [(rsp) 4]
      [(r8) 8]
      [(r9) 9]
      [(r10) 10]
      [(r11) 11]
      [(r12) 12]
      [(r13) 13]
      [(r14) 14]
      [(r15) 15]
      [(rip) (panic #"Not valid register")]))



  (define (mc-bytes->assembly [bytes : Bytes]) : (JoinList Bytes)
    (list->jl
      (cons
        #".byte "
        (interleave #", " (extract-hex-bytes bytes 0)))))

  (define (a) (interleave [sep : a] [xs : (List a)]) : (List a)
    (case xs
      [(empty) (empty)]
      [(cons x (empty)) (cons x (empty))]
      [(cons x xs) (cons x (cons sep (interleave sep xs)))]))

  (define (extract-hex-bytes [bytes : Bytes] [offset : Int]) : (List Bytes)
    (if (= offset (bytes-length bytes))
        (empty)
        (cons
          (bytes-append (cons #"0x" (cons (integer->hex-bytes (bytes-ref bytes offset)) (empty))))
          (extract-hex-bytes bytes (+ 1 offset)))))



  (define (instruction->assembly-bytes [inst : Instruction]) : (JoinList Bytes)
    (case inst
      [(addq rmi reg)
       (varargs join-list
          #"addq "
          (rmi->bytes rmi)
          #", "
          (register->bytes reg))]
      [(andq rmi reg)
       (varargs join-list
          #"andq "
          (rmi->bytes rmi)
          #", "
          (register->bytes reg))]
      [(call label)
       (varargs join-list #"call " label)]
      [(call/indirect reg)
       (varargs join-list #"callq *" (register->bytes reg))]
      [(cld)
       (single-jl #"cld")]
      [(cmpq rmi1 rmi2)
       (varargs join-list
          #"cmpq "
          (rmi->bytes rmi1)
          #", "
          (rmi->bytes rmi2))]
      [(decq reg)
       (varargs join-list #"decq " (register->bytes reg))]
      [(idivq reg)
       (varargs join-list #"idivq " (register->bytes reg))]
      [(imulq reg)
       (varargs join-list #"imulq " (register->bytes reg))]
      [(incq reg)
       (varargs join-list #"incq " (register->bytes reg))]
      [(jb label)
       (varargs join-list #"jb " label)]
      [(je label)
       (varargs join-list #"je " label)]
      [(jmp label)
       (varargs join-list #"jmp " label)]
      [(jmp/indirect reg)
       (varargs join-list #"jmp *" (register->bytes reg))]
      [(jne label)
       (varargs join-list #"jne " label)]
      [(jnz label)
       (varargs join-list #"jnz " label)]
      [(lahf)
       (single-jl #"lahf")]
      [(leaq rmi reg)
       (varargs join-list
          #"leaq "
          (rmi->bytes rmi)
          #", "
          (register->bytes reg))]
      [(leaq/rel label reg1 reg2)
       (varargs join-list
          #"leaq "
          label
          #"("
          (register->bytes reg1)
          #"), "
          (register->bytes reg2))]
      [(movb rmi1 rmi2)
       (varargs join-list
          #"movb "
          (rmi->bytes rmi1)
          #", "
          (rmi->bytes rmi2))]
      [(movq rmi1 rmi2)
       (varargs join-list
          #"movq "
          (rmi->bytes rmi1)
          #", "
          (rmi->bytes rmi2))]
      [(movzbq rmi reg)
       (varargs join-list
          #"movzbq "
          (rmi->bytes rmi)
          #", "
          (register->bytes reg))]
      [(nop)
       (single-jl #"nop")]
      [(notq reg)
       (varargs join-list #"notq " (register->bytes reg))]
      [(orq reg1 reg2)
       (varargs join-list
          #"orq "
          (register->bytes reg1)
          #", "
          (register->bytes reg2))]
      [(popq rmi)
       (varargs join-list #"popq " (rmi->bytes rmi))]
      [(pushq rmi)
       (varargs join-list #"pushq " (rmi->bytes rmi))]
      [(rep-stosb)
       (single-jl #"rep stosb")]
      [(rep-stosq)
       (single-jl #"rep stosq")]
      [(rep-movsb)
       (single-jl #"rep movsb")]
      [(rep-movsq)
       (single-jl #"rep movsq")]
      [(repe-cmpsb)
       (single-jl #"repe cmpsb")]
      [(repne-scasb)
       (single-jl #"repne scasb")]
      [(repne-scasq)
       (single-jl #"repne scasq")]
      [(ret)
       (single-jl #"ret")]
      [(sete reg)
       (varargs join-list #"sete " (register->bytes reg))]
      [(setg reg)
       (varargs join-list #"setg " (register->bytes reg))]
      [(setge reg)
       (varargs join-list #"setge " (register->bytes reg))]
      [(setl reg)
       (varargs join-list #"setl " (register->bytes reg))]
      [(setle reg)
       (varargs join-list #"setle " (register->bytes reg))]
      [(shlq reg)
       (varargs join-list #"shlq %cl, " (register->bytes reg))]
      [(shrq reg)
       (varargs join-list #"shrq %cl, " (register->bytes reg))]
      [(std)
       (single-jl #"std")]
      [(subq rmi reg)
       (varargs join-list
          #"subq "
          (rmi->bytes rmi)
          #", "
          (register->bytes reg))]
      [(syscall)
       (single-jl #"syscall")]
      [(ud2)
       (single-jl #"ud2")]))

  (define (register->bytes [reg : Register]) : Bytes
    (case reg
      ;; 8 bit
      [(al) #"%al"]
      [(ah) #"%ah"]
      [(bl) #"%bl"]
      [(bh) #"%bh"]
      [(cl) #"%cl"]
      [(ch) #"%ch"]
      [(dl) #"%dl"]
      [(dh) #"%dh"]
      [(dil) #"%dli"]
      [(sil) #"%sil"]
      [(bpl) #"%bpl"]
      [(spl) #"%spl"]
      [(r8b) #"%r8b"]
      [(r9b) #"%r9b"]
      [(r10b) #"%r10b"]
      [(r11b) #"%r11b"]
      [(r12b) #"%r12b"]
      [(r13b) #"%r13b"]
      [(r14b) #"%r14b"]
      [(r15b) #"%r15b"]
      ;; 16 bit
      [(ax) #"%ax"]
      [(bx) #"%bx"]
      [(cx) #"%cx"]
      [(dx) #"%dx"]
      [(di) #"%di"]
      [(si) #"%si"]
      [(bp) #"%bp"]
      [(sp) #"%sp"]
      [(r8w) #"%r8w"]
      [(r9w) #"%r9w"]
      [(r10w) #"%r10w"]
      [(r11w) #"%r11w"]
      [(r12w) #"%r12w"]
      [(r13w) #"%r13w"]
      [(r14w) #"%r14w"]
      [(r15w) #"%r15w"]
      ;; 32 bit
      [(eax) #"%eax"]
      [(ebx) #"%ebx"]
      [(ecx) #"%ecx"]
      [(edx) #"%edx"]
      [(edi) #"%edi"]
      [(esi) #"%esi"]
      [(ebp) #"%ebp"]
      [(esp) #"%esp"]
      [(r8d) #"%r8d"]
      [(r9d) #"%r9d"]
      [(r10d) #"%r10d"]
      [(r11d) #"%r11d"]
      [(r12d) #"%r12d"]
      [(r13d) #"%r13d"]
      [(r14d) #"%r14d"]
      [(r15d) #"%r15d"]
      ;; 64 bit
      [(rax) #"%rax"]
      [(rbx) #"%rbx"]
      [(rcx) #"%rcx"]
      [(rdx) #"%rdx"]
      [(rdi) #"%rdi"]
      [(rsi) #"%rsi"]
      [(rbp) #"%rbp"]
      [(rsp) #"%rsp"]
      [(r8) #"%r8"]
      [(r9) #"%r9"]
      [(r10) #"%r10"]
      [(r11) #"%r11"]
      [(r12) #"%r12"]
      [(r13) #"%r13"]
      [(r14) #"%r14"]
      [(r15) #"%r15"]
      [(rip) #"%rip"]))

  (define (rmi->bytes [rmi : RegMemImm]) : Bytes
    (case rmi
      [(rmi-register r) (register->bytes r)]
      [(rmi-direct-memory reg)
       (bytes-append (varargs list #"(" (register->bytes reg) #")"))]
      [(rmi-displaced-memory reg offset)
       (bytes-append (varargs list (integer->decimal-bytes (s32->s64 offset)) #"(" (register->bytes reg) #")"))]
      [(rmi-scaled-memory reg scale index offset)
       (bytes-append
         (varargs list
           (integer->decimal-bytes (s32->s64 offset))
           #"("
           (register->bytes reg)
           #", "
           (register->bytes index)
           #", "
           (integer->decimal-bytes
             (case scale
               [(scale-1) 1]
               [(scale-2) 2]
               [(scale-4) 4]
               [(scale-8) 8]))
           #")"))]
      [(rmi-imm (imm-s32 v))
       (bytes-append (varargs list #"$" (integer->decimal-bytes (s32->s64 v))))]
      [(rmi-imm (imm-s64 v))
       (bytes-append (varargs list #"$" (integer->decimal-bytes (eight-bytes-le->int v))))]))

  (define (reg [r : Register]) : RegMemImm
    (rmi-register r))
  (define (mem [r : Register] [offset : Int]) : RegMemImm
    (case r
      ;; rsp as the index means 0 index
      [(rsp) (rmi-scaled-memory r (scale-1) (rsp) (s32 offset))]
      [(r12) (rmi-scaled-memory r (scale-1) (rsp) (s32 offset))]
      [(rbp) (rmi-displaced-memory r (s32 offset))]
      [(r13) (rmi-displaced-memory r (s32 offset))]
      [_ (if (= offset 0)
             (rmi-direct-memory r)
             (rmi-displaced-memory r (s32 offset)))]))
  (define (imm [v : Int]) : RegMemImm
    (rmi-imm (imm-s32 (s32 v))))
  (define (scaled [r : Register] [scale : Scale] [index : Register] [offset : Int]) : RegMemImm
    (rmi-scaled-memory r scale index (s32 offset)))

  (define (write-assembly-commands [cmds : (List AssemblyCommand)] [output : OutputPort]) : Void
    (write-lines (map assembly-command->bytes cmds) output))

  (define (prim-assembly-function
            [name : Bytes]
            [instructions : (List Instruction)]) : (JoinList AssemblyFragment)
    (prim-assembly-function* name instructions #f))
  (define (prim-assembly-function/panic
            [name : Bytes]
            [instructions : (List Instruction)]) : (JoinList AssemblyFragment)
    (prim-assembly-function* name instructions #t))

  (define (prim-assembly-function*
            [name : Bytes]
            [instructions : (List Instruction)]
            [panic : Boolean]) : (JoinList AssemblyFragment)
    (varargs join-list
      (address-fragment
        (bytes-append (varargs list #"prim_" name #"_closure"))
        (bytes-append (varargs list #"prim_" name)))
      (function-fragment (bytes-append (varargs list #"prim_" name))
        (let ([main-block
               (basic-block (bytes-append (varargs list #"prim_" name))
                 (list->jl instructions))])
        (if panic
            (varargs list
              main-block
              (basic-block (bytes-append (varargs list #"prim_" name #"_panic"))
                (varargs join-list (ud2))))
            (varargs list main-block))))))

  (define (start-function-fragments [main-function-name : Bytes]) : (List AssemblyFragment)
    (varargs list
      (function-fragment
        #"start"
        (varargs list
          (basic-block #"start"
            (varargs join-list
              (jmp #"start_break")))))

      (function-fragment
        #"start_break"
        (varargs list
          (basic-block #"start_break"
            (varargs join-list
              ;; Allocate Heap (Call mmap)
              ;; No fixed address desired
              (movq (imm 0) (reg (rdi)))
              ;; We want a large heap
              (movq (imm #x20000000) (reg (rsi)))
              ;; 0x1 = PROT_READ
              ;; 0x2 = PROT_WRITE
              ;; 0x4 = PROT_EXEC
              (movq (imm #x7) (reg (rdx)))
              ;; 0x0002 = MAP_SHARED
              ;; 0x1000 = MAP_ANON
              (movq (imm #x1002) (reg (r10)))
              ;; FD = -1 for no FD
              (movq (imm (- 0 1)) (reg (r8)))
              ;; offset which is ignored because of MAP_ANON
              (movq (imm 0) (reg (r9)))
              ;; 0xC5 is mmap, plus 0x2000000 because xnu
              (movq (imm #x20000C5) (reg (rax)))
              (syscall)
              (jb #"prim_start_panic")
              ;; Save heap to %r15 which is our bump pointer
              (movq (reg (rax)) (reg (r15)))

              ;; Ignore number of args as we want to reuse code for environment.
              (addq (imm 8) (rsp))
              ;; Clear direction for all the scans that will be done when
              (cld)

              ;; Count number of args
              (movq (reg (rsp)) (reg (rdi)))
              (movq (imm 0) (reg (rax)))
              ;; Assumption: Strings cannot be longer than 2^64-1
              ;; Loads treat the immediate as a 32 bit signed number, which is sign extended.
              ;; Then repne-scasq treats it as unsigned which means -1 => 2^64-1
              (movq (imm (- 0 1)) (reg (rcx)))
              (repne-scasq)
              (notq (rcx))
              (decq (rcx))
              (movq (reg (rcx)) (reg (r8)))


              (movq (reg (r15)) (reg (r10))) ; r10 is the array of bytes
              (movq (reg (r10)) (reg (r11))) ; r11 is the address of the last bytes put into the array

              (movq (reg (r8)) (mem (r10) 0))
              (leaq (scaled (r10) (scale-8) (r8) 8) (r15))

              (jmp #"start_copy_args_test")))

          (basic-block #"start_copy_args_test"
            (varargs join-list
              (popq (reg (r9))) ; r9 is now the current string
              (cmpq (imm 0) (reg (r9)))
              (je #"start_copy_args_end")))

          (basic-block #"start_copy_args_body"
            (varargs join-list

              ;; Count string length
              (movq (reg (r9)) (reg (rdi)))
              (movq (imm 0) (reg (rax)))
              ;; Assumption: Strings cannot be longer than 2^64-1
              ;; Loads treat the immediate as a 32 bit signed number, which is sign extended.
              ;; Then repne-scasb treats it as unsigned which means -1 => 2^64-1
              (movq (imm (- 0 1)) (reg (rcx)))
              (repne-scasb)
              (notq (rcx))
              (decq (rcx))

              ;; Copy bytes
              (addq (imm 8) (r11))
              (movq (reg (r15)) (mem (r11) 0))
              (movq (reg (rcx)) (mem (r15) 0))
              (addq (imm 8) (r15))
              (movq (reg (r9)) (reg (rsi)))
              (movq (reg (r15)) (reg (rdi)))
              (rep-movsb)
              (movq (reg (rdi)) (reg (r15)))
              (jmp #"start_copy_args_test")))

          (basic-block #"start_copy_args_end"
            (varargs join-list

              ;; Count number of env
              (movq (reg (rsp)) (reg (rdi)))
              (movq (imm 0) (reg (rax)))
              ;; Assumption: Strings cannot be longer than 2^64-1
              ;; Loads treat the immediate as a 32 bit signed number, which is sign extended.
              ;; Then repne-scasq treats it as unsigned which means -1 => 2^64-1
              (movq (imm (- 0 1)) (reg (rcx)))
              (repne-scasq)
              (notq (rcx))
              (decq (rcx))
              (movq (reg (rcx)) (reg (r8)))

              (movq (reg (r15)) (reg (r14))) ; r14 is the array of bytes
              (movq (reg (r14)) (reg (r11))) ; r11 is the address of the last bytes put into the array

              (movq (reg (r8)) (mem (r14) 0))
              (leaq (scaled (r14) (scale-8) (r8) 8) (r15))

              (jmp #"start_copy_env_test")))

          (basic-block #"start_copy_env_test"
            (varargs join-list
              (popq (reg (r9))) ; r9 is now the current string
              (cmpq (imm 0) (reg (r9)))
              (je #"start_copy_env_end")))

          (basic-block #"start_copy_env_body"
            (varargs join-list

              ;; Count string length
              (movq (reg (r9)) (reg (rdi)))
              (movq (imm 0) (reg (rax)))
              ;; Assumption: Strings cannot be longer than 2^64-1
              ;; Loads treat the immediate as a 32 bit signed number, which is sign extended.
              ;; Then repne-scasb treats it as unsigned which means -1 => 2^64-1
              (movq (imm (- 0 1)) (reg (rcx)))
              (repne-scasb)
              (notq (rcx))
              (decq (rcx))

              ;; Copy bytes
              (addq (imm 8) (r11))
              (movq (reg (r15)) (mem (r11) 0))
              (movq (reg (rcx)) (mem (r15) 0))
              (addq (imm 8) (r15))
              (movq (reg (r9)) (reg (rsi)))
              (movq (reg (r15)) (reg (rdi)))
              (rep-movsb)
              (movq (reg (rdi)) (reg (r15)))
              (jmp #"start_copy_env_test")))


          (basic-block #"start_copy_env_end"
            (varargs join-list
              (nop)))


          ;; Call main and then exit
          (basic-block #"start_call_main"
            (varargs join-list

              ;; Set up initial base pointer
              (movq (imm 0) (reg (rbp)))
              (movq (reg (r10)) (reg (rdi))) ;; Arguments
              (movq (imm 0) (reg (rsi)))
              (movq (imm 1) (reg (rdx)))
              (movq (imm 2) (reg (rcx)))
              (movq (reg (r14)) (reg (r8))) ;; Environment
              (pushq (imm 0)) ;; Bogus closure
              (call (bytes-append (varargs list #"y" main-function-name #"_code")))
              ;; Closure is still on the stack
              (movq (reg (rax)) (reg (rdi)))
              (movq (imm #x2000001) (reg (rax)))
              (syscall)))

          (basic-block #"prim_start_panic"
            (varargs join-list
              (ud2)))))))


  (define (prim-function-fragments) : (JoinList AssemblyFragment)
    (varargs append-jl*
      ;; write-bytes
      (prim-assembly-function/panic #"write_bytes"
        (varargs list
          ;; Swap %rdi and %rsi
          (movq (reg (rdi)) (reg (rax)))
          (movq (reg (rsi)) (reg (rdi)))
          (movq (reg (rax)) (reg (rsi)))

          ;; %rdi is now the file descriptor
          ;; Make %rsi the start of the buffer
          (leaq (scaled (rsi) (scale-1) (rdx) 8) (rsi))
          ;; Make %rdx the length to write
          (subq (reg (rdx)) (rcx))
          (movq (reg (rcx)) (reg (rdx)))
          (movq (imm #x2000004) (reg (rax)))
          (syscall)
          (jb #"prim_write_bytes_panic")
          (ret)))

      ;; read-bytes
      (prim-assembly-function/panic #"read_bytes"
        (varargs list
          ;; Swap %rdi and %rsi
          (movq (reg (rdi)) (reg (rax)))
          (movq (reg (rsi)) (reg (rdi)))
          (movq (reg (rax)) (reg (rsi)))

          ;; %rdi is the file descriptor
          ;; Make %rsi the start of the buffer
          (leaq (scaled (rsi) (scale-1) (rdx) 8) (rsi))
          ;; Make %rdx the length to read
          (subq (reg (rdx)) (rcx))
          (movq (reg (rcx)) (reg (rdx)))
          (movq (imm #x2000003) (reg (rax)))
          (syscall)
          (jb #"prim_read_bytes_panic")
          (ret)))

      ;; open-input-file
      (prim-assembly-function/panic #"open_input_file"
        (varargs list
          ;; Make %rdi point at start of null terminated path
          (addq (imm 8) (rdi))
          (movq (imm 0) (reg (rsi))) ;; 0 is read only
          (movq (imm #x2000005) (reg (rax)))
          (syscall)
          (jb #"prim_open_input_file_panic")
          (ret)))

      ;; open-output-file
      (prim-assembly-function/panic #"open_output_file"
        (varargs list
          ;; Make %rdi point at start of null terminated path
          (addq (imm 8) (rdi))
          (movq (imm 513) (reg (rsi))) ;; 1 is write only, 512 is create
          (movq (imm 504) (reg (rdx))) ;; 770 for mode
          (movq (imm #x2000005) (reg (rax)))
          (syscall)
          (jb #"prim_open_output_file_panic")
          (ret)))


      ;; close-output-port
      ;; close-input-port
      (prim-assembly-function/panic #"close_port"
        (varargs list
          (movq (imm #x2000006) (reg (rax)))
          (syscall)
          (jb #"prim_close_port_panic")
          (ret)))

      ;; socket
      (prim-assembly-function/panic #"socket"
        (varargs list
          ;; Argument 1: domain
          ;; Argument 2: type
          ;; Argument 3: protocol
          (movq (imm #x2000061) (reg (rax)))
          (syscall)
          (jb #"prim_socket_panic")
          (ret)))

      ;; bind
      (prim-assembly-function/panic #"bind"
        (varargs list
          ;; Argument 1: socket
          ;; Argument 2: sockaddr
          ;; Argument 3: length
          (addq (imm 8) (rsi))
          (movq (imm #x2000068) (reg (rax)))
          (syscall)
          (jb #"prim_bind_panic")
          (ret)))

      ;; sendto
      (prim-assembly-function/panic #"sendto"
        (varargs list
          ;; Argument 1: socket
          ;; Argument 2: buffer
          ;; Argument 3: buffer-length
          ;; Argument 4: flags
          ;; Argument 5: sockaddr
          ;; Argument 6: sockaddr-length
          (addq (imm 8) (rsi))
          (addq (imm 8) (r8))
          (movq (reg (rcx)) (reg (r10)))
          (movq (imm #x2000085) (reg (rax)))
          (syscall)
          (jb #"prim_sendto_panic")
          (ret)))

      ;; recvfrom
      (prim-assembly-function/panic #"recvfrom"
        (varargs list
          ;; Argument 1: socket
          ;; Argument 2: buffer
          ;; Argument 3: buffer-length
          ;; Argument 4: flags
          ;; Argument 5: sockaddr
          ;; Argument 6: sockaddr-length
          (addq (imm 8) (rsi))
          (addq (imm 8) (r8))
          (addq (imm 8) (r9))
          (movq (reg (rcx)) (reg (r10)))
          (movq (imm #x200001d) (reg (rax)))
          (syscall)
          (jb #"prim_recvfrom_panic")
          (ret)))

      ;; connect
      (prim-assembly-function/panic #"connect"
        (varargs list
          ;; Argument 1: socket
          ;; Argument 2: sockaddr
          ;; Argument 3: sockaddr-length
          (addq (imm 8) (rsi))
          (movq (imm #x2000062) (reg (rax)))
          (syscall)
          (jb #"prim_connect_panic")
          (ret)))

      ;; shutdown
      (prim-assembly-function/panic #"shutdown"
        (varargs list
          ;; Argument 1: socket
          ;; Argument 2: how
          (movq (imm #x2000086) (reg (rax)))
          (syscall)
          (jb #"prim_shutdown_panic")
          (ret)))


      ;; listen
      (prim-assembly-function/panic #"listen"
        (varargs list
          ;; Argument 1: socket
          ;; Argument 2: backlog
          (movq (imm #x200006A) (reg (rax)))
          (syscall)
          (jb #"prim_listen_panic")
          (ret)))

      ;; accept
      (prim-assembly-function/panic #"accept"
        (varargs list
          ;; Argument 1: socket
          ;; Argument 2: sockaddr
          ;; Argument 3: sockaddr-length
          (addq (imm 8) (rsi))
          (addq (imm 8) (rdx))
          (movq (imm #x200001E) (reg (rax)))
          (syscall)
          (jb #"prim_accept_panic")
          (ret)))


      ;; setsockopt
      (prim-assembly-function/panic #"setsockopt"
        (varargs list
          ;; Argument 1: socket
          ;; Argument 2: level
          ;; Argument 3: option name
          ;; Argument 4: option value
          ;; Argument 5: option length
          (movq (reg (rcx)) (reg (r10)))
          (addq (imm 8) (r10))
          (movq (imm #x2000069) (reg (rax)))
          (syscall)
          (jb #"prim_setsockopt_panic")
          (ret)))


      ;; mach_task_self
      (prim-assembly-function/panic #"mach_task_self"
        (varargs list
          (movq (imm #x100001c) (reg (rax)))
          (syscall)
          (cmpq (imm 0) (reg (rax)))
          (je #"prim_mach_task_self_panic")
          (ret)))


      ;; mach_thread_self
      (prim-assembly-function/panic #"mach_thread_self"
        (varargs list
          (movq (imm #x100001b) (reg (rax)))
          (syscall)
          (cmpq (imm 0) (reg (rax)))
          (je #"prim_mach_thread_self_panic")
          (ret)))


      ;; mach_reply_port
      (prim-assembly-function/panic #"mach_reply_port"
        (varargs list
          (movq (imm #x100001a) (reg (rax)))
          (syscall)
          (cmpq (imm 0) (reg (rax)))
          (je #"prim_mach_reply_port_panic")
          (ret)))


      ;; mach_port_mod_refs
      (prim-assembly-function/panic #"mach_port_mod_refs"
        (varargs list
          ;; Argument 1: task
          ;; Argument 2: port
          ;; Argument 3: right
          ;; Argument 4: delta
          (movq (reg (rcx)) (reg (r10)))
          (movq (imm #x1000013) (reg (rax)))
          (syscall)
          (cmpq (imm 0) (reg (rax)))
          (jne #"prim_mach_port_mod_refs_panic")
          (ret)))

      ;; mach_msg
      (prim-assembly-function/panic #"mach_msg"
        (varargs list
          (movq (mem (r10) 0) (reg (rax))) ;; Notify Port
          (movq (reg (rcx)) (reg (r10)))

          (addq (imm 8) (rdi)) ;; Adjust past buffer's length field
          (pushq (reg (rax))) ;; Push back the notify port
          (pushq (imm 0)) ;; Dummy Return Address
          (movq (imm #x100001f) (reg (rax)))
          (syscall)
          (cmpq (imm 0) (reg (rax)))
          (jne #"prim_mach_msg_panic")
          (addq (imm #x10) (rsp)) ;; 2 pop
          (ret)))

      ;; mach_start_thread
      ;; This function is needed because we cannot cast the function to be called
      ;; to a int without being atomic with respect to GC.
      (prim-assembly-function/panic #"mach_start_thread"
        (varargs list
          ;; Argument 1: buffer (rdi)
          ;; Argument 2: closure (rsi)
          ;; Argument 3: reply-port (rdx)

          ;; Alocate the stack and fill in the stack pointer
          ;; The stack grows down so we adjust the pointer first
          (addq (imm #xFFFFF) (r15))
          (movq (reg (r15)) (mem (rdi) 104))
          (addq (imm #x1) (r15))
          ;; Alocate the heap and fill in the heap pointer
          (movq (reg (r15)) (mem (rdi) 168))
          (addq (imm #x100000) (r15))
          ;; Set the instruction pointer to the bootstrap function
          (leaq/rel #"prim_thread_bootstrap" (rip) (rax))
          (movq (reg (rax)) (mem (rdi) 176))
          ;; Set rax on the new thread to the closure
          (movq (reg (rsi)) (mem (rdi) 48))

          (movq (mem (rdi) 0) (reg (r10))) ;; Load buffer's length
          (movq (reg (rdx)) (reg (r8))) ;; Move reply-port to correct register
          (addq (imm 8) (rdi)) ;; Adjust past buffer's length field
          (movq (imm 3) (reg (rsi))) ;; We want to send and receive
          (movq (imm 208) (reg (rdx))) ;; The length of the incoming message
          (movq (imm 0) (reg (r9))) ;; Specify that there is no timeout
          (pushq (imm 0)) ;; Specify no notify port
          (pushq (imm 0)) ;; Put a dummy return address since syscalls don't return like functions

          (movq (imm #x100001f) (reg (rax)))
          (syscall)
          (cmpq (imm 0) (reg (rax)))
          (jne #"prim_mach_start_thread_panic")

          ;; TODO do GC magic to register new thread here
          (addq (imm #x10) (rsp)) ;; 2 pop
          (ret)))


      ;; and
      (prim-assembly-function #"and"
        (varargs list
          (andq (reg (rdi)) (rsi))
          (movq (reg (rsi)) (reg (rax)))
          (ret)))
      ;; or
      (prim-assembly-function #"or"
        (varargs list
          (orq (rdi) (rsi))
          (movq (reg (rsi)) (reg (rax)))
          (ret)))


      ;; bytes-ref
      (prim-assembly-function #"bytes_ref"
        (varargs list
          (movzbq (scaled (rdi) (scale-1) (rsi) 8) (rax))
          (ret)))
      ;; make-bytes
      (prim-assembly-function #"make_bytes"
        (varargs list
          (movq (reg (r15)) (reg (rdx)))
          (movq (reg (rdi)) (mem (r15) 0))
          (movq (reg (rdi)) (reg (rcx)))
          (addq (imm 8) (r15))
          (movq (imm 0) (reg (rax)))
          (movq (reg (r15)) (reg (rdi)))
          (cld)
          (rep-stosb)
          (movq (reg (rdi)) (reg (r15)))
          (movq (reg (rdx)) (reg (rax)))
          (ret)))

      ;; bytes-set!
      (prim-assembly-function #"bytes_set"
        (varargs list
          (movb (reg (dl)) (scaled (rdi) (scale-1) (rsi) 8))
          (movq (imm 0) (reg (rax)))
          (ret)))
      ;; bytes-length
      (prim-assembly-function #"bytes_length"
        (varargs list
          (movq (mem (rdi) 0) (reg (rax)))
          (ret)))

      ;; void
      (prim-assembly-function #"void"
        (varargs list
          (movq (imm 0) (reg (rax)))
          (ret)))

      ;; u8
      ;; TODO(endobson) add check that it is in the right range
      (prim-assembly-function #"u8"
        (varargs list
          (movq (reg (rdi)) (reg (rax)))
          (ret)))

      ;; s32
      ;; TODO(endobson) add check that it is in the right range
      (prim-assembly-function #"s32"
        (varargs list
          (movq (reg (rdi)) (reg (rax)))
          (ret)))

      ;; u32
      ;; TODO(endobson) add check that it is in the right range
      (prim-assembly-function #"u32"
        (varargs list
          (movq (reg (rdi)) (reg (rax)))
          (ret)))

      ;; u8->s64
      (prim-assembly-function #"u8_s64"
        (varargs list
          (movq (reg (rdi)) (reg (rax)))
          (ret)))

      ;; s32->s64
      (prim-assembly-function #"s32_s64"
        (varargs list
          (movq (reg (rdi)) (reg (rax)))
          (ret)))

      ;; u32->s64
      (prim-assembly-function #"u32_s64"
        (varargs list
          (movq (reg (rdi)) (reg (rax)))
          (ret)))

      ;; u32/le-byte#
      ;; s32/le-byte#
      (prim-assembly-function #"quad_le_byte0"
        (varargs list
          (andq (imm #xFF) (rdi))
          (movq (reg (rdi)) (reg (rax)))
          (ret)))
      (prim-assembly-function #"quad_le_byte1"
        (varargs list
          (movq (imm #x8) (reg (rcx)))
          (shrq (rdi))
          (andq (imm #xFF) (rdi))
          (movq (reg (rdi)) (reg (rax)))
          (ret)))
      (prim-assembly-function #"quad_le_byte2"
        (varargs list
          (movq (imm #x10) (reg (rcx)))
          (shrq (rdi))
          (andq (imm #xFF) (rdi))
          (movq (reg (rdi)) (reg (rax)))
          (ret)))
      (prim-assembly-function #"quad_le_byte3"
        (varargs list
          (movq (imm #x18) (reg (rcx)))
          (shrq (rdi))
          (andq (imm #xFF) (rdi))
          (movq (reg (rdi)) (reg (rax)))
          (ret)))

      ;; panic
      (prim-assembly-function #"panic"
        (varargs list
          (movq (mem (rsp) 0) (reg (rax)))
          (addq (imm 8) (rax))
          (ud2)))

      ;; These are not native functions, but just native subroutines
      ;; They do not follow standard calling conventions


      ;; variant-panic
      (prim-assembly-function #"variant_panic"
        (varargs list
          (ud2)))

      ;; thread_bootstrap
      (prim-assembly-function #"thread_bootstrap"
        (varargs list
          (pushq (reg (rax)))
          (movq (reg (rax)) (reg (r11)))
          (movq (mem (rax) 0) (reg (rax)))
          (call/indirect (rax))
          ;; Closure is still on the stack
          (ud2)))))



  (define (convert-objects [objects : (List TopLevelObject)]) : (List AssemblyFragment)
    (map (lambda ([object : TopLevelObject])
           (case object
             [(function-tlo fun) (convert-function fun)]
             [(bytes-tlo name value) (bytes-fragment name value)]
             [(trivial-closure-tlo name fun-name)
              (address-fragment name fun-name)]))
      objects))

  (define (convert-function [fun : StackFunction]) : AssemblyFragment
    (case fun
      [(stack-function name num-args blocks)
       (function-fragment name
         (cons
           (basic-block name
             (varargs append-jl*
               (varargs join-list
                 (pushq (reg (rbp)))
                 (movq (reg (rsp)) (reg (rbp))))
               (if (>= num-args 1)
                   (single-jl (pushq (reg (rdi))))
                   (empty-jl))
               (if (>= num-args 2)
                   (single-jl (pushq (reg (rsi))))
                   (empty-jl))
               (if (>= num-args 3)
                   (single-jl (pushq (reg (rdx))))
                   (empty-jl))
               (if (>= num-args 4)
                   (single-jl (pushq (reg (rcx))))
                   (empty-jl))
               (if (>= num-args 5)
                   (single-jl (pushq (reg (r8))))
                   (empty-jl))
               (if (>= num-args 6)
                   (single-jl (pushq (reg (r9))))
                   (empty-jl))
               (if (>= num-args 7)
                   (install-extra-arguments 0 (- num-args 6))
                   (empty-jl))))
           (convert-basic-blocks name 0 blocks)))]))

  (define (write-fragments [fragments : (List AssemblyFragment)] [output : OutputPort]) : Void
    (write-assembly-commands (jl->list (fragments->commands fragments)) output))

  (define (fragments->commands [fragments : (List AssemblyFragment)]) : (JoinList AssemblyCommand)
    (case fragments
      [(empty) (empty-jl)]
      [(cons fragment fragments)
       (append-jl
         (fragment->commands fragment)
         (fragments->commands fragments))]))

  (define (fragment->commands [frag : AssemblyFragment]) : (JoinList AssemblyCommand)
    (case frag
      [(function-fragment _ blocks)
       (cons-jl
         (directive-cmd (section-directive #"__TEXT" #"__text"))
         (basic-blocks->commands blocks))]
      [(address-fragment name value)
       (varargs join-list
         (directive-cmd (section-directive #"__TEXT" #"__const"))
         (directive-cmd (global-directive name))
         (directive-cmd (label-directive name))
         (directive-cmd (quad-directive/label value)))]
      [(bytes-fragment name value)
       (varargs join-list
         (directive-cmd (section-directive #"__TEXT" #"__const"))
         (directive-cmd (global-directive name))
         (directive-cmd (label-directive name))
         (directive-cmd (quad-directive/integer (bytes-length value)))
         (directive-cmd (ascii-directive value)))]))

  (define (basic-blocks->commands [blocks : (List BasicBlock)]) : (JoinList AssemblyCommand)
    (case blocks
      [(empty) (empty-jl)]
      [(cons (basic-block name instructions) blocks)
       (cons-jl
         (directive-cmd (global-directive name))
         (cons-jl
           (directive-cmd (label-directive name))
           (append-jl
             (map-jl instruction-cmd instructions)
             (basic-blocks->commands blocks))))]))


  (define (convert-basic-blocks [fun-name : Bytes] [index : Int] [blocks : (List StackBasicBlock)])
    : (List BasicBlock)
    (case blocks
      [(empty) (empty)]
      [(cons block blocks)
       (cons
         (convert-basic-block fun-name index block)
         (convert-basic-blocks fun-name (+ index 1) blocks))]))

  (define (convert-basic-block [fun-name : Bytes] [index : Int] [block : StackBasicBlock])
    : BasicBlock
    (case block
      [(stack-basic-block cmds terminal)
       (basic-block
         (bytes-append (varargs list fun-name #"_" (integer->decimal-bytes index)))
         (append-jl
           (convert-commands cmds)
           (convert-terminal fun-name terminal)))]))


  (define (line->bytes [line : (JoinList Bytes)]) : Bytes
    (case (jl->list line)
      [(empty) #""]
      [(cons entry (empty)) entry]
      [entries (bytes-append entries)]))

  (define (write-lines [lines : (List (JoinList Bytes))] [output : OutputPort]) : Void
    (for-each
      (lambda ([line : (JoinList Bytes)])
        (begin
          (write-line (line->bytes line) output)))
      lines))

  (define (convert-terminal [fun-name : Bytes] [terminal : StackTerminal]) : (JoinList Instruction)
    (case terminal
      [(return num-cleanup)
       (varargs join-list
         (popq (reg (rax)))
         (addq (imm (* 8 num-cleanup)) (rsp))
         (popq (reg (rbp)))
         (ret))]
      [(tail-call n num-cleanup)
       (if (> n 6)
           (panic #"large tail call not implemented")
           (varargs append-jl*
             (if (>= n 1)
                 (single-jl (movq (mem (rsp) (- (* 8 n) #x00)) (reg (rdi))))
                 (empty-jl))
             (if (>= n 2)
                 (single-jl (movq (mem (rsp) (- (* 8 n) #x08)) (reg (rsi))))
                 (empty-jl))
             (if (>= n 3)
                 (single-jl (movq (mem (rsp) (- (* 8 n) #x10)) (reg (rdx))))
                 (empty-jl))
             (if (>= n 4)
                 (single-jl (movq (mem (rsp) (- (* 8 n) #x18)) (reg (rcx))))
                 (empty-jl))
             (if (>= n 5)
                 (single-jl (movq (mem (rsp) (- (* 8 n) #x20)) (reg (r8))))
                 (empty-jl))
             (if (>= n 6)
                 (single-jl (movq (mem (rsp) (- (* 8 n) #x28)) (reg (r9))))
                 (empty-jl))
             (varargs join-list
               (movq (mem (rsp) 0) (reg (r11)))
               (movq (reg (r11)) (mem (rsp) (* 8 n)))
               (movq (mem (r11) 0) (reg (rax)))
               (addq (imm (* 8 (+ (+ num-cleanup 1) n))) (rsp))
               (popq (reg (rbp)))
               (jmp/indirect (rax)))))]
      [(known-tail-call name n num-cleanup)
       (if (> n 6)
           (panic #"large tail call not implemented")
           (varargs append-jl*
             (if (>= n 1)
                 (single-jl (movq (mem (rsp) (- (* 8 n) #x08)) (reg (rdi))))
                 (empty-jl))
             (if (>= n 2)
                 (single-jl (movq (mem (rsp) (- (* 8 n) #x10)) (reg (rsi))))
                 (empty-jl))
             (if (>= n 3)
                 (single-jl (movq (mem (rsp) (- (* 8 n) #x18)) (reg (rdx))))
                 (empty-jl))
             (if (>= n 4)
                 (single-jl (movq (mem (rsp) (- (* 8 n) #x20)) (reg (rcx))))
                 (empty-jl))
             (if (>= n 5)
                 (single-jl (movq (mem (rsp) (- (* 8 n) #x28)) (reg (r8))))
                 (empty-jl))
             (if (>= n 6)
                 (single-jl (movq (mem (rsp) (- (* 8 n) #x30)) (reg (r9))))
                 (empty-jl))
             (varargs join-list
               (addq (imm (* 8 (+ n num-cleanup))) (rsp))
               (popq (reg (rbp)))
               (jmp name))))]
      [(uncond-jmp index)
       (single-jl (jmp (bytes-append (varargs list fun-name #"_" (integer->decimal-bytes index)))))]
      [(boolean-jmp true-index false-index)
       (varargs join-list
         (popq (reg (rax)))
         (cmpq (imm 0) (reg (rax)))
         (jne (bytes-append (varargs list fun-name #"_" (integer->decimal-bytes true-index))))
         (jmp (bytes-append (varargs list fun-name #"_" (integer->decimal-bytes false-index)))))]
      [(variant-switch cases)
       (cons-jl
         (movq (mem (rsp) 0) (reg (rax)))
         (convert-variant-switch fun-name cases))]))

  ;; The current value is in %rax.
  (define (convert-variant-switch [fun-name : Bytes] [cases : VariantCases]) : (JoinList Instruction)
    (case cases
      [(no-catch-all-case)
       (single-jl (ud2))]
      [(catch-all-case block)
       (single-jl (jmp (bytes-append (varargs list fun-name #"_" (integer->decimal-bytes block)))))]
      [(variant-case tag block cases)
       (cons-jl
         (cmpq (imm tag) (mem (rax) 0))
         (cons-jl
           (je (bytes-append (varargs list fun-name #"_" (integer->decimal-bytes block))))
           (convert-variant-switch fun-name cases)))]))

  (define (convert-commands [cmds : (List StackCmd)]) : (JoinList Instruction)
    (case cmds
      [(empty) (empty-jl)]
      [(cons cmd cmds)
       (append-jl
         (convert-command cmd)
         (convert-commands cmds))]))


  (define (convert-command [cmd : StackCmd]) : (JoinList Instruction)
    (case cmd
      [(dup-cmd offset)
       (varargs join-list
         (pushq (mem (rsp) (* offset 8))))]
      [(dup-free-var-cmd offset index)
       (varargs join-list
         (pushq (mem (r11) (* (+ 1 index) 8))))]
      [(swap-cmd)
       (varargs join-list
         (popq (reg (rax)))
         (popq (reg (rbx)))
         (pushq (reg (rax)))
         (pushq (reg (rbx))))]
      [(pop-cmd)
       (varargs join-list
         (popq (reg (rax))))]
      [(num-lit-cmd v)
       (varargs join-list
         (movq (rmi-imm (imm-s64 (int->eight-bytes-le v))) (reg (rax)))
         (pushq (reg (rax))))]
      [(boolean-lit-cmd v)
       (varargs join-list
         (pushq (imm (if v 1 0))))]
      ;; TODO put the bytes not directly in the instruction stream
      [(bytes-cmp-cmd)
       (varargs join-list
         (popq (reg (rdi))) ;; Argument 2
         (popq (reg (rsi))) ;; Argument 1
         (movq (mem (rsi) 0) (reg (rcx)))
         (addq (imm 8) (rcx))
         (repe-cmpsb)
         (sete (al))
         (movzbq (reg (al)) (rax))
         (pushq (reg (rax))))]

      [(load-global-cmd name)
       (varargs join-list
         (leaq/rel name (rip) (rax))
         (pushq (reg (rax))))]

      [(create-closure-cmd n)
       (varargs append-jl*
         (single-jl (movq (reg (r15)) (reg (rax))))
         (copy-objects (+ n 1))
         (single-jl (pushq (reg (rax)))))]
      [(fun-call-cmd n)
       (varargs append-jl*
         (if (>= n 1)
             (single-jl (movq (mem (rsp) (- (* 8 n) #x00)) (reg (rdi))))
             (empty-jl))
         (if (>= n 2)
             (single-jl (movq (mem (rsp) (- (* 8 n) #x08)) (reg (rsi))))
             (empty-jl))
         (if (>= n 3)
             (single-jl (movq (mem (rsp) (- (* 8 n) #x10)) (reg (rdx))))
             (empty-jl))
         (if (>= n 4)
             (single-jl (movq (mem (rsp) (- (* 8 n) #x18)) (reg (rcx))))
             (empty-jl))
         (if (>= n 5)
             (single-jl (movq (mem (rsp) (- (* 8 n) #x20)) (reg (r8))))
             (empty-jl))
         (if (>= n 6)
             (single-jl (movq (mem (rsp) (- (* 8 n) #x28)) (reg (r9))))
             (empty-jl))
         (if (>= n 7)
             (cons-jl
               (movq (reg (r15)) (reg (r10)))
               (copy-extra-arguments 6 n))
             (empty-jl))
         (varargs join-list
           (movq (mem (rsp) 0) (reg (rax)))
           (movq (reg (rax)) (mem (rsp) (* 8 n)))
           (addq (imm (* 8 n)) (rsp))
           (movq (mem (rsp) 0) (reg (rax)))
           (movq (reg (r11)) (mem (rsp) 0))
           (movq (reg (rax)) (reg (r11)))
           (movq (mem (rax) 0) (reg (rax)))
           (call/indirect (rax))
           ;; Read back the closure and then overwrite it
           (movq (mem (rsp) 0) (reg (r11)))
           (movq (reg (rax)) (mem (rsp) 0))))]
      [(known-fun-call-cmd name n)
       (varargs append-jl*
         (if (>= n 1)
             (single-jl (movq (mem (rsp) (- (* 8 n) #x08)) (reg (rdi))))
             (empty-jl))
         (if (>= n 2)
             (single-jl (movq (mem (rsp) (- (* 8 n) #x10)) (reg (rsi))))
             (empty-jl))
         (if (>= n 3)
             (single-jl (movq (mem (rsp) (- (* 8 n) #x18)) (reg (rdx))))
             (empty-jl))
         (if (>= n 4)
             (single-jl (movq (mem (rsp) (- (* 8 n) #x20)) (reg (rcx))))
             (empty-jl))
         (if (>= n 5)
             (single-jl (movq (mem (rsp) (- (* 8 n) #x28)) (reg (r8))))
             (empty-jl))
         (if (>= n 6)
             (single-jl (movq (mem (rsp) (- (* 8 n) #x30)) (reg (r9))))
             (empty-jl))
         (if (>= n 7)
             (cons-jl
               (movq (reg (r15)) (reg (r10)))
               (copy-extra-arguments* 6 n))
             (empty-jl))
         (varargs join-list
           (addq (imm (* 8 n)) (rsp))
           (pushq (reg (r11)))
           (call name)
           ;; Read back the closure and then overwrite it
           (movq (mem (rsp) 0) (reg (r11)))
           (movq (reg (rax)) (mem (rsp) 0))))]

      [(make-array-cmd)
       (varargs join-list
         (popq (reg (rax)))
         (popq (reg (rcx)))
         (movq (reg (r15)) (reg (rdx)))
         (movq (reg (rcx)) (mem (r15) 0))
         (addq (imm 8) (r15))
         (movq (reg (r15)) (reg (rdi)))
         (rep-stosq)
         (movq (reg (rdi)) (reg (r15)))
         (pushq (reg (rdx))))]
      [(make-array-from-stack-cmd num-args)
       (varargs join-list
         (movq (imm num-args) (reg (rcx)))
         (movq (reg (rsp)) (reg (rsi)))
         (movq (reg (r15)) (reg (rax)))
         (leaq (scaled (rsp) (scale-8) (rcx) 0) (rsp))
         (movq (reg (rcx)) (mem (r15) 0))
         (leaq (mem (r15) 8) (rdi))
         (leaq (scaled (r15) (scale-8) (rcx) 8) (r15))
         (cld)
         (rep-movsq)
         (pushq (reg (rax))))]
      [(array-length-cmd)
       (varargs join-list
         (popq (reg (rax)))
         (pushq (mem (rax) 0)))]
      [(array-ref-cmd)
       (varargs join-list
         (popq (reg (rcx)))
         (popq (reg (rax)))
         (pushq (scaled (rax) (scale-8) (rcx) 8)))]
      [(array-set!-cmd)
       (varargs join-list
         (popq (reg (rdx)))
         (popq (reg (rcx)))
         (popq (reg (rax)))
         (movq (reg (rdx)) (scaled (rax) (scale-8) (rcx) 8))
         (pushq (imm 0)))]

      [(bin-logic-math-cmd op)
       (varargs join-list
         (popq (reg (rax))) ;; Argument 2
         (popq (reg (rcx))) ;; Argument 1
         (cmpq (reg (rax)) (reg (rcx)))
         (case op
           [(less-than-op)
            (setl (al))]
           [(less-than-or-equal-op)
            (setle (al))]
           [(equal-op)
            (sete (al))]
           [(greater-than-or-equal-op)
            (setge (al))]
           [(greater-than-op)
            (setg (al))])
         (movzbq (reg (al)) (rax))
         (pushq (reg (rax))))]
      [(bin-math-cmd (bin-add-op))
       (varargs join-list
         (popq (reg (rax)))
         (popq (reg (rcx)))
         (addq (reg (rcx)) (rax))
         (pushq (reg (rax))))]
      [(bin-math-cmd (bin-sub-op))
       (varargs join-list
         (popq (reg (rcx)))
         (popq (reg (rax)))
         (subq (reg (rcx)) (rax))
         (pushq (reg (rax))))]
      [(bin-math-cmd (bin-mult-op))
       (varargs join-list
         (popq (reg (rax)))
         (popq (reg (rcx)))
         (imulq (rcx))
         (pushq (reg (rax))))]
      [(bin-math-cmd (bin-quotient-op))
       (varargs join-list
         (popq (reg (rcx)))
         (popq (reg (rax)))
         (movq (imm 0) (reg (rdx)))
         (idivq (rcx))
         (pushq (reg (rax))))]
      [(bin-math-cmd (bin-remainder-op))
       (varargs join-list
         (popq (reg (rcx)))
         (popq (reg (rax)))
         (movq (imm 0) (reg (rdx)))
         (idivq (rcx))
         (pushq (reg (rdx))))]
      [(bin-math-cmd (bin-bitwise-and-op))
       (varargs join-list
         (popq (reg (rcx)))
         (popq (reg (rax)))
         (andq (reg (rcx)) (rax))
         (pushq (reg (rax))))]
      [(bin-math-cmd (bin-bitwise-ior-op))
       (varargs join-list
         (popq (reg (rcx)))
         (popq (reg (rax)))
         (orq (rcx) (rax))
         (pushq (reg (rax))))]
      ;; TODO check shift amount is valid value
      [(bin-math-cmd (bin-logical-shift-left-op))
       (varargs join-list
         (popq (reg (rcx)))
         (popq (reg (rax)))
         (shlq (rax))
         (pushq (reg (rax))))]
      [(bin-math-cmd (bin-logical-shift-right-op))
       (varargs join-list
         (popq (reg (rcx)))
         (popq (reg (rax)))
         (shrq (rax))
         (pushq (reg (rax))))]
      [(alloc-variant-cmd tag fields)
       (varargs append-jl*
         (single-jl (movq (reg (r15)) (reg (rax))))
         (single-jl (movq (imm tag) (mem (r15) 0)))
         (single-jl (addq (imm 8) (r15)))
         (copy-objects fields)
         (single-jl (pushq (reg (rax)))))]
      [(variant-ref-cmd tag field)
       (varargs join-list
         (popq (reg (rax)))
         (cmpq (imm tag) (mem (rax) 0))
         (jne #"prim_variant_panic")
         (pushq (mem (rax) (+ (* 8 field) 8))))]))


  ;; Generates assembly to copy `args` arguments from the top of the stack to the
  ;; memory starting at %r15 %r15 ends up pointing right after after the last argument written.
  ;; Dirties %rax
  (define (copy-extra-arguments [arg : Int] [args : Int]) : (JoinList Instruction)
    (if (= arg args)
        (empty-jl)
        (cons-jl
          (movq (mem (rsp) (* (- args arg) 8)) (reg (rax)))
          (cons-jl
            (movq (reg (rax)) (mem (r15) 0))
            (cons-jl
              (addq (imm 8) (r15))
              (copy-extra-arguments (+ 1 arg) args))))))

  ;; Generates assembly to copy `args` arguments from the top of the stack to the
  ;; memory starting at %r15 %r15 ends up pointing right after after the last argument written.
  ;; Dirties %rax
  (define (copy-extra-arguments* [arg : Int] [args : Int]) : (JoinList Instruction)
    (if (= arg args)
        (empty-jl)
        (cons-jl
          (movq (mem (rsp) (* (- args (+ arg 1)) 8)) (reg (rax)))
          (cons-jl
            (movq (reg (rax)) (mem (r15) 0))
            (cons-jl
              (addq (imm 8) (r15))
              (copy-extra-arguments* (+ 1 arg) args))))))


  ;; Generates assembly to install `args` arguments from %r10 ontop of the stack
  (define (install-extra-arguments [arg : Int] [args : Int]) : (JoinList Instruction)
    (if (= arg args)
        (empty-jl)
        (cons-jl
          (pushq (mem (r10) (* arg 8)))
          (install-extra-arguments (+ 1 arg) args))))


  ;; Generates assembly to copy n objects from the top of the stack to the
  ;; memory starting at %r15 %r15 ends up pointing right after after the last object written.
  (define (copy-objects [n : Int]) : (JoinList Instruction)
    (if (> n 0)
        (cons-jl
          (popq (mem (r15) 0))
          (cons-jl
            (addq (imm 8) (r15))
            (copy-objects (- n 1))))
        (empty-jl)))



  ;; TODO switch to a polymorphic one when it works
  (define (a) (extract-either [either : (Either Bytes a)]) : a
    (case either
      [(right v) v]
      [(left v) (panic v)])))
