(module x86-64-stack-machine
  (import
    (prim bytes-length make-bytes * + - = panic)
    (list
      #:types (List)
      #:values (cons-head))
    (numbers integer->decimal-bytes)
    (io read-all-bytes write-all-bytes write-newline)
    (arithmetic-expr parse-module)
    (sexp-parser parse-sexp)
    (bytes bytes-copy! subbytes)
    (stack-machine
      #:types (StackFunction StackBasicBlock StackCmd StackTerminal)
      #:values (compile-module stack-function-blocks stack-basic-block-cmds))
    (either right-v))
  (export main)
  (types)

  (define (compile-stack-machine [sfuns : (List StackFunction)]) : Bytes
    (let ([bytes (make-bytes (* 64 64))])
      (let ([offset 0])
        (let ([offset (write-start bytes offset)])
          (let ([offset (write-functions sfuns bytes offset)])
            (subbytes bytes 0 offset))))))

  (define (write-start [bytes : Bytes] [offset : Byte]) : Byte
    (let ([prologue #".section __TEXT,__text\n\n.global _start\n_start:\ncall main\nmov %rax, %rdi\nmovq $0x2000001, %rax\nsyscall\n"])
      (begin
        (bytes-copy! prologue 0 (bytes-length prologue) bytes offset)
        (+ (bytes-length prologue) offset))))


  (define (write-functions [funs : (List StackFunction)] [bytes : Bytes] [offset : Byte]) : Byte
    (case funs
      [(empty) offset]
      [(cons fun funs)
       (write-functions funs bytes (write-function fun bytes offset))]))


  (define (write-function [fun : StackFunction] [bytes : Bytes] [offset : Byte]) : Byte
    (case fun
      [(stack-function name blocks)
       (begin
         (bytes-copy! name 0 (bytes-length name) bytes offset)
         (let ([offset (+ (bytes-length name) offset)])
           (begin
             (bytes-copy! #":\n" 0 2 bytes offset)
             (let ([offset (+ offset 2)])
               (write-basic-blocks blocks bytes offset)))))]))

  (define (write-basic-blocks [blocks : (List StackBasicBlock)] [bytes : Bytes] [offset : Byte])
    : Byte
    (case blocks
      [(empty) offset]
      [(cons block blocks)
       (let ([offset (write-basic-block block bytes offset)])
         (write-basic-blocks blocks bytes offset))]))

  (define (write-basic-block [block : StackBasicBlock] [bytes : Bytes] [offset : Byte]) : Byte
    (case block
      [(stack-basic-block cmds terminal)
       (let ([offset (write-commands cmds bytes offset)])
         (write-terminal terminal bytes offset))]))


  (define (write-terminal [terminal : StackTerminal] [bytes : Bytes] [offset : Byte]) : Byte
    (case terminal
      [(return)
       (let ([ret #"pop %rax\nret\n"])
         (begin
           (bytes-copy! ret 0 (bytes-length ret) bytes offset)
           (+ (bytes-length ret) offset)))]))


  (define (write-commands [cmds : (List StackCmd)] [bytes : Bytes] [offset : Byte]) : Byte
    (case cmds
      [(empty) offset]
      [(cons cmd cmds)
       (case cmd
         [(num-lit-cmd v)
          (let ([initial-offset offset])
            (begin
              (bytes-copy! #"push $" 0 6 bytes offset)
              (let ([offset (+ 6 offset)])
                (let ([decimal-number (integer->decimal-bytes v)])
                  (begin
                    (bytes-copy! decimal-number 0 (bytes-length decimal-number) bytes offset)
                    (let ([offset (+ offset (bytes-length decimal-number))])
                      (begin
                        (bytes-copy! #"\n" 0 1 bytes offset)
                        (let ([offset (+ 1 offset)])
                          (write-commands cmds bytes offset)))))))))]
         [(fun-call-cmd name num-args)
          (if (= 0 num-args)
              (let ([prefix #"callq "])
                (let ([suffix #"\npush %rax\n"])
                  (begin
                    (bytes-copy! prefix 0 (bytes-length prefix) bytes offset)
                    (let ([offset (+ offset (bytes-length prefix))])
                      (begin
                        (bytes-copy! name 0 (bytes-length name) bytes offset)
                        (let ([offset (+ offset (bytes-length name))])
                          (begin
                            (bytes-copy! suffix 0 (bytes-length suffix) bytes offset)
                            (+ offset (bytes-length suffix)))))))))
              (panic #"Cannot handle functions with arguments yet."))]
         [(eval-op-cmd op)
          (let ([op-bytes (case op
                            [(plus-op) #"pop %rbx\npop %rax\naddq %rbx, %rax\npush %rax\n"]
                            [(times-op) #"pop %rbx\npop %rax\nmulq %rbx\npush %rax\n"]
                            [(minus-op) #"pop %rbx\npop %rax\nsubq %rbx, %rax\npush %rax\n"])])
            (begin
              (bytes-copy! op-bytes 0 (bytes-length op-bytes) bytes offset)
              (write-commands cmds bytes (+ offset (bytes-length op-bytes)))))])]))


  (define (main [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Byte
    (begin
      (write-all-bytes
        (compile-stack-machine
          (compile-module
            (parse-module
              (right-v (parse-sexp (read-all-bytes stdin))))))
        stdout)
      0)))
