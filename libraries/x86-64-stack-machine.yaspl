(module x86-64-stack-machine
  (import
    (prim
      #:types (Bytes Byte InputPort OutputPort Void Array)
      #:values (bytes-length make-bytes * + - = panic void > bytes-set!)
      #:patterns ())
    (prim-implementation prim-implementation)
    (list
      #:types (List)
      #:values (cons-head append)
      #:patterns (empty cons))
    (numbers integer->decimal-bytes)
    (io read-all-bytes write-all-bytes newline write-line)
    (sexp-parser
      #:types (Sexp)
      #:values (parse-sexp)
      #:patterns ())
    (bytes bytes-copy! subbytes)
    (stack-machine
      #:types (StackFunction StackBasicBlock StackCmd StackTerminal VariantCases TopLevelObject)
      #:values (stack-function-blocks stack-basic-block-cmds)
      #:patterns (stack-function stack-basic-block return
                  swap-cmd dup-cmd pop-cmd num-lit-cmd create-closure-cmd fun-call-cmd known-fun-call-cmd
                  bytes-lit-cmd boolean-lit-cmd uncond-jmp boolean-jmp alloc-variant-cmd
                  variant-ref-cmd variant-switch bytes-cmp-cmd load-global-cmd
                  no-catch-all-case catch-all-case variant-case
                  bin-math-cmd bin-add-op bin-sub-op bin-mult-op bin-quotient-op bin-remainder-op
                  bin-logic-math-cmd less-than-op less-than-or-equal-op equal-op
                  greater-than-or-equal-op greater-than-op
                  make-array-cmd array-length-cmd array-ref-cmd array-set!-cmd
                  make-array-from-stack-cmd dup-free-var-cmd function-tlo trivial-closure-tlo))
    (either
      #:types (Either)
      #:values ()
      #:patterns (left right)))
  (export compile-stack-machine)
  (types)

  (define (compile-stack-machine
            [main-function-name : Bytes]
            [objects : (List TopLevelObject)]
            [output : OutputPort]) : Void
    (begin
      (write-start main-function-name output)
      (write-objects objects output)))



  (define (write-start [main-function-name : Bytes] [output : OutputPort]) : Void
    (begin
      (write-line #".section __TEXT,__text" output)
      (write-line #".global start" output)
      (write-line #"start:" output)
      (write-line #"nop" output)
      (write-line #"start_break:" output)
      ;; Allocate Heap (Call mmap)
      ;; No fixed address desired
      (write-line #"movq $0x0, %rdi" output)
      ;; We want a large heap
      (write-line #"movq $0x20000000, %rsi" output)
      ;; 0x1 = PROT_READ
      ;; 0x2 = PROT_WRITE
      (write-line #"movq $0x7, %rdx" output)
      ;; 0x0002 = MAP_SHARED
      ;; 0x1000 = MAP_ANON
      (write-line #"movq $0x1002, %r10" output)
      ;; FD = -1 for no flags
      (write-line #"movq $-0x1, %r8" output)
      ;; offset which is ignored because of MAP_ANON
      (write-line #"movq $0x0, %r9" output)
      ;; C5 is mmap, plus 0x2000000 because xnu
      (write-line #"movq $0x20000c5, %rax" output)
      (write-line #"syscall" output)
      (write-line #"jb prim_start_panic" output)
      ;; Save heap to %rbp which is our bump pointer
      (write-line #"movq %rax, %rbp" output)

      ;; Construct args
      (write-line #"popq %r8" output) ; r8 is the number of c strings
      (write-line #"movq %rbp, %r10" output) ; r10 is the array of bytes
      (write-line #"movq $0, %r11" output) ; r11 is the index of the current string

      (write-line #"movq %r8, (%rbp)" output)
      (write-line #"lea 8(%rbp, %r8, 8), %rbp" output)

      (write-line #"cmp %r11, %r8" output)
      (write-line #"je start_copy_args_end" output)
      (write-line #"cld" output)
      (write-line #"start_copy_args_start:" output)
      (write-line #"popq %r9" output) ; r9 is the current string

      ;; Count string length
      (write-line #"mov %r9, %rdi" output)
      (write-line #"mov $0, %al" output)
      (write-line #"mov $-1, %rcx" output)
      (write-line #"repne scasb" output)
      (write-line #"not %rcx" output)
      (write-line #"dec %rcx" output)

      ;; Copy bytes
      (write-line #"movq %rbp, 8(%r10, %r11, 8)" output)
      (write-line #"movq %rcx, (%rbp)" output)
      (write-line #"add $8, %rbp" output)
      (write-line #"mov %r9, %rsi" output)
      (write-line #"mov %rbp, %rdi" output)
      (write-line #"rep movsb" output)
      (write-line #"mov %rdi, %rbp" output)

      (write-line #"inc %r11" output)
      (write-line #"cmp %r11, %r8" output)
      (write-line #"jne start_copy_args_start" output)
      (write-line #"start_copy_args_end:" output)

      ;; Call main and then exit
      (write-line #"pushq %r10" output)
      (write-line #"pushq $0" output)
      (write-line #"pushq $1" output)
      (write-line #"pushq $2" output)
      (write-line #"pushq $0" output) ;; Bogus closure
      (write-all-bytes #"call " output)
      (write-all-bytes main-function-name output)
      (write-all-bytes #"_code" output)
      (newline output)
      (write-line #"mov %rax, %rdi" output)
      (write-line #"movq $0x2000001, %rax" output)
      (write-line #"syscall" output)
      (write-line #"prim_start_panic:" output)
      (write-line #"ud2" output)
      ;; No return



      ;; write-bytes
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_write_bytes_closure: " output)
      (write-line #".quad prim_write_bytes" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_write_bytes:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"pop %rdx" output) ;; Argument 4
      (write-line #"pop %rcx" output) ;; Argument 3
      (write-line #"pop %rdi" output) ;; Argument 2
      (write-line #"pop %rsi" output) ;; Argument 1
      ;; %rdi is the file descriptor
      ;; Make $rsi the start of the buffer
      (write-line #"add $8, %rsi" output)
      (write-line #"add %rcx, %rsi" output)
      ;; Make %rdx the length to write
      (write-line #"sub %rcx, %rdx" output)
      (write-line #"movq $0x2000004, %rax" output)
      (write-line #"syscall" output)
      (write-line #"jb prim_write_bytes_panic" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      (write-line #"prim_write_bytes_panic:" output)
      (write-line #"ud2" output)
      ;; No return

      ;; read-bytes
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_read_bytes_closure: " output)
      (write-line #".quad prim_read_bytes" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_read_bytes:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"pop %rdx" output) ;; Argument 4
      (write-line #"pop %rcx" output) ;; Argument 3
      (write-line #"pop %rdi" output) ;; Argument 2
      (write-line #"pop %rsi" output) ;; Argument 1
      ;; %rdi is the file descriptor
      ;; Make $rsi the start of the buffer
      (write-line #"add $8, %rsi" output)
      (write-line #"add %rcx, %rsi" output)
      ;; Make %rdx the length to read
      (write-line #"sub %rcx, %rdx" output)
      (write-line #"movq $0x2000003, %rax" output)
      (write-line #"syscall" output)
      (write-line #"jb prim_read_bytes_panic" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      (write-line #"prim_read_bytes_panic:" output)
      (write-line #"ud2" output)
      ;; No return

      ;; open-input-file
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_open_input_file_closure: " output)
      (write-line #".quad prim_open_input_file" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_open_input_file:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"pop %rdi" output) ;; Null terminated path
      (write-line #"add $8, %rdi" output)
      (write-line #"movq $0, %rsi" output) ;; 0 is read only
      (write-line #"movq $0x2000005, %rax" output)
      (write-line #"syscall" output)
      (write-line #"jb prim_open_input_file_panic" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      (write-line #"prim_open_input_file_panic:" output)
      (write-line #"ud2" output)
      ;; No return

      ;; open-output-file
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_open_output_file_closure: " output)
      (write-line #".quad prim_open_output_file" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_open_output_file:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"pop %rdi" output) ;; Null terminated path
      (write-line #"add $8, %rdi" output)
      (write-line #"movq $513, %rsi" output) ;; 1 is write only, 512 is create
      (write-line #"movq $504, %rdx" output) ;; 770 for mode
      (write-line #"movq $0x2000005, %rax" output)
      (write-line #"syscall" output)
      (write-line #"jb prim_open_output_file_panic" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      (write-line #"prim_open_output_file_panic:" output)
      (write-line #"ud2" output)
      ;; No return


      ;; close-output-port
      ;; close-input-port
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_close_port_closure: " output)
      (write-line #".quad prim_close_port" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_close_port:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"pop %rdi" output) ;; fd
      (write-line #"movq $0x2000006, %rax" output)
      (write-line #"syscall" output)
      (write-line #"jb prim_close_port_panic" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      (write-line #"prim_close_port_panic:" output)
      (write-line #"ud2" output)
      ;; No return

      ;; socket
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_socket_closure: " output)
      (write-line #".quad prim_socket" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_socket:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"pop %rdx" output) ;; Argument 3: protocol
      (write-line #"pop %rsi" output) ;; Argument 2: type
      (write-line #"pop %rdi" output) ;; Argument 1: domain
      (write-line #"movq $0x2000061, %rax" output)
      (write-line #"syscall" output)
      (write-line #"jb prim_socket_panic" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      (write-line #"prim_socket_panic:" output)
      (write-line #"ud2" output)
      ;; No return

      ;; bind
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_bind_closure: " output)
      (write-line #".quad prim_bind" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_bind:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"pop %rdx" output) ;; Argument 3: length
      (write-line #"pop %rsi" output) ;; Argument 2: sockaddr
      (write-line #"pop %rdi" output) ;; Argument 1: socket
      (write-line #"add $8, %rsi" output)
      (write-line #"movq $0x2000068, %rax" output)
      (write-line #"syscall" output)
      (write-line #"jb prim_bind_panic" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      (write-line #"prim_bind_panic:" output)
      (write-line #"ud2" output)
      ;; No return

      ;; sendto
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_sendto_closure: " output)
      (write-line #".quad prim_sendto" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_sendto:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"pop %r9" output) ;; Argument 6: sockaddr-length
      (write-line #"pop %r8" output) ;; Argument 5: sockaddr
      (write-line #"pop %r10" output) ;; Argument 4: flags
      (write-line #"pop %rdx" output) ;; Argument 3: buffer-length
      (write-line #"pop %rsi" output) ;; Argument 2: buffer
      (write-line #"pop %rdi" output) ;; Argument 1: socket
      (write-line #"add $8, %rsi" output)
      (write-line #"add $8, %r8" output)
      (write-line #"movq $0x2000085, %rax" output)
      (write-line #"syscall" output)
      (write-line #"jb prim_sendto_panic" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      (write-line #"prim_sendto_panic:" output)
      (write-line #"ud2" output)
      ;; No return

      ;; recvfrom
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_recvfrom_closure: " output)
      (write-line #".quad prim_recvfrom" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_recvfrom:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"pop %r9" output) ;; Argument 6: sockaddr-length
      (write-line #"pop %r8" output) ;; Argument 5: sockaddr
      (write-line #"pop %r10" output) ;; Argument 4: flags
      (write-line #"pop %rdx" output) ;; Argument 3: buffer-length
      (write-line #"pop %rsi" output) ;; Argument 2: buffer
      (write-line #"pop %rdi" output) ;; Argument 1: socket
      (write-line #"add $8, %rsi" output)
      (write-line #"add $8, %r8" output)
      (write-line #"add $8, %r9" output)
      (write-line #"movq $0x200001d, %rax" output)
      (write-line #"syscall" output)
      (write-line #"jb prim_recvfrom_panic" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      (write-line #"prim_recvfrom_panic:" output)
      (write-line #"ud2" output)
      ;; No return


      ;; connect
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_connect_closure: " output)
      (write-line #".quad prim_connect" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_connect:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"pop %rdx" output) ;; Argument 3: sockaddr-length
      (write-line #"pop %rsi" output) ;; Argument 2: sockaddr
      (write-line #"pop %rdi" output) ;; Argument 1: socket
      (write-line #"add $8, %rsi" output)
      (write-line #"movq $0x2000062, %rax" output)
      (write-line #"syscall" output)
      (write-line #"jb prim_connect_panic" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      (write-line #"prim_connect_panic:" output)
      (write-line #"ud2" output)
      ;; No return

      ;; shutdown
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_shutdown_closure: " output)
      (write-line #".quad prim_shutdown" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_shutdown:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"pop %rsi" output) ;; Argument 2: how
      (write-line #"pop %rdi" output) ;; Argument 1: socket
      (write-line #"movq $0x2000086, %rax" output)
      (write-line #"syscall" output)
      (write-line #"jb prim_shutdown_panic" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      (write-line #"prim_shutdown_panic:" output)
      (write-line #"ud2" output)
      ;; No return


      ;; listen
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_listen_closure: " output)
      (write-line #".quad prim_listen" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_listen:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"pop %rsi" output) ;; Argument 2: backlog
      (write-line #"pop %rdi" output) ;; Argument 1: socket
      (write-line #"movq $0x200006A, %rax" output)
      (write-line #"syscall" output)
      (write-line #"jb prim_listen_panic" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      (write-line #"prim_listen_panic:" output)
      (write-line #"ud2" output)
      ;; No return


      ;; accept
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_accept_closure: " output)
      (write-line #".quad prim_accept" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_accept:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"pop %rdx" output) ;; Argument 3: sockaddr-length
      (write-line #"pop %rsi" output) ;; Argument 2: sockaddr
      (write-line #"pop %rdi" output) ;; Argument 1: socket
      (write-line #"add $8, %rsi" output)
      (write-line #"add $8, %rdx" output)
      (write-line #"movq $0x200001E, %rax" output)
      (write-line #"syscall" output)
      (write-line #"jb prim_accept_panic" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      (write-line #"prim_accept_panic:" output)
      (write-line #"ud2" output)
      ;; No return


      ;; setsockopt
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_setsockopt_closure: " output)
      (write-line #".quad prim_setsockopt" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_setsockopt:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"pop %r8" output)  ;; Argument 5: option length
      (write-line #"pop %r10" output) ;; Argument 4: option value
      (write-line #"pop %rdx" output) ;; Argument 3: option name
      (write-line #"pop %rsi" output) ;; Argument 2: level
      (write-line #"pop %rdi" output) ;; Argument 1: socket
      (write-line #"add $8, %r10" output)
      (write-line #"movq $0x2000069, %rax" output)
      (write-line #"syscall" output)
      (write-line #"jb prim_setsockopt_panic" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      (write-line #"prim_setsockopt_panic:" output)
      (write-line #"ud2" output)
      ;; No return


      ;; mach_task_self
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_mach_task_self_closure:" output)
      (write-line #".quad prim_mach_task_self" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_mach_task_self:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"movq $0x100001c, %rax" output)
      (write-line #"syscall" output)
      (write-line #"cmp $0, %rax" output)
      (write-line #"je prim_mach_task_self_panic" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      (write-line #"prim_mach_task_self_panic:" output)
      (write-line #"ud2" output)
      ;; No return


      ;; mach_thread_self
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_mach_thread_self_closure:" output)
      (write-line #".quad prim_mach_thread_self" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_mach_thread_self:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"movq $0x100001b, %rax" output)
      (write-line #"syscall" output)
      (write-line #"cmp $0, %rax" output)
      (write-line #"je prim_mach_thread_self_panic" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      (write-line #"prim_mach_thread_self_panic:" output)
      (write-line #"ud2" output)
      ;; No return


      ;; mach_reply_port
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_mach_reply_port_closure:" output)
      (write-line #".quad prim_mach_reply_port" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_mach_reply_port:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"movq $0x100001a, %rax" output)
      (write-line #"syscall" output)
      (write-line #"cmp $0, %rax" output)
      (write-line #"je prim_mach_reply_port_panic" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      (write-line #"prim_mach_reply_port_panic:" output)
      (write-line #"ud2" output)
      ;; No return


      ;; mach_port_mod_refs
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_mach_port_mod_refs_closure:" output)
      (write-line #".quad prim_mach_port_mod_refs" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_mach_port_mod_refs:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"pop %r10" output) ;; Argument 4: delta
      (write-line #"pop %rdx" output) ;; Argument 3: right
      (write-line #"pop %rsi" output) ;; Argument 2: port
      (write-line #"pop %rdi" output) ;; Argument 1: task
      (write-line #"movq $0x1000013, %rax" output)
      (write-line #"syscall" output)
      (write-line #"cmp $0, %rax" output)
      (write-line #"jne prim_mach_port_mod_refs_panic" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      (write-line #"prim_mach_port_mod_refs_panic:" output)
      (write-line #"ud2" output)
      ;; No return

      ;; mach_msg
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_mach_msg_closure:" output)
      (write-line #".quad prim_mach_msg" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_mach_msg:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"pop %r11" output) ;; Notify Port
      (write-line #"pop %r9" output)  ;; Timeout
      (write-line #"pop %r10" output) ;; Recv size
      (write-line #"pop %rdx" output) ;; Send size
      (write-line #"pop %rsi" output) ;; Options 
      (write-line #"pop %rdi" output) ;; Buffer
      (write-line #"addq $0x8, %rdi" output) ;; Adjust past buffer's length field
      (write-line #"pop %r8" output) ;; Reply-port
      (write-line #"push %r11" output) ;; Push back the notify port
      (write-line #"pushq $0x0" output) ;; Dummy Return Address
      (write-line #"movq $0x100001f, %rax" output)
      (write-line #"syscall" output)
      (write-line #"cmp $0, %rax" output)
      (write-line #"jne prim_mach_msg_panic" output)
      (write-line #"add $0x10, %rsp" output) ;; 2 pop
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      (write-line #"prim_mach_msg_panic:" output)
      (write-line #"ud2" output)
      ;; No return

      ;; and
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_and_closure: " output)
      (write-line #".quad prim_and" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_and:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"pop %rax" output) ;; Argument 2
      (write-line #"pop %rcx" output) ;; Argument 1
      (write-line #"and %rcx, %rax" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      ;; or
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_or_closure: " output)
      (write-line #".quad prim_or" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_or:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"pop %rax" output) ;; Argument 2
      (write-line #"pop %rcx" output) ;; Argument 1
      (write-line #"or %rcx, %rax" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)


      ;; bytes-ref
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_bytes_ref_closure: " output)
      (write-line #".quad prim_bytes_ref" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_bytes_ref:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"pop %rcx" output) ;; Argument 2
      (write-line #"pop %rax" output) ;; Argument 1
      (write-line #"movzb 8(%rax, %rcx), %rax" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      ;; make-bytes
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_make_bytes_closure: " output)
      (write-line #".quad prim_make_bytes" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_make_bytes:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"pop %rax" output) ;; Argument 1
      (write-line #"prim_make_bytes_loop_pre:" output)
      (write-line #"mov %rbp, %rdx" output)
      (write-line #"mov %rax, (%rbp)" output)
      (write-line #"add $8, %rbp" output)
      (write-line #"prim_make_bytes_loop_start:" output)
      (write-line #"cmp $0, %rax" output)
      (write-line #"je prim_make_bytes_loop_end" output)
      (write-line #"movb $0, (%rbp)" output)
      (write-line #"add $1, %rbp" output)
      (write-line #"add $-1, %rax" output)
      (write-line #"jmp prim_make_bytes_loop_start" output)
      (write-line #"prim_make_bytes_loop_end:" output)
      (write-line #"mov %rdx, %rax" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      ;; bytes-set!
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_bytes_set_closure: " output)
      (write-line #".quad prim_bytes_set" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_bytes_set:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"pop %rdx" output) ;; Argument 3
      (write-line #"pop %rcx" output) ;; Argument 2
      (write-line #"pop %rax" output) ;; Argument 1
      (write-line #"mov %dl, 8(%rax, %rcx)" output)
      (write-line #"mov $0, %rax" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      ;; bytes-length
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_bytes_length_closure: " output)
      (write-line #".quad prim_bytes_length" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_bytes_length:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"pop %rax" output) ;; Argument 1
      (write-line #"movq (%rax), %rax" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)

      ;; bytes-equal?
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_bytes_equal_closure: " output)
      (write-line #".quad prim_bytes_equal" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_bytes_equal:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"pop %rdi" output) ;; Argument 2
      (write-line #"pop %rsi" output) ;; Argument 1
      (write-line #"movq (%rsi), %rcx" output)
      (write-line #"add $8, %rcx" output)
      (write-line #"repe cmpsb" output)
      (write-line #"jz prim_bytes_equal_true" output)
      (write-line #"prim_bytes_equal_false:" output)
      (write-line #"mov $0, %rax" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      (write-line #"prim_bytes_equal_true:" output)
      (write-line #"mov $1, %rax" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)

      ;; void
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_void_closure: " output)
      (write-line #".quad prim_void" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_void:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Ignored closure
      (write-line #"push %rbx" output) ;; Return address
      (write-line #"movq $0, %rax" output)
      (write-line #"ret" output)

      ;; panic
      (write-line #".section __TEXT,__const" output)
      (write-line #"prim_panic_closure: " output)
      (write-line #".quad prim_panic" output)
      (write-line #".section __TEXT,__text" output)
      (write-line #"prim_panic:" output)
      (write-line #"movq 24(%rsp), %rax" output)
      (write-line #"add $8, %rax" output)
      (write-line #"ud2" output)

      ;; These are not native functions, but just native subroutines
      ;; They do not follow standard calling conventions

      ;; make-array-from-stack
      (write-line #"prim_make_array_from_stack:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rcx" output) ;; num-args
      (write-line #"mov %rbp, %rax" output)
      (write-line #"mov %rcx, (%rbp)" output)
      (write-line #"leaq (%rbp, %rcx, 8), %rbp" output)
      (write-line #"leaq 8(%rbp), %rdx" output)
      (write-line #"cmp $0, %rcx" output)
      (write-line #"je prim_make_array_from_stack_loop_end" output)
      (write-line #"prim_make_array_from_stack_loop_start:" output)
      (write-line #"popq (%rbp)" output)
      (write-line #"sub $8, %rbp" output)
      (write-line #"dec %rcx" output)
      (write-line #"jnz prim_make_array_from_stack_loop_start" output)
      (write-line #"prim_make_array_from_stack_loop_end:" output)
      (write-line #"mov %rdx, %rbp" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)

      ;; variant-panic
      (write-line #"prim_variant_panic:" output)
      (write-line #"ud2" output)

      ;; thread_bootstrap
      (write-line #"prim_thread_bootstrap:" output)
      (write-line #"pushq %rax" output)
      (write-line #"mov (%rax), %rax" output)
      (write-line #"callq *%rax" output)
      (write-line #"ud2" output)))


  (define (write-objects [objects : (List TopLevelObject)] [output : OutputPort]) : Void
    (case objects
      [(empty) (void)]
      [(cons (function-tlo fun) objects)
       (begin
         (write-function fun output)
         (write-objects objects output))]
      [(cons (trivial-closure-tlo name fun-name) objects)
       (begin
         (write-trivial-closure name fun-name output)
         (write-objects objects output))]))

  (define (write-trivial-closure [name : Bytes] [fun-name : Bytes] [output : OutputPort]) : Void
    (begin
      (write-line #".section __TEXT,__const" output)
      (write-all-bytes name output)
      (write-all-bytes #":" output)
      (newline output)
      (write-all-bytes #".quad " output)
      (write-all-bytes fun-name output)
      (newline output)))

  (define (write-function [fun : StackFunction] [output : OutputPort]) : Void
    (case fun
      [(stack-function name blocks)
       (begin
         (write-line #".section __TEXT,__text" output)
         (write-all-bytes name output)
         (write-all-bytes #":" output)
         (newline output)
         (write-basic-blocks name 0 blocks output))]))

  (define (write-basic-blocks [fun-name : Bytes] [index : Byte] [blocks : (List StackBasicBlock)] [output : OutputPort]) : Void
    (case blocks
      [(empty) (void)]
      [(cons block blocks)
       (begin
         (write-basic-block fun-name index block output)
         (write-basic-blocks fun-name (+ index 1) blocks output))]))

  (define (write-basic-block [fun-name : Bytes] [index : Byte] [block : StackBasicBlock] [output : OutputPort]) : Void
    (case block
      [(stack-basic-block cmds terminal)
       (begin
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes index) output)
         (write-all-bytes #":" output)
         (newline output)
         (write-commands cmds output)
         (write-terminal fun-name terminal output))]))


  (define (write-terminal [fun-name : Bytes] [terminal : StackTerminal] [output : OutputPort]) : Void
    (case terminal
      [(return num-args)
       (begin
         (write-line #"pop %rax" output) ;; Return value
         (write-line #"pop %rbx" output) ;; Return address
         (write-line #"pop %rcx" output) ;; Closure
         (write-pop-function-arguments num-args output)
         (write-line #"push %rbx" output)
         (write-line #"ret" output))]
      [(uncond-jmp index)
       (begin
         (write-all-bytes #"jmp " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes index) output)
         (newline output))]
      [(boolean-jmp true-index false-index)
       (begin
         (write-line #"pop %rax" output)
         (write-line #"cmpq $0, %rax" output)
         (write-all-bytes #"jne " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes true-index) output)
         (newline output)
         (write-all-bytes #"jmp " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes false-index) output)
         (newline output))]
      [(variant-switch cases)
       (begin 
         (write-line #"mov (%rsp), %rax" output)
         (write-variant-switch fun-name cases output))]))

  ;; The current value is in %rax.
  (define (write-variant-switch
            [fun-name : Bytes]
            [cases : VariantCases]
            [output : OutputPort]) : Void
    (case cases
      [(no-catch-all-case)
       (write-line #"ud2" output)]
      [(catch-all-case block)
       (begin
         (write-all-bytes #"jmp " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes block) output)
         (newline output))]
      [(variant-case tag block cases)
       (begin
         (write-all-bytes #"cmpq $" output)
         (write-all-bytes (integer->decimal-bytes tag) output)
         (write-all-bytes #", (%rax)" output)
         (newline output)
         (write-all-bytes #"je " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes block) output)
         (newline output)
         (write-variant-switch fun-name cases output))]))


  (define (write-pop-function-arguments [num-args : Byte] [output : OutputPort]) : Void
    (if (= 0 num-args)
        (void)
        (begin
          (write-line #"pop %rcx" output)
          (write-pop-function-arguments (- num-args 1) output))))

  (define (write-commands [cmds : (List StackCmd)] [output : OutputPort]) : Void
    (case cmds
      [(empty) (void)]
      [(cons cmd cmds)
       (case cmd
         [(dup-cmd offset)
          (begin
            (write-all-bytes #"push " output)
            (write-all-bytes (integer->decimal-bytes (* offset 8)) output)
            (write-line #"(%rsp)" output)
            (write-commands cmds output))]
         [(dup-free-var-cmd offset index)
          (begin
            (write-all-bytes #"mov " output)
            (write-all-bytes (integer->decimal-bytes (* offset 8)) output)
            (write-line #"(%rsp), %rax" output)
            (write-all-bytes #"push " output)
            (write-all-bytes (integer->decimal-bytes (* (+ 1 index) 8)) output)
            (write-line #"(%rax)" output)
            (write-commands cmds output))]
         [(swap-cmd)
          (begin
            (write-line #"pop %rax" output)
            (write-line #"pop %rbx" output)
            (write-line #"push %rax" output)
            (write-line #"push %rbx" output)
            (write-commands cmds output))]
         [(pop-cmd)
          (begin
            (write-line #"pop %rax" output)
            (write-commands cmds output))]
         [(num-lit-cmd v)
          ;; TODO fix when yaspl supports larger literals
          (let ([max-lit
                 (let ([shift (+ #xFF 1)])
                   (+ (* shift (+ (* shift (+ (* shift #xFF) #xFF)) #xFF)) #xFF))])
            (begin
              (if (> v max-lit)
                  (begin
                    (write-all-bytes #"mov $" output)
                    (write-all-bytes (integer->decimal-bytes v) output)
                    (write-all-bytes #", %rax" output)
                    (newline output)
                    (write-line #"push %rax" output))
                  (begin
                    (write-all-bytes #"pushq $" output)
                    (write-all-bytes (integer->decimal-bytes v) output)
                    (newline output)))
            (write-commands cmds output)))]
         [(boolean-lit-cmd v)
          (begin
            (if v
                (write-line #"push $1" output)
                (write-line #"push $0" output))
            (write-commands cmds output))]
         ;; TODO put the bytes not directly in the instruction stream
         [(bytes-lit-cmd v)
          (begin
            (write-line #".byte 0xe9" output)
            (write-all-bytes #".long " output)
            (write-all-bytes (integer->decimal-bytes (+ 8 (bytes-length v))) output)
            (newline output)
            (write-all-bytes #".8byte " output)
            (write-all-bytes (integer->decimal-bytes (bytes-length v)) output)
            (newline output)
            (let ([quote (let ([buf (make-bytes 1)]) (begin (bytes-set! buf 0 34) buf))])
              (begin
                (write-all-bytes #".ascii " output)
                (write-all-bytes quote output)
                (write-all-bytes v output)
                (write-all-bytes quote output)))
            (newline output)
            ;; Need to account for the 7 bytes of leaq
            (write-all-bytes #"leaq -" output)
            (write-all-bytes (integer->decimal-bytes (+ 15 (bytes-length v))) output)
            (write-line #"(%rip), %rax" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
          [(bytes-cmp-cmd)
           (begin
             (write-line #"push $0" output) ; Bogus closure
             (write-line #"call prim_bytes_equal" output)
             (write-line #"push %rax" output)
             (write-commands cmds output))]

         [(load-global-cmd name)
          (begin
            (write-all-bytes #"leaq " output)
            (write-all-bytes name output)
            (write-line #"(%rip), %rax" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]

         [(create-closure-cmd n)
          (begin
            (write-line #"mov %rbp, %rax" output)
            (copy-objects (+ n 1) output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(fun-call-cmd _)
          (begin
            (write-line #"mov (%rsp), %rax" output)
            (write-line #"mov (%rax), %rax" output)
            (write-line #"callq *%rax" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(known-fun-call-cmd name _)
          (begin
            (write-line #"push $0" output) ; Bogus closure
            (write-all-bytes #"callq " output)
            (write-all-bytes name output)
            (newline output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]

         [(make-array-cmd)
          (begin
            (write-line #"pop %rax" output)
            (write-line #"pop %rcx" output)
            (write-line #"mov %rbp, %rdx" output)
            (write-line #"mov %rcx, (%rbp)" output)
            (write-line #"add $8, %rbp" output)
            (write-line #"mov %rbp, %rdi" output)
            (write-line #"rep stosq" output)
            (write-line #"mov %rdi, %rbp" output)
            (write-line #"push %rdx" output)
            (write-commands cmds output))]
         [(make-array-from-stack-cmd num-args)
          (begin
            (write-all-bytes #"pushq $" output)
            (write-all-bytes (integer->decimal-bytes num-args) output)
            (newline output)
            (write-line #"call prim_make_array_from_stack" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(array-length-cmd)
          (begin
            (write-line #"pop %rax" output)
            (write-line #"push (%rax)" output)
            (write-commands cmds output))]
         [(array-ref-cmd)
          (begin
            (write-line #"pop %rcx" output)
            (write-line #"pop %rax" output)
            (write-line #"push 8(%rax, %rcx, 8)" output)
            (write-commands cmds output))]
         [(array-set!-cmd)
          (begin
            (write-line #"pop %rdx" output)
            (write-line #"pop %rcx" output)
            (write-line #"pop %rax" output)
            (write-line #"mov %rdx, 8(%rax, %rcx, 8)" output)
            (write-line #"push $0" output)
            (write-commands cmds output))]

         [(bin-logic-math-cmd op)
          (begin
            (write-line #"pop %rax" output) ;; Argument 2
            (write-line #"pop %rcx" output) ;; Argument 1
            (write-line #"cmpq %rax, %rcx" output)
            (case op
              [(less-than-op)
               (write-line #"setl %al" output)]
              [(less-than-or-equal-op)
               (write-line #"setle %al" output)]
              [(equal-op)
               (write-line #"sete %al" output)]
              [(greater-than-or-equal-op)
               (write-line #"setge %al" output)]
              [(greater-than-op)
               (write-line #"setg %al" output)])
            (write-line #"movzx %al, %rax" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(bin-math-cmd (bin-add-op))
          (begin
            (write-line #"pop %rax" output) ;; Argument 2
            (write-line #"pop %rcx" output) ;; Argument 1
            (write-line #"addq %rcx, %rax" output)
            (write-line #"pushq %rax" output)
            (write-commands cmds output))]
         [(bin-math-cmd (bin-sub-op))
          (begin
            (write-line #"pop %rcx" output) ;; Argument 2
            (write-line #"pop %rax" output) ;; Argument 1
            (write-line #"subq %rcx, %rax" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(bin-math-cmd (bin-mult-op))
          (begin
            (write-line #"pop %rax" output) ;; Argument 2
            (write-line #"pop %rcx" output) ;; Argument 1
            (write-line #"imulq %rcx" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(bin-math-cmd (bin-quotient-op))
          (begin
            (write-line #"pop %rcx" output) ;; Argument 2
            (write-line #"pop %rax" output) ;; Argument 1
            (write-line #"movq $0, %rdx" output)
            (write-line #"idiv %rcx" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(bin-math-cmd (bin-remainder-op))
          (begin
            (write-line #"pop %rcx" output) ;; Argument 2
            (write-line #"pop %rax" output) ;; Argument 1
            (write-line #"movq $0, %rdx" output)
            (write-line #"idiv %rcx" output)
            (write-line #"movq %rdx, %rax" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(alloc-variant-cmd tag fields)
          (begin
            (write-line #"mov %rbp, %rax" output)
            (write-all-bytes #"movq $" output)
            (write-all-bytes (integer->decimal-bytes tag) output)
            (write-all-bytes #", (%rbp)" output)
            (newline output)
            (write-line #"add $8, %rbp" output)
            (copy-objects fields output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(variant-ref-cmd tag field)
          (begin
            (write-line #"pop %rax" output)
            (write-all-bytes #"cmpq $" output)
            (write-all-bytes (integer->decimal-bytes tag) output)
            (write-line #", (%rax)" output)
            (write-line #"jne prim_variant_panic" output)
            (write-all-bytes #"pushq " output)
            (write-all-bytes (integer->decimal-bytes (+ (* 8 field) 8)) output)
            (write-line #"(%rax)" output)
            (write-commands cmds output))])]))

  ;; Generates assembly to copy n objects from the top of the stack to the
  ;; memory starting at %rbp. %rbp ends up pointing right after after the last object written.
  (define (copy-objects [n : Byte] [output : OutputPort]) : Void
    (if (> n 0)
        (begin
          (write-line #"pop (%rbp)" output)
          (write-line #"add $8, %rbp" output)
          (copy-objects (- n 1) output))
        (void)))



  ;; TODO switch to a polymorphic one when it works
  (define (a) (extract-either [either : (Either Bytes a)]) : a
    (case either
      [(right v) v]
      [(left v) (panic v)])))
