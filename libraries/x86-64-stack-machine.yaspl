(module x86-64-stack-machine
  (import
    (prim
      #:types (Bytes Byte InputPort OutputPort Void)
      #:values (bytes-length make-bytes * + - = panic void)
      #:patterns ())
    (list
      #:types (List)
      #:values (cons-head)
      #:patterns (empty cons))
    (numbers integer->decimal-bytes)
    (io read-all-bytes write-all-bytes write-newline)
    (arithmetic-expr
      #:types ()
      #:values (parse-module)
      #:patterns (plus-op minus-op times-op))
    (sexp-parser
      #:types (Sexp)
      #:values (parse-sexp)
      #:patterns ())
    (bytes bytes-copy! subbytes)
    (stack-machine
      #:types (StackFunction StackBasicBlock StackCmd StackTerminal)
      #:values (compile-module stack-function-blocks stack-basic-block-cmds)
      #:patterns (stack-function stack-basic-block return
                  swap-cmd dup-cmd pop-cmd num-lit-cmd fun-ref-cmd fun-call-cmd
                  boolean-lit-cmd uncond-jmp boolean-jmp))
    (either
      #:types (Either)
      #:values ()
      #:patterns (left right)))
  (export main compile-stack-machine)
  (types)

  ;; TODO support module other than main being used as the start
  (define (compile-stack-machine [sfuns : (List StackFunction)] [output : OutputPort]) : Void
    (begin 
      (write-start output)
      (write-functions sfuns output)))

  (define (write-start [output : OutputPort]) : Void
    (begin
      (write-all-bytes #".section __TEXT,__text\n\n" output)
      (write-all-bytes #".global _start\n" output)
      (write-all-bytes #"_start:\n" output)
      (write-all-bytes #"call main_main\n" output)
      (write-all-bytes #"mov %rax, %rdi\n" output)
      (write-all-bytes #"movq $0x2000001, %rax\n" output)
      (write-all-bytes #"syscall\n" output)
      ;; +
      (write-all-bytes #"prim_add:\n" output)
      (write-all-bytes #"pop %rbx\n" output) ;; Return address
      (write-all-bytes #"pop %rax\n" output) ;; Argument 2
      (write-all-bytes #"pop %rcx\n" output) ;; Argument 1
      (write-all-bytes #"addq %rcx, %rax\n" output)
      (write-all-bytes #"push %rbx\n" output)
      (write-all-bytes #"ret\n" output)
      ;; *
      (write-all-bytes #"prim_mult:\n" output)
      (write-all-bytes #"pop %rbx\n" output) ;; Return address
      (write-all-bytes #"pop %rax\n" output) ;; Argument 2
      (write-all-bytes #"pop %rcx\n" output) ;; Argument 1
      (write-all-bytes #"mulq %rcx\n" output)
      (write-all-bytes #"push %rbx\n" output)
      (write-all-bytes #"ret\n" output)
      ;; -
      (write-all-bytes #"prim_sub:\n" output)
      (write-all-bytes #"pop %rbx\n" output) ;; Return address
      (write-all-bytes #"pop %rcx\n" output) ;; Argument 2
      (write-all-bytes #"pop %rax\n" output) ;; Argument 1
      (write-all-bytes #"subq %rcx, %rax\n" output)
      (write-all-bytes #"push %rbx\n" output)
      (write-all-bytes #"ret\n" output)))


  (define (write-functions [funs : (List StackFunction)] [output : OutputPort]) : Void
    (case funs
      [(empty) (void)]
      [(cons fun funs)
       (begin
         (write-function fun output)
         (write-functions funs output))]))


  (define (write-function [fun : StackFunction] [output : OutputPort]) : Void
    (case fun
      [(stack-function name blocks)
       (begin
         (write-all-bytes name output)
         (write-all-bytes #":\n" output)
         (write-basic-blocks name 0 blocks output))]))

  (define (write-basic-blocks [fun-name : Bytes] [index : Byte] [blocks : (List StackBasicBlock)] [output : OutputPort]) : Void
    (case blocks
      [(empty) (void)]
      [(cons block blocks)
       (begin
         (write-basic-block fun-name index block output)
         (write-basic-blocks fun-name (+ index 1) blocks output))]))

  (define (write-basic-block [fun-name : Bytes] [index : Byte] [block : StackBasicBlock] [output : OutputPort]) : Void
    (case block
      [(stack-basic-block cmds terminal)
       (begin
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes index) output)
         (write-all-bytes #":\n" output)
         (write-commands cmds output)
         (write-terminal fun-name terminal output))]))


  (define (write-terminal [fun-name : Bytes] [terminal : StackTerminal] [output : OutputPort]) : Void
    (case terminal
      [(return num-args)
       (begin
         (write-all-bytes #"pop %rax\n" output)
         (write-all-bytes #"pop %rbx\n" output)
         (write-pop-function-arguments num-args output)
         (write-all-bytes #"push %rbx\n" output)
         (write-all-bytes #"ret\n" output))]
      [(uncond-jmp index)
       (begin
         (write-all-bytes #"jmp " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes index) output)
         (write-all-bytes #"\n" output))]
      [(boolean-jmp true-index false-index)
       (begin
         (write-all-bytes #"pop %rax\n" output)
         (write-all-bytes #"cmpq $0, %rax\n" output)
         (write-all-bytes #"jne " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes true-index) output)
         (write-all-bytes #"\n" output)
         (write-all-bytes #"jmp " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes false-index) output)
         (write-all-bytes #"\n" output)) ]))

  (define (write-pop-function-arguments [num-args : Byte] [output : OutputPort]) : Void
    (if (= 0 num-args)
        (void)
        (begin
          (write-all-bytes #"pop %rcx\n" output)
          (write-pop-function-arguments (- num-args 1) output))))

  (define (write-commands [cmds : (List StackCmd)] [output : OutputPort]) : Void
    (case cmds
      [(empty) (void)]
      [(cons cmd cmds)
       (case cmd
         [(dup-cmd offset)
          (begin
            (write-all-bytes #"push " output)
            (write-all-bytes (integer->decimal-bytes (* offset 8)) output)
            (write-all-bytes #"(%rsp)\n" output)
            (write-commands cmds output))]
         [(swap-cmd)
          (begin
            (write-all-bytes #"pop %rax\n" output)
            (write-all-bytes #"pop %rbx\n" output)
            (write-all-bytes #"push %rax\n" output)
            (write-all-bytes #"push %rbx\n" output)
            (write-commands cmds output))]
         [(pop-cmd)
          (begin
            (write-all-bytes #"pop %rax\n" output)
            (write-commands cmds output))]
         [(num-lit-cmd v)
          (begin
            (write-all-bytes #"push $" output)
            (write-all-bytes (integer->decimal-bytes v) output)
            (write-all-bytes #"\n" output)
            (write-commands cmds output))]
         [(boolean-lit-cmd v)
          (begin
            (if v
                (write-all-bytes #"push $1\n" output)
                (write-all-bytes #"push $0\n" output))
            (write-commands cmds output))]
         [(fun-ref-cmd name)
          (begin
            (write-all-bytes #"leaq " output)
            (write-all-bytes name output)
            (write-all-bytes #"(%rip), %rax\n" output)
            (write-all-bytes #"push %rax\n" output)
            (write-commands cmds output))]
         [(fun-call-cmd _)
          (begin
            (write-all-bytes #"pop %rax\n" output)
            (write-all-bytes #"callq *%rax\n" output)
            (write-all-bytes #"push %rax\n" output)
            (write-commands cmds output))])]))


  ;; TODO switch to a polymorphic one when it works
  (define (a) (extract-either [either : (Either Bytes a)]) : a
    (case either
      [(right v) v]
      [(left v) (panic v)]))

  (define (main [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Byte
    (begin
      (compile-stack-machine
        (compile-module
          (parse-module
            (extract-either (parse-sexp (read-all-bytes stdin)))))
        stdout)
      0)))
