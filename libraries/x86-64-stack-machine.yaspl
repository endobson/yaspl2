(module x86-64-stack-machine
  (import
    (prim bytes-length make-bytes * + -)
    (list cons-head)
    (numbers integer->decimal-bytes)
    (io read-all-bytes write-all-bytes write-newline)
    (arithmetic-expr parse-arith-expr)
    (sexp-parser parse-sexp)
    (bytes bytes-copy! subbytes)
    (stack-machine compile-arith-expr stack-function-blocks stack-basic-block-cmds)
    (either right-v))
  (export main)
  (types)

  (define (compile-stack-machine sfun)
    (let ([bytes (make-bytes (* 64 64))])
      (let ([offset 0])
        (let ([offset (write-start bytes offset)])
          (let ([offset (write-function sfun bytes offset)])
            (subbytes bytes 0 offset))))))

  (define (write-start bytes offset)
    (let ([prologue #".section __TEXT,__text\n\n.global _start\n_start:\ncall main\nmovq $0x2000001, %rax\npop %rdi\nsyscall\n"])
      (begin
        (bytes-copy! prologue 0 (bytes-length prologue) bytes offset)
        (+ (bytes-length prologue) offset))))

  (define (write-function fun bytes offset)
    (case fun
      [(stack-function name blocks)
       (begin
         (bytes-copy! name 0 (bytes-length name) bytes offset)
         (let ([offset (+ (bytes-length name) offset)])
           (begin
             (bytes-copy! #":\n" 0 2 bytes offset)
             (let ([offset (+ offset 2)])
               (write-basic-blocks blocks bytes offset)))))]))

  (define (write-basic-blocks blocks bytes offset)
    (case blocks
      [(empty) offset]
      [(cons block blocks)
       (let ([offset (write-basic-block block bytes offset)])
         (write-basic-blocks blocks bytes offset))]))

  (define (write-basic-block block bytes offset)
    (case block
      [(stack-basic-block cmds terminal)
       (let ([offset (write-commands cmds bytes offset)])
         (write-terminal terminal bytes offset))]))


  (define (write-terminal terminal bytes offset)
    (case terminal
      [(return)
       (let ([ret #"pop %rax\npop %rbx\npush %rax\njmpq *%rbx\n"])
         (begin
           (bytes-copy! ret 0 (bytes-length ret) bytes offset)
           (+ (bytes-length ret) offset)))]))


  (define (write-commands cmds bytes offset)
    (case cmds
      [(empty) offset]
      [(cons cmd cmds)
       (case cmd
         [(num-lit-cmd v)
          (let ([initial-offset offset])
            (begin
              (bytes-copy! #"push $" 0 6 bytes offset)
              (let ([offset (+ 6 offset)])
                (let ([decimal-number (integer->decimal-bytes v)])
                  (begin
                    (bytes-copy! decimal-number 0 (bytes-length decimal-number) bytes offset)
                    (let ([offset (+ offset (bytes-length decimal-number))])
                      (begin
                        (bytes-copy! #"\n" 0 1 bytes offset)
                        (let ([offset (+ 1 offset)])
                          (write-commands cmds bytes offset)))))))))]
         [(eval-op-cmd op)
          (let ([op-bytes (case op
                            [(plus-op) #"pop %rbx\npop %rax\naddq %rbx, %rax\npush %rax\n"]
                            [(times-op) #"pop %rbx\npop %rax\nmulq %rbx\npush %rax\n"]
                            [(minus-op) #"pop %rbx\npop %rax\nsubq %rbx, %rax\npush %rax\n"])])
            (begin
              (bytes-copy! op-bytes 0 (bytes-length op-bytes) bytes offset)
              (write-commands cmds bytes (+ offset (bytes-length op-bytes)))))])]))


  (define (main stdin stdout stderr)
    (begin
      (write-all-bytes
        (compile-stack-machine
          (compile-arith-expr
            (parse-arith-expr
              (right-v (parse-sexp (read-all-bytes stdin))))))
        stdout)
      0)))
