(module x86-64-stack-machine
  (import
    (prim
      #:types (Bytes Byte InputPort OutputPort Void)
      #:values (bytes-length make-bytes * + - = panic void > bytes-set!)
      #:patterns ())
    (prim-implementation prim-implementation)
    (list
      #:types (List)
      #:values (cons-head append)
      #:patterns (empty cons))
    (numbers integer->decimal-bytes)
    (io read-all-bytes write-all-bytes newline write-line)
    (arithmetic-expr
      #:types ()
      #:values (parse-module)
      #:patterns (plus-op minus-op times-op))
    (sexp-parser
      #:types (Sexp)
      #:values (parse-sexp)
      #:patterns ())
    (bytes bytes-copy! subbytes)
    (stack-machine
      #:types (StackFunction StackBasicBlock StackCmd StackTerminal VariantCases)
      #:values (compile-module stack-function-blocks stack-basic-block-cmds)
      #:patterns (stack-function stack-basic-block return
                  swap-cmd dup-cmd pop-cmd num-lit-cmd fun-ref-cmd fun-call-cmd
                  bytes-lit-cmd boolean-lit-cmd uncond-jmp boolean-jmp alloc-variant-cmd
                  variant-ref-cmd variant-switch bytes-cmp-cmd
                  no-catch-all-case catch-all-case variant-case
                  bin-math-cmd bin-add-op bin-sub-op bin-mult-op bin-quotient-op bin-remainder-op
                  bin-logic-math-cmd less-than-op less-than-or-equal-op equal-op
                  greater-than-or-equal-op greater-than-op
                  make-array-cmd array-length-cmd array-ref-cmd array-set!-cmd))
    (either
      #:types (Either)
      #:values ()
      #:patterns (left right)))
  (export main compile-stack-machine)
  (types)

  ;; TODO support module other than main being used as the start
  (define (compile-stack-machine [sfuns : (List StackFunction)] [output : OutputPort]) : Void
    (begin
      (write-start output)
      (write-functions sfuns output)))



  (define (write-start [output : OutputPort]) : Void
    (begin
      (write-line #".section __TEXT,__text" output)
      (write-line #".global _start" output)
      (write-line #"_start:" output)
      ;; Allocate Heap (Call mmap)
      ;; No fixed address desired
      (write-line #"movq $0x0, %rdi" output)
      ;; We want 16MB for the heap
      (write-line #"movq $0x1000000, %rsi" output)
      ;; 0x1 = PROT_READ
      ;; 0x2 = PROT_WRITE
      (write-line #"movq $0x3, %rdx" output)
      ;; 0x0002 = MAP_SHARED
      ;; 0x1000 = MAP_ANON
      (write-line #"movq $0x1002, %r10" output)
      ;; FD = -1 for no flags
      (write-line #"movq $-0x1, %r8" output)
      ;; offset which is ignored because of MAP_ANON
      (write-line #"movq $0x0, %r9" output)
      ;; C5 is mmap, plus 0x2000000 because xnu
      (write-line #"movq $0x20000c5, %rax" output)
      (write-line #"syscall" output)
      ;; Save heap to %rbp which is our bump pointer
      (write-line #"movq %rax, %rbp" output)

      ;; Call main and then exit
      (write-line #"pushq $0" output)
      (write-line #"pushq $1" output)
      (write-line #"pushq $2" output)
      (write-line #"call main_main" output)
      (write-line #"mov %rax, %rdi" output)
      (write-line #"movq $0x2000001, %rax" output)
      (write-line #"syscall" output)

      ;; write_bytes
      (write-line #"prim_write_bytes:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rdx" output) ;; Argument 4
      (write-line #"pop %rcx" output) ;; Argument 3
      (write-line #"pop %rdi" output) ;; Argument 2
      (write-line #"pop %rsi" output) ;; Argument 1
      ;; %rdi is the file descriptor
      ;; Make $rsi the start of the buffer
      (write-line #"add $8, %rsi" output)
      (write-line #"add %rcx, %rsi" output)
      ;; Make %rdx the length to write
      (write-line #"sub %rcx, %rdx" output)
      (write-line #"movq $0x2000004, %rax" output)
      (write-line #"syscall" output)
      (write-line #"cmp $0, %rax" output)
      (write-line #"jl prim_write_bytes_panic" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      (write-line #"prim_write_bytes_panic:" output)
      (write-line #"mov $255, %rdi" output)
      (write-line #"movq $0x2000001, %rax" output)
      (write-line #"syscall" output)

      ;; read_bytes
      (write-line #"prim_read_bytes:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rdx" output) ;; Argument 4
      (write-line #"pop %rcx" output) ;; Argument 3
      (write-line #"pop %rdi" output) ;; Argument 2
      (write-line #"pop %rsi" output) ;; Argument 1
      ;; %rdi is the file descriptor
      ;; Make $rsi the start of the buffer
      (write-line #"add $8, %rsi" output)
      (write-line #"add %rcx, %rsi" output)
      ;; Make %rdx the length to read
      (write-line #"sub %rcx, %rdx" output)
      (write-line #"movq $0x2000003, %rax" output)
      (write-line #"syscall" output)
      (write-line #"cmp $0, %rax" output)
      (write-line #"jl prim_read_bytes_panic" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      (write-line #"prim_read_bytes_panic:" output)
      (write-line #"mov $255, %rdi" output)
      (write-line #"movq $0x2000001, %rax" output)
      (write-line #"syscall" output)

      ;; and
      (write-line #"prim_and:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Argument 2
      (write-line #"pop %rcx" output) ;; Argument 1
      (write-line #"and %rcx, %rax" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      ;; or
      (write-line #"prim_or:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Argument 2
      (write-line #"pop %rcx" output) ;; Argument 1
      (write-line #"or %rcx, %rax" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)


      ;; bytes-ref
      (write-line #"prim_bytes_ref:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rcx" output) ;; Argument 2
      (write-line #"pop %rax" output) ;; Argument 1
      (write-line #"movzb 8(%rax, %rcx), %rax" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      ;; make-bytes
      (write-line #"prim_make_bytes:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Argument 1
      (write-line #"prim_make_bytes_loop_pre:" output)
      (write-line #"mov %rbp, %rdx" output)
      (write-line #"mov %rax, (%rbp)" output)
      (write-line #"add $8, %rbp" output)
      (write-line #"prim_make_bytes_loop_start:" output)
      (write-line #"cmp $0, %rax" output)
      (write-line #"je prim_make_bytes_loop_end" output)
      (write-line #"movb $0, (%rbp)" output)
      (write-line #"add $1, %rbp" output)
      (write-line #"add $-1, %rax" output)
      (write-line #"jmp prim_make_bytes_loop_start" output)
      (write-line #"prim_make_bytes_loop_end:" output)
      (write-line #"mov %rdx, %rax" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      ;; bytes-set!
      (write-line #"prim_bytes_set:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rdx" output) ;; Argument 3
      (write-line #"pop %rcx" output) ;; Argument 2
      (write-line #"pop %rax" output) ;; Argument 1
      (write-line #"mov %dl, 8(%rax, %rcx)" output)
      (write-line #"mov $0, %rax" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      ;; bytes-length
      (write-line #"prim_bytes_length:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rax" output) ;; Argument 1
      (write-line #"movq (%rax), %rax" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)

      ;; bytes-equal?
      (write-line #"prim_bytes_equal:" output)
      (write-line #"pop %rbx" output) ;; Return address
      (write-line #"pop %rdi" output) ;; Argument 2
      (write-line #"pop %rsi" output) ;; Argument 1
      (write-line #"movq (%rsi), %rcx" output)
      (write-line #"add $8, %rcx" output)
      (write-line #"repe cmpsb" output)
      (write-line #"jz prim_bytes_equal_true" output)
      (write-line #"prim_bytes_equal_false:" output)
      (write-line #"mov $0, %rax" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)
      (write-line #"prim_bytes_equal_true:" output)
      (write-line #"mov $1, %rax" output)
      (write-line #"push %rbx" output)
      (write-line #"ret" output)

      ;; void
      (write-line #"prim_void:" output)
      (write-line #"movq $0, %rax" output)
      (write-line #"ret" output)

      ;; panic
      (write-line #"prim_panic:" output)
      (write-line #"mov $255, %rdi" output)
      (write-line #"movq $0x2000001, %rax" output)
      (write-line #"syscall" output)
      ;; variant-panic
      (write-line #"prim_variant_panic:" output)
      (write-line #"mov $255, %rdi" output)
      (write-line #"movq $0x2000001, %rax" output)
      (write-line #"syscall" output)
      ;; case-panic
      (write-line #"prim_case_panic:" output)
      (write-line #"mov $255, %rdi" output)
      (write-line #"movq $0x2000001, %rax" output)
      (write-line #"syscall" output)))


  (define (write-functions [funs : (List StackFunction)] [output : OutputPort]) : Void
    (case funs
      [(empty) (void)]
      [(cons fun funs)
       (begin
         (write-function fun output)
         (write-functions funs output))]))


  (define (write-function [fun : StackFunction] [output : OutputPort]) : Void
    (case fun
      [(stack-function name blocks)
       (begin
         (write-all-bytes name output)
         (write-all-bytes #":" output)
         (newline output)
         (write-basic-blocks name 0 blocks output))]))

  (define (write-basic-blocks [fun-name : Bytes] [index : Byte] [blocks : (List StackBasicBlock)] [output : OutputPort]) : Void
    (case blocks
      [(empty) (void)]
      [(cons block blocks)
       (begin
         (write-basic-block fun-name index block output)
         (write-basic-blocks fun-name (+ index 1) blocks output))]))

  (define (write-basic-block [fun-name : Bytes] [index : Byte] [block : StackBasicBlock] [output : OutputPort]) : Void
    (case block
      [(stack-basic-block cmds terminal)
       (begin
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes index) output)
         (write-all-bytes #":" output)
         (newline output)
         (write-commands cmds output)
         (write-terminal fun-name terminal output))]))


  (define (write-terminal [fun-name : Bytes] [terminal : StackTerminal] [output : OutputPort]) : Void
    (case terminal
      [(return num-args)
       (begin
         (write-line #"pop %rax" output)
         (write-line #"pop %rbx" output)
         (write-pop-function-arguments num-args output)
         (write-line #"push %rbx" output)
         (write-line #"ret" output))]
      [(uncond-jmp index)
       (begin
         (write-all-bytes #"jmp " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes index) output)
         (newline output))]
      [(boolean-jmp true-index false-index)
       (begin
         (write-line #"pop %rax" output)
         (write-line #"cmpq $0, %rax" output)
         (write-all-bytes #"jne " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes true-index) output)
         (newline output)
         (write-all-bytes #"jmp " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes false-index) output)
         (newline output))]
      [(variant-switch cases)
       (begin 
         (write-line #"mov (%rsp), %rax" output)
         (write-variant-switch fun-name cases output))]))

  ;; The current value is in %rax.
  (define (write-variant-switch
            [fun-name : Bytes]
            [cases : VariantCases]
            [output : OutputPort]) : Void
    (case cases
      [(no-catch-all-case)
       (write-line #"jmp prim_case_panic" output)]
      [(catch-all-case block)
       (begin
         (write-all-bytes #"jmp " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes block) output)
         (newline output))]
      [(variant-case tag block cases)
       (begin
         (write-all-bytes #"cmpq $" output)
         (write-all-bytes (integer->decimal-bytes tag) output)
         (write-all-bytes #", (%rax)" output)
         (newline output)
         (write-all-bytes #"je " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes block) output)
         (newline output)
         (write-variant-switch fun-name cases output))]))


  (define (write-pop-function-arguments [num-args : Byte] [output : OutputPort]) : Void
    (if (= 0 num-args)
        (void)
        (begin
          (write-line #"pop %rcx" output)
          (write-pop-function-arguments (- num-args 1) output))))

  (define (write-commands [cmds : (List StackCmd)] [output : OutputPort]) : Void
    (case cmds
      [(empty) (void)]
      [(cons cmd cmds)
       (case cmd
         [(dup-cmd offset)
          (begin
            (write-all-bytes #"push " output)
            (write-all-bytes (integer->decimal-bytes (* offset 8)) output)
            (write-line #"(%rsp)" output)
            (write-commands cmds output))]
         [(swap-cmd)
          (begin
            (write-line #"pop %rax" output)
            (write-line #"pop %rbx" output)
            (write-line #"push %rax" output)
            (write-line #"push %rbx" output)
            (write-commands cmds output))]
         [(pop-cmd)
          (begin
            (write-line #"pop %rax" output)
            (write-commands cmds output))]
         [(num-lit-cmd v)
          (begin
            (write-all-bytes #"push $" output)
            (write-all-bytes (integer->decimal-bytes v) output)
            (newline output)
            (write-commands cmds output))]
         [(boolean-lit-cmd v)
          (begin
            (if v
                (write-line #"push $1" output)
                (write-line #"push $0" output))
            (write-commands cmds output))]
         ;; TODO put the bytes not directly in the instruction stream
         [(bytes-lit-cmd v)
          (begin
            (write-line #".byte 0xe9" output)
            (write-all-bytes #".long " output)
            (write-all-bytes (integer->decimal-bytes (+ 8 (bytes-length v))) output)
            (newline output)
            (write-all-bytes #".8byte " output)
            (write-all-bytes (integer->decimal-bytes (bytes-length v)) output)
            (newline output)
            (let ([quote (let ([buf (make-bytes 1)]) (begin (bytes-set! buf 0 34) buf))])
              (begin
                (write-all-bytes #".ascii " output)
                (write-all-bytes quote output)
                (write-all-bytes v output)
                (write-all-bytes quote output)))
            (newline output)
            ;; Need to account for the 7 bytes of leaq
            (write-all-bytes #"leaq -" output)
            (write-all-bytes (integer->decimal-bytes (+ 15 (bytes-length v))) output)
            (write-line #"(%rip), %rax" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
          [(bytes-cmp-cmd)
           (begin
             (write-line #"call prim_bytes_equal" output)
             (write-line #"push %rax" output)
             (write-commands cmds output))]

         [(fun-ref-cmd name)
          (begin
            (write-all-bytes #"leaq " output)
            (write-all-bytes name output)
            (write-line #"(%rip), %rax" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(fun-call-cmd _)
          (begin
            (write-line #"pop %rax" output)
            (write-line #"callq *%rax" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]

         [(make-array-cmd)
          (begin
            (write-line #"pop %rax" output)
            (write-line #"pop %rcx" output)
            (write-line #"mov %rbp, %rdx" output)
            (write-line #"mov %rcx, (%rbp)" output)
            (write-line #"add $8, %rbp" output)
            (write-line #"mov %rbp, %rdi" output)
            (write-line #"rep stosq" output)
            (write-line #"mov %rdi, %rbp" output)
            (write-line #"push %rdx" output)
            (write-commands cmds output))]
         [(array-length-cmd)
          (begin
            (write-line #"pop %rax" output)
            (write-line #"push (%rax)" output)
            (write-commands cmds output))]
         [(array-ref-cmd)
          (begin
            (write-line #"pop %rcx" output)
            (write-line #"pop %rax" output)
            (write-line #"push 8(%rax, %rcx, 8)" output)
            (write-commands cmds output))]
         [(array-set!-cmd)
          (begin
            (write-line #"pop %rdx" output)
            (write-line #"pop %rcx" output)
            (write-line #"pop %rax" output)
            (write-line #"mov %rdx, 8(%rax, %rcx, 8)" output)
            (write-line #"push $0" output)
            (write-commands cmds output))]

         [(bin-logic-math-cmd op)
          (begin
            (write-line #"pop %rax" output) ;; Argument 2
            (write-line #"pop %rcx" output) ;; Argument 1
            (write-line #"cmpq %rax, %rcx" output)
            (case op
              [(less-than-op)
               (write-line #"setl %al" output)]
              [(less-than-or-equal-op)
               (write-line #"setle %al" output)]
              [(equal-op)
               (write-line #"sete %al" output)]
              [(greater-than-or-equal-op)
               (write-line #"setge %al" output)]
              [(greater-than-op)
               (write-line #"setg %al" output)])
            (write-line #"movzx %al, %rax" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(bin-math-cmd (bin-add-op))
          (begin
            (write-line #"pop %rax" output) ;; Argument 2
            (write-line #"pop %rcx" output) ;; Argument 1
            (write-line #"addq %rcx, %rax" output)
            (write-line #"pushq %rax" output)
            (write-commands cmds output))]
         [(bin-math-cmd (bin-sub-op))
          (begin
            (write-line #"pop %rcx" output) ;; Argument 2
            (write-line #"pop %rax" output) ;; Argument 1
            (write-line #"subq %rcx, %rax" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(bin-math-cmd (bin-mult-op))
          (begin
            (write-line #"pop %rax" output) ;; Argument 2
            (write-line #"pop %rcx" output) ;; Argument 1
            (write-line #"imulq %rcx" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(bin-math-cmd (bin-quotient-op))
          (begin
            (write-line #"pop %rcx" output) ;; Argument 2
            (write-line #"pop %rax" output) ;; Argument 1
            (write-line #"movq $0, %rdx" output)
            (write-line #"idiv %rcx" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(bin-math-cmd (bin-remainder-op))
          (begin
            (write-line #"pop %rcx" output) ;; Argument 2
            (write-line #"pop %rax" output) ;; Argument 1
            (write-line #"movq $0, %rdx" output)
            (write-line #"idiv %rcx" output)
            (write-line #"movq %rdx, %rax" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(alloc-variant-cmd tag fields)
          (begin
            (write-line #"mov %rbp, %rax" output)
            (write-all-bytes #"movq $" output)
            (write-all-bytes (integer->decimal-bytes tag) output)
            (write-all-bytes #", (%rbp)" output)
            (newline output)
            (write-line #"add $8, %rbp" output)
            (copy-objects fields output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(variant-ref-cmd tag field)
          (begin
            (write-line #"pop %rax" output)
            (write-all-bytes #"cmpq $" output)
            (write-all-bytes (integer->decimal-bytes tag) output)
            (write-line #", (%rax)" output)
            (write-line #"jne prim_variant_panic" output)
            (write-all-bytes #"pushq " output)
            (write-all-bytes (integer->decimal-bytes (+ (* 8 field) 8)) output)
            (write-line #"(%rax)" output)
            (write-commands cmds output))])]))

  ;; Generates assembly to copy n objects from the top of the stack to the
  ;; memory starting at %rbp. %rbp ends up pointing right after after the last object written.
  (define (copy-objects [n : Byte] [output : OutputPort]) : Void
    (if (> n 0)
        (begin
          (write-line #"pop (%rbp)" output)
          (write-line #"add $8, %rbp" output)
          (copy-objects (- n 1) output))
        (void)))



  ;; TODO switch to a polymorphic one when it works
  (define (a) (extract-either [either : (Either Bytes a)]) : a
    (case either
      [(right v) v]
      [(left v) (panic v)]))

  (define (main [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Byte
    (begin
      (compile-stack-machine
        (append
          (compile-module
            (parse-module
              (extract-either (parse-sexp (read-all-bytes stdin)))))
          (prim-implementation))
        stdout)
      0)))
