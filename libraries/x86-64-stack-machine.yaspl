(module x86-64-stack-machine
  (import
    (prim
      #:types (Bytes Byte InputPort OutputPort Void Array)
      #:values (bytes-length make-bytes * + - = panic void > bytes-set!)
      #:patterns ())
    (prim-implementation prim-implementation)
    (list
      #:types (List)
      #:values (cons-head append list map)
      #:patterns (empty cons))
    (numbers integer->decimal-bytes)
    (io read-all-bytes write-all-bytes newline write-line)
    (join-list
      #:types (JoinList)
      #:values (jl->list single-jl join-list)
      #:patterns ())
    (sexp-parser
      #:types (Sexp)
      #:values (parse-sexp)
      #:patterns ())
    (bytes bytes-copy! subbytes)
    (stack-machine
      #:types (StackFunction StackBasicBlock StackCmd StackTerminal VariantCases TopLevelObject)
      #:values (stack-function-blocks stack-basic-block-cmds)
      #:patterns (stack-function stack-basic-block return
                  swap-cmd dup-cmd pop-cmd num-lit-cmd create-closure-cmd fun-call-cmd known-fun-call-cmd
                  bytes-lit-cmd boolean-lit-cmd uncond-jmp boolean-jmp alloc-variant-cmd
                  variant-ref-cmd variant-switch bytes-cmp-cmd load-global-cmd
                  no-catch-all-case catch-all-case variant-case
                  bin-math-cmd bin-add-op bin-sub-op bin-mult-op bin-quotient-op bin-remainder-op
                  bin-logic-math-cmd less-than-op less-than-or-equal-op equal-op
                  greater-than-or-equal-op greater-than-op
                  make-array-cmd array-length-cmd array-ref-cmd array-set!-cmd
                  make-array-from-stack-cmd dup-free-var-cmd function-tlo trivial-closure-tlo))
    (either
      #:types (Either)
      #:values ()
      #:patterns (left right)))
  (export compile-stack-machine)
  (types
    (define-type AssemblyCommand
      (directive-cmd [directive AssemblerDirective])
      (instruction-cmd [instruction Instruction]))
    (define-type AssemblerDirective
      (section-directive [segment-name Bytes] [section-name Bytes])
      (global-directive [name Bytes])
      (label-directive [name Bytes]))
    (define-type Instruction
      (nop)
      (movq [literal Byte] [register Register]))
    (define-type Register
      (rdi)
      (rsi)))

  (define (compile-stack-machine
            [main-function-name : Bytes]
            [objects : (List TopLevelObject)]
            [output : OutputPort]) : Void
    (begin
      (write-start main-function-name output)
      (write-objects objects output)))

  (define (assembly-command->bytes [cmd : AssemblyCommand]) : (JoinList Bytes)
    (case cmd
      [(directive-cmd directive) (assembler-directive->bytes directive)]
      [(instruction-cmd instruction) (instruction->assembly-bytes instruction)]))

  (define (assembler-directive->bytes [dir : AssemblerDirective]) : (JoinList Bytes)
    (case dir
      [(section-directive seg sect)
       (varargs join-list  #".section " seg #"," sect)]
      [(global-directive name)
       (varargs join-list  #".global " name)]
      [(label-directive name)
       (varargs join-list  name #":")]))

  (define (instruction->assembly-bytes [inst : Instruction]) : (JoinList Bytes)
    (case inst
      [(nop)
       (single-jl #"nop")]
      [(movq byte reg)
       (varargs join-list
          #"movq $"
          (integer->decimal-bytes byte)
          #", "
          (register->bytes reg))]))

  (define (register->bytes [reg : Register]) : Bytes
    (case reg
      [(rdi) #"rdi"]
      [(rsi) #"rsi"]))


  (define (write-start [main-function-name : Bytes] [output : OutputPort]) : Void
    (begin
      (write-lines
        (map
          assembly-command->bytes
          (varargs list
            (directive-cmd (section-directive #"__TEXT" #"__text"))
            (directive-cmd (global-directive #"start"))
            (directive-cmd (label-directive #"start"))
            (instruction-cmd (nop))
            (directive-cmd (label-directive #"start_break"))))
        output)
      ;; Allocate Heap (Call mmap)
      ;; No fixed address desired
      (write-line #"movq $0x0, %rdi" output)
      ;; We want a large heap
      (write-line #"movq $0x20000000, %rsi" output)
      ;; 0x1 = PROT_READ
      ;; 0x2 = PROT_WRITE
      (write-line #"movq $0x7, %rdx" output)
      ;; 0x0002 = MAP_SHARED
      ;; 0x1000 = MAP_ANON
      (write-line #"movq $0x1002, %r10" output)
      ;; FD = -1 for no flags
      (write-line #"movq $-0x1, %r8" output)
      ;; offset which is ignored because of MAP_ANON
      (write-line #"movq $0x0, %r9" output)
      ;; C5 is mmap, plus 0x2000000 because xnu
      (write-line #"movq $0x20000c5, %rax" output)
      (write-line #"syscall" output)
      (write-line #"jb prim_start_panic" output)
      ;; Save heap to %rbp which is our bump pointer
      (write-line #"movq %rax, %rbp" output)

      ;; Construct args
      (write-line #"popq %r8" output) ; r8 is the number of c strings
      (write-line #"movq %rbp, %r10" output) ; r10 is the array of bytes
      (write-line #"movq $0, %r11" output) ; r11 is the index of the current string

      (write-line #"movq %r8, (%rbp)" output)
      (write-line #"lea 8(%rbp, %r8, 8), %rbp" output)

      (write-line #"cmp %r11, %r8" output)
      (write-line #"je start_copy_args_end" output)
      (write-line #"cld" output)
      (write-line #"start_copy_args_start:" output)
      (write-line #"popq %r9" output) ; r9 is the current string

      ;; Count string length
      (write-line #"mov %r9, %rdi" output)
      (write-line #"mov $0, %al" output)
      (write-line #"mov $-1, %rcx" output)
      (write-line #"repne scasb" output)
      (write-line #"not %rcx" output)
      (write-line #"dec %rcx" output)

      ;; Copy bytes
      (write-line #"movq %rbp, 8(%r10, %r11, 8)" output)
      (write-line #"movq %rcx, (%rbp)" output)
      (write-line #"add $8, %rbp" output)
      (write-line #"mov %r9, %rsi" output)
      (write-line #"mov %rbp, %rdi" output)
      (write-line #"rep movsb" output)
      (write-line #"mov %rdi, %rbp" output)

      (write-line #"inc %r11" output)
      (write-line #"cmp %r11, %r8" output)
      (write-line #"jne start_copy_args_start" output)
      (write-line #"start_copy_args_end:" output)

      ;; Call main and then exit
      (write-lines
        (varargs list
          (single-jl #"pushq %r10")
          (single-jl #"pushq $0")
          (single-jl #"pushq $1")
          (single-jl #"pushq $2")
          (single-jl #"pushq $0") ;; Bogus closure
          (varargs join-list #"call " main-function-name #"_code" )
          (single-jl #"mov %rax, %rdi")
          (single-jl #"movq $0x2000001, %rax")
          (single-jl #"syscall")
          (single-jl #"prim_start_panic:")
          (single-jl #"ud2"))
        output)
      ;; No return



      ;; write-bytes
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_write_bytes_closure: ")
          (single-jl #".quad prim_write_bytes")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_write_bytes:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"pop %rdx") ;; Argument 4
          (single-jl #"pop %rcx") ;; Argument 3
          (single-jl #"pop %rdi") ;; Argument 2
          (single-jl #"pop %rsi") ;; Argument 1
          ;; %rdi is the file descriptor
          ;; Make $rsi the start of the buffer
          (single-jl #"add $8, %rsi")
          (single-jl #"add %rcx, %rsi")
          ;; Make %rdx the length to write
          (single-jl #"sub %rcx, %rdx")
          (single-jl #"movq $0x2000004, %rax")
          (single-jl #"syscall")
          (single-jl #"jb prim_write_bytes_panic")
          (single-jl #"push %rbx")
          (single-jl #"ret")
          (single-jl #"prim_write_bytes_panic:")
          (single-jl #"ud2"))
          ;; No return
        output)

      ;; read-bytes
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_read_bytes_closure: ")
          (single-jl #".quad prim_read_bytes")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_read_bytes:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"pop %rdx") ;; Argument 4
          (single-jl #"pop %rcx") ;; Argument 3
          (single-jl #"pop %rdi") ;; Argument 2
          (single-jl #"pop %rsi") ;; Argument 1
          ;; %rdi is the file descriptor
          ;; Make $rsi the start of the buffer
          (single-jl #"add $8, %rsi")
          (single-jl #"add %rcx, %rsi")
          ;; Make %rdx the length to read
          (single-jl #"sub %rcx, %rdx")
          (single-jl #"movq $0x2000003, %rax")
          (single-jl #"syscall")
          (single-jl #"jb prim_read_bytes_panic")
          (single-jl #"push %rbx")
          (single-jl #"ret")
          (single-jl #"prim_read_bytes_panic:")
          (single-jl #"ud2"))
          ;; No return
        output)

      ;; open-input-file
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_open_input_file_closure: ")
          (single-jl #".quad prim_open_input_file")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_open_input_file:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"pop %rdi") ;; Null terminated path
          (single-jl #"add $8, %rdi")
          (single-jl #"movq $0, %rsi") ;; 0 is read only
          (single-jl #"movq $0x2000005, %rax")
          (single-jl #"syscall")
          (single-jl #"jb prim_open_input_file_panic")
          (single-jl #"push %rbx")
          (single-jl #"ret")
          (single-jl #"prim_open_input_file_panic:")
          (single-jl #"ud2"))
          ;; No return
        output)

      ;; open-output-file
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_open_output_file_closure: ")
          (single-jl #".quad prim_open_output_file")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_open_output_file:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"pop %rdi") ;; Null terminated path
          (single-jl #"add $8, %rdi")
          (single-jl #"movq $513, %rsi") ;; 1 is write only, 512 is create
          (single-jl #"movq $504, %rdx") ;; 770 for mode
          (single-jl #"movq $0x2000005, %rax")
          (single-jl #"syscall")
          (single-jl #"jb prim_open_output_file_panic")
          (single-jl #"push %rbx")
          (single-jl #"ret")
          (single-jl #"prim_open_output_file_panic:")
          (single-jl #"ud2"))
          ;; No return
        output)


      ;; close-output-port
      ;; close-input-port
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_close_port_closure: ")
          (single-jl #".quad prim_close_port")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_close_port:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"pop %rdi") ;; fd
          (single-jl #"movq $0x2000006, %rax")
          (single-jl #"syscall")
          (single-jl #"jb prim_close_port_panic")
          (single-jl #"push %rbx")
          (single-jl #"ret")
          (single-jl #"prim_close_port_panic:")
          (single-jl #"ud2"))
          ;; No return
        output)

      ;; socket
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_socket_closure: ")
          (single-jl #".quad prim_socket")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_socket:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"pop %rdx") ;; Argument 3: protocol
          (single-jl #"pop %rsi") ;; Argument 2: type
          (single-jl #"pop %rdi") ;; Argument 1: domain
          (single-jl #"movq $0x2000061, %rax")
          (single-jl #"syscall")
          (single-jl #"jb prim_socket_panic")
          (single-jl #"push %rbx")
          (single-jl #"ret")
          (single-jl #"prim_socket_panic:")
          (single-jl #"ud2"))
          ;; No return
        output)

      ;; bind
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_bind_closure: ")
          (single-jl #".quad prim_bind")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_bind:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"pop %rdx") ;; Argument 3: length
          (single-jl #"pop %rsi") ;; Argument 2: sockaddr
          (single-jl #"pop %rdi") ;; Argument 1: socket
          (single-jl #"add $8, %rsi")
          (single-jl #"movq $0x2000068, %rax")
          (single-jl #"syscall")
          (single-jl #"jb prim_bind_panic")
          (single-jl #"push %rbx")
          (single-jl #"ret")
          (single-jl #"prim_bind_panic:")
          (single-jl #"ud2"))
          ;; No return
        output)

      ;; sendto
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_sendto_closure: ")
          (single-jl #".quad prim_sendto")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_sendto:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"pop %r9") ;; Argument 6: sockaddr-length
          (single-jl #"pop %r8") ;; Argument 5: sockaddr
          (single-jl #"pop %r10") ;; Argument 4: flags
          (single-jl #"pop %rdx") ;; Argument 3: buffer-length
          (single-jl #"pop %rsi") ;; Argument 2: buffer
          (single-jl #"pop %rdi") ;; Argument 1: socket
          (single-jl #"add $8, %rsi")
          (single-jl #"add $8, %r8")
          (single-jl #"movq $0x2000085, %rax")
          (single-jl #"syscall")
          (single-jl #"jb prim_sendto_panic")
          (single-jl #"push %rbx")
          (single-jl #"ret")
          (single-jl #"prim_sendto_panic:")
          (single-jl #"ud2"))
          ;; No return
        output)

      ;; recvfrom
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_recvfrom_closure: ")
          (single-jl #".quad prim_recvfrom")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_recvfrom:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"pop %r9") ;; Argument 6: sockaddr-length
          (single-jl #"pop %r8") ;; Argument 5: sockaddr
          (single-jl #"pop %r10") ;; Argument 4: flags
          (single-jl #"pop %rdx") ;; Argument 3: buffer-length
          (single-jl #"pop %rsi") ;; Argument 2: buffer
          (single-jl #"pop %rdi") ;; Argument 1: socket
          (single-jl #"add $8, %rsi")
          (single-jl #"add $8, %r8")
          (single-jl #"add $8, %r9")
          (single-jl #"movq $0x200001d, %rax")
          (single-jl #"syscall")
          (single-jl #"jb prim_recvfrom_panic")
          (single-jl #"push %rbx")
          (single-jl #"ret")
          (single-jl #"prim_recvfrom_panic:")
          (single-jl #"ud2"))
          ;; No return
        output)


      ;; connect
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_connect_closure: ")
          (single-jl #".quad prim_connect")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_connect:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"pop %rdx") ;; Argument 3: sockaddr-length
          (single-jl #"pop %rsi") ;; Argument 2: sockaddr
          (single-jl #"pop %rdi") ;; Argument 1: socket
          (single-jl #"add $8, %rsi")
          (single-jl #"movq $0x2000062, %rax")
          (single-jl #"syscall")
          (single-jl #"jb prim_connect_panic")
          (single-jl #"push %rbx")
          (single-jl #"ret")
          (single-jl #"prim_connect_panic:")
          (single-jl #"ud2"))
          ;; No return
        output)

      ;; shutdown
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_shutdown_closure: ")
          (single-jl #".quad prim_shutdown")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_shutdown:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"pop %rsi") ;; Argument 2: how
          (single-jl #"pop %rdi") ;; Argument 1: socket
          (single-jl #"movq $0x2000086, %rax")
          (single-jl #"syscall")
          (single-jl #"jb prim_shutdown_panic")
          (single-jl #"push %rbx")
          (single-jl #"ret")
          (single-jl #"prim_shutdown_panic:")
          (single-jl #"ud2"))
          ;; No return
        output)


      ;; listen
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_listen_closure: ")
          (single-jl #".quad prim_listen")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_listen:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"pop %rsi") ;; Argument 2: backlog
          (single-jl #"pop %rdi") ;; Argument 1: socket
          (single-jl #"movq $0x200006A, %rax")
          (single-jl #"syscall")
          (single-jl #"jb prim_listen_panic")
          (single-jl #"push %rbx")
          (single-jl #"ret")
          (single-jl #"prim_listen_panic:")
          (single-jl #"ud2"))
          ;; No return
        output)


      ;; accept
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_accept_closure: ")
          (single-jl #".quad prim_accept")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_accept:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"pop %rdx") ;; Argument 3: sockaddr-length
          (single-jl #"pop %rsi") ;; Argument 2: sockaddr
          (single-jl #"pop %rdi") ;; Argument 1: socket
          (single-jl #"add $8, %rsi")
          (single-jl #"add $8, %rdx")
          (single-jl #"movq $0x200001E, %rax")
          (single-jl #"syscall")
          (single-jl #"jb prim_accept_panic")
          (single-jl #"push %rbx")
          (single-jl #"ret")
          (single-jl #"prim_accept_panic:")
          (single-jl #"ud2"))
          ;; No return
        output)


      ;; setsockopt
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_setsockopt_closure: ")
          (single-jl #".quad prim_setsockopt")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_setsockopt:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"pop %r8")  ;; Argument 5: option length
          (single-jl #"pop %r10") ;; Argument 4: option value
          (single-jl #"pop %rdx") ;; Argument 3: option name
          (single-jl #"pop %rsi") ;; Argument 2: level
          (single-jl #"pop %rdi") ;; Argument 1: socket
          (single-jl #"add $8, %r10")
          (single-jl #"movq $0x2000069, %rax")
          (single-jl #"syscall")
          (single-jl #"jb prim_setsockopt_panic")
          (single-jl #"push %rbx")
          (single-jl #"ret")
          (single-jl #"prim_setsockopt_panic:")
          (single-jl #"ud2"))
          ;; No return
        output)


      ;; mach_task_self
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_mach_task_self_closure:")
          (single-jl #".quad prim_mach_task_self")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_mach_task_self:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"movq $0x100001c, %rax")
          (single-jl #"syscall")
          (single-jl #"cmp $0, %rax")
          (single-jl #"je prim_mach_task_self_panic")
          (single-jl #"push %rbx")
          (single-jl #"ret")
          (single-jl #"prim_mach_task_self_panic:")
          (single-jl #"ud2"))
          ;; No return
        output)


      ;; mach_thread_self
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_mach_thread_self_closure:")
          (single-jl #".quad prim_mach_thread_self")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_mach_thread_self:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"movq $0x100001b, %rax")
          (single-jl #"syscall")
          (single-jl #"cmp $0, %rax")
          (single-jl #"je prim_mach_thread_self_panic")
          (single-jl #"push %rbx")
          (single-jl #"ret")
          (single-jl #"prim_mach_thread_self_panic:")
          (single-jl #"ud2"))
          ;; No return
        output)


      ;; mach_reply_port
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_mach_reply_port_closure:")
          (single-jl #".quad prim_mach_reply_port")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_mach_reply_port:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"movq $0x100001a, %rax")
          (single-jl #"syscall")
          (single-jl #"cmp $0, %rax")
          (single-jl #"je prim_mach_reply_port_panic")
          (single-jl #"push %rbx")
          (single-jl #"ret")
          (single-jl #"prim_mach_reply_port_panic:")
          (single-jl #"ud2"))
          ;; No return
        output)


      ;; mach_port_mod_refs
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_mach_port_mod_refs_closure:")
          (single-jl #".quad prim_mach_port_mod_refs")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_mach_port_mod_refs:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"pop %r10") ;; Argument 4: delta
          (single-jl #"pop %rdx") ;; Argument 3: right
          (single-jl #"pop %rsi") ;; Argument 2: port
          (single-jl #"pop %rdi") ;; Argument 1: task
          (single-jl #"movq $0x1000013, %rax")
          (single-jl #"syscall")
          (single-jl #"cmp $0, %rax")
          (single-jl #"jne prim_mach_port_mod_refs_panic")
          (single-jl #"push %rbx")
          (single-jl #"ret")
          (single-jl #"prim_mach_port_mod_refs_panic:")
          (single-jl #"ud2"))
          ;; No return
        output)

      ;; mach_msg
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_mach_msg_closure:")
          (single-jl #".quad prim_mach_msg")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_mach_msg:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"pop %r11") ;; Notify Port
          (single-jl #"pop %r9")  ;; Timeout
          (single-jl #"pop %r10") ;; Recv size
          (single-jl #"pop %rdx") ;; Send size
          (single-jl #"pop %rsi") ;; Options
          (single-jl #"pop %rdi") ;; Buffer
          (single-jl #"addq $0x8, %rdi") ;; Adjust past buffer's length field
          (single-jl #"pop %r8") ;; Reply-port
          (single-jl #"push %r11") ;; Push back the notify port
          (single-jl #"pushq $0x0") ;; Dummy Return Address
          (single-jl #"movq $0x100001f, %rax")
          (single-jl #"syscall")
          (single-jl #"cmp $0, %rax")
          (single-jl #"jne prim_mach_msg_panic")
          (single-jl #"add $0x10, %rsp") ;; 2 pop
          (single-jl #"push %rbx")
          (single-jl #"ret")
          (single-jl #"prim_mach_msg_panic:")
          (single-jl #"ud2"))
          ;; No return
        output)

      ;; and
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_and_closure: ")
          (single-jl #".quad prim_and")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_and:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"pop %rax") ;; Argument 2
          (single-jl #"pop %rcx") ;; Argument 1
          (single-jl #"and %rcx, %rax")
          (single-jl #"push %rbx")
          (single-jl #"ret"))
        output)
      ;; or
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_or_closure: ")
          (single-jl #".quad prim_or")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_or:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"pop %rax") ;; Argument 2
          (single-jl #"pop %rcx") ;; Argument 1
          (single-jl #"or %rcx, %rax")
          (single-jl #"push %rbx")
          (single-jl #"ret"))
        output)


      ;; bytes-ref
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_bytes_ref_closure: ")
          (single-jl #".quad prim_bytes_ref")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_bytes_ref:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"pop %rcx") ;; Argument 2
          (single-jl #"pop %rax") ;; Argument 1
          (single-jl #"movzb 8(%rax, %rcx), %rax")
          (single-jl #"push %rbx")
          (single-jl #"ret"))
        output)
      ;; make-bytes
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_make_bytes_closure: ")
          (single-jl #".quad prim_make_bytes")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_make_bytes:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"pop %rax") ;; Argument 1
          (single-jl #"prim_make_bytes_loop_pre:")
          (single-jl #"mov %rbp, %rdx")
          (single-jl #"mov %rax, (%rbp)")
          (single-jl #"add $8, %rbp")
          (single-jl #"prim_make_bytes_loop_start:")
          (single-jl #"cmp $0, %rax")
          (single-jl #"je prim_make_bytes_loop_end")
          (single-jl #"movb $0, (%rbp)")
          (single-jl #"add $1, %rbp")
          (single-jl #"add $-1, %rax")
          (single-jl #"jmp prim_make_bytes_loop_start")
          (single-jl #"prim_make_bytes_loop_end:")
          (single-jl #"mov %rdx, %rax")
          (single-jl #"push %rbx")
          (single-jl #"ret"))
        output)
      ;; bytes-set!
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_bytes_set_closure: ")
          (single-jl #".quad prim_bytes_set")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_bytes_set:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"pop %rdx") ;; Argument 3
          (single-jl #"pop %rcx") ;; Argument 2
          (single-jl #"pop %rax") ;; Argument 1
          (single-jl #"mov %dl, 8(%rax, %rcx)")
          (single-jl #"mov $0, %rax")
          (single-jl #"push %rbx")
          (single-jl #"ret"))
        output)
      ;; bytes-length
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_bytes_length_closure: ")
          (single-jl #".quad prim_bytes_length")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_bytes_length:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"pop %rax") ;; Argument 1
          (single-jl #"movq (%rax), %rax")
          (single-jl #"push %rbx")
          (single-jl #"ret"))
        output)

      ;; bytes-equal?
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_bytes_equal_closure: ")
          (single-jl #".quad prim_bytes_equal")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_bytes_equal:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"pop %rdi") ;; Argument 2
          (single-jl #"pop %rsi") ;; Argument 1
          (single-jl #"movq (%rsi), %rcx")
          (single-jl #"add $8, %rcx")
          (single-jl #"repe cmpsb")
          (single-jl #"jz prim_bytes_equal_true")
          (single-jl #"prim_bytes_equal_false:")
          (single-jl #"mov $0, %rax")
          (single-jl #"push %rbx")
          (single-jl #"ret")
          (single-jl #"prim_bytes_equal_true:")
          (single-jl #"mov $1, %rax")
          (single-jl #"push %rbx")
          (single-jl #"ret"))
        output)

      ;; void
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_void_closure: ")
          (single-jl #".quad prim_void")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_void:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"push %rbx") ;; Return address
          (single-jl #"movq $0, %rax")
          (single-jl #"ret"))
        output)

      ;; panic
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_panic_closure: ")
          (single-jl #".quad prim_panic")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_panic:")
          (single-jl #"movq 24(%rsp), %rax")
          (single-jl #"add $8, %rax")
          (single-jl #"ud2"))
        output)

          ;; These are not native functions, but just native subroutines
          ;; They do not follow standard calling conventions

      ;; make-array-from-stack
      (write-lines
        (varargs list
          (single-jl #"prim_make_array_from_stack:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rcx") ;; num-args
          (single-jl #"mov %rbp, %rax")
          (single-jl #"mov %rcx, (%rbp)")
          (single-jl #"leaq (%rbp, %rcx, 8), %rbp")
          (single-jl #"leaq 8(%rbp), %rdx")
          (single-jl #"cmp $0, %rcx")
          (single-jl #"je prim_make_array_from_stack_loop_end")
          (single-jl #"prim_make_array_from_stack_loop_start:")
          (single-jl #"popq (%rbp)")
          (single-jl #"sub $8, %rbp")
          (single-jl #"dec %rcx")
          (single-jl #"jnz prim_make_array_from_stack_loop_start")
          (single-jl #"prim_make_array_from_stack_loop_end:")
          (single-jl #"mov %rdx, %rbp")
          (single-jl #"push %rbx")
          (single-jl #"ret"))
        output)

      ;; variant-panic
      (write-lines
        (varargs list
          (single-jl #"prim_variant_panic:")
          (single-jl #"ud2"))
        output)

      ;; thread_bootstrap
      (write-lines
        (varargs list
          (single-jl #"prim_thread_bootstrap:")
          (single-jl #"pushq %rax")
          (single-jl #"mov (%rax), %rax")
          (single-jl #"callq *%rax")
          (single-jl #"ud2"))
        output)))


  (define (write-objects [objects : (List TopLevelObject)] [output : OutputPort]) : Void
    (case objects
      [(empty) (void)]
      [(cons (function-tlo fun) objects)
       (begin
         (write-function fun output)
         (write-objects objects output))]
      [(cons (trivial-closure-tlo name fun-name) objects)
       (begin
         (write-trivial-closure name fun-name output)
         (write-objects objects output))]))

  (define (write-trivial-closure [name : Bytes] [fun-name : Bytes] [output : OutputPort]) : Void
    (begin
      (write-line #".section __TEXT,__const" output)
      (write-all-bytes name output)
      (write-all-bytes #":" output)
      (newline output)
      (write-all-bytes #".quad " output)
      (write-all-bytes fun-name output)
      (newline output)))

  (define (write-function [fun : StackFunction] [output : OutputPort]) : Void
    (case fun
      [(stack-function name blocks)
       (begin
         (write-line #".section __TEXT,__text" output)
         (write-all-bytes name output)
         (write-all-bytes #":" output)
         (newline output)
         (write-basic-blocks name 0 blocks output))]))

  (define (write-basic-blocks [fun-name : Bytes] [index : Byte] [blocks : (List StackBasicBlock)] [output : OutputPort]) : Void
    (case blocks
      [(empty) (void)]
      [(cons block blocks)
       (begin
         (write-basic-block fun-name index block output)
         (write-basic-blocks fun-name (+ index 1) blocks output))]))

  (define (write-basic-block [fun-name : Bytes] [index : Byte] [block : StackBasicBlock] [output : OutputPort]) : Void
    (case block
      [(stack-basic-block cmds terminal)
       (begin
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes index) output)
         (write-all-bytes #":" output)
         (newline output)
         (write-commands cmds output)
         (write-terminal fun-name terminal output))]))

  (define (a) (for-each [f : (a -> Void)] [l : (List a)]) : Void
    (case l
      [(empty) (void)]
      [(cons e l)
       (begin
         (f e)
         (for-each f l))]))

  (define (write-lines [lines : (List (JoinList Bytes))] [output : OutputPort]) : Void
    (for-each
      (lambda ([line : (JoinList Bytes)])
        (begin
          (for-each
            (lambda ([bytes : Bytes]) (write-all-bytes bytes output))
            (jl->list line))
          (newline output)))
      lines))

  (define (write-terminal [fun-name : Bytes] [terminal : StackTerminal] [output : OutputPort]) : Void
    (case terminal
      [(return num-args)
       (begin
         (write-line #"pop %rax" output) ;; Return value
         (write-line #"pop %rbx" output) ;; Return address
         (write-line #"pop %rcx" output) ;; Closure
         (write-pop-function-arguments num-args output)
         (write-line #"push %rbx" output)
         (write-line #"ret" output))]
      [(uncond-jmp index)
       (begin
         (write-all-bytes #"jmp " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes index) output)
         (newline output))]
      [(boolean-jmp true-index false-index)
       (begin
         (write-line #"pop %rax" output)
         (write-line #"cmpq $0, %rax" output)
         (write-all-bytes #"jne " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes true-index) output)
         (newline output)
         (write-all-bytes #"jmp " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes false-index) output)
         (newline output))]
      [(variant-switch cases)
       (begin
         (write-line #"mov (%rsp), %rax" output)
         (write-variant-switch fun-name cases output))]))

  ;; The current value is in %rax.
  (define (write-variant-switch
            [fun-name : Bytes]
            [cases : VariantCases]
            [output : OutputPort]) : Void
    (case cases
      [(no-catch-all-case)
       (write-line #"ud2" output)]
      [(catch-all-case block)
       (begin
         (write-all-bytes #"jmp " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes block) output)
         (newline output))]
      [(variant-case tag block cases)
       (begin
         (write-all-bytes #"cmpq $" output)
         (write-all-bytes (integer->decimal-bytes tag) output)
         (write-all-bytes #", (%rax)" output)
         (newline output)
         (write-all-bytes #"je " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes block) output)
         (newline output)
         (write-variant-switch fun-name cases output))]))


  (define (write-pop-function-arguments [num-args : Byte] [output : OutputPort]) : Void
    (if (= 0 num-args)
        (void)
        (begin
          (write-line #"pop %rcx" output)
          (write-pop-function-arguments (- num-args 1) output))))

  (define (write-commands [cmds : (List StackCmd)] [output : OutputPort]) : Void
    (case cmds
      [(empty) (void)]
      [(cons cmd cmds)
       (case cmd
         [(dup-cmd offset)
          (begin
            (write-all-bytes #"push " output)
            (write-all-bytes (integer->decimal-bytes (* offset 8)) output)
            (write-line #"(%rsp)" output)
            (write-commands cmds output))]
         [(dup-free-var-cmd offset index)
          (begin
            (write-all-bytes #"mov " output)
            (write-all-bytes (integer->decimal-bytes (* offset 8)) output)
            (write-line #"(%rsp), %rax" output)
            (write-all-bytes #"push " output)
            (write-all-bytes (integer->decimal-bytes (* (+ 1 index) 8)) output)
            (write-line #"(%rax)" output)
            (write-commands cmds output))]
         [(swap-cmd)
          (begin
            (write-line #"pop %rax" output)
            (write-line #"pop %rbx" output)
            (write-line #"push %rax" output)
            (write-line #"push %rbx" output)
            (write-commands cmds output))]
         [(pop-cmd)
          (begin
            (write-line #"pop %rax" output)
            (write-commands cmds output))]
         [(num-lit-cmd v)
          ;; TODO fix when yaspl supports larger literals
          (let ([max-lit
                 (let ([shift (+ #xFF 1)])
                   (+ (* shift (+ (* shift (+ (* shift #xFF) #xFF)) #xFF)) #xFF))])
            (begin
              (if (> v max-lit)
                  (begin
                    (write-all-bytes #"mov $" output)
                    (write-all-bytes (integer->decimal-bytes v) output)
                    (write-all-bytes #", %rax" output)
                    (newline output)
                    (write-line #"push %rax" output))
                  (begin
                    (write-all-bytes #"pushq $" output)
                    (write-all-bytes (integer->decimal-bytes v) output)
                    (newline output)))
            (write-commands cmds output)))]
         [(boolean-lit-cmd v)
          (begin
            (if v
                (write-line #"push $1" output)
                (write-line #"push $0" output))
            (write-commands cmds output))]
         ;; TODO put the bytes not directly in the instruction stream
         [(bytes-lit-cmd v)
          (begin
            (write-line #".byte 0xe9" output)
            (write-all-bytes #".long " output)
            (write-all-bytes (integer->decimal-bytes (+ 8 (bytes-length v))) output)
            (newline output)
            (write-all-bytes #".8byte " output)
            (write-all-bytes (integer->decimal-bytes (bytes-length v)) output)
            (newline output)
            (let ([quote (let ([buf (make-bytes 1)]) (begin (bytes-set! buf 0 34) buf))])
              (begin
                (write-all-bytes #".ascii " output)
                (write-all-bytes quote output)
                (write-all-bytes v output)
                (write-all-bytes quote output)))
            (newline output)
            ;; Need to account for the 7 bytes of leaq
            (write-all-bytes #"leaq -" output)
            (write-all-bytes (integer->decimal-bytes (+ 15 (bytes-length v))) output)
            (write-line #"(%rip), %rax" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
          [(bytes-cmp-cmd)
           (begin
             (write-line #"push $0" output) ; Bogus closure
             (write-line #"call prim_bytes_equal" output)
             (write-line #"push %rax" output)
             (write-commands cmds output))]

         [(load-global-cmd name)
          (begin
            (write-all-bytes #"leaq " output)
            (write-all-bytes name output)
            (write-line #"(%rip), %rax" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]

         [(create-closure-cmd n)
          (begin
            (write-line #"mov %rbp, %rax" output)
            (copy-objects (+ n 1) output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(fun-call-cmd _)
          (begin
            (write-line #"mov (%rsp), %rax" output)
            (write-line #"mov (%rax), %rax" output)
            (write-line #"callq *%rax" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(known-fun-call-cmd name _)
          (begin
            (write-line #"push $0" output) ; Bogus closure
            (write-all-bytes #"callq " output)
            (write-all-bytes name output)
            (newline output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]

         [(make-array-cmd)
          (begin
            (write-line #"pop %rax" output)
            (write-line #"pop %rcx" output)
            (write-line #"mov %rbp, %rdx" output)
            (write-line #"mov %rcx, (%rbp)" output)
            (write-line #"add $8, %rbp" output)
            (write-line #"mov %rbp, %rdi" output)
            (write-line #"rep stosq" output)
            (write-line #"mov %rdi, %rbp" output)
            (write-line #"push %rdx" output)
            (write-commands cmds output))]
         [(make-array-from-stack-cmd num-args)
          (begin
            (write-all-bytes #"pushq $" output)
            (write-all-bytes (integer->decimal-bytes num-args) output)
            (newline output)
            (write-line #"call prim_make_array_from_stack" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(array-length-cmd)
          (begin
            (write-line #"pop %rax" output)
            (write-line #"push (%rax)" output)
            (write-commands cmds output))]
         [(array-ref-cmd)
          (begin
            (write-line #"pop %rcx" output)
            (write-line #"pop %rax" output)
            (write-line #"push 8(%rax, %rcx, 8)" output)
            (write-commands cmds output))]
         [(array-set!-cmd)
          (begin
            (write-line #"pop %rdx" output)
            (write-line #"pop %rcx" output)
            (write-line #"pop %rax" output)
            (write-line #"mov %rdx, 8(%rax, %rcx, 8)" output)
            (write-line #"push $0" output)
            (write-commands cmds output))]

         [(bin-logic-math-cmd op)
          (begin
            (write-line #"pop %rax" output) ;; Argument 2
            (write-line #"pop %rcx" output) ;; Argument 1
            (write-line #"cmpq %rax, %rcx" output)
            (case op
              [(less-than-op)
               (write-line #"setl %al" output)]
              [(less-than-or-equal-op)
               (write-line #"setle %al" output)]
              [(equal-op)
               (write-line #"sete %al" output)]
              [(greater-than-or-equal-op)
               (write-line #"setge %al" output)]
              [(greater-than-op)
               (write-line #"setg %al" output)])
            (write-line #"movzx %al, %rax" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(bin-math-cmd (bin-add-op))
          (begin
            (write-line #"pop %rax" output) ;; Argument 2
            (write-line #"pop %rcx" output) ;; Argument 1
            (write-line #"addq %rcx, %rax" output)
            (write-line #"pushq %rax" output)
            (write-commands cmds output))]
         [(bin-math-cmd (bin-sub-op))
          (begin
            (write-line #"pop %rcx" output) ;; Argument 2
            (write-line #"pop %rax" output) ;; Argument 1
            (write-line #"subq %rcx, %rax" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(bin-math-cmd (bin-mult-op))
          (begin
            (write-line #"pop %rax" output) ;; Argument 2
            (write-line #"pop %rcx" output) ;; Argument 1
            (write-line #"imulq %rcx" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(bin-math-cmd (bin-quotient-op))
          (begin
            (write-line #"pop %rcx" output) ;; Argument 2
            (write-line #"pop %rax" output) ;; Argument 1
            (write-line #"movq $0, %rdx" output)
            (write-line #"idiv %rcx" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(bin-math-cmd (bin-remainder-op))
          (begin
            (write-line #"pop %rcx" output) ;; Argument 2
            (write-line #"pop %rax" output) ;; Argument 1
            (write-line #"movq $0, %rdx" output)
            (write-line #"idiv %rcx" output)
            (write-line #"movq %rdx, %rax" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(alloc-variant-cmd tag fields)
          (begin
            (write-line #"mov %rbp, %rax" output)
            (write-all-bytes #"movq $" output)
            (write-all-bytes (integer->decimal-bytes tag) output)
            (write-all-bytes #", (%rbp)" output)
            (newline output)
            (write-line #"add $8, %rbp" output)
            (copy-objects fields output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(variant-ref-cmd tag field)
          (begin
            (write-line #"pop %rax" output)
            (write-all-bytes #"cmpq $" output)
            (write-all-bytes (integer->decimal-bytes tag) output)
            (write-line #", (%rax)" output)
            (write-line #"jne prim_variant_panic" output)
            (write-all-bytes #"pushq " output)
            (write-all-bytes (integer->decimal-bytes (+ (* 8 field) 8)) output)
            (write-line #"(%rax)" output)
            (write-commands cmds output))])]))

  ;; Generates assembly to copy n objects from the top of the stack to the
  ;; memory starting at %rbp. %rbp ends up pointing right after after the last object written.
  (define (copy-objects [n : Byte] [output : OutputPort]) : Void
    (if (> n 0)
        (begin
          (write-line #"pop (%rbp)" output)
          (write-line #"add $8, %rbp" output)
          (copy-objects (- n 1) output))
        (void)))



  ;; TODO switch to a polymorphic one when it works
  (define (a) (extract-either [either : (Either Bytes a)]) : a
    (case either
      [(right v) v]
      [(left v) (panic v)])))
