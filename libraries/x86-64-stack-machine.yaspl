(module x86-64-stack-machine
  (import
    (prim
      #:types (Bytes Byte InputPort OutputPort Void Array)
      #:values (bytes-length make-bytes * + - = panic void > bytes-set!)
      #:patterns ())
    (prim-implementation prim-implementation)
    (list
      #:types (List)
      #:values (cons-head append list map)
      #:patterns (empty cons))
    (numbers integer->decimal-bytes)
    (io read-all-bytes write-all-bytes newline write-line)
    (join-list
      #:types (JoinList)
      #:values (jl->list single-jl join-list)
      #:patterns ())
    (sexp-parser
      #:types (Sexp)
      #:values (parse-sexp)
      #:patterns ())
    (bytes bytes-copy! subbytes bytes-append)
    (stack-machine
      #:types (StackFunction StackBasicBlock StackCmd StackTerminal VariantCases TopLevelObject)
      #:values (stack-function-blocks stack-basic-block-cmds)
      #:patterns (stack-function stack-basic-block return
                  swap-cmd dup-cmd pop-cmd num-lit-cmd create-closure-cmd fun-call-cmd known-fun-call-cmd
                  bytes-lit-cmd boolean-lit-cmd uncond-jmp boolean-jmp alloc-variant-cmd
                  variant-ref-cmd variant-switch bytes-cmp-cmd load-global-cmd
                  no-catch-all-case catch-all-case variant-case
                  bin-math-cmd bin-add-op bin-sub-op bin-mult-op bin-quotient-op bin-remainder-op
                  bin-logic-math-cmd less-than-op less-than-or-equal-op equal-op
                  greater-than-or-equal-op greater-than-op
                  make-array-cmd array-length-cmd array-ref-cmd array-set!-cmd
                  make-array-from-stack-cmd dup-free-var-cmd function-tlo trivial-closure-tlo))
    (either
      #:types (Either)
      #:values ()
      #:patterns (left right)))
  (export compile-stack-machine)
  (types
    (define-type AssemblyCommand
      (directive-cmd [directive AssemblerDirective])
      (instruction-cmd [instruction Instruction]))
    (define-type AssemblerDirective
      (section-directive [segment-name Bytes] [section-name Bytes])
      (global-directive [label Bytes])
      (label-directive [name Bytes])
      (quad-directive [label Bytes]))
    (define-type Instruction
      (add [rmi RegMemImm] [reg Register])
      (and [reg1 RegMemImm] [reg2 Register])
      (call [label Bytes])
      (call/indirect [rmi RegMemImm])
      (cmovz [rmi RegMemImm] [reg Register])
      (cmp [rmi RegMemImm] [reg Register])
      (dec [reg Register])
      (inc [reg Register])
      (jb [label Bytes])
      (je [label Bytes])
      (jne [label Bytes])
      (jnz [label Bytes])
      (leaq [rmi RegMemImm] [reg Register])
      (lahf)
      (movb [rmi1 RegMemImm] [rmi2 RegMemImm])
      (movq [rmi1 RegMemImm] [rmi2 RegMemImm])
      (movzb [rmi RegMemImm] [r Register])
      (nop)
      (not [reg Register])
      (or [reg1 Register] [reg2 Register])
      (pop [rmi RegMemImm])
      (push [register Register])
      (pushq [v Byte])
      (rep-movsb)
      (repe-cmpsb)
      (repne-scasb)
      (ret)
      (shr [reg1 Register] [reg2 Register])
      (sub [rmi RegMemImm] [reg Register])
      (syscall)
      (ud2))
    (define-type Register
      ;; 8 Bit registers
      (al)
      (ah)
      (bl)
      (bh)
      (cl)
      (ch)
      (dl)
      (dh)
      (dil)
      (sil)
      (bpl)
      (spl)
      (r8b)
      (r9b)
      (r10b)
      (r11b)
      (r12b)
      (r13b)
      (r14b)
      (r15b)
      ;; 16 bit registers
      (ax)
      (bx)
      (cx)
      (dx)
      (di)
      (si)
      (bp)
      (sp)
      (r8w)
      (r9w)
      (r10w)
      (r11w)
      (r12w)
      (r13w)
      (r14w)
      (r15w)
      ;; 32 bit registers
      (eax)
      (ebx)
      (ecx)
      (edx)
      (edi)
      (esi)
      (ebp)
      (esp)
      (r8d)
      (r9d)
      (r10d)
      (r11d)
      (r12d)
      (r13d)
      (r14d)
      (r15d)
      ;;64 bit registers
      (rax)
      (rbx)
      (rcx)
      (rdx)
      (rdi)
      (rsi)
      (rbp)
      (rsp)
      (r8)
      (r9)
      (r10)
      (r11)
      (r12)
      (r13)
      (r14)
      (r15)
      (rip))
    (define-type RegMemImm
      (rmi-register [r Register])
      (rmi-direct-memory [reg Register] [offset Byte])
      (rmi-scaled-memory [reg Register] [scale Byte] [index-reg Register] [offset Byte])
      (rmi-immediate [v Byte])))

  (define (compile-stack-machine
            [main-function-name : Bytes]
            [objects : (List TopLevelObject)]
            [output : OutputPort]) : Void
    (begin
      (write-start main-function-name output)
      (write-objects objects output)))

  (define (assembly-command->bytes [cmd : AssemblyCommand]) : (JoinList Bytes)
    (case cmd
      [(directive-cmd directive) (assembler-directive->bytes directive)]
      [(instruction-cmd instruction) (instruction->assembly-bytes instruction)]))

  (define (assembler-directive->bytes [dir : AssemblerDirective]) : (JoinList Bytes)
    (case dir
      [(section-directive seg sect)
       (varargs join-list #".section " seg #"," sect)]
      [(global-directive label)
       (varargs join-list #".global " label)]
      [(label-directive name)
       (varargs join-list name #":")]
      [(quad-directive label)
       (varargs join-list #".quad " label)]))

  (define (instruction->assembly-bytes [inst : Instruction]) : (JoinList Bytes)
    (case inst
      [(add rmi reg)
       (varargs join-list
          #"add "
          (rmi->bytes rmi)
          #", "
          (register->bytes reg))]
      [(and rmi reg)
       (varargs join-list
          #"and "
          (rmi->bytes rmi)
          #", "
          (register->bytes reg))]
      [(call label)
       (varargs join-list #"call " label)]
      [(call/indirect rmi)
       (varargs join-list #"callq *" (rmi->bytes rmi))]
      [(cmovz rmi reg)
       (varargs join-list
          #"cmovz "
          (rmi->bytes rmi)
          #", "
          (register->bytes reg))]
      [(cmp rmi reg)
       (varargs join-list
          #"cmp "
          (rmi->bytes rmi)
          #", "
          (register->bytes reg))]
      [(dec reg)
       (varargs join-list #"dec " (register->bytes reg))]
      [(inc reg)
       (varargs join-list #"inc " (register->bytes reg))]
      [(jb label)
       (varargs join-list #"jb " label)]
      [(je label)
       (varargs join-list #"je " label)]
      [(jne label)
       (varargs join-list #"jne " label)]
      [(jnz label)
       (varargs join-list #"jnz " label)]
      [(lahf)
       (single-jl #"lahf")]
      [(leaq rmi reg)
       (varargs join-list
          #"leaq "
          (rmi->bytes rmi)
          #", "
          (register->bytes reg))]
      [(movb rmi1 rmi2)
       (varargs join-list
          #"movb "
          (rmi->bytes rmi1)
          #", "
          (rmi->bytes rmi2))]
      [(movq rmi1 rmi2)
       (varargs join-list
          #"movq "
          (rmi->bytes rmi1)
          #", "
          (rmi->bytes rmi2))]
      [(movzb rmi reg)
       (varargs join-list
          #"movzb "
          (rmi->bytes rmi)
          #", "
          (register->bytes reg))]
      [(nop)
       (single-jl #"nop")]
      [(not reg)
       (varargs join-list #"not " (register->bytes reg))]
      [(or reg1 reg2)
       (varargs join-list
          #"or "
          (register->bytes reg1)
          #", "
          (register->bytes reg2))]
      [(pop rmi)
       (varargs join-list #"pop " (rmi->bytes rmi))]
      [(push reg)
       (varargs join-list #"push " (register->bytes reg))]
      [(pushq v)
       (varargs join-list #"pushq $" (integer->decimal-bytes v))]
      [(rep-movsb)
       (single-jl #"rep movsb")]
      [(repe-cmpsb)
       (single-jl #"repe cmpsb")]
      [(repne-scasb)
       (single-jl #"repne scasb")]
      [(ret)
       (single-jl #"ret")]
      [(sub rmi reg)
       (varargs join-list
          #"sub "
          (rmi->bytes rmi)
          #", "
          (register->bytes reg))]
      [(shr reg1 reg2)
       (varargs join-list
          #"shr "
          (register->bytes reg1)
          #", "
          (register->bytes reg2))]
      [(syscall)
       (single-jl #"syscall")]
      [(ud2)
       (single-jl #"ud2")]))

  (define (register->bytes [reg : Register]) : Bytes
    (case reg
      ;; 8 bit
      [(al) #"%al"]
      [(ah) #"%ah"]
      [(bl) #"%bl"]
      [(bh) #"%bh"]
      [(cl) #"%cl"]
      [(ch) #"%ch"]
      [(dl) #"%dl"]
      [(dh) #"%dh"]
      [(dil) #"%dli"]
      [(sil) #"%sil"]
      [(bpl) #"%bpl"]
      [(spl) #"%spl"]
      [(r8b) #"%r8b"]
      [(r9b) #"%r9b"]
      [(r10b) #"%r10b"]
      [(r11b) #"%r11b"]
      [(r12b) #"%r12b"]
      [(r13b) #"%r13b"]
      [(r14b) #"%r14b"]
      [(r15b) #"%r15b"]
      ;; 16 bit
      [(ax) #"%ax"]
      [(bx) #"%bx"]
      [(cx) #"%cx"]
      [(dx) #"%dx"]
      [(di) #"%di"]
      [(si) #"%si"]
      [(bp) #"%bp"]
      [(sp) #"%sp"]
      [(r8w) #"%r8w"]
      [(r9w) #"%r9w"]
      [(r10w) #"%r10w"]
      [(r11w) #"%r11w"]
      [(r12w) #"%r12w"]
      [(r13w) #"%r13w"]
      [(r14w) #"%r14w"]
      [(r15w) #"%r15w"]
      ;; 32 bit
      [(eax) #"%eax"]
      [(ebx) #"%ebx"]
      [(ecx) #"%ecx"]
      [(edx) #"%edx"]
      [(edi) #"%edi"]
      [(esi) #"%esi"]
      [(ebp) #"%ebp"]
      [(esp) #"%esp"]
      [(r8d) #"%r8d"]
      [(r9d) #"%r9d"]
      [(r10d) #"%r10d"]
      [(r11d) #"%r11d"]
      [(r12d) #"%r12d"]
      [(r13d) #"%r13d"]
      [(r14d) #"%r14d"]
      [(r15d) #"%r15d"]
      ;; 64 bit
      [(rax) #"%rax"]
      [(rbx) #"%rbx"]
      [(rcx) #"%rcx"]
      [(rdx) #"%rdx"]
      [(rdi) #"%rdi"]
      [(rsi) #"%rsi"]
      [(rbp) #"%rbp"]
      [(rsp) #"%rsp"]
      [(r8) #"%r8"]
      [(r9) #"%r9"]
      [(r10) #"%r10"]
      [(r11) #"%r11"]
      [(r12) #"%r12"]
      [(r13) #"%r13"]
      [(r14) #"%r14"]
      [(r15) #"%r15"]
      [(rip) #"%rip"]))

  (define (rmi->bytes [rmi : RegMemImm]) : Bytes
    (case rmi
      [(rmi-register r) (register->bytes r)]
      [(rmi-direct-memory reg offset)
       (bytes-append (varargs list (integer->decimal-bytes offset) #"(" (register->bytes reg) #")"))]
      [(rmi-scaled-memory reg scale index offset)
       (bytes-append
         (varargs list
           (integer->decimal-bytes offset)
           #"("
           (register->bytes reg)
           #", "
           (register->bytes index)
           #", "
           (integer->decimal-bytes scale)
           #")"))]
      [(rmi-immediate v)
       (bytes-append (varargs list #"$" (integer->decimal-bytes v)))]))

  (define (reg [r : Register]) : RegMemImm
    (rmi-register r))
  (define (mem [r : Register] [offset : Byte]) : RegMemImm
    (rmi-direct-memory r offset))
  (define (imm [v : Byte]) : RegMemImm
    (rmi-immediate v))
  (define (scaled [r : Register] [scale : Byte] [index : Register] [offset : Byte]) : RegMemImm
    (rmi-scaled-memory r scale index offset))

  (define (write-assembly-commands [cmds : (List AssemblyCommand)] [output : OutputPort]) : Void
    (write-lines (map assembly-command->bytes cmds) output))

  (define (write-prim-assembly-function
            [name : Bytes]
            [output : OutputPort]
            [instructions : (List Instruction)]) : Void
    (write-assembly-commands
      (append
        (varargs list
          (directive-cmd (section-directive #"__TEXT" #"__const"))
          (directive-cmd (label-directive (bytes-append (varargs list #"prim_" name #"_closure"))))
          (directive-cmd (quad-directive (bytes-append (varargs list #"prim_" name))))
          (directive-cmd (section-directive #"__TEXT" #"__text"))
          (directive-cmd (label-directive (bytes-append (varargs list #"prim_" name)))))
        (map instruction-cmd instructions))
      output))

  (define (write-prim-assembly-function/panic
            [name : Bytes]
            [output : OutputPort]
            [instructions : (List Instruction)]) : Void
    (begin
      (write-prim-assembly-function name output instructions)
      (write-assembly-commands
        (varargs list
          (directive-cmd (label-directive (bytes-append (varargs list #"prim_" name #"_panic"))))
          (instruction-cmd (ud2)))
        output)))

  (define (write-block
            [name : Bytes]
            [output : OutputPort]
            [instructions : (List Instruction)]) : Void
    (write-assembly-commands
      (append
        (varargs list
          (directive-cmd (label-directive name)))
        (map instruction-cmd instructions))
      output))




  (define (write-start [main-function-name : Bytes] [output : OutputPort]) : Void
    (begin
      (write-assembly-commands
        (varargs list
          (directive-cmd (section-directive #"__TEXT" #"__text"))
          (directive-cmd (global-directive #"start"))
          (directive-cmd (label-directive #"start"))
          (instruction-cmd (nop))
          (directive-cmd (label-directive #"start_break")))
        output)
      ;; Allocate Heap (Call mmap)
      ;; No fixed address desired
      (write-line #"movq $0x0, %rdi" output)
      ;; We want a large heap
      (write-line #"movq $0x20000000, %rsi" output)
      ;; 0x1 = PROT_READ
      ;; 0x2 = PROT_WRITE
      (write-line #"movq $0x7, %rdx" output)
      ;; 0x0002 = MAP_SHARED
      ;; 0x1000 = MAP_ANON
      (write-line #"movq $0x1002, %r10" output)
      ;; FD = -1 for no flags
      (write-line #"movq $-0x1, %r8" output)
      ;; offset which is ignored because of MAP_ANON
      (write-line #"movq $0x0, %r9" output)
      ;; C5 is mmap, plus 0x2000000 because xnu
      (write-line #"movq $0x20000c5, %rax" output)
      (write-line #"syscall" output)
      (write-line #"jb prim_start_panic" output)
      ;; Save heap to %rbp which is our bump pointer
      (write-line #"movq %rax, %rbp" output)

      ;; Construct args
      (write-line #"popq %r8" output) ; r8 is the number of c strings
      (write-line #"movq %rbp, %r10" output) ; r10 is the array of bytes
      (write-line #"movq $0, %r11" output) ; r11 is the index of the current string

      (write-line #"movq %r8, (%rbp)" output)
      (write-line #"lea 8(%rbp, %r8, 8), %rbp" output)

      (write-line #"cmp %r11, %r8" output)
      (write-line #"je start_copy_args_end" output)
      (write-line #"cld" output)
      (write-block #"start_copy_args_start" output
        (varargs list
          (pop (reg (r9))) ; r9 is now the current string

          ;; Count string length
          (movq (reg (r9)) (reg (rdi)))
          (movb (imm 0) (reg (al)))
          (movq (imm (- 0 1)) (reg (rcx)))
          (repne-scasb)
          (not (rcx))
          (dec (rcx))

          ;; Copy bytes
          (movq (reg (rbp)) (scaled (r10) 8 (r11) 8))
          (movq (reg (rcx)) (mem (rbp) 0))
          (add (imm 8) (rbp))
          (movq (reg (r9)) (reg (rsi)))
          (movq (reg (rbp)) (reg (rdi)))
          (rep-movsb)
          (movq (reg (rdi)) (reg (rbp)))
          (inc (r11))
          (cmp (reg (r11)) (r8))
          (jne #"start_copy_args_start")))



      ;; Call main and then exit
      (write-block #"start_copy_args_end" output
        (varargs list
          (push (r10))
          (pushq 0)
          (pushq 1)
          (pushq 2)
          (pushq 0) ;; Bogus closure
          (call (bytes-append (varargs list main-function-name #"_code")))
          (movq (reg (rax)) (reg (rdi)))
          (movq (imm #x2000001) (reg (rax)))
          (syscall)))
      (write-block #"prim_start_panic" output
        (varargs list
          (ud2)))



      ;; write-bytes
      (write-prim-assembly-function/panic #"write_bytes" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (pop (reg (rdx))) ;; Argument 4
          (pop (reg (rcx))) ;; Argument 3
          (pop (reg (rdi))) ;; Argument 2
          (pop (reg (rsi))) ;; Argument 1
          ;; %rdi is the file descriptor
          ;; Make $rsi the start of the buffer
          (add (imm 8) (rsi))
          (add (reg (rcx)) (rsi))
          ;; Make %rdx the length to write
          (sub (reg (rcx)) (rdx))
          (movq (imm #x2000004) (reg (rax)))
          (syscall)
          (jb #"prim_write_bytes_panic")
          (push (rbx))
          (ret)))

      ;; read-bytes
      (write-prim-assembly-function/panic #"read_bytes" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (pop (reg (rdx))) ;; Argument 4
          (pop (reg (rcx))) ;; Argument 3
          (pop (reg (rdi))) ;; Argument 2
          (pop (reg (rsi))) ;; Argument 1
          ;; %rdi is the file descriptor
          ;; Make $rsi the start of the buffer
          (add (imm 8) (rsi))
          (add (reg (rcx)) (rsi))
          ;; Make %rdx the length to read
          (sub (reg (rcx)) (rdx))
          (movq (imm #x2000003) (reg (rax)))
          (syscall)
          (jb #"prim_read_bytes_panic")
          (push (rbx))
          (ret)))

      ;; open-input-file
      (write-prim-assembly-function/panic #"open_input_file" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (pop (reg (rdi))) ;; Null terminated path
          (add (imm 8) (rdi))
          (movq (imm 0) (reg (rsi))) ;; 0 is read only
          (movq (imm #x2000005) (reg (rax)))
          (syscall)
          (jb #"prim_open_input_file_panic")
          (push (rbx))
          (ret)))

      ;; open-output-file
      (write-prim-assembly-function/panic #"open_output_file" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (pop (reg (rdi))) ;; Null terminated path
          (add (imm 8) (rdi))
          (movq (imm 513) (reg (rsi))) ;; 1 is write only, 512 is create
          (movq (imm 504) (reg (rdx))) ;; 770 for mode
          (movq (imm #x2000005) (reg (rax)))
          (syscall)
          (jb #"prim_open_output_file_panic")
          (push (rbx))
          (ret)))


      ;; close-output-port
      ;; close-input-port
      (write-prim-assembly-function/panic #"close_port" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (pop (reg (rdi))) ;; fd
          (movq (imm #x2000006) (reg (rax)))
          (syscall)
          (jb #"prim_close_port_panic")
          (push (rbx))
          (ret)))

      ;; socket
      (write-prim-assembly-function/panic #"socket" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (pop (reg (rdx))) ;; Argument 3: protocol
          (pop (reg (rsi))) ;; Argument 2: type
          (pop (reg (rdi))) ;; Argument 1: domain
          (movq (imm #x2000061) (reg (rax)))
          (syscall)
          (jb #"prim_socket_panic")
          (push (rbx))
          (ret)))

      ;; bind
      (write-prim-assembly-function/panic #"bind" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (pop (reg (rdx))) ;; Argument 3: length
          (pop (reg (rsi))) ;; Argument 2: sockaddr
          (pop (reg (rdi))) ;; Argument 1: socket
          (add (imm 8) (rsi))
          (movq (imm #x2000068) (reg (rax)))
          (syscall)
          (jb #"prim_bind_panic")
          (push (rbx))
          (ret)))

      ;; sendto
      (write-prim-assembly-function/panic #"sendto" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (pop (reg (r9))) ;; Argument 6: sockaddr-length
          (pop (reg (r8))) ;; Argument 5: sockaddr
          (pop (reg (r10))) ;; Argument 4: flags
          (pop (reg (rdx))) ;; Argument 3: buffer-length
          (pop (reg (rsi))) ;; Argument 2: buffer
          (pop (reg (rdi))) ;; Argument 1: socket
          (add (imm 8) (rsi))
          (add (imm 8) (r8))
          (movq (imm #x2000085) (reg (rax)))
          (syscall)
          (jb #"prim_sendto_panic")
          (push (rbx))
          (ret)))

      ;; recvfrom
      (write-prim-assembly-function/panic #"recvfrom" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (pop (reg (r9))) ;; Argument 6: sockaddr-length
          (pop (reg (r8))) ;; Argument 5: sockaddr
          (pop (reg (r10))) ;; Argument 4: flags
          (pop (reg (rdx))) ;; Argument 3: buffer-length
          (pop (reg (rsi))) ;; Argument 2: buffer
          (pop (reg (rdi))) ;; Argument 1: socket
          (add (imm 8) (rsi))
          (add (imm 8) (r8))
          (add (imm 8) (r9))
          (movq (imm #x200001d) (reg (rax)))
          (syscall)
          (jb #"prim_recvfrom_panic")
          (push (rbx))
          (ret)))

      ;; connect
      (write-prim-assembly-function/panic #"connect" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (pop (reg (rdx))) ;; Argument 3: sockaddr-length
          (pop (reg (rsi))) ;; Argument 2: sockaddr
          (pop (reg (rdi))) ;; Argument 1: socket
          (add (imm 8) (rsi))
          (movq (imm #x2000062) (reg (rax)))
          (syscall)
          (jb #"prim_connect_panic")
          (push (rbx))
          (ret)))

      ;; shutdown
      (write-prim-assembly-function/panic #"shutdown" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (pop (reg (rsi))) ;; Argument 2: how
          (pop (reg (rdi))) ;; Argument 1: socket
          (movq (imm #x2000086) (reg (rax)))
          (syscall)
          (jb #"prim_shutdown_panic")
          (push (rbx))
          (ret)))


      ;; listen
      (write-prim-assembly-function/panic #"listen" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (pop (reg (rsi))) ;; Argument 2: backlog
          (pop (reg (rdi))) ;; Argument 1: socket
          (movq (imm #x200006A) (reg (rax)))
          (syscall)
          (jb #"prim_listen_panic")
          (push (rbx))
          (ret)))

      ;; accept
      (write-prim-assembly-function/panic #"accept" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (pop (reg (rdx))) ;; Argument 3: sockaddr-length
          (pop (reg (rsi))) ;; Argument 2: sockaddr
          (pop (reg (rdi))) ;; Argument 1: socket
          (add (imm 8) (rsi))
          (add (imm 8) (rdx))
          (movq (imm #x200001E) (reg (rax)))
          (syscall)
          (jb #"prim_accept_panic")
          (push (rbx))
          (ret)))


      ;; setsockopt
      (write-prim-assembly-function/panic #"setsockopt" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (pop (reg (r8)))  ;; Argument 5: option length
          (pop (reg (r10))) ;; Argument 4: option value
          (pop (reg (rdx))) ;; Argument 3: option name
          (pop (reg (rsi))) ;; Argument 2: level
          (pop (reg (rdi))) ;; Argument 1: socket
          (add (imm 8) (r10))
          (movq (imm #x2000069) (reg (rax)))
          (syscall)
          (jb #"prim_setsockopt_panic")
          (push (rbx))
          (ret)))


      ;; mach_task_self
      (write-prim-assembly-function/panic #"mach_task_self" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (movq (imm #x100001c) (reg (rax)))
          (syscall)
          (cmp (imm 0) (rax))
          (je #"prim_mach_task_self_panic")
          (push (rbx))
          (ret)))


      ;; mach_thread_self
      (write-prim-assembly-function/panic #"mach_thread_self" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (movq (imm #x100001b) (reg (rax)))
          (syscall)
          (cmp (imm 0) (rax))
          (je #"prim_mach_thread_self_panic")
          (push (rbx))
          (ret)))


      ;; mach_reply_port
      (write-prim-assembly-function/panic #"mach_reply_port" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (movq (imm #x100001a) (reg (rax)))
          (syscall)
          (cmp (imm 0) (rax))
          (je #"prim_mach_reply_port_panic")
          (push (rbx))
          (ret)))


      ;; mach_port_mod_refs
      (write-prim-assembly-function/panic #"mach_port_mod_refs" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (pop (reg (r10))) ;; Argument 4: delta
          (pop (reg (rdx))) ;; Argument 3: right
          (pop (reg (rsi))) ;; Argument 2: port
          (pop (reg (rdi))) ;; Argument 1: task
          (movq (imm #x1000013) (reg (rax)))
          (syscall)
          (cmp (imm 0) (rax))
          (jne #"prim_mach_port_mod_refs_panic")
          (push (rbx))
          (ret)))

      ;; mach_msg
      (write-prim-assembly-function/panic #"mach_msg" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (pop (reg (r11))) ;; Notify Port
          (pop (reg (r9)))  ;; Timeout
          (pop (reg (r10))) ;; Recv size
          (pop (reg (rdx))) ;; Send size
          (pop (reg (rsi))) ;; Options
          (pop (reg (rdi))) ;; Buffer
          (add (imm 8) (rdi)) ;; Adjust past buffer's length field
          (pop (reg (r8))) ;; Reply-port
          (push (r11)) ;; Push back the notify port
          (pushq 0) ;; Dummy Return Address
          (movq (imm #x100001f) (reg (rax)))
          (syscall)
          (cmp (imm 0) (rax))
          (jne #"prim_mach_msg_panic")
          (add (imm #x10) (rsp)) ;; 2 pop
          (push (rbx))
          (ret)))

      ;; and
      (write-prim-assembly-function #"and" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (pop (reg (rax))) ;; Argument 2
          (pop (reg (rcx))) ;; Argument 1
          (and (reg (rcx)) (rax))
          (push (rbx))
          (ret)))
      ;; or
      (write-prim-assembly-function #"or" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (pop (reg (rax))) ;; Argument 2
          (pop (reg (rcx))) ;; Argument 1
          (or (rcx) (rax))
          (push (rbx))
          (ret)))


      ;; bytes-ref
      (write-prim-assembly-function #"bytes_ref" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (pop (reg (rcx))) ;; Argument 2
          (pop (reg (rax))) ;; Argument 1
          (movzb (scaled (rax) 1 (rcx) 8) (rax))
          (push (rbx))
          (ret)))
      ;; make-bytes
      (write-lines
        (varargs list
          (single-jl #".section __TEXT,__const")
          (single-jl #"prim_make_bytes_closure: ")
          (single-jl #".quad prim_make_bytes")
          (single-jl #".section __TEXT,__text")
          (single-jl #"prim_make_bytes:")
          (single-jl #"pop %rbx") ;; Return address
          (single-jl #"pop %rax") ;; Ignored closure
          (single-jl #"pop %rax") ;; Argument 1
          (single-jl #"prim_make_bytes_loop_pre:")
          (single-jl #"mov %rbp, %rdx")
          (single-jl #"mov %rax, (%rbp)")
          (single-jl #"add $8, %rbp")
          (single-jl #"prim_make_bytes_loop_start:")
          (single-jl #"cmp $0, %rax")
          (single-jl #"je prim_make_bytes_loop_end")
          (single-jl #"movb $0, (%rbp)")
          (single-jl #"add $1, %rbp")
          (single-jl #"add $-1, %rax")
          (single-jl #"jmp prim_make_bytes_loop_start")
          (single-jl #"prim_make_bytes_loop_end:")
          (single-jl #"mov %rdx, %rax")
          (single-jl #"push %rbx")
          (single-jl #"ret"))
        output)

      ;; bytes-set!
      (write-prim-assembly-function #"bytes_set" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (pop (reg (rdx))) ;; Argument 3
          (pop (reg (rcx))) ;; Argument 2
          (pop (reg (rax))) ;; Argument 1
          (movb (reg (dl)) (scaled (rax) 1 (rcx) 8))
          (movq (imm 0) (reg (rax)))
          (push (rbx))
          (ret)))
      ;; bytes-length
      (write-prim-assembly-function #"bytes_length" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (pop (reg (rax))) ;; Argument 1
          (movq (mem (rax) 0) (reg (rax)))
          (push (rbx))
          (ret)))

      ;; bytes-equal?
      (write-prim-assembly-function #"bytes_equal" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (pop (reg (rdi))) ;; Argument 2
          (pop (reg (rsi))) ;; Argument 1
          (movq (mem (rsi) 0) (reg (rcx)))
          (add (imm 8) (rcx))
          (repe-cmpsb)
          (movq (imm 0) (reg (rax)))
          (movq (imm 1) (reg (rcx)))
          (cmovz (reg (rcx)) (rax))
          (push (rbx))
          (ret)))

      ;; void
      (write-prim-assembly-function #"void" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rax))) ;; Ignored closure
          (push (rbx)) ;; Return address
          (movq (imm 0) (reg (rax)))
          (ret)))

      ;; panic
      (write-prim-assembly-function #"panic" output
        (varargs list
          (movq (mem (rsp) 0) (reg (rax)))
          (add (imm 8) (rax))
          (ud2)))

      ;; These are not native functions, but just native subroutines
      ;; They do not follow standard calling conventions

      ;; make-array-from-stack
      (write-block #"prim_make_array_from_stack" output
        (varargs list
          (pop (reg (rbx))) ;; Return address
          (pop (reg (rcx))) ;; num-args
          (movq (reg (rbp)) (reg (rax)))
          (movq (reg (rcx)) (mem (rbp) 0))
          (leaq (scaled (rbp) 8 (rcx) 0) (rbp))
          (leaq (mem (rbp) 8) (rdx))
          (cmp (imm 0) (rcx))
          (je #"prim_make_array_from_stack_loop_end")))
      (write-block #"prim_make_array_from_stack_loop_start" output
        (varargs list
          (pop (mem (rbp) 0))
          (sub (imm 8) (rbp))
          (dec (rcx))
          (jnz #"prim_make_array_from_stack_loop_start")))
      (write-block #"prim_make_array_from_stack_loop_end" output
        (varargs list
          (movq (reg (rdx)) (reg (rbp)))
          (push (rbx))
          (ret)))

      ;; variant-panic
      (write-block #"prim_variant_panic" output
        (varargs list
          (ud2)))

      ;; thread_bootstrap
      (write-block #"prim_thread_bootstrap" output
        (varargs list
          (push (rax))
          (movq (mem (rax) 0) (reg (rax)))
          (call/indirect (reg (rax)))
          (ud2)))))



  (define (write-objects [objects : (List TopLevelObject)] [output : OutputPort]) : Void
    (case objects
      [(empty) (void)]
      [(cons (function-tlo fun) objects)
       (begin
         (write-function fun output)
         (write-objects objects output))]
      [(cons (trivial-closure-tlo name fun-name) objects)
       (begin
         (write-trivial-closure name fun-name output)
         (write-objects objects output))]))

  (define (write-trivial-closure [name : Bytes] [fun-name : Bytes] [output : OutputPort]) : Void
    (begin
      (write-line #".section __TEXT,__const" output)
      (write-all-bytes name output)
      (write-all-bytes #":" output)
      (newline output)
      (write-all-bytes #".quad " output)
      (write-all-bytes fun-name output)
      (newline output)))

  (define (write-function [fun : StackFunction] [output : OutputPort]) : Void
    (case fun
      [(stack-function name blocks)
       (begin
         (write-line #".section __TEXT,__text" output)
         (write-all-bytes name output)
         (write-all-bytes #":" output)
         (newline output)
         (write-basic-blocks name 0 blocks output))]))

  (define (write-basic-blocks [fun-name : Bytes] [index : Byte] [blocks : (List StackBasicBlock)] [output : OutputPort]) : Void
    (case blocks
      [(empty) (void)]
      [(cons block blocks)
       (begin
         (write-basic-block fun-name index block output)
         (write-basic-blocks fun-name (+ index 1) blocks output))]))

  (define (write-basic-block [fun-name : Bytes] [index : Byte] [block : StackBasicBlock] [output : OutputPort]) : Void
    (case block
      [(stack-basic-block cmds terminal)
       (begin
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes index) output)
         (write-all-bytes #":" output)
         (newline output)
         (write-commands cmds output)
         (write-terminal fun-name terminal output))]))

  (define (a) (for-each [f : (a -> Void)] [l : (List a)]) : Void
    (case l
      [(empty) (void)]
      [(cons e l)
       (begin
         (f e)
         (for-each f l))]))

  (define (write-lines [lines : (List (JoinList Bytes))] [output : OutputPort]) : Void
    (for-each
      (lambda ([line : (JoinList Bytes)])
        (begin
          (for-each
            (lambda ([bytes : Bytes]) (write-all-bytes bytes output))
            (jl->list line))
          (newline output)))
      lines))

  (define (write-terminal [fun-name : Bytes] [terminal : StackTerminal] [output : OutputPort]) : Void
    (case terminal
      [(return num-args)
       (begin
         (write-line #"pop %rax" output) ;; Return value
         (write-line #"pop %rbx" output) ;; Return address
         (write-line #"pop %rcx" output) ;; Closure
         (write-pop-function-arguments num-args output)
         (write-line #"push %rbx" output)
         (write-line #"ret" output))]
      [(uncond-jmp index)
       (begin
         (write-all-bytes #"jmp " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes index) output)
         (newline output))]
      [(boolean-jmp true-index false-index)
       (begin
         (write-line #"pop %rax" output)
         (write-line #"cmpq $0, %rax" output)
         (write-all-bytes #"jne " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes true-index) output)
         (newline output)
         (write-all-bytes #"jmp " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes false-index) output)
         (newline output))]
      [(variant-switch cases)
       (begin
         (write-line #"mov (%rsp), %rax" output)
         (write-variant-switch fun-name cases output))]))

  ;; The current value is in %rax.
  (define (write-variant-switch
            [fun-name : Bytes]
            [cases : VariantCases]
            [output : OutputPort]) : Void
    (case cases
      [(no-catch-all-case)
       (write-line #"ud2" output)]
      [(catch-all-case block)
       (begin
         (write-all-bytes #"jmp " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes block) output)
         (newline output))]
      [(variant-case tag block cases)
       (begin
         (write-all-bytes #"cmpq $" output)
         (write-all-bytes (integer->decimal-bytes tag) output)
         (write-all-bytes #", (%rax)" output)
         (newline output)
         (write-all-bytes #"je " output)
         (write-all-bytes fun-name output)
         (write-all-bytes #"_" output)
         (write-all-bytes (integer->decimal-bytes block) output)
         (newline output)
         (write-variant-switch fun-name cases output))]))


  (define (write-pop-function-arguments [num-args : Byte] [output : OutputPort]) : Void
    (if (= 0 num-args)
        (void)
        (begin
          (write-line #"pop %rcx" output)
          (write-pop-function-arguments (- num-args 1) output))))

  (define (write-commands [cmds : (List StackCmd)] [output : OutputPort]) : Void
    (case cmds
      [(empty) (void)]
      [(cons cmd cmds)
       (case cmd
         [(dup-cmd offset)
          (begin
            (write-all-bytes #"push " output)
            (write-all-bytes (integer->decimal-bytes (* offset 8)) output)
            (write-line #"(%rsp)" output)
            (write-commands cmds output))]
         [(dup-free-var-cmd offset index)
          (begin
            (write-all-bytes #"mov " output)
            (write-all-bytes (integer->decimal-bytes (* offset 8)) output)
            (write-line #"(%rsp), %rax" output)
            (write-all-bytes #"push " output)
            (write-all-bytes (integer->decimal-bytes (* (+ 1 index) 8)) output)
            (write-line #"(%rax)" output)
            (write-commands cmds output))]
         [(swap-cmd)
          (begin
            (write-line #"pop %rax" output)
            (write-line #"pop %rbx" output)
            (write-line #"push %rax" output)
            (write-line #"push %rbx" output)
            (write-commands cmds output))]
         [(pop-cmd)
          (begin
            (write-line #"pop %rax" output)
            (write-commands cmds output))]
         [(num-lit-cmd v)
          ;; TODO fix when yaspl supports larger literals
          (let ([max-lit
                 (let ([shift (+ #xFF 1)])
                   (+ (* shift (+ (* shift (+ (* shift #xFF) #xFF)) #xFF)) #xFF))])
            (begin
              (if (> v max-lit)
                  (begin
                    (write-all-bytes #"mov $" output)
                    (write-all-bytes (integer->decimal-bytes v) output)
                    (write-all-bytes #", %rax" output)
                    (newline output)
                    (write-line #"push %rax" output))
                  (begin
                    (write-all-bytes #"pushq $" output)
                    (write-all-bytes (integer->decimal-bytes v) output)
                    (newline output)))
            (write-commands cmds output)))]
         [(boolean-lit-cmd v)
          (begin
            (if v
                (write-line #"push $1" output)
                (write-line #"push $0" output))
            (write-commands cmds output))]
         ;; TODO put the bytes not directly in the instruction stream
         [(bytes-lit-cmd v)
          (begin
            (write-line #".byte 0xe9" output)
            (write-all-bytes #".long " output)
            (write-all-bytes (integer->decimal-bytes (+ 8 (bytes-length v))) output)
            (newline output)
            (write-all-bytes #".8byte " output)
            (write-all-bytes (integer->decimal-bytes (bytes-length v)) output)
            (newline output)
            (let ([quote (let ([buf (make-bytes 1)]) (begin (bytes-set! buf 0 34) buf))])
              (begin
                (write-all-bytes #".ascii " output)
                (write-all-bytes quote output)
                (write-all-bytes v output)
                (write-all-bytes quote output)))
            (newline output)
            ;; Need to account for the 7 bytes of leaq
            (write-all-bytes #"leaq -" output)
            (write-all-bytes (integer->decimal-bytes (+ 15 (bytes-length v))) output)
            (write-line #"(%rip), %rax" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
          [(bytes-cmp-cmd)
           (begin
             (write-line #"push $0" output) ; Bogus closure
             (write-line #"call prim_bytes_equal" output)
             (write-line #"push %rax" output)
             (write-commands cmds output))]

         [(load-global-cmd name)
          (begin
            (write-all-bytes #"leaq " output)
            (write-all-bytes name output)
            (write-line #"(%rip), %rax" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]

         [(create-closure-cmd n)
          (begin
            (write-line #"mov %rbp, %rax" output)
            (copy-objects (+ n 1) output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(fun-call-cmd _)
          (begin
            (write-line #"mov (%rsp), %rax" output)
            (write-line #"mov (%rax), %rax" output)
            (write-line #"callq *%rax" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(known-fun-call-cmd name _)
          (begin
            (write-line #"push $0" output) ; Bogus closure
            (write-all-bytes #"callq " output)
            (write-all-bytes name output)
            (newline output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]

         [(make-array-cmd)
          (begin
            (write-line #"pop %rax" output)
            (write-line #"pop %rcx" output)
            (write-line #"mov %rbp, %rdx" output)
            (write-line #"mov %rcx, (%rbp)" output)
            (write-line #"add $8, %rbp" output)
            (write-line #"mov %rbp, %rdi" output)
            (write-line #"rep stosq" output)
            (write-line #"mov %rdi, %rbp" output)
            (write-line #"push %rdx" output)
            (write-commands cmds output))]
         [(make-array-from-stack-cmd num-args)
          (begin
            (write-all-bytes #"pushq $" output)
            (write-all-bytes (integer->decimal-bytes num-args) output)
            (newline output)
            (write-line #"call prim_make_array_from_stack" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(array-length-cmd)
          (begin
            (write-line #"pop %rax" output)
            (write-line #"push (%rax)" output)
            (write-commands cmds output))]
         [(array-ref-cmd)
          (begin
            (write-line #"pop %rcx" output)
            (write-line #"pop %rax" output)
            (write-line #"push 8(%rax, %rcx, 8)" output)
            (write-commands cmds output))]
         [(array-set!-cmd)
          (begin
            (write-line #"pop %rdx" output)
            (write-line #"pop %rcx" output)
            (write-line #"pop %rax" output)
            (write-line #"mov %rdx, 8(%rax, %rcx, 8)" output)
            (write-line #"push $0" output)
            (write-commands cmds output))]

         [(bin-logic-math-cmd op)
          (begin
            (write-line #"pop %rax" output) ;; Argument 2
            (write-line #"pop %rcx" output) ;; Argument 1
            (write-line #"cmpq %rax, %rcx" output)
            (case op
              [(less-than-op)
               (write-line #"setl %al" output)]
              [(less-than-or-equal-op)
               (write-line #"setle %al" output)]
              [(equal-op)
               (write-line #"sete %al" output)]
              [(greater-than-or-equal-op)
               (write-line #"setge %al" output)]
              [(greater-than-op)
               (write-line #"setg %al" output)])
            (write-line #"movzx %al, %rax" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(bin-math-cmd (bin-add-op))
          (begin
            (write-line #"pop %rax" output) ;; Argument 2
            (write-line #"pop %rcx" output) ;; Argument 1
            (write-line #"addq %rcx, %rax" output)
            (write-line #"pushq %rax" output)
            (write-commands cmds output))]
         [(bin-math-cmd (bin-sub-op))
          (begin
            (write-line #"pop %rcx" output) ;; Argument 2
            (write-line #"pop %rax" output) ;; Argument 1
            (write-line #"subq %rcx, %rax" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(bin-math-cmd (bin-mult-op))
          (begin
            (write-line #"pop %rax" output) ;; Argument 2
            (write-line #"pop %rcx" output) ;; Argument 1
            (write-line #"imulq %rcx" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(bin-math-cmd (bin-quotient-op))
          (begin
            (write-line #"pop %rcx" output) ;; Argument 2
            (write-line #"pop %rax" output) ;; Argument 1
            (write-line #"movq $0, %rdx" output)
            (write-line #"idiv %rcx" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(bin-math-cmd (bin-remainder-op))
          (begin
            (write-line #"pop %rcx" output) ;; Argument 2
            (write-line #"pop %rax" output) ;; Argument 1
            (write-line #"movq $0, %rdx" output)
            (write-line #"idiv %rcx" output)
            (write-line #"movq %rdx, %rax" output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(alloc-variant-cmd tag fields)
          (begin
            (write-line #"mov %rbp, %rax" output)
            (write-all-bytes #"movq $" output)
            (write-all-bytes (integer->decimal-bytes tag) output)
            (write-all-bytes #", (%rbp)" output)
            (newline output)
            (write-line #"add $8, %rbp" output)
            (copy-objects fields output)
            (write-line #"push %rax" output)
            (write-commands cmds output))]
         [(variant-ref-cmd tag field)
          (begin
            (write-line #"pop %rax" output)
            (write-all-bytes #"cmpq $" output)
            (write-all-bytes (integer->decimal-bytes tag) output)
            (write-line #", (%rax)" output)
            (write-line #"jne prim_variant_panic" output)
            (write-all-bytes #"pushq " output)
            (write-all-bytes (integer->decimal-bytes (+ (* 8 field) 8)) output)
            (write-line #"(%rax)" output)
            (write-commands cmds output))])]))

  ;; Generates assembly to copy n objects from the top of the stack to the
  ;; memory starting at %rbp. %rbp ends up pointing right after after the last object written.
  (define (copy-objects [n : Byte] [output : OutputPort]) : Void
    (if (> n 0)
        (begin
          (write-line #"pop (%rbp)" output)
          (write-line #"add $8, %rbp" output)
          (copy-objects (- n 1) output))
        (void)))



  ;; TODO switch to a polymorphic one when it works
  (define (a) (extract-either [either : (Either Bytes a)]) : a
    (case either
      [(right v) v]
      [(left v) (panic v)])))
