#:module (linker-main)
#:import {
  (bytes)
  (data indexed-set)
  (either)
  (io)
  (linker)
  (list)
  (mach-o)
  (mach-o-writer)
  (maybe)
  (prim)
  (set)
  (structured-mach-o)
}
(export)
(types)

(define (read-mach-o-files [object-files : (List Bytes)]) : (Either Bytes (List MachOFile))
  (extract-rights
    (map
      (lambda ([input-path : Bytes])
        (call-with-input-file input-path
          (lambda ([input-file : InputPort])
            (read-mach-o input-file))))
      object-files)))

(define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Int
  (case (array->list args)
    [(empty)
     (begin
       (write-line #"No executable specified???" stderr)
       1)]
    [(cons _ (empty))
     (begin
       (write-line #"No output executable file name supplied." stderr)
       1)]
    [(cons _ (cons output-file-name object-files))
     (case (read-mach-o-files object-files)
       [(left msg)
        (begin
          (write-line msg stderr)
          1)]
       [(right mach-o-files)
        (case (extract-rights (map parse-mach-o mach-o-files))
          [(left msg)
           (begin
             (write-line msg stderr)
             1)]
          [(right parsed-mach-o-files)
           (match-define (text-segment
                           contents
                           text-section-offset
                           text-section-size
                           const-section-offset
                           const-section-size
                           relocations
                           symbols)
             (construct-text-segment
               (map parsed-mach-o-text-section parsed-mach-o-files)
               (map parsed-mach-o-const-section parsed-mach-o-files)))

           (match-define raw-text-segment-length (bytes-length contents))
           (match-define rounded-text-segment-length
             (* #x1000 (+ (quotient (+ raw-text-segment-length #x330) #x1000) 1)))
           (match-define text-segment-start-offset
             (- rounded-text-segment-length raw-text-segment-length))
           ;; This is where the actual content starts.
           (match-define text-segment-start-address
             (+ #x100000000 text-segment-start-offset))

           (match-define symbol-table-entries
             (sort
               (set->list
                 (set-add-all
                   ;; TODO make sure that the right definition is kept
                   (make-set symbol-table-entry-name-cmp)
                   (map
                     (lambda ([sym : DefinedSymbol])
                       (case sym
                         [(defined-symbol name offset)
                          (symbol-table-entry name (u8 #x0f) (u8 #x01) (u8 #x20)
                                              (u64 (+ text-segment-start-address offset)))]))
                     symbols)))
               symbol-table-entry-name<))

           (match-define symbol-table-lookup
             (foldl
               (lambda ([e : SymbolTableEntry] [acc : (IndexedSet SymbolTableEntry Bytes)])
                 (indexed-set-add acc e))
               symbol-table-entries
               (make-indexed-set symbol-table-entry-name bytes-cmp)))
           (case (apply-relocations
                   relocations
                   symbol-table-lookup
                   contents
                   text-segment-start-address)
             [(just msg)
              (begin
                (write-line msg stderr)
                1)]
             [(nothing)
              (case (write-mach-o-executable
                      symbol-table-entries
                      contents
                      text-section-size
                      const-section-size
                      output-file-name)
                [(left v)
                 (begin
                   (write-line v stderr)
                   1)]
                [(right _)
                 0])])])])]))
