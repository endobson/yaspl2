#:module extra-action-linter-main
#:import {
  boolean {
    #:values
      not
  }
  bytes {
    #:values
      ends-with?
  }
  either {
    #:types
      Either
    #:values
      left
    #:patterns
      left
      right
  }
  extra-action-parser {
    #:values
      parse-extra-action-info
      proto-parser
    #:patterns
      extra-action-info
      spawn-info
  }
  io {
    #:values
      call-with-input-file
      call-with-output-file
      read-all-bytes
      write-line
  }
  linter {
    #:types
      LintResults
    #:values
      lint-module
      write-lint-results
  }
  list {
    #:values
      filter
      reverse
    #:patterns
      cons
      empty
  }
  prim {
    #:types
      Array
      Bytes
      InputPort
      Int
      OutputPort
    #:values
      =
      array-length
      array-ref
      bytes-length
  }
}
(export)
(types)

(define (handle-failure-result [msg : Bytes] [stderr : OutputPort]) : Int
  (begin
    (write-line msg stderr)
    1))

(define (handle-result [output : OutputPort] [stderr : OutputPort]
                       [results : (Either Bytes LintResults)]) : Int
  (case results
    [(left v)
     (handle-failure-result v stderr)]
    [(right results)
     (begin
       (write-lint-results results output)
       0)]))

(define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Int
  (if (not (= (array-length args) 3))
      (handle-failure-result #"Too few arguments" stderr)
      (let ([bytes (call-with-input-file (array-ref args 1) read-all-bytes)])
        (let ([output-file-name (array-ref args 2)])
          (call-with-output-file output-file-name
            (lambda ([output-port : OutputPort])
              (handle-result output-port stderr
                (case (parse-extra-action-info (proto-parser bytes 0 (bytes-length bytes)))
                  [(left msg)
                   (left msg)]
                  [(right info)
                   (case info
                     [(extra-action-info owner id mnemonic (spawn-info arguments input-files output-files))
                      (case mnemonic
                        [#"YasplCompile"
                         (case (reverse
                                 (filter
                                   (lambda ([input-path : Bytes])
                                     (ends-with? input-path #".yaspl"))
                                   input-files))
                           [(empty) (left #"No source file.")]
                           [(cons _ (cons _ _)) (left #"More than one source file.")]
                           [(cons src-file-path (empty))
                            (let ([signatures
                                   (filter
                                     (lambda ([input-path : Bytes])
                                       (ends-with? input-path #".sig"))
                                     input-files)])
                              (lint-module src-file-path signatures))])]
                        [x (left x)])])]))))))))
