#:module (lexer)
#:import {
  (byte-escapes)
  (bytes)
  (data range-map)
  (data source-location)
  (either)
  (list)
  (maybe)
  (numbers)
  (prim)
}
(export
  (#:types Lexer Result Lexeme)
  (#:values make-lexer run-lexer lexer-remaining-input)
  (#:patterns end-of-input bad-input lex-result
              symbol-lexeme decimal-number-lexeme hexadecimal-number-lexeme
              left-paren-lexeme right-paren-lexeme
              left-brace-lexeme right-brace-lexeme
              left-bracket-lexeme right-bracket-lexeme comment-lexeme
              bytes-lexeme boolean-lexeme
              keyword-lexeme))
(types
  (define-type Lexer
    (lexer [ctx : LexerContext] [pos : Int]))
  (define-type LexerContext
    (lexer-context
      [bytes : Bytes]
      [source : Source]
      [line-start-map : (IntRangeMap LineStart)]))
  (define-type LineStart
    (line-start [line-number : Int] [start-pos : Int]))

  (define-type Lexeme
    (left-paren-lexeme)
    (right-paren-lexeme)
    (left-bracket-lexeme)
    (right-bracket-lexeme)
    (left-brace-lexeme)
    (right-brace-lexeme)
    (comment-lexeme)
    (symbol-lexeme [v : Bytes])
    (boolean-lexeme [v : Boolean])
    (bytes-lexeme [v : Bytes])
    (keyword-lexeme [v : Bytes])
    (decimal-number-lexeme [v : Bytes])
    (hexadecimal-number-lexeme [v : Bytes]))

  (define-type Result
    (lex-result [v : (SourceSpanAnnotated Lexeme)] [next : Lexer])
    (end-of-input [v : SourceSpan])
    (bad-input [v : Bytes] [source : SourceSpan])))

(define (decimal-start-byte? [v : U8]) : Boolean
  (digit? v))
(define (decimal-continue-byte? [v : U8]) : Boolean
  (digit? v))

(define (hexadecimal-byte? [v : U8]) : Boolean
  (or (digit? v)
      (let ([v (u8->s64 v)])
        (or (and (<= 65 v) (<= v 70))
            (and (<= 97 v) (<= v 102))))))

(define (math-symbol? [v : U8]) : Boolean
  (let ([v (u8->s64 v)])
    (or (= v 42)
        (or (= v 43)
            (or (= v 45)
                (= v 47))))))

(define (letter? [v : U8]) : Boolean
  (let ([v (u8->s64 v)])
    (or (and (<= 97 v) (< v 123))
        (and (<= 65 v) (< v 91)))))

(define (lexer-remaining-input [lexer : Lexer]) : Bytes
  (match-define (lexer (lexer-context b _ _) pos) lexer)
  (subbytes b pos (bytes-length b)))

(define (lexer-context-get-span [ctx : LexerContext] [start : Int] [end : Int])
  : SourceSpan
  (match-define (lexer-context _ source line-map) ctx)
  (case (int-range-map-lookup line-map start)
    [(nothing) (panic #"No line number for start")]
    [(just (line-start start-line start-line-start))
     (case (int-range-map-lookup line-map end)
       [(nothing) (panic #"No line number for end")]
       [(just (line-start end-line end-line-start))
        (source-span source start-line (+ (- start start-line-start) 1)
                     end-line (+ (- end end-line-start) 1))])]))

(define (symbol-lexeme* [ctx : LexerContext] [start : Int] [end : Int])
  : (SourceSpanAnnotated Lexeme)
  (source-span-annotated
    (symbol-lexeme (subbytes (lexer-context-bytes ctx) start end))
    (lexer-context-get-span ctx start end)))

;; Need to adjust for ; at the begining
(define (comment-lexeme* [ctx : LexerContext] [start : Int] [end : Int])
  : (SourceSpanAnnotated Lexeme)
  (source-span-annotated
    (comment-lexeme)
    (lexer-context-get-span ctx start end)))

;; Boolean lexemes are always two characters
(define (boolean-lexeme* [ctx : LexerContext] [v : Boolean] [end : Int])
  : (SourceSpanAnnotated Lexeme)
  (source-span-annotated
    (boolean-lexeme v)
    (lexer-context-get-span ctx (- end 2) end)))

;; Need to adjust for #: at begining
(define (keyword-lexeme* [ctx : LexerContext] [start : Int] [end : Int])
  : (SourceSpanAnnotated Lexeme)
  (source-span-annotated
    (keyword-lexeme (subbytes (lexer-context-bytes ctx) start end))
    (lexer-context-get-span ctx (- start 2) end)))

;; Need to adjust for #" at begining.
(define (bytes-lexeme* [ctx : LexerContext] [v : Bytes] [start : Int] [end : Int])
  : (SourceSpanAnnotated Lexeme)
  (source-span-annotated
    (bytes-lexeme v)
    (lexer-context-get-span ctx (- start 2) end)))

(define (decimal-number-lexeme* [ctx : LexerContext] [start : Int] [end : Int])
  : (SourceSpanAnnotated Lexeme)
  (source-span-annotated
    (decimal-number-lexeme (subbytes (lexer-context-bytes ctx) start end))
    (lexer-context-get-span ctx start end)))

;; Need to adjust for #x at the begining
(define (hexadecimal-number-lexeme* [ctx : LexerContext] [start : Int] [end : Int])
  : (SourceSpanAnnotated Lexeme)
  (source-span-annotated
    (hexadecimal-number-lexeme (subbytes (lexer-context-bytes ctx) start end))
    (lexer-context-get-span ctx (- start 2) end)))

(define (left-paren-lexeme* [ctx : LexerContext] [start : Int] [end : Int])
  : (SourceSpanAnnotated Lexeme)
  (source-span-annotated
    (left-paren-lexeme)
    (lexer-context-get-span ctx start end)))

(define (right-paren-lexeme* [ctx : LexerContext] [start : Int] [end : Int])
  : (SourceSpanAnnotated Lexeme)
  (source-span-annotated
    (right-paren-lexeme)
    (lexer-context-get-span ctx start end)))

(define (left-bracket-lexeme* [ctx : LexerContext] [start : Int] [end : Int])
  : (SourceSpanAnnotated Lexeme)
  (source-span-annotated
    (left-bracket-lexeme)
    (lexer-context-get-span ctx start end)))

(define (right-bracket-lexeme* [ctx : LexerContext] [start : Int] [end : Int])
  : (SourceSpanAnnotated Lexeme)
  (source-span-annotated
    (right-bracket-lexeme)
    (lexer-context-get-span ctx start end)))

(define (left-brace-lexeme* [ctx : LexerContext] [start : Int] [end : Int])
  : (SourceSpanAnnotated Lexeme)
  (source-span-annotated
    (left-brace-lexeme)
    (lexer-context-get-span ctx start end)))

(define (right-brace-lexeme* [ctx : LexerContext] [start : Int] [end : Int])
  : (SourceSpanAnnotated Lexeme)
  (source-span-annotated
    (right-brace-lexeme)
    (lexer-context-get-span ctx start end)))

;; Symbol ok values
;; (set-ok! 33)
;; (set-ok! 36 38)
;; (set-ok! 42 43)
;; (set-ok! 45 47)
;; ;(set-ok! 48 57) ;; Only for continue bytes
;; (set-ok! 58)
;; (set-ok! 60 90)
;; (set-ok! 94 95)
;; (set-ok! 97 122)
;; (set-ok! 126)

;; Make this saner
(define (symbol-start-byte? [v : U8]) : Boolean
  (let ([valid #"                                 X  XXX   XX XXX          X XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   XX XXXXXXXXXXXXXXXXXXXXXXXXXX   X "])
    (let ([index (u8->s64 v)])
      (and (<= index 127)
           (= (u8->s64 (bytes-ref valid index)) 88)))))

;; Make this saner
(define (symbol-continue-byte? [v : U8]) : Boolean
  (let ([valid #"                                 X  XXX   XX XXXXXXXXXXXXXX XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   XX XXXXXXXXXXXXXXXXXXXXXXXXXX   X "])
    (let ([index (u8->s64 v)])
      (and (<= index 127)
           (= (u8->s64 (bytes-ref valid index)) 88)))))

(define (keyword-continue-byte? [v : U8]) : Boolean
  (or (math-symbol? v)
      (letter? v)))

(define (bytes-continue-byte? [v : U8]) : Boolean
  (let ([int (u8->s64 v)])
    (and (and (<= 32 int) (< int 127))
         (not (double-quote? v)))))

(define (newline? [v : U8]) : Boolean
  (= (u8->s64 v) 10))

(define (space? [v : U8]) : Boolean
  (= (u8->s64 v) 32))

(define (double-quote? [v : U8]) : Boolean
  (= (u8->s64 v) 34))

(define (hash? [v : U8]) : Boolean
  (= (u8->s64 v) 35))

(define (colon? [v : U8]) : Boolean
  (= (u8->s64 v) 58))

(define (semi-colon? [v : U8]) : Boolean
  (= (u8->s64 v) 59))

(define (back-slash? [v : U8]) : Boolean
  (= (u8->s64 v) 92))

(define (lex-symbol [ctx : LexerContext] [start : Int] [cur : Int]) : Result
  (match-define bytes (lexer-context-bytes ctx))
  (if (= (bytes-length bytes) cur)
      (lex-result (symbol-lexeme* ctx start cur)
                  (lexer ctx cur))
      (if (symbol-continue-byte? (bytes-ref bytes cur))
          (lex-symbol ctx start (+ 1 cur))
          (lex-result (symbol-lexeme* ctx start cur)
                      (lexer ctx cur)))))

(define (lex-after-hash [ctx : LexerContext] [pos : Int]) : Result
  (match-define bytes (lexer-context-bytes ctx))
  (if (= (bytes-length bytes) pos)
      (bad-input #"Input ended with hash" (lexer-context-get-span ctx (- pos 1) pos))
      (let ([byte (bytes-ref bytes pos)])
        (let ([next-pos (+ 1 pos)])
          (if (colon? byte)
              (lex-keyword ctx next-pos next-pos)
              (if (double-quote? byte)
                  (lex-bytes ctx next-pos next-pos)
                  (if (= (u8->s64 byte) 116)
                      (lex-result (boolean-lexeme* ctx #t next-pos) (lexer ctx next-pos))
                      (if (= (u8->s64 byte) 102)
                          (lex-result (boolean-lexeme* ctx #f next-pos) (lexer ctx next-pos))
                          (if (= (u8->s64 byte) 120)
                              (lex-hexadecimal ctx next-pos next-pos)
                              (bad-input #"Unsupported character after hash"
                                         (lexer-context-get-span ctx (- pos 1) next-pos)))))))))))

(define (lex-keyword [ctx : LexerContext] [start : Int] [cur : Int]) : Result
  (match-define bytes (lexer-context-bytes ctx))
  (if (= (bytes-length bytes) cur)
      (lex-result (keyword-lexeme* ctx start cur)
                  (lexer ctx cur))
      (if (keyword-continue-byte? (bytes-ref bytes cur))
          (lex-keyword ctx start (+ 1 cur))
          (lex-result (keyword-lexeme* ctx start cur)
                      (lexer ctx cur)))))

(define (lex-bytes [ctx : LexerContext] [start : Int] [cur : Int]) : Result
  (match-define bytes (lexer-context-bytes ctx))
  (if (= (bytes-length bytes) cur)
      (bad-input #"Input ended in the middle of bytes literal"
                 (lexer-context-get-span ctx (- start 2) cur))
      (let ([byte (bytes-ref bytes cur)])
        (if (back-slash? byte)
            (let ([cur (+ 1 cur)])
              (let ([byte (bytes-ref bytes cur)])
                (if (= (bytes-length bytes) cur)
                    (bad-input #"Input ended with backslash"
                               (lexer-context-get-span ctx (- start 2) cur))
                    (if (or (or (double-quote? byte)
                                (back-slash? byte))
                            (or (= (u8->s64 byte) 110) ;; n
                                (or (= (u8->s64 byte) 114) ;; r
                                    (= (u8->s64 byte) 120)))) ;; x
                        (lex-bytes ctx start (+ 1 cur))
                        (bad-input #"Unknown character after backslash"
                                    (lexer-context-get-span ctx (- cur 1) (+ cur 1)))))))
            (if (bytes-continue-byte? byte)
                (lex-bytes ctx start (+ 1 cur))
                (if (double-quote? byte)
                    (case (unescape-bytes (subbytes bytes start cur))
                      [(left _) (bad-input #"Bytes literal couldn't be unescaped"
                                           (lexer-context-get-span ctx (- start 2) (+ cur 1)))]
                      [(right v)
                       (lex-result (bytes-lexeme* ctx v start (+ 1 cur)) (lexer ctx (+ 1 cur)))])
                    (bad-input (bytes-append (varargs list #"Unsupported character in bytes literal: #x"
                                                           (integer->hex-bytes (u8->s64 byte))))
                               (lexer-context-get-span ctx cur (+ cur 1)))))))))

(define (lex-decimal [ctx : LexerContext] [start : Int] [cur : Int]) : Result
  (match-define bytes (lexer-context-bytes ctx))
  (if (= (bytes-length bytes) cur)
      (lex-result (decimal-number-lexeme* ctx start cur)
                  (lexer ctx cur))
      (if (decimal-continue-byte? (bytes-ref bytes cur))
          (lex-decimal ctx start (+ 1 cur))
          (lex-result (decimal-number-lexeme* ctx start cur)
                      (lexer ctx cur)))))

(define (lex-hexadecimal [ctx : LexerContext] [start : Int] [cur : Int]) : Result
  (match-define bytes (lexer-context-bytes ctx))
  (if (= (bytes-length bytes) cur)
      (lex-result (hexadecimal-number-lexeme* ctx start cur)
                  (lexer ctx cur))
      (if (hexadecimal-byte? (bytes-ref bytes cur))
          (lex-hexadecimal ctx start (+ 1 cur))
          (lex-result (hexadecimal-number-lexeme* ctx start cur)
                      (lexer ctx cur)))))

(define (lex-line-comment [ctx : LexerContext] [start : Int] [pos : Int]) : Result
  (match-define bytes (lexer-context-bytes ctx))
  (if (= (bytes-length bytes) pos)
      (lex-result (comment-lexeme* ctx start pos) (lexer ctx pos))
      (if (newline? (bytes-ref bytes pos))
          (lex-result (comment-lexeme* ctx start pos) (lexer ctx pos))
          (lex-line-comment ctx start (+ 1 pos)))))

(define (make-lexer [sbytes : SourcedBytes]) : Lexer
  (match-define (sourced-bytes source contents) sbytes)
  (lexer (lexer-context contents source (make-line-start-map contents)) 0))

(define (run-lexer [lexer : Lexer]) : Result
  (run (lexer-ctx lexer) (lexer-pos lexer)))

(define (run [ctx : LexerContext] [pos : Int]) : Result
  (match-define bytes (lexer-context-bytes ctx))
  (if (= pos (bytes-length bytes))
      (end-of-input (lexer-context-get-span ctx pos pos))
      (let ([byte/u8 (bytes-ref bytes pos)])
        (let ([next-pos (+ pos 1)])
          (let ([byte (u8->s64 byte/u8)])
            (if (= byte 40)
                (lex-result (left-paren-lexeme* ctx pos next-pos) (lexer ctx next-pos))
                (if (= byte 41)
                    (lex-result (right-paren-lexeme* ctx pos next-pos) (lexer ctx next-pos))
                    (if (= byte 91)
                        (lex-result (left-bracket-lexeme* ctx pos next-pos) (lexer ctx next-pos))
                        (if (= byte 93)
                            (lex-result (right-bracket-lexeme* ctx pos next-pos) (lexer ctx next-pos))
                            (if (= byte 123)
                                (lex-result (left-brace-lexeme* ctx pos next-pos) (lexer ctx next-pos))
                                (if (= byte 125)
                                    (lex-result (right-brace-lexeme* ctx pos next-pos) (lexer ctx next-pos))
                                    (if (or (newline? byte/u8) (space? byte/u8))
                                        (run ctx next-pos)
                                        (if (symbol-start-byte? byte/u8)
                                            (lex-symbol ctx pos next-pos)
                                            (if (decimal-start-byte? byte/u8)
                                                (lex-decimal ctx pos next-pos)
                                                (if (hash? byte/u8)
                                                    (lex-after-hash ctx next-pos)
                                                    (if (semi-colon? byte/u8)
                                                        (lex-line-comment ctx pos next-pos)
                                                        (if (double-quote? byte/u8)
                                                            (bad-input #"String literals not supported"
                                                                       (lexer-context-get-span
                                                                         ctx pos next-pos))
                                                            (bad-input
                                                              (bytes-append
                                                                (varargs list
                                                                  #"Unsupported character at start "
                                                                  #"of lexeme: #x"
                                                                  (integer->hex-bytes byte)))
                                                               (lexer-context-get-span
                                                                 ctx pos next-pos)))))))))))))))))))

(define (make-line-start-map [bytes : Bytes]) : (IntRangeMap LineStart)
  (make-line-start-map* bytes 1 0 0 (make-int-range-map)))

(define (make-line-start-map*
          [bytes : Bytes] [line : Int] [start-of-line : Int] [pos : Int] [acc : (IntRangeMap LineStart)])
  : (IntRangeMap LineStart)
  (if (= pos (bytes-length bytes))
      (int-range-map-set acc (clopen-int-range start-of-line (+ pos 1)) (line-start line start-of-line))
      (let ([byte (bytes-ref bytes pos)])
        (let ([next-pos (+ 1 pos)])
          (if (newline? byte)
              (make-line-start-map*
                bytes (+ 1 line) next-pos next-pos
                (int-range-map-set acc (clopen-int-range start-of-line next-pos)
                                   (line-start line start-of-line)))
              (make-line-start-map* bytes line start-of-line next-pos acc))))))
