(module lexer
  (import
    (prim
      #:types (Bytes Byte Boolean InputPort OutputPort Array Int)
      #:values (+ = make-bytes bytes-length bytes-ref bytes-set! or and <= < panic u8)
      #:patterns ())
    (numbers digit?)
    (bytes subbytes)
    (io read-all-bytes))
  (export
    #:types (Lexer Result Lexeme)
    #:values (main make-lexer run-lexer lex-result-v lex-result-next)
    #:patterns (end-of-input bad-input lex-result
                  symbol-lexeme decimal-number-lexeme hexadecimal-number-lexeme
                  left-paren-lexeme right-paren-lexeme
                  left-bracket-lexeme right-bracket-lexeme comment-lexeme
                  bytes-lexeme boolean-lexeme
                  keyword-lexeme))
  (types
    (define-type Lexer
      (lexer [input Bytes] [pos Int]))

    (define-type Lexeme
      (left-paren-lexeme)
      (right-paren-lexeme)
      (left-bracket-lexeme)
      (right-bracket-lexeme)
      (comment-lexeme)
      (symbol-lexeme [v Bytes])
      (boolean-lexeme [v Boolean])
      (bytes-lexeme [v Bytes])
      (keyword-lexeme [v Bytes])
      (decimal-number-lexeme [v Bytes])
      (hexadecimal-number-lexeme [v Bytes]))

    (define-type Result
      (lex-result [v Lexeme] [next Lexer])
      (end-of-input)
      (bad-input)))

  (define (decimal-start-byte? [v : Byte]) : Boolean
    (digit? v))
  (define (decimal-continue-byte? [v : Byte]) : Boolean
    (digit? v))

  (define (hexadecimal-byte? [v : Byte]) : Boolean
    (or (digit? v)
        (or (and (<= 65 v) (<= v 70))
            (and (<= 97 v) (<= v 102)))))

  (define (math-symbol? [v : Byte]) : Boolean
    (or (= v 42)
        (or (= v 43)
            (or (= v 45)
                (= v 47)))))

  (define (letter? [v : Byte]) : Boolean
    (or (and (<= 97 v) (< v 123))
        (and (<= 65 v) (< v 91))))


  ;; Symbol ok values
  ;; (set-ok! 33)
  ;; (set-ok! 36 38)
  ;; (set-ok! 42 43)
  ;; (set-ok! 45)
  ;; (set-ok! 47)
  ;; ;(set-ok! 48 57) ;; Only for continue bytes
  ;; (set-ok! 58)
  ;; (set-ok! 60 90)
  ;; (set-ok! 94 95)
  ;; (set-ok! 97 122)
  ;; (set-ok! 126)

  ;; Make this saner
  (define (symbol-start-byte? [v : Byte]) : Boolean
    (let ([valid #"                                 X  XXX   XX X X          X XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   XX XXXXXXXXXXXXXXXXXXXXXXXXXX   X "])
      (= (bytes-ref valid v) 88)))

  ;; Make this saner
  (define (symbol-continue-byte? [v : Byte]) : Boolean
    (let ([valid #"                                 X  XXX   XX X XXXXXXXXXXXX XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX   XX XXXXXXXXXXXXXXXXXXXXXXXXXX   X "])
      (= (bytes-ref valid v) 88)))


  (define (keyword-continue-byte? [v : Byte]) : Boolean
    (or (math-symbol? v)
        (letter? v)))

  (define (bytes-continue-byte? [v : Byte]) : Boolean
    (and (and (<= 32 v) (< v 127))
         (not (double-quote? v))))

  ;; TODO put this in shared code
  (define (not [b : Boolean]) : Boolean
    (if b #f #t))

  (define (newline? [v : Byte]) : Boolean
    (= v 10))

  (define (space? [v : Byte]) : Boolean
    (= v 32))

  (define (bang? [v : Byte]) : Boolean
    (= v 33))

  (define (double-quote? [v : Byte]) : Boolean
    (= v 34))

  (define (hash? [v : Byte]) : Boolean
    (= v 35))

  (define (hyphen? [v : Byte]) : Boolean
    (= v 45))

  (define (colon? [v : Byte]) : Boolean
    (= v 58))

  (define (semi-colon? [v : Byte]) : Boolean
    (= v 59))

  (define (greater-than? [v : Byte]) : Boolean
    (= v 60))

  (define (equals-sign? [v : Byte]) : Boolean
    (= v 61))

  (define (less-than? [v : Byte]) : Boolean
    (= v 62))

  (define (question-mark? [v : Byte]) : Boolean
    (= v 63))

  (define (back-slash? [v : Byte]) : Boolean
    (= v 92))





  (define (lex-symbol [bytes : Bytes] [start : Int] [cur : Int]) : Result
    (if (= (bytes-length bytes) cur)
        (lex-result (symbol-lexeme (subbytes bytes start cur))
                    (lexer bytes cur))
        (if (symbol-continue-byte? (bytes-ref bytes cur))
            (lex-symbol bytes start (+ 1 cur))
            (lex-result (symbol-lexeme (subbytes bytes start cur))
                        (lexer bytes cur)))))


  (define (lex-after-hash [bytes : Bytes] [pos : Int]) : Result
    (if (= (bytes-length bytes) pos)
        (bad-input)
        (let ([byte (bytes-ref bytes pos)])
          (let ([next-pos (+ 1 pos)])
            (if (colon? byte)
                (lex-keyword bytes next-pos next-pos)
                (if (double-quote? byte)
                    (lex-bytes bytes next-pos next-pos 0)
                    (if (= byte 116)
                        (lex-result (boolean-lexeme #t) (lexer bytes next-pos))
                        (if (= byte 102)
                            (lex-result (boolean-lexeme #f) (lexer bytes next-pos))
                            (if (= byte 120)
                                (lex-hexadecimal bytes next-pos next-pos)
                                (bad-input))))))))))


  (define (lex-keyword [bytes : Bytes] [start : Int] [cur : Int]) : Result
    (if (= (bytes-length bytes) cur)
        (lex-result (symbol-lexeme (subbytes bytes start cur))
                    (lexer bytes cur))
        (if (keyword-continue-byte? (bytes-ref bytes cur))
            (lex-keyword bytes start (+ 1 cur))
            (lex-result (keyword-lexeme (subbytes bytes start cur))
                        (lexer bytes cur)))))

  (define (lex-bytes [bytes : Bytes] [start : Int] [cur : Int] [len : Int]) : Result
    (if (= (bytes-length bytes) cur)
        (bad-input)
        (let ([byte (bytes-ref bytes cur)])
          (if (back-slash? byte)
              (let ([cur (+ 1 cur)])
                (let ([byte (bytes-ref bytes cur)])
                  (if (= (bytes-length bytes) cur)
                      (bad-input)
                      (if (or (or (double-quote? byte)
                                  (back-slash? byte))
                              (or (= byte 110) ;; n
                                  (= byte 114))) ;; r
                          (lex-bytes bytes start (+ 1 cur) (+ 1 len))
                          (bad-input)))))
              (if (bytes-continue-byte? (bytes-ref bytes cur))
                  (lex-bytes bytes start (+ 1 cur) (+ 1 len))
                  (if (double-quote? (bytes-ref bytes cur))
                      (lex-result
                        (bytes-lexeme (extract-lexed-bytes bytes start cur (make-bytes len) 0))
                        (lexer bytes (+ 1 cur)))
                      (bad-input)))))))

  (define (extract-lexed-bytes
            [src : Bytes] [src-offset : Int] [src-end : Int] [dest : Bytes] [dest-offset : Int])
    : Bytes
    (if (= src-offset src-end)
        dest
        (let ([byte (bytes-ref src src-offset)])
          (if (back-slash? byte)
              (let ([src-offset (+ 1 src-offset)])
                (let ([byte (bytes-ref src src-offset)])
                  (if (double-quote? byte)
                      (begin
                        (bytes-set! dest dest-offset (u8 byte))
                        (extract-lexed-bytes src (+ 1 src-offset) src-end dest (+ 1 dest-offset)))
                      (if (= byte 110) ;; n
                          (begin
                            (bytes-set! dest dest-offset (u8 10)) ;; newline
                            (extract-lexed-bytes src (+ 1 src-offset) src-end dest (+ 1 dest-offset)))
                          (if (back-slash? byte)
                              (begin
                                (bytes-set! dest dest-offset (u8 92)) ;; backslash
                                (extract-lexed-bytes src (+ 1 src-offset) src-end dest (+ 1 dest-offset)))
                              (if (= byte 114) ;; n
                                  (begin
                                    (bytes-set! dest dest-offset (u8 13)) ;; carriage return
                                    (extract-lexed-bytes src (+ 1 src-offset) src-end dest (+ 1 dest-offset)))
                                  (panic #"Unknown escape")))))))
              (begin
                (bytes-set! dest dest-offset (u8 byte))
                (extract-lexed-bytes src (+ 1 src-offset) src-end dest (+ 1 dest-offset)))))))

  (define (lex-decimal [bytes : Bytes] [start : Int] [cur : Int]) : Result
    (if (= (bytes-length bytes) cur)
        (lex-result (decimal-number-lexeme (subbytes bytes start cur))
                    (lexer bytes cur))
        (if (decimal-continue-byte? (bytes-ref bytes cur))
            (lex-decimal bytes start (+ 1 cur))
            (lex-result (decimal-number-lexeme (subbytes bytes start cur))
                        (lexer bytes cur)))))

  (define (lex-hexadecimal [bytes : Bytes] [start : Int] [cur : Int]) : Result
    (if (= (bytes-length bytes) cur)
        (lex-result (hexadecimal-number-lexeme (subbytes bytes start cur))
                    (lexer bytes cur))
        (if (hexadecimal-byte? (bytes-ref bytes cur))
            (lex-hexadecimal bytes start (+ 1 cur))
            (lex-result (hexadecimal-number-lexeme (subbytes bytes start cur))
                        (lexer bytes cur)))))


  (define (lex-line-comment [bytes : Bytes] [pos : Int]) : Result
    (if (= (bytes-length bytes) pos)
        (lex-result (comment-lexeme) (lexer bytes pos))
        (if (newline? (bytes-ref bytes pos))
            (lex-result (comment-lexeme) (lexer bytes pos))
            (lex-line-comment bytes (+ 1 pos)))))



  (define (make-lexer [bytes : Bytes]) : Lexer
    (lexer bytes 0))

  (define (run-lexer [lexer : Lexer]) : Result
    (run (lexer-input lexer) (lexer-pos lexer)))


  (define (run [bytes : Bytes] [pos : Int]) : Result
    (if (= pos (bytes-length bytes))
        (end-of-input)
        (let ([byte (bytes-ref bytes pos)])
          (if (= byte 40)
              (lex-result (left-paren-lexeme) (lexer bytes (+ pos 1)))
              (if (= byte 41)
                  (lex-result (right-paren-lexeme) (lexer bytes (+ pos 1)))
                  (if (= byte 91)
                      (lex-result (left-bracket-lexeme) (lexer bytes (+ pos 1)))
                      (if (= byte 93)
                          (lex-result (right-bracket-lexeme) (lexer bytes (+ pos 1)))
                          (if (or (newline? byte) (space? byte))
                              (run bytes (+ 1 pos))
                              (if (symbol-start-byte? byte)
                                  (lex-symbol bytes pos (+ pos 1))
                                  (if (decimal-start-byte? byte)
                                      (lex-decimal bytes pos (+ pos 1))
                                      (if (hash? byte)
                                          (lex-after-hash bytes (+ pos 1))
                                          (if (semi-colon? byte)
                                              (lex-line-comment bytes (+ pos 1))
                                              (bad-input)))))))))))))

  (define (loop [lexer : Lexer]) : Int
    (case (run-lexer lexer)
      [(lex-result v lexer) (loop lexer)]
      [(end-of-input) 0]
      [(bad-input) 1]))

  (define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Int
    (loop (make-lexer (read-all-bytes stdin)))))
