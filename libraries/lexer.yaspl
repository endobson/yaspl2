(module lexer
  (import
    (prim
      #:types (Bytes Byte Boolean InputPort OutputPort)
      #:values (+ = make-bytes read-bytes bytes-length bytes-ref or and <= <)
      #:patterns ())
    (numbers digit?)
    (bytes subbytes)
    (io read-all-bytes))
  (export main Lexer make-lexer run-lexer lex-result-v lex-result-next)
  (types
    (define-type Lexer
      (lexer [input Bytes] [pos Byte]))

    (define-type Lexeme
      (left-paren-lexeme)
      (right-paren-lexeme)
      (left-bracket-lexeme)
      (right-bracket-lexeme)
      (symbol-lexeme [v Bytes])
      (bytes-lexeme [v Bytes])
      (keyword-lexeme [v Bytes])
      (number-lexeme [v Bytes]))

    (define-type Result
      (lex-result [v Lexeme] [next Lexer])
      (end-of-input)
      (bad-input)))

  ;; Space or Newline
  (define (whitespace? [v : Byte]) : Boolean
    (or (= v 32) (= v 10)))


  (define (number-start-byte? [v : Byte]) : Boolean
    (digit? v))
  (define (number-continue-byte? [v : Byte]) : Boolean
    (digit? v))

  (define (math-symbol? [v : Byte]) : Boolean
    (or (= v 42)
        (or (= v 43)
            (or (= v 45)
                (= v 47)))))

  (define (letter? [v : Byte]) : Boolean
    (or (and (<= 97 v) (< v 123))
        (and (<= 65 v) (< v 91))))

  (define (symbol-start-byte? [v : Byte]) : Boolean
    (or (math-symbol? v)
        (letter? v)))

  (define (symbol-continue-byte? [v : Byte]) : Boolean
    (or (math-symbol? v)
        (letter? v)))

  (define (keyword-continue-byte? [v : Byte]) : Boolean
    (or (math-symbol? v)
        (letter? v)))

  (define (bytes-continue-byte? [v : Byte]) : Boolean
    (or (letter? v) (space? v)))


  (define (hash? [v : Byte]) : Boolean
    (= v 35))

  (define (colon? [v : Byte]) : Boolean
    (= v 58))

  (define (double-quote? [v : Byte]) : Boolean
    (= v 34))

  (define (space? [v : Byte]) : Boolean
    (= v 32))

  (define (lex-symbol [bytes : Bytes] [start : Byte] [cur : Byte]) : Result
    (if (= (bytes-length bytes) cur)
        (lex-result (symbol-lexeme (subbytes bytes start cur))
                    (lexer bytes cur))
        (if (symbol-continue-byte? (bytes-ref bytes cur))
            (lex-symbol bytes start (+ 1 cur))
            (lex-result (symbol-lexeme (subbytes bytes start cur))
                        (lexer bytes cur)))))


  (define (lex-after-hash [bytes : Bytes] [pos : Byte]) : Result
    (if (= (bytes-length bytes) pos)
        (bad-input)
        (let ([byte (bytes-ref bytes pos)])
          (let ([next-pos (+ 1 pos)])
            (if (colon? byte)
                (lex-keyword bytes next-pos next-pos)
                (if (double-quote? byte)
                    (lex-bytes bytes next-pos next-pos)
                    (bad-input)))))))

  (define (lex-keyword [bytes : Bytes] [start : Byte] [cur : Byte]) : Result
    (if (= (bytes-length bytes) cur)
        (lex-result (symbol-lexeme (subbytes bytes start cur))
                    (lexer bytes cur))
        (if (keyword-continue-byte? (bytes-ref bytes cur))
            (lex-keyword bytes start (+ 1 cur))
            (lex-result (keyword-lexeme (subbytes bytes start cur))
                        (lexer bytes cur)))))

  (define (lex-bytes [bytes : Bytes] [start : Byte] [cur : Byte]) : Result
    (if (= (bytes-length bytes) cur)
        (bad-input)
        (if (bytes-continue-byte? (bytes-ref bytes cur))
            (lex-bytes bytes start (+ 1 cur))
            (if (double-quote? (bytes-ref bytes cur))
                (lex-result (bytes-lexeme (subbytes bytes start cur))
                            (lexer bytes (+ 1 cur)))
                (bad-input)))))

  (define (lex-number [bytes : Bytes] [start : Byte] [cur : Byte]) : Result
    (if (= (bytes-length bytes) cur)
        (lex-result (number-lexeme (subbytes bytes start cur))
                    (lexer bytes cur))
        (if (number-continue-byte? (bytes-ref bytes cur))
            (lex-number bytes start (+ 1 cur))
            (lex-result (number-lexeme (subbytes bytes start cur))
                        (lexer bytes cur)))))



  (define (make-lexer [bytes : Bytes]) : Lexer
    (lexer bytes 0))

  (define (run-lexer [lexer : Lexer]) : Result
    (run (lexer-input lexer) (lexer-pos lexer)))


  (define (run [bytes : Bytes] [pos : Byte]) : Result
    (if (= pos (bytes-length bytes))
        (end-of-input)
        (let ([byte (bytes-ref bytes pos)])
          (if (= byte 40)
              (lex-result (left-paren-lexeme) (lexer bytes (+ pos 1)))
              (if (= byte 41)
                  (lex-result (right-paren-lexeme) (lexer bytes (+ pos 1)))
                  (if (= byte 91)
                      (lex-result (left-bracket-lexeme) (lexer bytes (+ pos 1)))
                      (if (= byte 93)
                          (lex-result (right-bracket-lexeme) (lexer bytes (+ pos 1)))
                          (if (whitespace? byte)
                              (run bytes (+ 1 pos))
                              (if (symbol-start-byte? byte)
                                  (lex-symbol bytes pos (+ pos 1))
                                  (if (number-start-byte? byte)
                                      (lex-number bytes pos (+ pos 1))
                                      (if (hash? byte)
                                          (lex-after-hash bytes (+ pos 1))
                                          (bad-input))))))))))))

  (define (loop [lexer : Lexer]) : Byte
    (case (run-lexer lexer)
      [(lex-result v lexer) (loop lexer)]
      [(end-of-input) 0]
      [(bad-input) 1]))

  (define (main [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Byte
    (loop (make-lexer (read-all-bytes stdin)))))
