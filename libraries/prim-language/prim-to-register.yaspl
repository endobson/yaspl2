#:module prim-to-register
#:import {
  boolean {
    #:values
      not
  }
  bytes {
    #:values
      bytes=?
  }
  dict {
    #:types
      Dict
    #:values
      dict-add
      dict-add-all
      dict-keys
      dict-ref
      dict-replace
      dict-replace-all
      make-dict
      merge-dicts
  }
  list {
    #:types
      List
    #:values
      cons
      empty
      filter
      foldl
      map
      reverse
    #:patterns
      cons
      empty
  }
  maybe {
    #:patterns
      just
      nothing
  }
  prim {
    #:types
      Boolean
      Bytes
      Int
    #:values
      +
      =
      panic
  }
  prim-language {
    #:types
      Expr
      [FunctionDefinition p:FunctionDefinition]
      Statement
      Type
    #:values
      [function-definition-body p:function-definition-body]
      mul
      numeric-bin-op
      plus
    #:patterns
      allocate-array-expr
      array-ref-expr
      [assignment p:assignment]
      bin-op-expr
      [declaration p:declaration]
      [function-definition p:function-definition]
      [if-statement p:if-statement]
      int-literal
      int64-type
      [pointer-assignment p:pointer-assignment]
      pointer-ref-expr
      [return p:return]
      syscall-expr
      var-expr
      [while p:while]
  }
  register-language {
    #:types
      BasicBlock
      [FunctionDefinition r:FunctionDefinition]
      Instruction
      Terminal
      Var
    #:values
      basic-block
      bin-op-inst
      cond-jump
      function-allocate-inst
      [function-definition r:function-definition]
      [int-literal r:int-literal]
      jump
      negated-var-condition
      [pointer-ref-inst r:pointer-ref-inst]
      pointer-set!-inst
      [return r:return]
      syscall-inst
      var
      var=?
  }
  set {
    #:types
      Set
    #:values
      make-set
      set->list
      set-add
  }
  tuples {
    #:types
      Tuple2
    #:values
      tuple2
    #:patterns
      tuple2
  }
}
(export
  #:types ()
  #:values (convert-function)
  #:patterns ())
(types
  (define-type Environment
    (environment [vars : (Dict Bytes Var)] [mutated-vars : (Set Bytes)]))
  (define-type State
    (state [var-counter : Int] [block-counter : Int]))
  (define-type Accumulator
    (accumulator
      [next-block : PendingBasicBlock]
      [blocks : (Dict Int BasicBlock)]))
  (define-type PendingBasicBlock
    (pending-basic-block
      [index : Int]
      [cur-args : (List Var)]
      [reversed-instructions : (List Instruction)])))

(define (convert-function [f : p:FunctionDefinition]) : r:FunctionDefinition
  (match-define (p:function-definition name args body) f)
  (match-define (tuple2 freshened-args state)
    (map-state fresh-name args (initial-state)))
  (match-define env
    (add-all-args freshened-args (initial-environment (mutated-vars f))))
  (match-define (tuple2 block-number state) (fresh-block-number state))
  (match-define (tuple2 (accumulator (pending-basic-block _ _ instructions) blocks)
                        (tuple2 state environment))
    (convert-statements body
                        (start-block block-number (map new-arg freshened-args) (make-dict =))
                        env
                        state))
  (match-define (state next-var next-block) state)
  (case instructions
    [(cons _ _) (panic #"Incorrectly terminated function")]
    [_ (r:function-definition name block-number blocks next-var next-block)]))

(define (mutated-vars [f : p:FunctionDefinition]) : (Set Bytes)
  (mutated-vars/statements (p:function-definition-body f)))

(define (mutated-vars/statements [ss : (List Statement)]) : (Set Bytes)
  (foldl mutated-vars* ss (make-set bytes=?)))

(define (mutated-vars* [s : Statement] [acc : (Set Bytes)]) : (Set Bytes)
  (case s
    [(p:return _) acc]
    [(p:declaration _ _)  acc]
    [(p:pointer-assignment _ _) acc]
    [(p:assignment v _) (set-add acc v)]
    [(p:while _ body) (foldl mutated-vars* body acc)]
    [(p:if-statement _ then else)
     (foldl mutated-vars* else (foldl mutated-vars* then acc))]))

(define (initial-state) : State
  (state 0 0))
(define (new-arg [fresh-arg : (Tuple2 Bytes Var)]) : Var
  (case fresh-arg
    [(tuple2 _ v) v]))

(define (initial-environment [mutated-vars : (Set Bytes)]) : Environment
  (environment (make-dict bytes=?) mutated-vars))

(define (env-ref [env : Environment] [name : Bytes]) : Var
  (case (dict-ref (environment-vars env) name)
    [(nothing) (panic #"unbound variable")]
    [(just v) v]))

(define (env-ref* [env : Environment] [names : (List Bytes)]) : (List Var)
  (map (lambda ([name : Bytes]) (env-ref env name)) names))

(define (env-add [env : Environment] [name : Bytes] [var : Var]) : Environment
  (case env
    [(environment vars mutated-vars)
     (environment (dict-add vars name var) mutated-vars)]))

(define (env-replace [env : Environment] [name : Bytes] [var : Var]) : Environment
  (case env
    [(environment vars mutated-vars)
     (environment (dict-replace vars name var) mutated-vars)]))

(define (fresh-name [v : Bytes] [s : State]) : (Tuple2 (Tuple2 Bytes Var) State)
  (case s
    [(state var-counter block-counter)
     (tuple2
       (tuple2 v (var v var-counter))
       (state (+ 1 var-counter) block-counter))]))

(define (fresh-block-number [s : State]) : (Tuple2 Int State)
  (case s
    [(state var-counter block-counter)
     (tuple2
       block-counter
       (state var-counter (+ 1 block-counter)))]))

(define (start-block [block-num : Int] [args : (List Var)] [blocks : (Dict Int BasicBlock)]) : Accumulator
  (accumulator (pending-basic-block block-num args (empty)) blocks))

(define (a b s) (map-state [f : (a s -> (Tuple2 b s))] [l : (List a)] [s : s]) : (Tuple2 (List b) s)
  (case l
    [(empty) (tuple2 (empty) s)]
    [(cons e l)
     (case (f e s)
       [(tuple2 v s)
        (case (map-state f l s)
          [(tuple2 vs s)
           (tuple2 (cons v vs) s)])])]))

(define (add-all-args [args : (List (Tuple2 Bytes Var))] [env : Environment]) : Environment
  (case env
    [(environment vars mutated-vars)
     (environment (dict-add-all vars args) mutated-vars)]))

(define (replace-all-args [args : (List (Tuple2 Bytes Var))] [env : Environment]) : Environment
  (case env
    [(environment vars mutated-vars)
     (environment (dict-replace-all vars args) mutated-vars)]))

(define (get-differing-vars [base-env : Environment] [env1 : Environment] [env2 : Environment])
  : (List Bytes)
  (match-define (environment vars _) base-env)
  (filter
    (lambda ([name : Bytes]) : Boolean
      (not (var=? (env-ref env1 name) (env-ref env2 name))))
    (set->list (dict-keys vars))))

(define (convert-statements
          [statements : (List Statement)]
          [acc : Accumulator]
          [env : Environment]
          [state : State])
  : (Tuple2 Accumulator (Tuple2 State Environment))
  (case statements
    [(empty) (tuple2 acc (tuple2 state env))]
    [(cons statement statements)
     (case (convert-statement statement acc env state)
       [(tuple2 acc (tuple2 state env))
        (convert-statements statements acc env state)])]))

(define (add-terminal [a : Accumulator] [term : Terminal]) : (Dict Int BasicBlock)
  (case a
    [(accumulator (pending-basic-block n args rev-instructions) blocks)
     (dict-add blocks n (basic-block args (reverse rev-instructions) term))]))

(define (convert-statement
          [statement : Statement]
          [acc : Accumulator]
          [env : Environment]
          [state : State])
  : (Tuple2 Accumulator (Tuple2 State Environment))
  (case statement
    [(p:return expr)
     (match-define (tuple2 (tuple2 temp acc) state)
       (convert-expr #"ret" expr acc env state))
     (match-define (tuple2 block-num state) (fresh-block-number state))
     (tuple2
       (start-block block-num (empty) (add-terminal acc (r:return temp)))
       (tuple2 state env))]
    [(p:declaration name expr)
     (match-define (tuple2 (tuple2 temp acc) state)
       (convert-expr name expr acc env state))
     (tuple2 acc (tuple2 state (env-add env name temp)))]
    [(p:if-statement cond then else)
     (match-define (tuple2 (tuple2 branch-var acc) state)
       (convert-expr #"cond" cond acc env state))
     (match-define (tuple2 t-block-num state) (fresh-block-number state))
     (match-define (tuple2 f-block-num state) (fresh-block-number state))
     (match-define old-blocks
       (add-terminal acc (cond-jump (negated-var-condition branch-var)
                                    f-block-num (empty)
                                    t-block-num (empty))))

     (match-define (tuple2 t-acc (tuple2 state t-env))
       (convert-statements then (start-block t-block-num (empty) (make-dict =)) env state))
     (match-define (tuple2 f-acc (tuple2 state f-env))
       (convert-statements else (start-block f-block-num (empty) (make-dict =)) env state))

     (match-define mut-vars (get-differing-vars env t-env f-env))
     (match-define t-mut-vars (env-ref* t-env mut-vars))
     (match-define f-mut-vars (env-ref* f-env mut-vars))

     (match-define (tuple2 c-block-num state) (fresh-block-number state))
     (match-define all-blocks
       (merge-dicts
         old-blocks
         (merge-dicts
           (add-terminal t-acc (jump c-block-num t-mut-vars))
           (add-terminal f-acc (jump c-block-num f-mut-vars)))))

     (match-define (tuple2 fresh-mut-args state)
       (map-state fresh-name mut-vars state))

     (tuple2
       (start-block c-block-num (map new-arg fresh-mut-args) all-blocks)
       (tuple2 state (replace-all-args fresh-mut-args env)))]
    [(p:assignment name expr)
     (match-define (tuple2 (tuple2 temp acc) state)
       (convert-expr name expr acc env state))
     (tuple2 acc (tuple2 state (env-replace env name temp)))]
    [(p:pointer-assignment pointer expr)
     (match-define (tuple2 (tuple2 temp-pointer acc) state)
       (convert-expr #"ptr" pointer acc env state))
     (match-define (tuple2 (tuple2 temp-expr acc) state)
       (convert-expr #"val" expr acc env state))
     (tuple2
       (add-instruction acc (pointer-set!-inst temp-pointer temp-expr))
       (tuple2 state env))]
    [(p:while cond body)
     (match-define (tuple2 header-block-num state) (fresh-block-number state))
     (match-define mut-vars (set->list (mutated-vars/statements body)))
     (match-define blocks (add-terminal acc (jump header-block-num (env-ref* env mut-vars))))

     (match-define (tuple2 fresh-mut-args state)
       (map-state fresh-name mut-vars state))

     (match-define header-acc (start-block header-block-num (map new-arg fresh-mut-args) blocks))
     (match-define header-env (replace-all-args fresh-mut-args env))

     (match-define (tuple2 (tuple2 branch-var header-acc) state)
       (convert-expr #"cond" cond header-acc header-env state))

     (match-define (tuple2 body-block-num state) (fresh-block-number state))

     (match-define (tuple2 body-acc (tuple2 state body-env))
       (convert-statements
         body
         (start-block body-block-num (empty) (make-dict =))
         header-env
         state))

     (match-define (tuple2 after-block-num state) (fresh-block-number state))

     (tuple2
       (start-block
         after-block-num
         (empty)
         (merge-dicts
           (add-terminal header-acc (cond-jump (negated-var-condition branch-var)
                                               after-block-num (empty)
                                               body-block-num (empty)))
           (add-terminal body-acc (jump header-block-num (env-ref* body-env mut-vars)))))
       (tuple2 state header-env))]))

(define (add-instruction [a : Accumulator] [inst : Instruction]) : Accumulator
  (case a
    [(accumulator (pending-basic-block n args rev-instructions) blocks)
     (accumulator (pending-basic-block n args (cons inst rev-instructions)) blocks)]))

(define (convert-exprs
          [base-name : Bytes]
          [exprs : (List Expr)]
          [acc : Accumulator]
          [env : Environment]
          [state : State])
  : (Tuple2 (Tuple2 (List Var) Accumulator) State)
  (case exprs
    [(empty) (tuple2 (tuple2 (empty) acc) state)]
    [(cons expr exprs)
     (case (convert-expr base-name expr acc env state)
       [(tuple2 (tuple2 var acc) state)
        (case (convert-exprs base-name exprs acc env state)
          [(tuple2 (tuple2 vars acc) state)
           (tuple2 (tuple2 (cons var vars) acc) state)])])]))

(define (convert-expr
          [base-name : Bytes]
          [expr : Expr]
          [acc : Accumulator]
          [env : Environment]
          [state : State])
  : (Tuple2 (Tuple2 Var Accumulator) State)
  (case expr
    [(var-expr name)
     (tuple2 (tuple2 (env-ref env name) acc) state)]
    [(int-literal v)
     (match-define (tuple2 (tuple2 _ name) state) (fresh-name base-name state))
     (tuple2
       (tuple2
         name
         (add-instruction acc (r:int-literal name v)))
       state)]
    [(bin-op-expr op left right)
     (case (convert-expr #"tmp" left acc env state)
       [(tuple2 (tuple2 left-res acc) state)
        (case (convert-expr #"tmp" right acc env state)
          [(tuple2 (tuple2 right-res acc) state)
           (case (fresh-name base-name state)
             [(tuple2 (tuple2 _ name) state)
              (tuple2
                (tuple2
                  name
                  (add-instruction acc (bin-op-inst name op left-res right-res)))
                state)])])])]
    [(allocate-array-expr type e)
     (case (convert-expr #"count" e acc env state)
       [(tuple2 (tuple2 count-res acc) state)
        (case (fresh-name #"size" state)
          [(tuple2 (tuple2 _ size-name) state)
           (case (fresh-name #"count-mul" state)
             [(tuple2 (tuple2 _ count-mul-name) state)
              (case (fresh-name base-name state)
                [(tuple2 (tuple2 _ name) state)
                 (tuple2
                   (tuple2 name
                           (add-instruction
                             (add-instruction
                               (add-instruction
                                 acc
                                 (r:int-literal size-name (type->size type)))
                               (bin-op-inst count-mul-name (numeric-bin-op (mul)) count-res size-name))
                             (function-allocate-inst name count-mul-name)))
                   state)])])])])]
    [(pointer-ref-expr pointer)
     (case (convert-expr #"ptr" pointer acc env state)
       [(tuple2 (tuple2 p acc) state)
        (case (fresh-name base-name state)
          [(tuple2 (tuple2 _ name) state)
           (tuple2 (tuple2 name (add-instruction acc (r:pointer-ref-inst name p))) state)])])]
    [(array-ref-expr type array offset)
     (case (convert-expr #"ptr" array acc env state)
       [(tuple2 (tuple2 array acc) state)
        (case (convert-expr #"off" offset acc env state)
          [(tuple2 (tuple2 offset acc) state)
           (case (fresh-name #"size" state)
             [(tuple2 (tuple2 _ size-name) state)
              (case (fresh-name #"offset-mul" state)
                [(tuple2 (tuple2 _ offset-mul-name) state)
                 (case (fresh-name base-name state)
                   [(tuple2 (tuple2 _ name) state)
                    (tuple2
                      (tuple2 name
                              (add-instruction
                                (add-instruction
                                  (add-instruction
                                    acc
                                    (r:int-literal size-name (type->size type)))
                                  (bin-op-inst offset-mul-name (numeric-bin-op (mul)) offset size-name))
                                (bin-op-inst name (numeric-bin-op (plus)) array offset-mul-name)))
                      state)])])])])])]
    [(syscall-expr s args)
     (case (convert-exprs #"arg" args acc env state)
       [(tuple2 (tuple2 vars acc) state)
        (case (fresh-name base-name state)
          [(tuple2 (tuple2 _ name) state)
           (tuple2
             (tuple2 name (add-instruction acc (syscall-inst name s vars)))
             state)])])]))

;; TODO support types better
(define (type->size [t : Type]) : Int
  (case t
    [(int64-type) 8]
    [_ (panic #"Type doesn't have size")]))
