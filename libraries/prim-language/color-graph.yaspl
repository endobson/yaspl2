#:module (color-graph)
#:import {
  (bytes)
  (dict)
  (either)
  (list)
  (lower-x86-64)
  (lowered-live-variables)
  (maybe)
  (prim)
  (register-language)
  (set)
  (tuples)
  (undirected-graph)
}
(export
  #:types (RegisterAssignment)
  #:values (color-graph initial-state state->bytes
            determine-register-assignments register-assignment->bytes)
  #:patterns ())
(types
  (define-type RegisterAssignment
    (assign-free [v : Var] [conflicts : (Set Var)] [fixed-conflicts : (Set X8664Register)])
    (assign-same [v1 : Var] [v2 : Var])
    (assign-fixed [v1 : Var] [fixed : X8664Register])
    (assign-spill [v1 : Var] [conflicts : (Set Var)] [fixed-conflicts : (Set X8664Register)]))
  (define-type EdgeData
    (move-edge)
    (interference-edge))
  (define-type State
    (state
      [graph : (Graph Var Void EdgeData)]
      [fixed-constraints : (Dict Var (Set X8664Register))]
      [fixed-neighbors : (Dict Var (Set X8664Register))]
      [register-assignments : (List RegisterAssignment)])))

(define (initial-state [live-outs : (List (LiveOutState Reg))]) : State
  (state
    (initial-graph live-outs)
    (initial-fixed-constraints live-outs)
    (initial-fixed-neighbors live-outs)
    (empty)))

;; TODO make this include the graph and the assignments
(define (state->bytes [s : State]) : Bytes
  (match-define (state g fixed-constraints fixed-neighbors assignment) s)
  (bytes-append
    (cons #"fixed: "
    (interleave
      (dict-map
        fixed-constraints
        (lambda ([v : Var] [rs : (Set X8664Register)])
          (var->bytes v)))
      #","))))

(define (initial-graph [live-outs : (List (LiveOutState Reg))]) : (Graph Var Void EdgeData)
  (foldl
    (lambda ([l : (LiveOutState Reg)] [acc : (Graph Var Void EdgeData)])
      (case l
        [(live-out-state out-regs def-regs move-source)
         (foldl
           (lambda ([def-reg : Reg] [acc : (Graph Var Void EdgeData)])
             (case def-reg
               [(fixed-reg _) acc]
               [(temporary-reg reg)
                (match-define out-regs
                  (filter-map
                    (lambda ([r : Reg]) : (Maybe Var)
                      (case r
                        [(fixed-reg _) (nothing)]
                        [(temporary-reg r)
                         (if (var=? r reg)
                             (nothing)
                             (just r))]))
                    (set->list out-regs)))
                (match-define acc (graph-add-vertex-if-absent acc reg (void)))
                (match-define acc
                  (foldl
                    (lambda ([v : Var] [acc : (Graph Var Void EdgeData)]) : (Graph Var Void EdgeData)
                      (case
                        (graph-update-edge
                          (graph-add-vertex-if-absent acc v (void))
                          v reg
                          (lambda ([e : EdgeData]) (interference-edge))
                          (interference-edge))
                        [(nothing) (panic #"Bad graph")]
                        [(just g) g]))
                    out-regs
                    acc))
                (match-define acc
                  (case move-source
                    [(nothing) acc]
                    [(just (fixed-reg _)) acc]
                    [(just (temporary-reg v))
                     (case
                       (graph-update-edge
                         (graph-add-vertex-if-absent acc v (void))
                         v reg
                         (lambda ([e : EdgeData]) e)
                         (move-edge))
                       [(nothing) ((lambda () : (Graph Var Void EdgeData) (panic #"Bad graph")))]
                       [(just g) g])]))
                acc]))
           (set->list def-regs)
           acc)]))
    live-outs
    ((lambda () : (Graph Var Void EdgeData) (empty-graph var=?)))))

(define (initial-fixed-constraints [live-outs : (List (LiveOutState Reg))])
  : (Dict Var (Set X8664Register))
  (foldl
    (lambda ([l : (LiveOutState Reg)] [acc : (Dict Var (Set X8664Register))])
      (case l
        [(live-out-state out-regs defined-regs _)
         (foldl
           (lambda ([defined : Reg] [acc : (Dict Var (Set X8664Register))])
             (case defined
               [(fixed-reg f-reg)
                (foldl
                  (lambda ([r : Reg] [acc : (Dict Var (Set X8664Register))])
                    (case r
                      [(fixed-reg _) acc]
                      [(temporary-reg r)
                       (dict-update
                         acc
                         r
                         (lambda ([s : (Set X8664Register)]) (set-add s f-reg))
                         (make-set x86-64-register=?))]))
                  (set->list out-regs)
                  acc)]
               [(temporary-reg t-reg)
                (foldl
                  (lambda ([r : Reg] [acc : (Dict Var (Set X8664Register))])
                    (case r
                      [(temporary-reg _) acc]
                      [(fixed-reg r)
                       (dict-update-existing
                         acc
                         t-reg
                         (lambda ([s : (Set X8664Register)]) (set-add s r)))]))
                  (set->list out-regs)
                  (dict-update
                    acc
                    t-reg
                    (lambda ([s : (Set X8664Register)]) s)
                    (make-set x86-64-register=?)))]))
           (set->list defined-regs)
           acc)]))
    live-outs
    ((lambda () : (Dict Var (Set X8664Register)) (make-dict var=?)))))

(define (initial-fixed-neighbors [live-outs : (List (LiveOutState Reg))])
  : (Dict Var (Set X8664Register))
  (foldl
    (lambda ([l : (LiveOutState Reg)] [acc : (Dict Var (Set X8664Register))])
      (case l
        [(live-out-state _ defined-regs move-source)
         (foldl
           (lambda ([defined : Reg] [acc : (Dict Var (Set X8664Register))])
             (case defined
               [(temporary-reg t-reg)
                (match-define acc
                  (dict-update
                    acc
                    t-reg
                    (lambda ([s : (Set X8664Register)]) s)
                    (make-set x86-64-register=?)))
                (case move-source
                  [(nothing) acc]
                  [(just (temporary-reg _)) acc]
                  [(just (fixed-reg f-reg))
                   (dict-update-existing
                     acc
                     t-reg
                     (lambda ([s : (Set X8664Register)]) (set-add s f-reg)))])]
               [(fixed-reg f-reg)
                (case move-source
                  [(nothing) acc]
                  [(just (fixed-reg _)) acc]
                  [(just (temporary-reg t-reg))
                   (dict-update
                     acc
                     t-reg
                     (lambda ([s : (Set X8664Register)]) (set-add s f-reg))
                     (make-set x86-64-register=?))])]))
           (set->list defined-regs)
           acc)]))
    live-outs
    ((lambda () : (Dict Var (Set X8664Register)) (make-dict var=?)))))



(define (color-graph [state : State]) : (Either (Set Var) (Dict Var X8664Register))
  (select-loop-start (determine-register-assignments state)))


(define (determine-register-assignments [state : State]) : (List RegisterAssignment)
  (let ([state (simplify-loop-start state)])
    (if (= 0 (num-vertices state))
        (state-register-assignments state)
        (case (coalesce-loop-start state)
          [(tuple2 coalesced state)
           (if coalesced
               (determine-register-assignments state)
               (case (maybe-freeze state)
                 [(just state) (determine-register-assignments state)]
                 [(nothing)
                  (determine-register-assignments (spill-once state))]))]))))

(define (simplify-loop-start [state : State]) : State
  (simplify-loop (non-move-related-vertices state) state))

(define (simplify-loop
          [vertices : (Set Var)]
          [state : State]) : State
  (case (set-split vertices)
    [(nothing) state]
    [(just (tuple2 v vertices))
     (if (< (num-interfering-neighbors state v) (set-count (valid-temporary-x86-64-registers)))
         (simplify-loop
           (set-union vertices (non-move-related-neighbors state v))
           (remove-unconstrained-vertex state v))
         (simplify-loop vertices state))]))

(define (coalesce-loop-start [state : State]) : (Tuple2 Boolean State)
  (coalesce-loop (move-related-vertices state) #f state))

(define (coalesce-loop
          [vertices : (Set Var)]
          [coalesced : Boolean]
          [state : State]) : (Tuple2 Boolean State)
  (case (set-split vertices)
    [(nothing) (tuple2 coalesced state)]
    [(just (tuple2 v vertices))
     (case (find-fixed-coalescable-neighbor v state)
       [(just reg)
        (coalesce-loop vertices #t (coalesce-fixed state v reg))]
       [(nothing)
        (case (find-temporary-coalescable-neighbor v state)
          [(just v2)
           (coalesce-loop vertices #t (coalesce state v v2))]
          [(nothing)
           (coalesce-loop vertices coalesced state)])])]))

(define (maybe-freeze [state : State]) : (Maybe State)
  (case (arg-min (lambda ([v : Var]) (num-interfering-neighbors state v)) (move-related-vertices state))
    [(nothing) (nothing)]
    [(just v)
     (just (freeze state v))]))

(define (spill-once [state : State]) : State
  (case (arg-max (lambda ([v : Var]) (num-interfering-neighbors state v)) (non-move-related-vertices state))
    [(nothing) (panic #"Cannot spill on empty state")]
    [(just v)
     (spill-vertex state v)]))

(define (find-temporary-coalescable-neighbor [v : Var] [state : State]) : (Maybe Var)
  (case (set-split (set-filter (move-neighbors state v)
                               (lambda ([v2 : Var])
                                 (is-coalescable-edge state v v2))))
    [(nothing) (nothing)]
    [(just (tuple2 v _)) (just v)]))


(define (fixed-neighbors [v : Var] [state : State]) : (Set X8664Register)
  (case (dict-ref (state-fixed-neighbors state) v)
    [(nothing) (panic #"Bad vertex")]
    [(just v) v]))

(define (find-fixed-coalescable-neighbor [v : Var] [state : State]) : (Maybe X8664Register)
  (case (set-split (set-filter (fixed-neighbors v state)
                               (lambda ([reg : X8664Register])
                                 (is-coalescable-fixed-edge state v reg))))
    [(nothing) (nothing)]
    [(just (tuple2 v _)) (just v)]))


(define (A) (arg-max [f : (A -> Int)] [elems : (Set A)]) : (Maybe A)
  (case (set-split elems)
    [(nothing) (nothing)]
    [(just (tuple2 e elems)) (arg-max* f e (f e) elems)]))

(define (A) (arg-max* [f : (A -> Int)] [e : A] [v : Int] [elems : (Set A)]) : (Maybe A)
  (case (set-split elems)
    [(nothing) (just e)]
    [(just (tuple2 e2 elems))
     (let ([v2 (f e2)])
       (if (> v2 v)
           (arg-max* f e2 v2 elems)
           (arg-max* f e v elems)))]))

(define (A) (arg-min [f : (A -> Int)] [elems : (Set A)]) : (Maybe A)
  (arg-max (lambda ([x : A]) (- 0 (f x))) elems))

(define (num-interfering-neighbors [state : State] [v : Var]) : Int
  (case (dict-ref (state-fixed-constraints state) v)
    [(nothing)
     (panic
       (bytes-append
         (varargs list #"Bad context: " (var->bytes v))))]
    [(just fixed-regs)
     (+
       (set-count fixed-regs)
       (set-count (interfering-neighbors state v)))]))


(define (num-vertices [state : State]) : Int
  (dict-count (graph-vertices (state-graph state))))

(define (non-move-related-vertices [state : State]) : (Set Var)
  (let ([g (state-graph state)])
    (set-filter
      (dict-keys (graph-vertices g))
      (lambda ([v : Var])
        (case (graph-vertex-edges g v)
          [(nothing) (panic #"Bad vertex")]
          [(just edges)
           (case
             (findf
               (lambda ([e : EdgeData])
                 (case e
                   [(move-edge) #t]
                   [_ #f]))
               (dict-values edges))
             [(just _) #f]
             [_ (= (set-count (fixed-neighbors v state)) 0)])])))))

(define (move-related-vertices [state : State]) : (Set Var)
  (let ([g (state-graph state)])
    (set-union
      (set-filter
        (dict-keys (graph-vertices g))
        (lambda ([v : Var])
          (case (graph-vertex-edges g v)
            [(nothing) (panic #"Bad vertex")]
            [(just edges)
             (case
               (findf
                 (lambda ([e : EdgeData])
                   (case e
                     [(move-edge) #t]
                     [_ #f]))
                 (dict-values edges))
               [(just _) #t]
               [_ #f])])))
      (dict-keys
        (dict-filter
          (state-fixed-neighbors state)
          (lambda ([v : Var] [neighbors : (Set X8664Register)])
            (> (set-count neighbors) 0)))))))

(define (move-neighbors [state : State] [v : Var]) : (Set Var)
  (let ([g (state-graph state)])
    (case (graph-vertex-edges g v)
      [(nothing) (panic #"Bad vertex")]
      [(just edges)
       (dict-keys
         (dict-filter
           edges
           (lambda ([v : Var] [e : EdgeData])
             (case e
               [(move-edge) #t]
               [(interference-edge) #f]))))])))

(define (interfering-neighbors [state : State] [v : Var]) : (Set Var)
  (let ([g (state-graph state)])
    (case (graph-vertex-edges g v)
      [(nothing) (panic #"Bad vertex")]
      [(just edges)
       (dict-keys
         (dict-filter
           edges
           (lambda ([v : Var] [e : EdgeData])
             (case e
               [(move-edge) #f]
               [(interference-edge) #t]))))])))


(define (non-move-related-neighbors [state : State] [v : Var]) : (Set Var)
  (let ([g (state-graph state)])
    (case (graph-vertex-edges g v)
      [(nothing) (panic #"Bad vertex")]
      [(just edges)
       (set-filter
         (dict-keys edges)
         (lambda ([v : Var])
           (case (graph-vertex-edges g v)
             [(nothing) (panic #"Bad vertex")]
             [(just edges)
              (case
                (findf
                  (lambda ([e : EdgeData])
                    (case e
                      [(move-edge) #t]
                      [_ #f]))
                  (dict-values edges))
                [(just _) #f]
                [(nothing)
                 (= (set-count (fixed-neighbors v state)) 0) ])])))])))

(define (neighbors [state : State] [v : Var]) : (Set Var)
  (let ([g (state-graph state)])
    (case (graph-vertex-edges g v)
      [(nothing) (panic #"Bad vertex")]
      [(just edges)
       (dict-keys edges)])))


(define (freeze [s : State] [v : Var]) : State
  (match-define (state g fixed-constraints fixed-neighbors assignments) s)
  (state
    (foldl
      (lambda ([v2 : Var] [g : (Graph Var Void EdgeData)])
        (graph-remove-edge g v v2))
      (set->list (move-neighbors s v))
      g)
    fixed-constraints
    (dict-set fixed-neighbors v (make-set x86-64-register=?))
    assignments))

;; TODO Should check that it actually is not move related.
(define (remove-unconstrained-vertex [s : State] [v : Var]) : State
  (match-define (state g fixed-constraints fixed-neighbors assignments) s)
  (match-define vs (neighbors s v))
  (match-define g
    (foldl
      (lambda ([v2 : Var] [g : (Graph Var Void EdgeData)])
        (graph-remove-edge g v v2))
      (set->list vs)
      g))
  (case (graph-remove-unconnected-vertex g v)
    [(left _) (panic #"Bad graph")]
    [(right g)
     (case (dict-ref fixed-constraints v)
       [(nothing) (panic #"Bad vertex")]
       [(just constraints)
        (state
          g
          (dict-remove fixed-constraints v)
          (dict-remove fixed-neighbors v)
          (cons (assign-free v vs constraints) assignments))])]))


;; This merges v1 into v2, keeping the v2 name
(define (coalesce [s : State] [v1 : Var] [v2 : Var]) : State
  (match-define (state g fixed-constraints fixed-neighbors assignments) s)
  (case (graph-vertex-edges g v1)
    [(nothing) (panic #"Bad vertex")]
    [(just edges)
     (match-define g
       (dict-fold
         edges
         (lambda ([v : Var] [e : EdgeData] [g : (Graph Var Void EdgeData)]) : (Graph Var Void EdgeData)
           (let ([g (graph-remove-edge g v1 v)])
             (if (var=? v v2)
                 g
                 (case (graph-update-edge
                         g v2 v
                         (lambda ([old-e : EdgeData])
                           (case e
                             [(interference-edge) (interference-edge)]
                             [(move-edge) old-e]))
                         e)
                 [(nothing) (panic #"Bad edge")]
                 [(just g) g]))))
         g))

     (match-define fixed-constraints
       (dict-remove
         (dict-update-existing
           fixed-constraints
           v2
           (lambda ([conflicts2 : (Set X8664Register)]) : (Set X8664Register)
             (case (dict-ref fixed-constraints v1)
               [(nothing) (panic #"Bad vertex")]
               [(just conflicts1)
                (set-union conflicts1 conflicts2)])))
         v1))

     (match-define fixed-neighbors
       (dict-remove
         (dict-update-existing
           fixed-neighbors
           v2
           (lambda ([neighbors2 : (Set X8664Register)]) : (Set X8664Register)
             (case (dict-ref fixed-neighbors v1)
               [(nothing) (panic #"Bad vertex")]
               [(just neighbors1)
                (set-union neighbors1 neighbors2)])))
         v1))


     (case (graph-remove-unconnected-vertex g v1)
       [(left (nothing))
        (panic
          (bytes-append
            (varargs list
              #"Couldn't remove unconnected vertex it is not in the graph:\n"
              (var->bytes v1))))]
       [(left (just edges))
        (panic
          (bytes-append
            (varargs list
              #"Couldn't remove unconnected vertex it still has edges in the graph:\n"
              (var->bytes v1)
              #"\nEdges remain to :\n"
              (bytes-append
                (interleave
                  (map var->bytes (set->list (dict-keys edges)))
                  #" ")))))]
       [(right g)
        (state g fixed-constraints fixed-neighbors (cons (assign-same v1 v2) assignments))])]))

;; This merges v1 into reg.
(define (coalesce-fixed [s : State] [v1 : Var] [reg : X8664Register]) : State
  (match-define (state g fixed-constraints fixed-neighbors assignments) s)
  (case (graph-vertex-edges g v1)
    [(nothing) (panic #"Bad vertex")]
    [(just edges)
     (match-define g
       (dict-fold
         edges
         (lambda ([v : Var] [e : EdgeData] [g : (Graph Var Void EdgeData)]) : (Graph Var Void EdgeData)
           (graph-remove-edge g v1 v))
         g))

     (match-define fixed-constraints
       (dict-remove
         (dict-fold
           edges
           (lambda ([v : Var] [e : EdgeData] [fixed-constraints : (Dict Var (Set X8664Register))])
               : (Dict Var (Set X8664Register))
             (case e
               [(interference-edge)
                (dict-update-existing fixed-constraints v (lambda ([s : (Set X8664Register)])
                                                            (set-add s reg)))]
               [(move-edge) fixed-constraints]))
           fixed-constraints)
         v1))

     (match-define fixed-neighbors
       (dict-remove
         (dict-fold
           edges
           (lambda ([v : Var] [e : EdgeData] [fixed-neighbors : (Dict Var (Set X8664Register))])
               : (Dict Var (Set X8664Register))
             (case e
               [(move-edge)
                (dict-update-existing fixed-neighbors v (lambda ([s : (Set X8664Register)])
                                                          (set-add s reg)))]
               [(interference-edge) fixed-neighbors]))
           fixed-neighbors)
         v1))

     (case (graph-remove-unconnected-vertex g v1)
       [(left (nothing))
        (panic
          (bytes-append
            (varargs list
              #"Couldn't remove unconnected vertex it is not in the graph:\n"
              (var->bytes v1))))]
       [(left (just edges))
        (panic
          (bytes-append
            (varargs list
              #"Couldn't remove unconnected vertex it still has edges in the graph:\n"
              (var->bytes v1)
              #"\nEdges remain to :\n"
              (bytes-append
                (interleave
                  (map var->bytes (set->list (dict-keys edges)))
                  #" ")))))]
       [(right g)
        (state g fixed-constraints fixed-neighbors (cons (assign-fixed v1 reg) assignments))])]))


;; TODO check that this is not move related
(define (spill-vertex [s : State] [v : Var]) : State
  (match-define (state g fixed-constraints fixed-neighbors assignments) s)
  (match-define vs (neighbors s v))
  (match-define g
    (foldl
      (lambda ([v2 : Var] [g : (Graph Var Void EdgeData)])
        (graph-remove-edge g v v2))
      (set->list vs)
      g))
  (case (graph-remove-unconnected-vertex g v)
    [(left _) (panic #"Bad graph")]
    [(right g)
     (case (dict-ref fixed-constraints v)
       [(nothing) (panic #"Bad vertex")]
       [(just constraints)
        (state
          g
          (dict-remove fixed-constraints v)
          (dict-remove fixed-neighbors v)
          (cons (assign-spill v vs constraints) assignments))])]))


(define (is-coalescable-fixed-edge [s : State] [v : Var] [reg : X8664Register]) : Boolean
  (match-define (state g fixed-constraints fixed-neighbors assignments) s)

  (< (set-count
       (set-filter
         (interfering-neighbors s v)
         (lambda ([v : Var]) : Boolean
           (case (dict-ref fixed-constraints v)
             [(nothing) (panic #"Bad vertex")]
             [(just fixed-regs) (set-member? fixed-regs reg)]))))
     (set-count (valid-temporary-x86-64-registers))))


(define (is-coalescable-edge [s : State] [v1 : Var] [v2 : Var]) : Boolean
  (match-define (state g fixed-constraints fixed-neighbors assignments) s)
  (match-define fixed-count
    ((lambda () : Int
       (case (dict-ref fixed-constraints v1)
         [(nothing) (panic #"Bad vertex")]
         [(just regs1)
          (case (dict-ref fixed-constraints v2)
            [(nothing) (panic #"Bad vertex")]
            [(just regs2)
             (set-count (set-union regs1 regs2))])]))))
  (< (+ fixed-count
       (set-count
         (set-filter
           (set-union
             (interfering-neighbors s v1)
             (interfering-neighbors s v2))
           (lambda ([v : Var])
             (>= (num-interfering-neighbors s v) (set-count (valid-temporary-x86-64-registers)))))))
     (set-count (valid-temporary-x86-64-registers))))

(define (select-loop-start [assignment : (List RegisterAssignment)])
  : (Either (Set Var) (Dict Var X8664Register))
  (let ([maybe-mapping (select-loop assignment (make-dict var=?))])
    (let ([uncolorable-nodes (dict-keys (dict-filter maybe-mapping
                                                     (lambda ([k : Var] [v : (Maybe X8664Register)])
                                                       (case v
                                                         [(nothing) #t]
                                                         [(just _) #f]))))])
      (if (= 0 (set-count uncolorable-nodes))
          (right (dict-filter-map maybe-mapping (lambda ([k : Var] [v : (Maybe X8664Register)]) v)))
          (left uncolorable-nodes)))))

(define (select-loop [assignment : (List RegisterAssignment)] [acc : (Dict Var (Maybe X8664Register))])
  : (Dict Var (Maybe X8664Register))
  (case assignment
    [(empty) acc]
    [(cons (assign-same v1 v2) assignment)
     (case (dict-ref acc v2)
       [(nothing) (panic #"Bad assign-same")]
       [(just reg)
        (select-loop assignment (dict-add acc v1 reg))])]
    [(cons (assign-fixed v1 reg) assignment)
     (select-loop assignment (dict-add acc v1 (just reg)))]
    [(cons (assign-free v con fixed-con) assignment)
     (case (set-split
             (set-difference
               (valid-temporary-x86-64-registers)
               (set-add-all
                 fixed-con
                 (filter-map
                   (lambda ([v : Var]) : (Maybe X8664Register)
                     (case (dict-ref acc v)
                       [(nothing) (panic #"Bad assign-free")]
                       [(just v) v]))
                   (set->list con)))))
       [(nothing) (panic #"Bad assign-free")]
       [(just (tuple2 reg _))
        (select-loop assignment (dict-add acc v (just reg)))])]
    [(cons (assign-spill v con fixed-con) assignment)
     (case (set-split
             (set-difference
               (valid-temporary-x86-64-registers)
               (set-add-all
                 fixed-con
                 (filter-map
                   (lambda ([v : Var]) : (Maybe X8664Register)
                     (case (dict-ref acc v)
                       [(nothing) (panic #"Bad assign-spill")]
                       [(just v) v]))
                   (set->list con)))))
       [(nothing)
        (select-loop assignment (dict-add acc v (nothing)))]
       [(just (tuple2 reg _))
        (select-loop assignment (dict-add acc v (just reg)))])]))

(define (register-assignment->bytes [v : RegisterAssignment]) : Bytes
  (case v
    [(assign-free v _ _)
     (bytes-append (varargs list (var->bytes v) #" = free"))]
    [(assign-same v v2)
     (bytes-append (varargs list (var->bytes v) #" = " (var->bytes v2)))]
    [(assign-fixed v reg)
     (bytes-append (varargs list (var->bytes v) #" = " (x86-64-register->bytes reg)))]
    [(assign-spill v _ _)
     (bytes-append (varargs list (var->bytes v) #" = spill"))]))
