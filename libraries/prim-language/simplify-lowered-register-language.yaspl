#:module simplify-lowered-register-language
#:import {
  boolean {
    #:values
      not
  }
  dict {
    #:types
      Dict
    #:values
      dict-filter
      dict-filter-map
      dict-ref
      dict-value-map
      dict-values
  }
  list {
    #:values
      filter
      foldl
    #:patterns
      empty
  }
  lowered-register-language {
    #:types
      BasicBlock
      FunctionDefinition
      Instruction
      Terminal
    #:values
      basic-block
      cond-jump
      function-definition
      jump
      return
    #:patterns
      basic-block
      cond-jump
      function-definition
      jump
      move
      return
  }
  maybe {
    #:types
      Maybe
    #:values
      just
      nothing
    #:patterns
      just
      nothing
  }
  prim {
    #:types
      Boolean
      Int
    #:values
      =
  }
  set {
    #:types
      Set
    #:values
      make-set
      set-add
      set-member?
  }
}

(export
  #:types ()
  #:values (simplify-function-definition)
  #:patterns ())
(types)

(define (Reg) (simplify-function-definition
                [f : (FunctionDefinition Reg)]
                [reg=? : (Reg Reg -> Boolean)])
  : (FunctionDefinition Reg)
  (match-define (function-definition name extras entry blocks) f)
  (function-definition
    name
    extras
    entry
    (remove-unused-blocks
      entry
      (collapse-trivial-blocks
        (remove-redundant-moves reg=?  blocks)))))

(define (Reg) (collapse-trivial-blocks [blocks : (Dict Int (BasicBlock Reg))])
  : (Dict Int (BasicBlock Reg))
  (let ([replacements (find-trivial-blocks blocks)])
    (dict-value-map
      blocks
      (lambda ([b : (BasicBlock Reg)])
        (case b
          [(basic-block insts term)
           (basic-block insts (collapse-trivial-blocks/terminal term replacements))])))))


(define (Reg) (collapse-trivial-blocks/terminal
                [terminal : (Terminal Reg)]
                [replacements : (Dict Int Int)])
  : (Terminal Reg)
 (case terminal
   [(jump i)
    (jump (collapse-trivial-blocks/jump i replacements))]
   [(return r)
    (return r)]
   [(cond-jump c t f)
    (cond-jump
      c
      (collapse-trivial-blocks/jump t replacements)
      (collapse-trivial-blocks/jump f replacements))]))

(define (collapse-trivial-blocks/jump
          [block : Int]
          [replacements : (Dict Int Int)])
  : Int
  (case (dict-ref replacements block)
    [(nothing) block]
    [(just new-block)
     (collapse-trivial-blocks/jump new-block replacements)]))

(define (Reg) (find-trivial-blocks
                [blocks : (Dict Int (BasicBlock Reg))])
  : (Dict Int Int)
  (dict-filter-map
    blocks
    (lambda ([key : Int] [b : (BasicBlock Reg)]) : (Maybe Int)
      (case b
        [(basic-block (empty) (jump target))
         (just target)]
        [_ (nothing)]))))


(define (Reg) (remove-unused-blocks
                [entry-block : Int]
                [blocks : (Dict Int (BasicBlock Reg))])
  : (Dict Int (BasicBlock Reg))
  (let ([live-blocks (set-add (find-live-blocks blocks) entry-block)])
    (dict-filter
      blocks
      (lambda ([key : Int] [b : (BasicBlock Reg)]) : Boolean
        (set-member? live-blocks key)))))

(define (Reg) (find-live-blocks
                [blocks : (Dict Int (BasicBlock Reg))])
  : (Set Int)
  (foldl
    (lambda ([b : (BasicBlock Reg)] [acc : (Set Int)])
      (case b
        [(basic-block _ (jump target))
         (set-add acc target)]
        [(basic-block _ (cond-jump _ t f))
         (set-add (set-add acc t) f)]
        [(basic-block _ (return _))
         acc]))
    (dict-values blocks)
    (make-set =)))

(define (Reg) (remove-redundant-moves
                [reg=? : (Reg Reg -> Boolean)]
                [blocks : (Dict Int (BasicBlock Reg))])
  : (Dict Int (BasicBlock Reg))
  (dict-value-map
    blocks
    (lambda ([b : (BasicBlock Reg)])
      (case b
        [(basic-block instructions terminal)
         (basic-block
           (filter
             (lambda ([i : (Instruction Reg)])
               (useful-move? i reg=?))
             instructions)
           terminal)]))))

(define (Reg) (useful-move? [i : (Instruction Reg)] [reg=? : (Reg Reg -> Boolean)]) : Boolean
  (case i
    [(move r1 r2)
     (not (reg=? r1 r2))]
    [_ #t]))
