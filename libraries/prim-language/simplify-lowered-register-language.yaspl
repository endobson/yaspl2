#:module (simplify-lowered-register-language)
#:import {
  (data boolean)
  (dict)
  (either)
  (list)
  (lowered-register-language)
  (maybe)
  (prim)
  (set)
  (set-multi-dict)
  (unique-dict)
}

(export
  #:types ()
  #:values (simplify-function-definition)
  #:patterns ())
(types)

(define (Reg) (simplify-function-definition
                [f : (AssignedRegistersFunctionDefinition Reg)]
                [reg=? : (Reg Reg -> Boolean)])
  : (AssignedRegistersFunctionDefinition Reg)
  (match-define (assigned-registers-function-definition name blocks) f)
  (assigned-registers-function-definition
    name
    (remove-unused-blocks
      (collapse-single-fallthroughs
        (add-unambiguous-fall-through
          (remove-unused-blocks
            (collapse-trivial-blocks
              (remove-no-op-instructions reg=? blocks))))))))

;; TODO support collapsing trivial fall-through blocks
(define (Reg) (collapse-trivial-blocks [blocks : (BlockMap Reg)])
  : (BlockMap Reg)
  (let ([replacements (find-trivial-blocks (block-map-blocks blocks))])
    (case (validate-block-map
            (unvalidated-block-map-map
              (block-map->unvalidated-block-map blocks)
              (lambda ([int : Int] [b : (BasicBlock Reg)])
                (case b
                  [(basic-block insts term)
                   (basic-block insts (collapse-trivial-blocks/terminal term replacements))]))))
      [(left msg) (panic msg)]
      [(right v) v])))


(define (Reg) (collapse-trivial-blocks/terminal
                [terminal : (Terminal Reg)]
                [replacements : (Dict Int Int)])
  : (Terminal Reg)
 (case terminal
   [(jump i)
    (jump (collapse-trivial-blocks/jump i replacements))]
   [(fall-through i)
    (collapse-trivial-blocks/fall-through i replacements)]
   [(return r)
    (return r)]
   [(halt)
    (halt)]
   [(cond-jump/false-fall-through c t f)
    (cond-jump/false-fall-through
      c
      (collapse-trivial-blocks/jump t replacements)
      f)]))

(define (Reg) (collapse-trivial-blocks/fall-through
                [block : Int]
                [replacements : (Dict Int Int)])
  : (Terminal Reg)
  (case (dict-ref replacements block)
    [(nothing) (fall-through block)]
    [(just new-block)
     (jump (collapse-trivial-blocks/jump new-block replacements))]))

(define (collapse-trivial-blocks/jump
          [block : Int]
          [replacements : (Dict Int Int)])
  : Int
  (case (dict-ref replacements block)
    [(nothing) block]
    [(just new-block)
     (collapse-trivial-blocks/jump new-block replacements)]))

(define (Reg) (find-trivial-blocks
                [blocks : (Dict Int (BasicBlock Reg))])
  : (Dict Int Int)
  (dict-filter-map
    blocks
    (lambda ([key : Int] [b : (BasicBlock Reg)]) : (Maybe Int)
      (case b
        [(basic-block (empty) (jump target))
         (just target)]
        [_ (nothing)]))))


(define (Reg) (remove-unused-blocks [blocks : (BlockMap Reg)])
  : (BlockMap Reg)
  (let ([live-blocks (set-add (find-live-blocks (block-map-blocks blocks))
                              (block-map-entry-block blocks))])
    (case (validate-block-map
            (unvalidated-block-map-filter
              (block-map->unvalidated-block-map blocks)
              (lambda ([key : Int] [b : (BasicBlock Reg)]) : Boolean
                (set-member? live-blocks key))))
      [(left msg) (panic msg)]
      [(right v) v])))

(define (Reg) (find-live-blocks
                [blocks : (Dict Int (BasicBlock Reg))])
  : (Set Int)
  (foldl
    (lambda ([b : (BasicBlock Reg)] [acc : (Set Int)])
      (case b
        [(basic-block _ (jump target))
         (set-add acc target)]
        [(basic-block _ (fall-through target))
         (set-add acc target)]
        [(basic-block _ (cond-jump/false-fall-through _ t f))
         (set-add (set-add acc t) f)]
        [(basic-block _ (return _))
         acc]
        [(basic-block _ (halt))
         acc]))
    (dict-values blocks)
    (make-set =)))

(define (Reg) (remove-no-op-instructions
                [reg=? : (Reg Reg -> Boolean)]
                [blocks : (BlockMap Reg)])
  : (BlockMap Reg)
  (case (validate-block-map
          (unvalidated-block-map-map
            (block-map->unvalidated-block-map blocks)
            (lambda ([index : Int] [b : (BasicBlock Reg)])
              (case b
                [(basic-block instructions terminal)
                 (basic-block
                   (filter
                     (lambda ([i : (Instruction Reg)])
                       (not (no-op-instruction? i reg=?)))
                     instructions)
                   terminal)]))))
    [(left msg) (panic msg)]
    [(right v) v]))

(define (Reg) (no-op-instruction? [i : (Instruction Reg)] [reg=? : (Reg Reg -> Boolean)]) : Boolean
  (case i
    [(move r1 r2)
     (reg=? r1 r2)]
    [(subtract-immediate r1 amount)
     (= 0 amount)]
    [_ #f]))

(define (Reg) (add-unambiguous-fall-through [blocks : (BlockMap Reg)])
   : (BlockMap Reg)
   (case (validate-block-map
           (unvalidated-block-map-map
             (block-map->unvalidated-block-map blocks)
             (lambda ([int : Int] [b : (BasicBlock Reg)]) : (BasicBlock Reg)
               (case b
                 [(basic-block insts (jump target))
                  (if (= 1 (set-count (set-multi-dict-ref/empty
                                        (block-map-predecessors blocks) target)))
                      (basic-block insts (fall-through target))
                      b)]
                 [_ b]))))
     [(left msg) (panic msg)]
     [(right v) v]))

(define (Reg) (construct-combined-block [prefix : (List (Instruction Reg))] [block : Int]
                                        [blocks : (BlockMap Reg)]) : (BasicBlock Reg)
  (case (dict-ref (block-map-blocks blocks) block)
    [(nothing) (panic #"Block not found")]
    [(just (basic-block next-insts term))
     (case term
       [(fall-through t)
        (if (= 1 (set-count (set-multi-dict-ref/empty (block-map-predecessors blocks) t)))
            (construct-combined-block (append prefix next-insts) t blocks)
            (basic-block (append prefix next-insts) term))]
       [_
        (basic-block (append prefix next-insts) term)])]))


(define (Reg) (remove-single-fallthrough-targets [blocks : (BlockMap Reg)])
  : (UnvalidatedBlockMap Reg)
  (foldl
    (lambda ([block : Int] [acc : (UnvalidatedBlockMap Reg)]) : (UnvalidatedBlockMap Reg)
      (if (= 1 (set-count (set-multi-dict-ref/empty (block-map-predecessors blocks) block)))
          (case (unique-dict-reverse-ref (block-map-fall-through blocks) block)
            [(nothing) (panic #"Missing block")]
            [(just block-num)
             (case (dict-ref (block-map-blocks blocks) block-num)
               [(nothing) (panic #"Missing block")]
               [(just (basic-block inst (fall-through _)))
                (unvalidated-block-map-remove-block acc block)]
               [_ acc])])
          acc))
    (set->list (unique-dict-reverse-keys (block-map-fall-through blocks)))
    (block-map->unvalidated-block-map blocks)))

(define (Reg) (collapse-single-fallthroughs [blocks : (BlockMap Reg)])
  : (BlockMap Reg)
  (case (validate-block-map
          (unvalidated-block-map-map
            (remove-single-fallthrough-targets blocks)
            (lambda ([int : Int] [b : (BasicBlock Reg)]) : (BasicBlock Reg)
              (construct-combined-block (empty) int blocks))))
    [(left msg) (panic msg)]
    [(right v) v]))
