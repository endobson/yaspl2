#:module (lowered-register-language-to-x86-64)
#:import {
  (bytes)
  (dict)
  (either)
  (join-list)
  (list)
  (lower-x86-64) {
    #:types
      X8664Register
    #:values
      rbp
      rsp
    #:patterns
      r10
      r11
      r12
      r13
      r14
      r15
      r8
      r9
      rax
      rbp
      rbx
      rcx
      rdi
      rdx
      rsi
      rsp
  }
  (lowered-register-language)
  (maybe)
  (numbers)
  (prim)
  (prim-language) {
    #:values
      sub
    #:patterns
      and
      comparison-bin-op
      equal
      greater-than
      greater-than-or-equal
      less-than
      less-than-or-equal
      logical-bin-op
      mul
      not-equal
      numeric-bin-op
      or
      plus
      sub
  }
  (register-language) {
    #:patterns
      truncate-unsigned-int64->unsigned-int8
  }
  (set)
  (yaspl x86-64-assembly) {
    #:types
      [BasicBlock a:BasicBlock]
      [Instruction a:Instruction]
      [Register a:Register]
      TextFragment
    #:values
      addq
      [al a:al]
      andq
      [basic-block a:basic-block]
      [bl a:bl]
      [bpl a:bpl]
      call
      call/indirect
      [cl a:cl]
      cmpq
      [dil a:dil]
      [dl a:dl]
      function-fragment
      imm-s32
      imulq
      imulq/imm
      je
      jg
      jge
      jl
      jle
      jmp
      jne
      leaq/rip-rel
      mem
      movb
      movq
      movq/imm
      movzbq
      orq
      popq
      pushq
      [r10 a:r10]
      [r10b a:r10b]
      [r11 a:r11]
      [r11b a:r11b]
      [r12 a:r12]
      [r12b a:r12b]
      [r13 a:r13]
      [r13b a:r13b]
      [r14 a:r14]
      [r14b a:r14b]
      [r15 a:r15]
      [r15b a:r15b]
      [r8 a:r8]
      [r8b a:r8b]
      [r9 a:r9]
      [r9b a:r9b]
      [rax a:rax]
      [rbp a:rbp]
      [rbx a:rbx]
      [rcx a:rcx]
      [rdi a:rdi]
      [rdx a:rdx]
      reg
      repe-cmpsb
      ret
      rmi-imm
      [rsi a:rsi]
      [rsp a:rsp]
      [section a:section]
      sete
      setg
      setge
      setl
      setle
      setne
      [sil a:sil]
      subq
      [syscall a:syscall]
      test
      ud2
  }
}
(export
  #:types ()
  #:values (assign-registers function-definition->assembly-fragment)
  #:patterns ())
(types)

(define (Reg) (assign-registers [f : (FunctionDefinition Reg)] [assignment : (Reg -> X8664Register)])
  : (AssignedRegistersFunctionDefinition X8664Register)
  (match-define (function-definition name extra-temporaries blocks) f)

  (assigned-registers-function-definition
    name
    (add-entry-block
      (varargs list
        (push (rbp))
        (move (rbp) (rsp))
        (numeric-op-immediate (rsp) (sub) (s32 (* extra-temporaries 8))))
      (rename-registers/block-map blocks assignment))))

(define (Reg) (add-entry-block [insts : (List (Instruction Reg))] [blocks : (BlockMap Reg)]) :
  (BlockMap Reg)
  (case (add-entry-block* insts blocks)
    [(left v) (panic v)]
    [(right v) v]))

(define (Reg) (add-entry-block* [insts : (List (Instruction Reg))] [blocks : (BlockMap Reg)]) :
  (Either Bytes (BlockMap Reg))
  (let ([new-entry-block
          (+ 1
            (foldl
              (lambda ([x : Int] [y : Int]) (if (< x y) y x))
              (set->list (dict-keys (block-map-blocks blocks)))
              (block-map-entry-block blocks)))])
    (validate-block-map
      (unvalidated-block-map-add-block
        (unvalidated-block-map-set-entry
          (block-map->unvalidated-block-map blocks)
          new-entry-block)
        new-entry-block
        (basic-block insts (jump (block-map-entry-block blocks)))))))

(define (function-definition->assembly-fragment
          [f : (AssignedRegistersFunctionDefinition X8664Register)]) : TextFragment
  (match-define (assigned-registers-function-definition name blocks) f)
  (match-define block-prefix (bytes-append (varargs list name #"_")))
  (match-define block-chains (block-map-block-chains blocks))
  ;; TODO Don't require a basic block with the name of the function
  (function-fragment name
    (cons
      (a:section (varargs list (a:basic-block name (empty-jl))))
      (map
        (lambda ([chain : (List Int)])
          (a:section
            (map
              (lambda ([block-num : Int]) : a:BasicBlock
                (case (dict-ref (block-map-blocks blocks) block-num)
                  [(nothing) (panic #"No such block")]
                  [(just b)
                   (convert-block block-prefix block-num b)]))
              chain)))
        block-chains))))

(define (convert-block [block-prefix : Bytes] [block-num : Int] [b : (BasicBlock X8664Register)]) : a:BasicBlock
  (match-define (basic-block instructions terminal) b)
  (a:basic-block
    (make-block-label block-prefix block-num)
    (append-jl (concat-jl (map convert-instruction instructions))
               (convert-terminal block-prefix terminal))))

(define (make-block-label [block-prefix : Bytes] [block-num : Int]) : Bytes
  (bytes-append (varargs list block-prefix (integer->decimal-bytes block-num))))

(define (convert-register [r : X8664Register]) : a:Register
  (case r
    [(rax) (a:rax)]
    [(rbx) (a:rbx)]
    [(rcx) (a:rcx)]
    [(rdx) (a:rdx)]
    [(rdi) (a:rdi)]
    [(rsi) (a:rsi)]
    [(rbp) (a:rbp)]
    [(rsp) (a:rsp)]
    [(r8) (a:r8)]
    [(r9) (a:r9)]
    [(r10) (a:r10)]
    [(r11) (a:r11)]
    [(r12) (a:r12)]
    [(r13) (a:r13)]
    [(r14) (a:r14)]
    [(r15) (a:r15)]))

(define (convert-register/8 [r : X8664Register]) : a:Register
  (case r
    [(rax) (a:al)]
    [(rbx) (a:bl)]
    [(rcx) (a:cl)]
    [(rdx) (a:dl)]
    [(rdi) (a:dil)]
    [(rsi) (a:sil)]
    [(rbp) (a:bpl)]
    [(r8) (a:r8b)]
    [(r9) (a:r9b)]
    [(r10) (a:r10b)]
    [(r11) (a:r11b)]
    [(r12) (a:r12b)]
    [(r13) (a:r13b)]
    [(r14) (a:r14b)]
    [(r15) (a:r15b)]
    [(rsp) (panic #"No corresponding 8bit register for rsp")]))



(define (convert-instruction [i : (Instruction X8664Register)]) : (JoinList a:Instruction)
  (case i
    [(int-literal r v)
     (single-jl (movq/imm (int->eight-bytes-le v) (convert-register r)))]
    [(symbol-address r sym)
     (single-jl (leaq/rip-rel sym (convert-register r)))]
    ;; TODO check that the registers are sensible for function calls
    [(function-call-inst _ (syscall _) _ _)
     (single-jl (a:syscall))]
    [(function-call-inst _ (direct-call f) _ _)
     (single-jl (call f))]
    [(function-call-inst _ (indirect-function-call f) _ _)
     (single-jl (call/indirect (reg (convert-register f))))]
    [(function-call-inst _ (closure-call c) _ _)
     (single-jl (call/indirect (mem (convert-register c) 0)))]
    [(move out in)
     (single-jl (movq (reg (convert-register in)) (reg (convert-register out))))]
    [(push in)
     (single-jl (pushq (reg (convert-register in))))]
    [(pop out)
     (single-jl (popq (reg (convert-register out))))]
    [(store-8byte loc offset val)
     (single-jl (movq (reg (convert-register val)) (mem (convert-register loc) offset)))]
    [(store-least-significant-byte loc offset val)
     (single-jl (movb (reg (convert-register/8 val)) (mem (convert-register loc) offset)))]
    [(store-temporary index val)
     (single-jl (movq (reg (convert-register val)) (mem (a:rbp) (* (+ index 1) (- 0 8)))))]
    [(load-8byte out loc offset)
     (single-jl (movq (mem (convert-register loc) offset) (reg (convert-register out))))]
    [(load-zero-extended-byte out loc offset)
     (single-jl (movzbq (mem (convert-register loc) offset) (convert-register out)))]
    [(load-temporary out index)
     (single-jl (movq (mem (a:rbp) (* (+ index 1) (- 0 8))) (reg (convert-register out))))]
    [(unary-op-inst out (truncate-unsigned-int64->unsigned-int8) in)
     (single-jl (movzbq (reg (convert-register in)) (convert-register out)))]
    [(bin-op-inst out (numeric-bin-op (plus)) in)
     (single-jl (addq (reg (convert-register in)) (convert-register out)))]
    [(numeric-op-immediate out (plus) v)
     (single-jl (addq (rmi-imm (imm-s32 v)) (convert-register out)))]
    [(bin-op-inst out (numeric-bin-op (sub)) in)
     (single-jl (subq (reg (convert-register in)) (convert-register out)))]
    [(numeric-op-immediate out (sub) v)
     (single-jl (subq (rmi-imm (imm-s32 v)) (convert-register out)))]
    [(bin-op-inst out (numeric-bin-op (mul)) in)
     (single-jl (imulq (convert-register in) (convert-register out)))]
    [(numeric-op-immediate out (mul) v)
     (single-jl (imulq/imm v (reg (convert-register out)) (convert-register out)))]
    [(bin-op-inst out (logical-bin-op (and)) in)
     (single-jl (andq (reg (convert-register in)) (convert-register out)))]
    [(bin-op-inst out (logical-bin-op (or)) in)
     (single-jl (orq (convert-register in) (convert-register out)))]
    [(bin-op-inst out (comparison-bin-op op) in)
     (varargs join-list
       (cmpq (reg (convert-register in)) (reg (convert-register out)))
       (case op
         [(equal) (sete (convert-register/8 out))]
         [(not-equal) (setne (convert-register/8 out))]
         [(less-than) (setl (convert-register/8 out))]
         [(greater-than) (setg (convert-register/8 out))]
         [(less-than-or-equal) (setle (convert-register/8 out))]
         [(greater-than-or-equal) (setge (convert-register/8 out))])
       (movzbq (reg (convert-register/8 out)) (convert-register out)))]
    ;; TODO check that these are the right registers
    [(compare-memory out _ _ _)
     (varargs join-list
       (repe-cmpsb)
       (sete (convert-register/8 out))
       (movzbq (reg (convert-register/8 out)) (convert-register out)))]))

(define (convert-terminal [block-prefix : Bytes] [t : (Terminal X8664Register)]) : (JoinList a:Instruction)
  (case t
    ;; TODO investigating making this not have a register
    [(return _)
     (varargs join-list
       (movq (reg (a:rbp)) (reg (a:rsp)))
       (popq (reg (a:rbp)))
       (ret))]
    [(halt)
     (single-jl (ud2))]
    [(jump block-num)
     (single-jl (jmp (make-block-label block-prefix block-num)))]
    [(fall-through block-num)
     (empty-jl)]
    [(cond-jump/false-fall-through (reg-condition c) t-block-num f-block-num)
     (varargs join-list
       (test (reg (convert-register c)) (reg (convert-register c)))
       (jne (make-block-label block-prefix t-block-num)))]
    [(cond-jump/false-fall-through (negated-reg-condition c) t-block-num f-block-num)
     (varargs join-list
       (test (reg (convert-register c)) (reg (convert-register c)))
       (je (make-block-label block-prefix t-block-num)))]
    [(cond-jump/false-fall-through (comparison-condition c reg1 reg2) t-block-num f-block-num)
     (varargs join-list
       (cmpq (reg (convert-register reg2)) (reg (convert-register reg1)))
       ((case c
         [(equal) je]
         [(not-equal) jne]
         [(less-than) jg]
         [(greater-than) jl]
         [(less-than-or-equal) jle]
         [(greater-than-or-equal) jge])
        (make-block-label block-prefix t-block-num)))]
    ;; TODO check that these are the right registers
    [(cond-jump/false-fall-through (memory-compare-condition negated? _ _ _) t-block-num f-block-num)
     (varargs join-list
       (repe-cmpsb)
       ((if negated? jne je) (make-block-label block-prefix t-block-num)))]))
