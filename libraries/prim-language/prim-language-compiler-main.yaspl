#:module (prim-language-compiler-main)
#:import {
  (bytes)
  (color-graph)
  (dict)
  (either)
  (io)
  (join-list)
  (list)
  (lower-x86-64) {
    #:types
      Reg
      X8664Register
    #:values
      lower-function
      reg=?
      x86-64-register=?
    #:patterns
      fixed-reg
      temporary-reg
  }
  (lowered-live-variables) {
    #:values
      blocks->live-out-states
      live-variables
  }
  (lowered-register-language) {
    #:types
      [FunctionDefinition l:FunctionDefinition]
    #:values
      rename-registers/function-definition
  }
  (lowered-register-language-to-x86-64) {
    #:values
      function-definition->assembly-fragment
  }
  (mach-o-writer2) {
    #:values
      write-mach-o-library/fragments
  }
  (maybe)
  (prim)
  (prim-language) {
    #:types
      [FunctionDefinition p:FunctionDefinition]
      [Module p:Module]
    #:values
      [function-definition->function-type p:function-definition->function-type]
      [function-definition-name p:function-definition-name]
    #:patterns
      [function-type p:function-type]
      [int64-type p:int64-type]
      [module p:module]
  }
  (prim-language-parser) {
    #:values
      parse-module
  }
  (prim-language-type-checker) {
    #:values
      type-check
  }
  (prim-to-register) {
    #:values
      convert-function
  }
  (register-language) {
    #:types
      Var
  }
  (sexp-parser) {
    #:values
      parse-single-sexp
  }
  (simplify-lowered-register-language) {
    #:values
      [simplify-function-definition l:simplify-function-definition]
  }
  (simplify-register-language) {
    #:values
      [simplify-function-definition r:simplify-function-definition]
  }
  (spill-lowered-register-language) {
    #:values
      spill-variables
  }
  (tuples) {
    #:types
      Tuple2
    #:values
      tuple2
    #:patterns
      tuple2
  }
  (x86-64-stack-machine) {
    #:types
      TextFragment
    #:values
      assembly-fragments
      basic-block
      call
      function-fragment
      imm
      jmp
      mem
      movq
      rax
      rdi
      reg
      rsp
      section
      syscall
  }
}
(export)
(types)


(define (start-function-fragment [main-function-name : Bytes]) : TextFragment
  (function-fragment
    #"start"
    (varargs list
      (section
        (varargs list
          (basic-block #"start"
            (varargs join-list
              (jmp #"start_break")))
          (basic-block #"start_break"
            (varargs join-list
              (movq (mem (rsp) 0) (reg (rdi)))
              (call main-function-name)
              (movq (reg (rax)) (reg (rdi)))
              (movq (imm #x2000001) (reg (rax)))
              (syscall))))))))

(define (parse-args [args : (List Bytes)]) : (Either Bytes (Tuple2 Bytes Bytes))
  (case args
    [(empty)
     (left #"No executable???")]
    [(cons _ (empty))
     (left #"No file name provided.")]
    [(cons _ (cons _ (empty)))
     (left #"No output file name provided.")]
    [(cons _ (cons _ (cons _ (cons _ _))))
     (left #"Too many arguments.")]
    [(cons _ (cons file-name (cons out-file-name (empty))))
     (right (tuple2 file-name out-file-name))]))

(define (color-function [f : (l:FunctionDefinition Reg)])
  : (Tuple2 (l:FunctionDefinition Reg) (Dict Var X8664Register))
  (let ([live (live-variables f reg=?)])
    (let ([live-outs (blocks->live-out-states live)])
      (case (color-graph (initial-state live-outs))
        [(left vs)
         (color-function (spill-variables f vs))]
        [(right assignments)
         (tuple2 f assignments)]))))

(define (compile-functions [fs : (List p:FunctionDefinition)] [acc : (List TextFragment)])
  : (Either Bytes (List TextFragment))
  (case fs
    [(empty) (right acc)]
    [(cons f fs)
     (case (compile-function f)
       [(left v) (left v)]
       [(right fragment) (compile-functions fs (cons fragment acc))])]))

(define (compile-function [f : p:FunctionDefinition]) : (Either Bytes TextFragment)
  (let ([f (r:simplify-function-definition (convert-function f))])
    (case (color-function (lower-function f))
      [(tuple2 lowered assignments)
       (let ([opt-f
              (l:simplify-function-definition
                (rename-registers/function-definition
                  lowered
                  (lambda ([r : Reg]) : X8664Register
                    (case r
                      [(fixed-reg r) r]
                      [(temporary-reg v)
                       (case (dict-ref assignments v)
                         [(nothing) (panic #"No assignment")]
                         [(just r) r])])))
                x86-64-register=?)])
         (right (function-definition->assembly-fragment opt-f)))])))

(define (compile-prim-program [file-bytes : Bytes]) : (Either Bytes (List TextFragment))
  (case (parse-single-sexp file-bytes)
    [(left v)
     (left v)]
    [(right sexp)
     (case (parse-module sexp)
       [(left v)
        (left v)]
       [(right module)
        (case (type-check module)
          [(just v) (left v)]
          [(nothing)
           (case (check-main-function module)
             [(just v) (left v)]
             [(nothing)
              (case module
                [(p:module name functions)
                 (compile-functions
                   functions
                   (varargs list
                     (start-function-fragment #"main")))])])])])]))

(define (check-main-function [module : p:Module]) : (Maybe Bytes)
  (case module
    [(p:module name functions)
     (case (findf (lambda ([f : p:FunctionDefinition])
                     (bytes=? #"main" (p:function-definition-name f))) functions)
       [(nothing) (just #"No main function")]
       [(just f)
        (case (p:function-definition->function-type f)
          [(p:function-type (cons (p:int64-type) (empty)) (p:int64-type))
           (nothing)]
          [_ (just #"Main function has wrong type")])])]))

(define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]): Int
  (case (parse-args (array->list args))
    [(left msg)
     (begin
       (write-line msg stderr)
       1)]
    [(right (tuple2 file-name out-file-name))
     (case (compile-prim-program (call-with-input-file file-name read-all-bytes))
       [(left msg)
        (begin
          (write-line msg stderr)
          1)]
       [(right fragments)
        (case (write-mach-o-library/fragments out-file-name
                                              (assembly-fragments fragments (empty)))
          [(left msg)
           (begin
             (write-line msg stderr)
             1)]
          [(right _)
           0])])]))
