#:module (prim-language-parser)
#:import {
  (either) {
    #:types
      Either
    #:values
      left
      right
    #:patterns
      left
      right
  }
  (list) {
    #:values
      extract-rights
      map
    #:patterns
      cons
      empty
  }
  (prim) {
    #:types
      Bytes
  }
  (prim-language) {
    #:types
      BinOp
      Conversion
      Expr
      FunctionDefinition
      Module
      Statement
      Type
    #:values
      allocate-array-expr
      and
      array-ref-expr
      array-type
      assignment
      bin-op-expr
      boolean-type
      cast-expr
      comparison-bin-op
      declaration
      equal
      function-definition
      greater-than
      greater-than-or-equal
      if-statement
      int-literal
      int64-type
      int8-type
      less-than
      less-than-or-equal
      logical-bin-op
      module
      mul
      numeric-bin-op
      or
      plus
      pointer-assignment
      pointer-ref-expr
      pointer-type
      return
      sub
      syscall-expr
      truncate-unsigned-int64->unsigned-int8
      unsigned-int8->unsigned-int64
      var-expr
      while
  }
  (sexp-parser)
  (syscalls) {
    #:types
      Syscall
    #:values
      exit-syscall
      write-syscall
  }
  (tuples)
}
(export
  #:types ()
  #:values (parse-module)
  #:patterns ())
(types)



(define (parse-module [sexp : Sexp]) : (Either Bytes Module)
  (case sexp
    [(node (cons (symbol-sexp #"module") (cons (symbol-sexp name) definitions)))
     (case (extract-rights (map parse-function-definition definitions))
       [(left v) (left v)]
       [(right definitions)
        (right (module name definitions))])]
    [_
     (left #"Not a valid module form")]))

(define (parse-function-definition [sexp : Sexp]) : (Either Bytes FunctionDefinition)
  (case sexp
    [(node (cons (symbol-sexp #"define") (cons (node (cons (symbol-sexp name) args)) statements)))
     (case (extract-rights (map parse-arg args))
       [(left v) (left v)]
       [(right args)
        (case (extract-rights (map parse-statement statements))
          [(left v) (left v)]
          [(right statements)
           (right (function-definition name args statements))])])]
    [_
     (left #"Not a valid function definition")]))

(define (parse-arg [sexp : Sexp]) : (Either Bytes (Tuple2 Bytes Type))
  (case sexp
    [(bracket-node (cons (symbol-sexp v) (cons (symbol-sexp #":") (cons type (empty)))))
     (case (parse-type type)
       [(left v) (left v)]
       [(right ty)
        (right (tuple2 v ty))])]
    [_ (left #"Not a valid arg")]))

(define (parse-statement [sexp : Sexp]) : (Either Bytes Statement)
  (case sexp
    [(node (cons (symbol-sexp #"return") (cons expr (empty))))
     (case (parse-expr expr)
       [(left v) (left v)]
       [(right v) (right (return v))])]
    [(node (cons (symbol-sexp #"def") (cons (symbol-sexp name) (cons expr (empty)))))
     (case (parse-expr expr)
       [(left v) (left v)]
       [(right v) (right (declaration name v))])]
    [(node (cons (symbol-sexp #"if")
                 (cons cond
                       (cons (node (cons (symbol-sexp #"then") then-statements))
                             (cons (node (cons (symbol-sexp #"else") else-statements))
                                   (empty))))))
     (case (parse-expr cond)
       [(left v) (left v)]
       [(right cond)
        (case (extract-rights (map parse-statement then-statements))
          [(left v) (left v)]
          [(right then-statements)
           (case (extract-rights (map parse-statement else-statements))
             [(left v) (left v)]
             [(right else-statements)
              (right (if-statement cond then-statements else-statements))])])])]
    [(node (cons (symbol-sexp #"set!")
                 (cons (symbol-sexp var)
                       (cons expr (empty)))))
     (case (parse-expr expr)
       [(left v) (left v)]
       [(right expr)
        (right (assignment var expr))])]
    [(node (cons (symbol-sexp #"ptr-set!")
                 (cons pointer-expr (cons expr (empty)))))
     (case (parse-expr pointer-expr)
       [(left v) (left v)]
       [(right pointer-expr)
        (case (parse-expr expr)
          [(left v) (left v)]
          [(right expr)
           (right (pointer-assignment pointer-expr expr))])])]
    [(node (cons (symbol-sexp #"while")
                 (cons cond body)))
     (case (parse-expr cond)
       [(left v) (left v)]
       [(right cond)
        (case (extract-rights (map parse-statement body))
          [(left v) (left v)]
          [(right body)
           (right (while cond body))])])]
    [_
     (left #"Not a valid statement")]))

(define (parse-expr [sexp : Sexp]) : (Either Bytes Expr)
  (case sexp
    [(symbol-sexp v) (right (var-expr v))]
    [(number-sexp v) (right (int-literal v))]
    [(node (cons (symbol-sexp #"allocate-array") (cons type (cons expr (empty)))))
     (case (parse-type type)
       [(left v) (left v)]
       [(right type)
        (case (parse-expr expr)
          [(left v) (left v)]
          [(right count) (right (allocate-array-expr type count))])])]
    [(node (cons (symbol-sexp #"ptr-ref") (cons expr (empty))))
     (case (parse-expr expr)
       [(left v) (left v)]
       [(right pointer) (right (pointer-ref-expr pointer))])]
    [(node (cons (symbol-sexp #"array-ref") (cons type (cons array (cons offset (empty))))))
     (case (parse-type type)
       [(left v) (left v)]
       [(right type)
        (case (parse-expr array)
          [(left v) (left v)]
          [(right array)
           (case (parse-expr offset)
             [(left v) (left v)]
             [(right offset) (right (array-ref-expr type array offset))])])])]
    [(node (cons (symbol-sexp #"syscall") (cons (symbol-sexp syscall-name) args)))
     (case (parse-syscall-name syscall-name)
       [(left v) (left v)]
       [(right syscall)
        (case (extract-rights (map parse-expr args))
          [(left v) (left v)]
          [(right exprs)
           (right (syscall-expr syscall exprs))])])]
    [(node (cons (symbol-sexp #"cast") (cons conversion (cons expr (empty)))))
     (case (parse-conversion conversion)
       [(left v) (left v)]
       [(right conversion)
        (case (parse-expr expr)
          [(left v) (left v)]
          [(right expr)
           (right (cast-expr conversion expr))])])]
    [(node (cons (symbol-sexp op) (cons left-expr (cons right-expr (empty)))))
     (case (parse-bin-op op)
       [(left v) (left v)]
       [(right op)
        (case (parse-expr left-expr)
          [(left v) (left v)]
          [(right left-expr)
           (case (parse-expr right-expr)
             [(left v) (left v)]
             [(right right-expr)
              (right (bin-op-expr op left-expr right-expr))])])])]
    [_ (left #"Not a valid expression")]))

(define (parse-syscall-name [name : Bytes]) : (Either Bytes Syscall)
  (case name
    [#"exit" (right (exit-syscall))]
    [#"write" (right (write-syscall))]
    [_  (left #"Unknown syscall name")]))

(define (parse-bin-op [op : Bytes]) : (Either Bytes BinOp)
  (case op
    [#"+" (right (numeric-bin-op (plus)))]
    [#"*" (right (numeric-bin-op (mul)))]
    [#"-" (right (numeric-bin-op (sub)))]
    [#"and" (right (logical-bin-op (and)))]
    [#"or" (right (logical-bin-op (or)))]
    [#"<" (right (comparison-bin-op (less-than)))]
    [#"<=" (right (comparison-bin-op (less-than-or-equal)))]
    [#">" (right (comparison-bin-op (greater-than)))]
    [#">=" (right (comparison-bin-op (greater-than-or-equal)))]
    [#"=" (right (comparison-bin-op (equal)))]
    [_ (left #"Not a valid bin-op")]))

(define (parse-conversion [sexp : Sexp]) : (Either Bytes Conversion)
  (case sexp
    [(symbol-sexp #"int64->int8")
     (right (truncate-unsigned-int64->unsigned-int8))]
    [(symbol-sexp #"int8->int64")
     (right (unsigned-int8->unsigned-int64))]
    [_ (left #"Not a valid conversion")]))

(define (parse-type [sexp : Sexp]) : (Either Bytes Type)
  (case sexp
    [(symbol-sexp #"int64") (right (int64-type))]
    [(symbol-sexp #"int8") (right (int8-type))]
    [(symbol-sexp #"boolean") (right (boolean-type))]
    [(node (cons (symbol-sexp #"pointer") (cons sexp (empty))))
     (case (parse-type sexp)
       [(left v) (left v)]
       [(right t) (right (pointer-type t))])]
    [(node (cons (symbol-sexp #"array") (cons sexp (empty))))
     (case (parse-type sexp)
       [(left v) (left v)]
       [(right t) (right (array-type t))])]
    [_ (left #"Not a valid type")]))
