#:module (prim-language-parser)
#:import {
  (bytes)
  (dict)
  (either)
  (list)
  (maybe)
  (prim)
  (prim-language)
  (sexp-parser)
  (sexp-printer)
  (syscalls)
  (tuples)
  (yaspl math-operations)
}
(export
  (#:types)
  (#:values parse-module)
  (#:patterns))
(types
  (define-type ParseEnvironment
    (parse-environment
      [types : (Dict Bytes MemoryType)])))

(define (parse-module [sexp : Sexp]) : (Either Bytes Module)
  (case sexp
    [(node (cons (symbol-sexp #"module")
                 (cons (symbol-sexp name)
                       (cons (node (cons (symbol-sexp #"types") (empty)))
                             definitions))))
     (match-define env (initial-parse-env))
     (case (extract-rights
             (map (lambda ([sexp : Sexp])
                    (parse-function-definition sexp env))
                  definitions))
       [(left v) (left v)]
       [(right definitions)
        (right (module name (void) definitions))])]
    [_
     (left #"Not a valid module form")]))

(define (initial-parse-env) : ParseEnvironment
  (parse-environment
    (dict-add-all
      (make-dict bytes-cmp)
      (varargs list
        (tuple2 #"int64" (value-type (int64-type)))
        (tuple2 #"int8" (value-type (int8-type)))
        (tuple2 #"boolean" (value-type (boolean-type)))
        (tuple2 #"undetermined-pointer" (value-type (undetermined-pointer-type)))))))

(define (parse-function-definition [sexp : Sexp] [env : ParseEnvironment]) : (Either Bytes FunctionDefinition)
  (case sexp
    [(node (cons (symbol-sexp #"define")
                 (cons (node (cons (symbol-sexp name) args))
                       (cons (symbol-sexp #":")
                             (cons type statements)))))
     (case (extract-rights (map (lambda ([sexp : Sexp]) (parse-arg sexp env)) args))
       [(left v) (left v)]
       [(right args)
        (case (parse-type type env)
          [(left v) (left v)]
          [(right type)
           (case (extract-rights (map (lambda ([sexp : Sexp]) (parse-statement sexp env)) statements))
             [(left v) (left v)]
             [(right statements)
              (right (function-definition name args type statements))])])])]
    [_
     (left #"Not a valid function definition")]))

(define (parse-arg [sexp : Sexp] [env : ParseEnvironment]) : (Either Bytes (Tuple2 Bytes Type))
  (case sexp
    [(bracket-node (cons (symbol-sexp v) (cons (symbol-sexp #":") (cons type (empty)))))
     (case (parse-type type env)
       [(left v) (left v)]
       [(right ty)
        (right (tuple2 v ty))])]
    [_ (left #"Not a valid arg")]))

(define (parse-statement [sexp : Sexp] [env : ParseEnvironment]) : (Either Bytes Statement)
  (match-define parse-statement*
    (lambda ([sexp : Sexp]) (parse-statement sexp env)))
  (case sexp
    [(node (cons (symbol-sexp #"return") (cons expr (empty))))
     (case (parse-expr expr env)
       [(left v) (left v)]
       [(right v) (right (return v))])]
    [(node (cons (symbol-sexp #"def") (cons (symbol-sexp name) (cons expr (empty)))))
     (case (parse-expr expr env)
       [(left v) (left v)]
       [(right v) (right (declaration name v))])]
    [(node (cons (symbol-sexp #"if")
                 (cons cond
                       (cons (node (cons (symbol-sexp #"then") then-statements))
                             (cons (node (cons (symbol-sexp #"else") else-statements))
                                   (empty))))))
     (case (parse-expr cond env)
       [(left v) (left v)]
       [(right cond)
        (case (extract-rights (map parse-statement* then-statements))
          [(left v) (left v)]
          [(right then-statements)
           (case (extract-rights (map parse-statement* else-statements))
             [(left v) (left v)]
             [(right else-statements)
              (right (if-statement cond then-statements else-statements))])])])]
    [(node (cons (symbol-sexp #"set!")
                 (cons (symbol-sexp var)
                       (cons expr (empty)))))
     (case (parse-expr expr env)
       [(left v) (left v)]
       [(right expr)
        (right (assignment var expr))])]
    [(node (cons (symbol-sexp #"ptr-set!")
                 (cons pointer-expr (cons expr (empty)))))
     (case (parse-expr pointer-expr env)
       [(left v) (left v)]
       [(right pointer-expr)
        (case (parse-expr expr env)
          [(left v) (left v)]
          [(right expr)
           (right (pointer-assignment pointer-expr expr))])])]
    [(node (cons (symbol-sexp #"while")
                 (cons cond body)))
     (case (parse-expr cond env)
       [(left v) (left v)]
       [(right cond)
        (case (extract-rights (map parse-statement* body))
          [(left v) (left v)]
          [(right body)
           (right (while cond body))])])]
    [_
     (left #"Not a valid statement")]))

(define (parse-expr [sexp : Sexp] [env : ParseEnvironment]) : (Either Bytes Expr)
  (match-define parse-expr*
    (lambda ([sexp : Sexp]) (parse-expr sexp env)))
  (case sexp
    [(symbol-sexp v) (right (var-expr v))]
    [(number-sexp v) (right (int-literal v))]
    [(node (cons (symbol-sexp #"allocate-array") (cons type (cons expr (empty)))))
     (case (parse-type type env)
       [(left v) (left v)]
       [(right type)
        (case (parse-expr expr env)
          [(left v) (left v)]
          [(right count) (right (allocate-array-expr type count))])])]
    [(node (cons (symbol-sexp #"ptr-ref") (cons expr (empty))))
     (case (parse-expr expr env)
       [(left v) (left v)]
       [(right pointer) (right (pointer-ref-expr pointer))])]
    [(node (cons (symbol-sexp #"array-index") (cons type (cons pointer (cons offset (empty))))))
     (case (parse-memory-type type env)
       [(left v) (left v)]
       [(right type)
        (case (parse-expr pointer env)
          [(left v) (left v)]
          [(right pointer)
           (case (parse-expr offset env)
             [(left v) (left v)]
             [(right offset) (right (array-index-expr type pointer offset))])])])]
    [(node (cons (symbol-sexp #"syscall") (cons (symbol-sexp syscall-name) args)))
     (case (parse-syscall-name syscall-name)
       [(left v) (left v)]
       [(right syscall)
        (case (extract-rights (map parse-expr* args))
          [(left v) (left v)]
          [(right exprs)
           (right (syscall-expr syscall exprs))])])]
    [(node (cons (symbol-sexp #"call") (cons (symbol-sexp function-name) args)))
     (case (extract-rights (map parse-expr* args))
       [(left v) (left v)]
       [(right exprs)
        (right (call-expr function-name exprs))])]
    [(node (cons (symbol-sexp #"cast") (cons conversion (cons expr (empty)))))
     (case (parse-conversion conversion env)
       [(left v) (left v)]
       [(right conversion)
        (case (parse-expr expr env)
          [(left v) (left v)]
          [(right expr)
           (right (cast-expr conversion expr))])])]
    [(node (cons (symbol-sexp op) (cons left-expr (cons right-expr (empty)))))
     (case (parse-bin-op op)
       [(left v) (left v)]
       [(right op)
        (case (parse-expr left-expr env)
          [(left v) (left v)]
          [(right left-expr)
           (case (parse-expr right-expr env)
             [(left v) (left v)]
             [(right right-expr)
              (right (bin-op-expr op left-expr right-expr))])])])]
    [_ (left #"Not a valid expression")]))

(define (parse-syscall-name [name : Bytes]) : (Either Bytes Syscall)
  (case name
    [#"exit" (right (exit-syscall))]
    [#"write" (right (write-syscall))]
    [_  (left #"Unknown syscall name")]))

(define (parse-bin-op [op : Bytes]) : (Either Bytes BinOp)
  (case op
    [#"+" (right (numeric-bin-op (add-op)))]
    [#"*" (right (numeric-bin-op (mult-op)))]
    [#"-" (right (numeric-bin-op (sub-op)))]
    [#"/" (right (numeric-bin-op (quotient-op)))]
    [#"and" (right (logical-bin-op (and-op)))]
    [#"or" (right (logical-bin-op (ior-op)))]
    [#"<" (right (comparison-bin-op (less-than-op)))]
    [#"<=" (right (comparison-bin-op (less-than-or-equal-op)))]
    [#">" (right (comparison-bin-op (greater-than-op)))]
    [#">=" (right (comparison-bin-op (greater-than-or-equal-op)))]
    [#"=" (right (comparison-bin-op (equal-op)))]
    [#"!=" (right (comparison-bin-op (not-equal-op)))]
    [_ (left (bytes-append (varargs list #"Not a valid bin-op: " op)))]))

(define (parse-conversion [sexp : Sexp] [env : ParseEnvironment]) : (Either Bytes Conversion)
  (case sexp
    [(symbol-sexp #"int64->int8")
     (right (truncate-unsigned-int64->unsigned-int8))]
    [(symbol-sexp #"int8->int64")
     (right (unsigned-int8->unsigned-int64))]
    [(symbol-sexp #"pointer->int64")
     (right (pointer->unsigned-int64))]
    [(node (cons (symbol-sexp #"refine-pointer") (cons sexp (empty))))
     (case (parse-memory-type sexp env)
       [(left v) (left v)]
       [(right type)
        (right (refine-pointer type))])]
    [(node (cons (symbol-sexp #"unrefine-pointer") (cons sexp (empty))))
     (case (parse-memory-type sexp env)
       [(left v) (left v)]
       [(right type)
        (right (unrefine-pointer type))])]
    [_ (left (bytes-append (varargs list #"Not a valid conversion " (print-sexp sexp))))]))

(define (parse-memory-type [sexp : Sexp] [env : ParseEnvironment]) : (Either Bytes MemoryType)
  (case sexp
    [(node (cons (symbol-sexp #"pointer") (cons sexp (empty))))
     (case (parse-memory-type sexp env)
       [(left v) (left v)]
       [(right t) (right (value-type (pointer-type t)))])]
    [(node (cons (symbol-sexp #"array") (cons sexp (empty))))
     (case (parse-memory-type sexp env)
       [(left v) (left v)]
       [(right t) (right (array-type t))])]
    [(symbol-sexp sym)
     (case (dict-ref (parse-environment-types env) sym)
       [(just t) (right t)]
       [(nothing)
        (left (bytes-append (varargs list #"Unknown type name: " sym)))])]
    [_ (left (bytes-append (varargs list #"Not a valid type: " (print-sexp sexp))))]))

(define (parse-type [sexp : Sexp] [env : ParseEnvironment]) : (Either Bytes Type)
  (case (parse-memory-type sexp env)
    [(left v) (left v)]
    [(right (value-type t)) (right t)]
    [(right _)
     (left #"Type must be a value type")]))
