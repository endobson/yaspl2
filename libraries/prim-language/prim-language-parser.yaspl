#:module (prim-language-parser)
#:import {
  (bytes)
  (either)
  (list)
  (prim) {
    {#:types
      Bytes
    }
  }
  (prim-language)
  (sexp-parser)
  (sexp-printer)
  (syscalls)
  (tuples)
  (yaspl math-operations)
}
(export
  #:types ()
  #:values (parse-module)
  #:patterns ())
(types)

(define (parse-module [sexp : Sexp]) : (Either Bytes Module)
  (case sexp
    [(node (cons (symbol-sexp #"module") (cons (symbol-sexp name) definitions)))
     (case (extract-rights (map parse-function-definition definitions))
       [(left v) (left v)]
       [(right definitions)
        (right (module name definitions))])]
    [_
     (left #"Not a valid module form")]))

(define (parse-function-definition [sexp : Sexp]) : (Either Bytes FunctionDefinition)
  (case sexp
    [(node (cons (symbol-sexp #"define")
                 (cons (node (cons (symbol-sexp name) args))
                       (cons (symbol-sexp #":")
                             (cons type statements)))))
     (case (extract-rights (map parse-arg args))
       [(left v) (left v)]
       [(right args)
        (case (parse-type type)
          [(left v) (left v)]
          [(right type)
           (case (extract-rights (map parse-statement statements))
             [(left v) (left v)]
             [(right statements)
              (right (function-definition name args type statements))])])])]
    [_
     (left #"Not a valid function definition")]))

(define (parse-arg [sexp : Sexp]) : (Either Bytes (Tuple2 Bytes Type))
  (case sexp
    [(bracket-node (cons (symbol-sexp v) (cons (symbol-sexp #":") (cons type (empty)))))
     (case (parse-type type)
       [(left v) (left v)]
       [(right ty)
        (right (tuple2 v ty))])]
    [_ (left #"Not a valid arg")]))

(define (parse-statement [sexp : Sexp]) : (Either Bytes Statement)
  (case sexp
    [(node (cons (symbol-sexp #"return") (cons expr (empty))))
     (case (parse-expr expr)
       [(left v) (left v)]
       [(right v) (right (return v))])]
    [(node (cons (symbol-sexp #"def") (cons (symbol-sexp name) (cons expr (empty)))))
     (case (parse-expr expr)
       [(left v) (left v)]
       [(right v) (right (declaration name v))])]
    [(node (cons (symbol-sexp #"if")
                 (cons cond
                       (cons (node (cons (symbol-sexp #"then") then-statements))
                             (cons (node (cons (symbol-sexp #"else") else-statements))
                                   (empty))))))
     (case (parse-expr cond)
       [(left v) (left v)]
       [(right cond)
        (case (extract-rights (map parse-statement then-statements))
          [(left v) (left v)]
          [(right then-statements)
           (case (extract-rights (map parse-statement else-statements))
             [(left v) (left v)]
             [(right else-statements)
              (right (if-statement cond then-statements else-statements))])])])]
    [(node (cons (symbol-sexp #"set!")
                 (cons (symbol-sexp var)
                       (cons expr (empty)))))
     (case (parse-expr expr)
       [(left v) (left v)]
       [(right expr)
        (right (assignment var expr))])]
    [(node (cons (symbol-sexp #"ptr-set!")
                 (cons pointer-expr (cons expr (empty)))))
     (case (parse-expr pointer-expr)
       [(left v) (left v)]
       [(right pointer-expr)
        (case (parse-expr expr)
          [(left v) (left v)]
          [(right expr)
           (right (pointer-assignment pointer-expr expr))])])]
    [(node (cons (symbol-sexp #"while")
                 (cons cond body)))
     (case (parse-expr cond)
       [(left v) (left v)]
       [(right cond)
        (case (extract-rights (map parse-statement body))
          [(left v) (left v)]
          [(right body)
           (right (while cond body))])])]
    [_
     (left #"Not a valid statement")]))

(define (parse-expr [sexp : Sexp]) : (Either Bytes Expr)
  (case sexp
    [(symbol-sexp v) (right (var-expr v))]
    [(number-sexp v) (right (int-literal v))]
    [(node (cons (symbol-sexp #"allocate-array") (cons type (cons expr (empty)))))
     (case (parse-type type)
       [(left v) (left v)]
       [(right type)
        (case (parse-expr expr)
          [(left v) (left v)]
          [(right count) (right (allocate-array-expr type count))])])]
    [(node (cons (symbol-sexp #"ptr-ref") (cons expr (empty))))
     (case (parse-expr expr)
       [(left v) (left v)]
       [(right pointer) (right (pointer-ref-expr pointer))])]
    [(node (cons (symbol-sexp #"ptr-adjust") (cons type (cons pointer (cons offset (empty))))))
     (case (parse-type type)
       [(left v) (left v)]
       [(right type)
        (case (parse-expr pointer)
          [(left v) (left v)]
          [(right pointer)
           (case (parse-expr offset)
             [(left v) (left v)]
             [(right offset) (right (pointer-adjust-expr type pointer offset))])])])]
    [(node (cons (symbol-sexp #"syscall") (cons (symbol-sexp syscall-name) args)))
     (case (parse-syscall-name syscall-name)
       [(left v) (left v)]
       [(right syscall)
        (case (extract-rights (map parse-expr args))
          [(left v) (left v)]
          [(right exprs)
           (right (syscall-expr syscall exprs))])])]
    [(node (cons (symbol-sexp #"call") (cons (symbol-sexp function-name) args)))
     (case (extract-rights (map parse-expr args))
       [(left v) (left v)]
       [(right exprs)
        (right (call-expr function-name exprs))])]
    [(node (cons (symbol-sexp #"cast") (cons conversion (cons expr (empty)))))
     (case (parse-conversion conversion)
       [(left v) (left v)]
       [(right conversion)
        (case (parse-expr expr)
          [(left v) (left v)]
          [(right expr)
           (right (cast-expr conversion expr))])])]
    [(node (cons (symbol-sexp op) (cons left-expr (cons right-expr (empty)))))
     (case (parse-bin-op op)
       [(left v) (left v)]
       [(right op)
        (case (parse-expr left-expr)
          [(left v) (left v)]
          [(right left-expr)
           (case (parse-expr right-expr)
             [(left v) (left v)]
             [(right right-expr)
              (right (bin-op-expr op left-expr right-expr))])])])]
    [_ (left #"Not a valid expression")]))

(define (parse-syscall-name [name : Bytes]) : (Either Bytes Syscall)
  (case name
    [#"exit" (right (exit-syscall))]
    [#"write" (right (write-syscall))]
    [_  (left #"Unknown syscall name")]))

(define (parse-bin-op [op : Bytes]) : (Either Bytes BinOp)
  (case op
    [#"+" (right (numeric-bin-op (add-op)))]
    [#"*" (right (numeric-bin-op (mult-op)))]
    [#"-" (right (numeric-bin-op (sub-op)))]
    [#"/" (right (numeric-bin-op (quotient-op)))]
    [#"and" (right (logical-bin-op (and-op)))]
    [#"or" (right (logical-bin-op (ior-op)))]
    [#"<" (right (comparison-bin-op (less-than-op)))]
    [#"<=" (right (comparison-bin-op (less-than-or-equal-op)))]
    [#">" (right (comparison-bin-op (greater-than-op)))]
    [#">=" (right (comparison-bin-op (greater-than-or-equal-op)))]
    [#"=" (right (comparison-bin-op (equal-op)))]
    [#"!=" (right (comparison-bin-op (not-equal-op)))]
    [_ (left (bytes-append (varargs list #"Not a valid bin-op: " op)))]))

(define (parse-conversion [sexp : Sexp]) : (Either Bytes Conversion)
  (case sexp
    [(symbol-sexp #"int64->int8")
     (right (truncate-unsigned-int64->unsigned-int8))]
    [(symbol-sexp #"int8->int64")
     (right (unsigned-int8->unsigned-int64))]
    [(symbol-sexp #"pointer->int64")
     (right (pointer->unsigned-int64))]
    [(node (cons (symbol-sexp #"refine-pointer") (cons sexp (empty))))
     (case (parse-type sexp)
       [(left v) (left v)]
       [(right type)
        (right (refine-pointer type))])]
    [(node (cons (symbol-sexp #"unrefine-pointer") (cons sexp (empty))))
     (case (parse-type sexp)
       [(left v) (left v)]
       [(right type)
        (right (unrefine-pointer type))])]
    [_ (left (bytes-append (varargs list #"Not a valid conversion " (print-sexp sexp))))]))

(define (parse-type [sexp : Sexp]) : (Either Bytes Type)
  (case sexp
    [(symbol-sexp #"int64") (right (int64-type))]
    [(symbol-sexp #"int8") (right (int8-type))]
    [(symbol-sexp #"boolean") (right (boolean-type))]
    [(symbol-sexp #"undetermined-pointer") (right (undetermined-pointer-type))]
    [(node (cons (symbol-sexp #"pointer") (cons sexp (empty))))
     (case (parse-type sexp)
       [(left v) (left v)]
       [(right t) (right (pointer-type t))])]
    [_ (left (bytes-append (varargs list #"Not a valid type: " (print-sexp sexp))))]))
