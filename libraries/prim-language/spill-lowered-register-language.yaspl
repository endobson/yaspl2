#:module (spill-lowered-register-language)
#:import {
  (dict)
  (either)
  (list)
  (lower-x86-64)
  (lowered-live-variables)
  (lowered-register-language)
  (maybe)
  (prim)
  (set)
  (tuples)
  (yaspl var)
}
(export
  #:types ()
  #:values (spill-variables)
  #:patterns ())
(types)

(define (spill-variables [f : (FunctionDefinition Reg)] [vars : (Set Var)]) : (FunctionDefinition Reg)
  (match-define (function-definition name num-temporaries block-map) f)
  (match-define (tuple2 new-num-temporaries spilled)
    (set-fold
      vars
      (lambda ([v : Var] [acc : (Tuple2 Int (Dict Var Int))])
        (case acc
          [(tuple2 num-temp dict)
           (tuple2 (+ 1 num-temp) (dict-add dict v num-temp))]))
      (tuple2 num-temporaries (ann (Dict Var Int) (make-dict var-cmp)))))
  (match-define next-var (compute-next-var block-map))
  (match-define (tuple2 unvalidated-block-map next-var)
    (unvalidated-block-map-map/acc
      (block-map->unvalidated-block-map block-map)
      (lambda ([index : Int] [b : (BasicBlock Reg)] [next-var : Int])
        (spill-variables/block b spilled next-var))
      next-var))
  (case (validate-block-map unvalidated-block-map)
    [(left v) (panic v)]
    [(right block-map)
     (function-definition name new-num-temporaries block-map)]))

(define (compute-next-var [blocks : (BlockMap Reg)]) : Int
  (foldl
    (lambda ([s : (Set Var)] [next-var : Int])
      (set-fold
        s
        (lambda ([v : Var] [next-var : Int])
          (case v
            [(var _ c)
             (if (< c next-var)
                 next-var
                 (+ 1 c))]))
        next-var))
    (dict-map
      (block-map-blocks blocks)
      (lambda ([i : Int] [b : (BasicBlock Reg)])
        (used-vars/block b)))
    0))

(define (used-vars/block [b : (BasicBlock Reg)]) : (Set Var)
  (match-define (basic-block instructions terminal) b)
  (match-define reg-sets
    (cons
      ;; Should also have initial-defined/terminal but it is currently redundent
      (initial-live-in/terminal terminal reg-cmp)
      (append
        (map (lambda ([i : (Instruction Reg)]) (input-registers i reg-cmp)) instructions)
        (map (lambda ([i : (Instruction Reg)]) (dirtied-registers i reg-cmp)) instructions))))
  (foldl
    (lambda ([regs : (Set Reg)] [vars : (Set Var)])
      (set-fold
        regs
        (lambda ([reg : Reg] [vars : (Set Var)])
          (case reg
            [(temporary-reg v) (set-add vars v)]
            [(fixed-reg _) vars]))
        vars))
    reg-sets
    (make-set var-cmp)))


(define (spill-variables/block [b : (BasicBlock Reg)] [spilled : (Dict Var Int)] [next-var : Int])
  : (Tuple2 (BasicBlock Reg) Int)
  (case b
    [(basic-block instructions terminal)
     (match-define (tuple3 term-instructions terminal next-var)
       (spill-variables/terminal terminal spilled next-var))
     (match-define (tuple2 instructions next-var)
       (spill-variables/reverse-instructions
         (reverse instructions)
         term-instructions
         spilled
         next-var))
     (tuple2
       (basic-block
         instructions
         terminal)
       next-var)]))


(define (maybe-spill-reg [reg : Reg] [spilled : (Dict Var Int)] [loads : (Dict Var Int)]
                         [next-var : Int])
  : (Tuple3 Reg (Dict Var Int) Int)
  (case reg
    [(fixed-reg _) (tuple3 reg loads next-var)]
    [(temporary-reg v)
     (case (dict-ref spilled v)
       [(nothing) (tuple3 reg loads next-var)]
       [(just temp)
        (match-define new-var
          (case v
            [(var n _) (var n next-var)]))
        (tuple3
          (temporary-reg new-var)
          (dict-add loads new-var temp)
          (+ 1 next-var))])]))


(define (empty-loads) : (Dict Var Int)
  (make-dict var-cmp))

(define (spill-variables/terminal [t : (Terminal Reg)] [spilled : (Dict Var Int)] [next-var : Int])
  : (Tuple3 (List (Instruction Reg)) (Terminal Reg) Int)
  (match-define loads (empty-loads))
  (match-define (tuple3 t loads next-var)
    (case t
      [(halt)
       (tuple3 t loads next-var)]
      [(jump _)
       (tuple3 t loads next-var)]
      [(tail-call f args)
       ;; Currently assume that all args are fixed regs and so don't need to be spilled
       (match-define (tuple3 f loads next-var)
         (case f
           [(indirect-function-call reg)
            (match-define (tuple3 new-reg loads next-var) (maybe-spill-reg reg spilled loads next-var))
            (tuple3 (indirect-function-call new-reg) loads next-var)]
           [_
            (tuple3 f loads next-var)]))
       (tuple3 (tail-call f args) loads next-var)]
      [(fall-through _)
       (tuple3 t loads next-var)]
      [(return reg)
       (match-define (tuple3 new-reg loads next-var) (maybe-spill-reg reg spilled loads next-var))
       (tuple3 (return new-reg) loads next-var)]
      [(cond-jump/false-fall-through cond t f)
       (match-define (tuple3 new-condition loads next-var)
         (case cond
           [(reg-condition reg)
            (match-define (tuple3 new-reg loads next-var) (maybe-spill-reg reg spilled loads next-var))
            (tuple3 (reg-condition new-reg) loads next-var)]
           [(negated-reg-condition reg)
            (match-define (tuple3 new-reg loads next-var) (maybe-spill-reg reg spilled loads next-var))
            (tuple3 (negated-reg-condition new-reg) loads next-var)]
           [(comparison-condition op (compare-s64 reg-mem1 reg-imm2))
            (match-define (tuple3 new-reg-mem1 loads next-var)
              (case reg-mem1
                [(compare-mem-arg-val v)
                 (match-define (tuple3 r loads next-var)
                   (maybe-spill-reg v spilled loads next-var))
                 (tuple3 (compare-mem-arg-val r) loads next-var)]
                [(compare-mem-arg-ptr v)
                 (match-define (tuple3 r loads next-var)
                   (maybe-spill-reg v spilled loads next-var))
                 (tuple3 (compare-mem-arg-ptr r) loads next-var)]))
            (match-define (tuple3 new-reg-imm2 loads next-var)
              (ann (Tuple3 (Either Reg S32) (Dict Var Int) Int)
                (case reg-imm2
                  [(left r)
                   (match-define (tuple3 new-r loads next-var) (maybe-spill-reg r spilled loads next-var))
                   (tuple3 (left new-r) loads next-var)]
                  [(right imm)
                   (tuple3 (right imm) loads next-var)])))
            (tuple3 (comparison-condition op (compare-s64 new-reg-mem1 new-reg-imm2)) loads next-var)]
           [(comparison-condition op (compare-u8 reg-mem1 reg-imm2))
            (match-define (tuple3 new-reg-mem1 loads next-var)
              (case reg-mem1
                [(compare-mem-arg-val v)
                 (match-define (tuple3 r loads next-var)
                   (maybe-spill-reg v spilled loads next-var))
                 (tuple3 (compare-mem-arg-val r) loads next-var)]
                [(compare-mem-arg-ptr v)
                 (match-define (tuple3 r loads next-var)
                   (maybe-spill-reg v spilled loads next-var))
                 (tuple3 (compare-mem-arg-ptr r) loads next-var)]))
            (match-define (tuple3 new-reg-imm2 loads next-var)
              (ann (Tuple3 (Either Reg U8) (Dict Var Int) Int)
                (case reg-imm2
                  [(left r)
                   (match-define (tuple3 new-r loads next-var) (maybe-spill-reg r spilled loads next-var))
                   (tuple3 (left new-r) loads next-var)]
                  [(right imm)
                   (tuple3 (right imm) loads next-var)])))
            (tuple3 (comparison-condition op (compare-u8 new-reg-mem1 new-reg-imm2)) loads next-var)]
           [(memory-compare-condition op size reg1 reg2)
            (match-define (tuple3 new-reg1 loads next-var) (maybe-spill-reg reg1 spilled loads next-var))
            (match-define (tuple3 new-reg2 loads next-var) (maybe-spill-reg reg2 spilled loads next-var))
            (tuple3 (memory-compare-condition op size new-reg1 new-reg2) loads next-var)]))
       (tuple3 (cond-jump/false-fall-through new-condition t f) loads next-var)]))
  (tuple3 (add-loads loads (empty)) t next-var))

(define (spill-variables/reverse-instructions
          [instructions : (List (Instruction Reg))]
          [acc : (List (Instruction Reg))]
          [spilled : (Dict Var Int)]
          [next-var : Int])
  : (Tuple2 (List (Instruction Reg)) Int)
  (case instructions
    [(empty) (tuple2 acc next-var)]
    [(cons inst instructions)
     (match-define (tuple2 new-instructions next-var)
       (spill-instruction inst spilled next-var))
     (spill-variables/reverse-instructions
       instructions
       (append new-instructions acc)
       spilled
       next-var)]))

(define (add-loads [loads : (Dict Var Int)]
                   [instructions : (List (Instruction Reg))]) : (List (Instruction Reg))
  (dict-fold
    loads
    (lambda ([v : Var] [i : Int] [instructions : (List (Instruction Reg))])
      (cons (load-temporary (temporary-reg v) i) instructions))
    instructions))


(define (spill-instruction [instruction : (Instruction Reg)] [spilled : (Dict Var Int)] [next-var : Int])
  : (Tuple2 (List (Instruction Reg)) Int)
  (match-define in (input-registers instruction reg-cmp))
  (match-define out (dirtied-registers instruction reg-cmp))
  (match-define (tuple2 actual-spilled-regs next-var)
    (compute-spills
      (set-union in out)
      spilled
      next-var))
  (match-define new-instruction
    (rename-registers/instruction
      instruction
      (lambda ([reg : Reg])
        (case (dict-ref actual-spilled-regs reg)
          [(nothing) reg]
          [(just (tuple2 new-reg _)) new-reg]))))
  (tuple2
    (append
      (filter-map
        (lambda ([reg : Reg]) : (Maybe (Instruction Reg))
          (case (dict-ref actual-spilled-regs reg)
            [(nothing) (nothing)]
            [(just (tuple2 new-reg temp))
             (just (load-temporary new-reg temp))]))
        (set->list in))
      (cons
        new-instruction
        (filter-map
          (lambda ([reg : Reg]) : (Maybe (Instruction Reg))
            (case (dict-ref actual-spilled-regs reg)
              [(nothing) (nothing)]
              [(just (tuple2 new-reg temp))
               (just (store-temporary temp new-reg))]))
          (set->list out))))
    next-var))

(define (empty-spills) : (Dict Reg (Tuple2 Reg Int))
  (make-dict reg-cmp))

(define (compute-spills [regs : (Set Reg)] [spilled : (Dict Var Int)] [next-var : Int])
  : (Tuple2 (Dict Reg (Tuple2 Reg Int)) Int)
  (set-fold
    regs
    (lambda ([reg : Reg] [acc : (Tuple2 (Dict Reg (Tuple2 Reg Int)) Int)])
      (case reg
        [(fixed-reg _) acc]
        [(temporary-reg v)
         (case (dict-ref spilled v)
           [(nothing) acc]
           [(just temp)
            (match-define (tuple2 actual-spills next-var) acc)
            (match-define (var n _) v)
            (tuple2
              (dict-add actual-spills reg (tuple2 (temporary-reg (var n next-var)) temp))
              (+ 1 next-var))])]))
    (tuple2 (empty-spills) next-var)))
