#:module (simplify-assigned-register-language)
#:import {
  (assigned-register-language)
  (block-number)
  (dict)
  (either)
  (list)
  (maybe)
  (panic)
  (prim)
  (set)
  (set-multi-dict)
  (tuples)
  (yaspl math-operations)
}

(export
  (#:values simplify-function-definition))
(types)


(define [Reg] (simplify-function-definition
                [f : (FunctionDefinition Reg)]
                [reg=? : (Reg Reg -> Boolean)])
  : (FunctionDefinition Reg)
  (match-define (function-definition name blocks) f)
  (function-definition
    name
    (remove-unused-blocks
      (collapse-jumps
        (remove-unused-blocks
          (collapse-trivial-blocks
            (remove-no-op-instructions reg=? blocks)))))))

(define [Reg] (collapse-trivial-blocks [blocks : (BlockMap Reg)])
  : (BlockMap Reg)
  (let ([replacements (find-trivial-blocks (block-map-blocks blocks))])
    (case (validate-block-map
            (unvalidated-block-map-map
              (block-map->unvalidated-block-map blocks)
              (lambda ([_ : BlockNumber] [b : (BasicBlock Reg)])
                (case b
                  [(basic-block insts term)
                   (basic-block insts (collapse-trivial-blocks/terminal term replacements))]))))
      [(left msg) (panic msg)]
      [(right v) v])))


(define [Reg] (collapse-trivial-blocks/terminal
                [terminal : (Terminal Reg)]
                [replacements : (Dict BlockNumber BlockNumber)])
  : (Terminal Reg)
 (case terminal
   [(jump i)
    (jump (collapse-trivial-blocks/jump i (make-set block-number-cmp) replacements))]
   [(return r)
    (return r)]
   [(halt)
    (halt)]
   [(tail-call f args)
    (tail-call f args)]
   [(cond-jump c t f)
    (cond-jump
      c
      (collapse-trivial-blocks/jump t (make-set block-number-cmp) replacements)
      f)]))

(define (collapse-trivial-blocks/jump
          [block : BlockNumber]
          [seen-blocks : (Set BlockNumber)]
          [replacements : (Dict BlockNumber BlockNumber)])
  : BlockNumber
  (if (set-member? seen-blocks block)
      block
      (case (dict-ref replacements block)
        [(nothing) block]
        [(just new-block)
         (collapse-trivial-blocks/jump new-block (set-add seen-blocks block) replacements)])))

(define [Reg] (find-trivial-blocks
                [blocks : (Dict BlockNumber (BasicBlock Reg))])
  : (Dict BlockNumber BlockNumber)
  (dict-filter-map
    blocks
    (lambda ([_ : BlockNumber] [b : (BasicBlock Reg)]) : (Maybe BlockNumber)
      (case b
        [(basic-block (empty) (jump target))
         (just target)]
        [_ (nothing)]))))


(define [Reg] (remove-unused-blocks [blocks : (BlockMap Reg)])
  : (BlockMap Reg)
  (let ([live-blocks (set-add (find-live-blocks (block-map-blocks blocks))
                              (block-map-entry-block blocks))])
    (case (validate-block-map
            (unvalidated-block-map-filter
              (block-map->unvalidated-block-map blocks)
              (lambda ([key : BlockNumber] [_ : (BasicBlock Reg)]) : Boolean
                (set-member? live-blocks key))))
      [(left msg) (panic msg)]
      [(right v) v])))

(define [Reg] (find-live-blocks
                [blocks : (Dict BlockNumber (BasicBlock Reg))])
  : (Set BlockNumber)
  (foldl
    (lambda ([b : (BasicBlock Reg)] [acc : (Set BlockNumber)])
      (case b
        [(basic-block _ (jump target))
         (set-add acc target)]
        [(basic-block _ (cond-jump _ t f))
         (set-add (set-add acc t) f)]
        [(basic-block _ (return _))
         acc]
        [(basic-block _ (tail-call _ _))
         acc]
        [(basic-block _ (halt))
         acc]))
    (dict-values blocks)
    (make-set block-number-cmp)))

(define [Reg] (remove-no-op-instructions
                [reg=? : (Reg Reg -> Boolean)]
                [blocks : (BlockMap Reg)])
  : (BlockMap Reg)
  (case (validate-block-map
          (unvalidated-block-map-map
            (block-map->unvalidated-block-map blocks)
            (lambda ([_ : BlockNumber] [b : (BasicBlock Reg)])
              (case b
                [(basic-block instructions terminal)
                 (basic-block
                   (filter
                     (lambda ([i : (Instruction Reg)])
                       (not (no-op-instruction? i reg=?)))
                     instructions)
                   terminal)]))))
    [(left msg) (panic msg)]
    [(right v) v]))

(define [Reg] (no-op-instruction? [i : (Instruction Reg)] [reg=? : (Reg Reg -> Boolean)]) : Boolean
  (case i
    [(move r1 r2)
     (reg=? r1 r2)]
    [(numeric-op-immediate _ (sub-op) amount)
     (= 0 (s32->s64 amount))]
    [_ #f]))


(define [Reg] (construct-combined-block [index : BlockNumber]
                                        [blocks : (BlockMap Reg)]) : (BasicBlock Reg)
  (construct-combined-block* (empty) index blocks))

(define [Reg] (construct-combined-block*
                [prefix : (List (Instruction Reg))] [index : BlockNumber]
                [blocks : (BlockMap Reg)]) : (BasicBlock Reg)
  (match-define (basic-block next-insts term)
    (dict-ref/panic (block-map-blocks blocks) index))
  (case term
    [(jump t)
     (if (= 1 (set-multi-dict-ref/count (block-map-predecessors blocks) t))
         (construct-combined-block* (append prefix next-insts) t blocks)
         (basic-block (append prefix next-insts) term))]
    [_
     (basic-block (append prefix next-insts) term)]))


(define [Reg] (collapse-jumps [blocks : (BlockMap Reg)])
  : (BlockMap Reg)
  (case (validate-block-map
          (unvalidated-block-map-filter-map
            (block-map->unvalidated-block-map blocks)
            (lambda ([index : BlockNumber] [_ : (BasicBlock Reg)]) : (Maybe (BasicBlock Reg))
              ;; We keep the block if it doesn't have exactly one predecessor
              ;; that jumps to it.
              (match-define keep
                (let ([preds (set-multi-dict-ref/empty (block-map-predecessors blocks) index)])
                  (case (set-split preds)
                    [(nothing) #t]
                    [(just (tuple2 pred preds))
                     (if (not (set-empty? preds))
                         #t
                         (case (dict-ref (block-map-blocks blocks) pred)
                           [(nothing) (panic/boolean #"Block not found")]
                           [(just (basic-block _ (jump _))) #f]
                           [_ #t]))])))
              (if keep
                  (just (construct-combined-block index blocks))
                  (nothing)))))
    [(left msg) (panic msg)]
    [(right v) v]))
