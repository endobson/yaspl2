#:module (print-assigned-register-language)
#:import {
  (assigned-register-language)
  (block-number)
  (bytes)
  (dict)
  (join-list)
  (list)
  (numbers)
  (prim)
  {(print-lowered-register-language)
    {#:values
      print-instruction
    }
  }
  (yaspl math-operations)
}
(export
  (#:values print-function))
(types)


(define [Reg] (print-function
                [f : (FunctionDefinition Reg)]
                [print-reg : (Reg -> Bytes)]) : Bytes
  (case f
    [(function-definition name blocks)
     (bytes-append
       (jl->list
         (append-jl
           (varargs join-list
              name
              #"\n")
           (concat-jl
             (dict-map (block-map-blocks blocks)
                       (lambda ([i : BlockNumber] [b : (BasicBlock Reg)])
                         (print-basic-block i b print-reg)))))))]))


(define [Reg] (print-basic-block [index : BlockNumber] [b : (BasicBlock Reg)]
                                 [print-reg : (Reg -> Bytes)]) : (JoinList Bytes)
  (case b
    [(basic-block instructions terminal)
     (varargs append-jl*
       (varargs join-list
         #"block: "
         (block-number->bytes index)
         #"\n")
       (concat-map-jl/list
         (lambda ([i : (Instruction Reg)]) (print-instruction i print-reg))
         instructions)
       (print-terminal terminal print-reg))]))

(define [Reg] (print-terminal [t : (Terminal Reg)] [print-reg : (Reg -> Bytes)]) : (JoinList Bytes)
  (case t
    [(return reg)
     (varargs join-list
       #"return "
       (print-reg reg)
       #"\n")]
    [(halt)
     (single-jl #"halt\n")]
    [(tail-call f args)
     (varargs append-jl*
       (case f
         [(direct-call f)
          (varargs join-list #"call[" f #"]")]
         [(indirect-function-call f)
          (varargs join-list #"call[" (print-reg f) #"]")]
         [(closure-call c)
          (varargs join-list #"closure-call[" (print-reg c) #"]")]
         [(syscall n)
          (varargs join-list #"syscall[" (print-reg n) #"]")])
       (single-jl #"(")
       (list->jl (interleave (map print-reg args) #", "))
       (single-jl #")\n"))]
    [(jump block-num)
     (varargs join-list
       #"jump "
       (block-number->bytes block-num)
       #"\n")]
    [(cond-jump (reg-condition reg) t-block-num f-block-num)
     (varargs join-list
       #"cond-jump "
       (print-reg reg)
       #" "
       (block-number->bytes t-block-num)
       #" "
       (block-number->bytes f-block-num)
       #"\n")]
    [(cond-jump (negated-reg-condition reg) t-block-num f-block-num)
     (varargs join-list
       #"cond-jump (not "
       (print-reg reg)
       #") "
       (block-number->bytes t-block-num)
       #" "
       (block-number->bytes f-block-num)
       #"\n")]
    [(cond-jump (comparison-condition op (compare-s64 reg-mem1 reg-imm2))
                t-block-num f-block-num)
     (varargs join-list
       #"cond-jump ("
       (comparison-bin-op->bytes op)
       #" "
       (case reg-mem1
         [(compare-mem-arg-val r) (print-reg r)]
         [(compare-mem-arg-ptr r) (bytes-append (varargs list #"*" (print-reg r)))])
       #" "
       (case reg-imm2
         [(reg-or-s32-reg reg2) (print-reg reg2)]
         [(reg-or-s32-s32 imm) (integer->decimal-bytes (s32->s64 imm))])
       #") "
       (block-number->bytes t-block-num)
       #" "
       (block-number->bytes f-block-num)
       #"\n")]
    [(cond-jump (comparison-condition op (compare-s8 reg-mem1 reg-imm2))
                t-block-num f-block-num)
     (varargs join-list
       #"cond-jump ("
       (comparison-bin-op->bytes op)
       #" "
       (case reg-mem1
         [(compare-mem-arg-val r) (print-reg r)]
         [(compare-mem-arg-ptr r) (bytes-append (varargs list #"*" (print-reg r)))])
       #" "
       (case reg-imm2
         [(reg-or-s8-reg reg2) (print-reg reg2)]
         [(reg-or-s8-s8 imm) (integer->decimal-bytes (s8->s64 imm))])
       #") "
       (block-number->bytes t-block-num)
       #" "
       (block-number->bytes f-block-num)
       #" (byte)\n")]
    [(cond-jump (memory-compare-condition negated size reg1 reg2) t-block-num f-block-num)
     (varargs join-list
       #"cond-jump (compare-memory-"
       (if negated #"!= " #"= ")
       (print-reg size)
       #" "
       (print-reg reg1)
       #" "
       (print-reg reg2)
       #") "
       (block-number->bytes t-block-num)
       #" "
       (block-number->bytes f-block-num)
       #"\n")]))
