#:module (lowered-live-variables)
#:import {
  (bytes)
  (data ordering)
  (dict)
  (graphviz)
  (join-list)
  (list)
  (lowered-register-language)
  (maybe)
  (numbers)
  (prim)
  (set)
  (tuples)
  (undirected-graph)
}
(export
  #:types (LiveOutState)
  #:values (live-variables print-blocks print-graph blocks->live-out-states live-out-state->bytes
                           input-registers output-registers)
  #:patterns (live-out-state))
(types
  (define-type (BlockState Reg)
    (block-state [instruction-states : (List (PointState Reg))]
                 [terminal-live-in : (Set Reg)]
                 [terminal-defined : (Set Reg)]))
  (define-type (PointState Reg)
    (point-state [live-in : (Set Reg)]
                 [defined : (Set Reg)]
                 [move-source : (Maybe Reg)]))
  (define-type (LiveOutState Reg)
    (live-out-state [live-out : (Set Reg)]
                    [defined : (Set Reg)]
                    [move-source : (Maybe Reg)])))

(define (Reg) (live-out-state->bytes [los : (LiveOutState Reg)] [reg->bytes : (Reg -> Bytes)]) : Bytes
  (match-define (live-out-state live-out defined move-source) los)
  (bytes-append
    (jl->list
      (varargs append-jl*
        (list->jl (interleave (map reg->bytes (set->list defined)) #", "))
        (case move-source
          [(nothing) (single-jl #" (")]
          [(just reg) (varargs join-list #" <- " (reg->bytes reg) #" (")])
        (list->jl (interleave (map reg->bytes (set->list live-out)) #", "))
        (single-jl #")")))))

(define (Reg) (live-variables [f : (FunctionDefinition Reg)]
                              [reg-cmp : (Reg Reg -> Ordering)]) : (Dict Int (BlockState Reg))
  (match-define (function-definition _ _ block-map) f)
  (match-define blocks (block-map-blocks block-map))
  (match-define jump-index (make-jump-index blocks))
  (fully-propagate-live-variables/blocks
    (dict-value-map blocks (lambda ([block : (BasicBlock Reg)])
                             (initial-block-state block reg-cmp)))
    reg-cmp
    jump-index
    (reverse-jump-index jump-index)
    (dict-keys blocks)))

(define (Reg) (make-jump-index [blocks : (Dict Int (BasicBlock Reg))]) : (Dict Int (Set Int))
  (dict-value-map
    blocks
    (lambda ([block : (BasicBlock Reg)])
      (terminal-next-blocks (basic-block-terminal block)))))

(define (reverse-jump-index [jump-index : (Dict Int (Set Int))]) : (Dict Int (Set Int))
  (dict-fold
    jump-index
    (lambda ([index : Int] [targets : (Set Int)] [acc : (Dict Int (Set Int))])
      (foldl
        (lambda ([target : Int] [acc : (Dict Int (Set Int))])
          (dict-update
            acc
            target
            (lambda ([set : (Set Int)]) (set-add set index))
            (make-set int-cmp)))
        (set->list targets)
        acc))
    (dict-value-map
      jump-index
      (lambda ([ignored : (Set Int)]) (make-set int-cmp)))))

(define (Reg) (print-blocks [blocks : (Dict Int (BlockState Reg))] [reg->bytes : (Reg -> Bytes)]) : Bytes
  (bytes-append
    (dict-map
      blocks
      (lambda ([i : Int] [block : (BlockState Reg)])
        (print-block-state i block reg->bytes)))))


(define (Reg) (print-block-state [i : Int] [block : (BlockState Reg)] [reg->bytes : (Reg -> Bytes)]) : Bytes
  (match-define (block-state instructions terminal-live terminal-def) block)
  (match-define print-live-set
    (lambda ([live : (Set Reg)]) : (JoinList Bytes)
      (list->jl (interleave (map reg->bytes (set->list live)) #", "))))
  (match-define print-point-state
    (lambda ([ps : (PointState Reg)]) : (JoinList Bytes)
      (case ps
        [(point-state live def move)
         (varargs append-jl*
           (case move
             [(nothing)
              (single-jl #"def: ")]
             [(just move-source)
              (single-jl (bytes-append (varargs list #"mov(" (reg->bytes move-source) #"): ")))])
           (list->jl (interleave (map reg->bytes (set->list def)) #", "))
           (single-jl #" live: ")
           (print-live-set live)
           (single-jl #"\n"))])))
  (bytes-append
    (jl->list
      (varargs append-jl*
        (single-jl #"block: ")
        (single-jl (integer->decimal-bytes i))
        (single-jl #"\n")
        (concat-jl (map print-point-state instructions))
        (single-jl #"term-def: ")
        (list->jl (interleave (map reg->bytes (set->list terminal-def)) #", "))
        (single-jl #"live: ")
        (print-live-set terminal-live)
        (single-jl #"\n")))))

(define (Reg) (fully-propagate-live-variables/blocks
                [blocks : (Dict Int (BlockState Reg))]
                [reg-cmp : (Reg Reg -> Ordering)]
                [jump-index : (Dict Int (Set Int))]
                [reverse-jump-index : (Dict Int (Set Int))]
                [worklist : (Set Int)])
  : (Dict Int (BlockState Reg))
  (case (set-split worklist)
    [(nothing) blocks]
    [(just (tuple2 block-num worklist))
     (case (dict-ref jump-index block-num)
       [(nothing)
        (panic #"Unknown block")]
       [(just other-blocks)
        (case
          (propagate-live-variables/block
            (case (dict-ref blocks block-num)
              [(nothing)
               ((lambda () : (BlockState Reg) (panic #"Unknown block")))]
              [(just block) block])
            (set-union*
              (make-set reg-cmp)
              (map
                (lambda ([num : Int]) : (Set Reg)
                  (case (dict-ref blocks num)
                    [(nothing)
                     (panic #"Unknown block")]
                    [(just block) (block-live-in block)]))
                (set->list other-blocks))))
          [(nothing)
           (fully-propagate-live-variables/blocks
             blocks
             reg-cmp
             jump-index
             reverse-jump-index
             worklist)]
          [(just new-block)
           (fully-propagate-live-variables/blocks
             (dict-replace blocks block-num new-block)
             reg-cmp
             jump-index
             reverse-jump-index
             (set-union
               worklist
               (case (dict-ref reverse-jump-index block-num)
                 [(nothing) ((lambda () : (Set Int) (panic #"Unknown block")))]
                 [(just block-nums) block-nums])))])])]))

(define (Reg) (propagate-live-variables/block [state : (BlockState Reg)] [incoming-live-in : (Set Reg)])
  : (Maybe (BlockState Reg))
  (match-define (block-state instructions old-live-in defined) state)
  (if (= (set-count (set-difference (set-difference incoming-live-in defined) old-live-in)) 0)
      (nothing)
      (just
        (let ([new-live-in (set-union incoming-live-in old-live-in)])
          (block-state
            (propagate-live-variables/instructions (reverse instructions) (empty) new-live-in)
            new-live-in
            defined)))))

(define (Reg) (propagate-live-variables/instructions
                [rev-instructions : (List (PointState Reg))]
                [acc-instructions : (List (PointState Reg))]
                [live-out : (Set Reg)]) : (List (PointState Reg))
  (case rev-instructions
    [(empty) acc-instructions]
    [(cons (point-state live-in def move) rev-instructions)
     (let ([live-in (set-union live-in (set-difference live-out def))])
       (propagate-live-variables/instructions
         rev-instructions
         (cons
           (point-state live-in def move)
           acc-instructions)
         live-in))]))

(define (Reg) (initial-block-state [block : (BasicBlock Reg)]
                                   [reg-cmp : (Reg Reg -> Ordering)])
  : (BlockState Reg)
  (match-define (basic-block instructions terminal) block)
  (match-define terminal-live-in (initial-live-in/terminal terminal reg-cmp))
  (match-define terminal-defined (initial-defined/terminal terminal reg-cmp))
  (block-state
    (propagate-live-variables/instructions
      (reverse
        (map (lambda ([inst : (Instruction Reg)])
               (initial-point-state/instruction inst reg-cmp)) instructions))
      (empty)
      terminal-live-in)
    terminal-live-in
    terminal-defined))

(define (Reg) (initial-point-state/instruction
                [i : (Instruction Reg)]
                [reg-cmp : (Reg Reg -> Ordering)]) : (PointState Reg)
  (case i
    [(move _ src)
     (point-state
       (input-registers i reg-cmp)
       (output-registers i reg-cmp)
       (just src))]
    [(function-call-inst _ _ _ conflicts)
     (point-state
       (input-registers i reg-cmp)
       (set-add-all (output-registers i reg-cmp) conflicts)
       (nothing))]
    [(compare-memory out size v1 v2)
     (point-state
       (input-registers i reg-cmp)
       (set-add-all (output-registers i reg-cmp) (varargs list size v1 v2))
       (nothing))]
    [_
     (point-state
       (input-registers i reg-cmp)
       (output-registers i reg-cmp)
       (nothing))]))

(define (Reg) (input-registers [inst : (Instruction Reg)] [reg-cmp : (Reg Reg -> Ordering)]) : (Set Reg)
  (case inst
    [(int-literal output _)
     (make-set reg-cmp)]
    [(symbol-address output _)
     (make-set reg-cmp)]
    [(move dest src)
     (set-add (make-set reg-cmp) src)]
    [(push reg)
     (set-add (make-set reg-cmp) reg)]
    [(pop reg)
     (make-set reg-cmp)]
    [(store-least-significant-byte loc offset val)
     (set-add (set-add (make-set reg-cmp) loc) val)]
    [(load-zero-extended-byte output loc offset)
     (set-add (make-set reg-cmp) loc)]
    [(store-8byte loc offset val)
     (set-add (set-add (make-set reg-cmp) loc) val)]
    [(load-8byte output loc offset)
     (set-add (make-set reg-cmp) loc)]
    [(compare-memory out size v1 v2)
     (set-add (set-add (set-add (make-set reg-cmp) size) v1) v2)]
    [(store-temporary index val)
     (set-add (make-set reg-cmp) val)]
    [(load-temporary output index)
     (make-set reg-cmp)]
    [(bin-op-inst output _ input)
     (set-add (set-add (make-set reg-cmp) input) output)]
    [(numeric-op-immediate output _ _)
     (set-add (make-set reg-cmp) output)]
    [(unary-op-inst output _ input)
     (set-add (make-set reg-cmp) input)]
    [(function-call-inst output f args conflicts)
     (let ([input (set-add-all (make-set reg-cmp) args)])
       (case f
         [(syscall num) (set-add input num)]
         [(closure-call c) (set-add input c)]
         [(direct-call f) input]
         [(indirect-function-call f) (set-add input f)]))]))

(define (Reg) (output-registers [inst : (Instruction Reg)] [reg-cmp : (Reg Reg -> Ordering)]) : (Set Reg)
  (case inst
    [(int-literal output _)
     (set-add (make-set reg-cmp) output)]
    [(symbol-address output _)
     (set-add (make-set reg-cmp) output)]
    [(move dest src)
     (set-add (make-set reg-cmp) dest)]
    [(push reg)
     (make-set reg-cmp)]
    [(pop reg)
     (set-add (make-set reg-cmp) reg)]
    [(store-least-significant-byte loc offset val)
     (make-set reg-cmp)]
    [(load-zero-extended-byte output loc offset)
     (set-add (make-set reg-cmp) output)]
    [(store-8byte loc offset val)
     (make-set reg-cmp)]
    [(load-8byte output loc offset)
     (set-add (make-set reg-cmp) output)]
    [(compare-memory output size v1 v2)
     (set-add (make-set reg-cmp) output)]
    [(store-temporary index val)
     (make-set reg-cmp)]
    [(load-temporary output index)
     (set-add (make-set reg-cmp) output)]
    [(bin-op-inst output _ input)
     (set-add (make-set reg-cmp) output)]
    [(numeric-op-immediate output _ _)
     (set-add (make-set reg-cmp) output)]
    [(unary-op-inst output _ input)
     (set-add (make-set reg-cmp) output)]
    [(function-call-inst output f args conflicts)
     (set-add (make-set reg-cmp) output)]))


(define (Reg) (initial-live-in/terminal [t : (Terminal Reg)] [reg-cmp : (Reg Reg -> Ordering)]) : (Set Reg)
  (case t
    [(return reg) (set-add (make-set reg-cmp) reg)]
    [(halt) (make-set reg-cmp)]
    [(jump index) (make-set reg-cmp)]
    [(fall-through index) (make-set reg-cmp)]
    [(cond-jump/false-fall-through condition true false)
     (case condition
       [(reg-condition reg) (set-add (make-set reg-cmp) reg)]
       [(negated-reg-condition reg) (set-add (make-set reg-cmp) reg)]
       [(comparison-condition _ reg1 reg2)
        (set-add (set-add (make-set reg-cmp) reg1) reg2)]
       [(memory-compare-condition _ size reg1 reg2)
        (set-add (set-add (set-add (make-set reg-cmp) size) reg1) reg2)])]))


(define (Reg) (initial-defined/terminal [t : (Terminal Reg)] [reg-cmp : (Reg Reg -> Ordering)]) : (Set Reg)
  (case t
    [(return reg) (make-set reg-cmp)]
    [(halt) (make-set reg-cmp)]
    [(jump index) (make-set reg-cmp)]
    [(fall-through index) (make-set reg-cmp)]
    [(cond-jump/false-fall-through condition true false)
     (case condition
       [(reg-condition reg) (make-set reg-cmp)]
       [(negated-reg-condition reg) (make-set reg-cmp)]
       [(comparison-condition _ reg1 reg2)
        (make-set reg-cmp)]
       [(memory-compare-condition _ size reg1 reg2)
        (set-add (set-add (set-add (make-set reg-cmp) size) reg1) reg2)])]))


(define (Reg) (block-live-in [b : (BlockState Reg)]) : (Set Reg)
  (case b
    [(block-state (cons (point-state live _ _) _) _ _) live]
    [(block-state (empty) live _) live]))

(define (Reg) (block->live-out-states [b : (BlockState Reg)]) : (List (LiveOutState Reg))
  (match-define (block-state live-ins final-live-in _) b)
  (block->live-out-states* (reverse live-ins) final-live-in (empty)))

(define (Reg) (block->live-out-states* [live-in-states : (List (PointState Reg))]
                                       [live-out : (Set Reg)]
                                       [acc : (List (LiveOutState Reg))]) : (List (LiveOutState Reg))
  (case live-in-states
    [(empty) acc]
    [(cons (point-state live-in def move) live-in-states)
     (block->live-out-states* live-in-states live-in (cons (live-out-state live-out def move) acc))]))


(define (Reg) (add-live-variables-to-graph/blocks
                [blocks : (Dict Int (BlockState Reg))]
                [g : (Graph Reg VertexData EdgeData)]
                [reg->bytes : (Reg -> Bytes)]) : (Graph Reg VertexData EdgeData)
  (dict-fold
    blocks
    (lambda ([block-num : Int] [state : (BlockState Reg)] [acc : (Graph Reg VertexData EdgeData)])
      : (Graph Reg VertexData EdgeData)
      (case state
        [(block-state instructions term-live-in term-defined)
         (add-live-variables-to-graph/list
           (append (set->list term-defined) (set->list term-live-in))
           (foldl
             (lambda ([p : (PointState Reg)] [g : (Graph Reg VertexData EdgeData)])
               (add-live-variables-to-graph/point-state p g reg->bytes))
             instructions
             acc)
           reg->bytes)]))
    g))

(define (Reg) (add-live-variables-to-graph/point-state
                [p : (PointState Reg)]
                [g : (Graph Reg VertexData EdgeData)]
                [reg->bytes : (Reg -> Bytes)]) : (Graph Reg VertexData EdgeData)
  (match-define (point-state live def move) p)
  (add-live-variables-to-graph/list (set->list live) g reg->bytes))

(define (Reg) (add-live-variables-to-graph/list
                [l : (List Reg)]
                [g : (Graph Reg VertexData EdgeData)]
                [reg->bytes : (Reg -> Bytes)]) : (Graph Reg VertexData EdgeData)
  (foldl
    (lambda ([r : Reg] [g : (Graph Reg VertexData EdgeData)])
      (graph-add-vertex-if-absent
        g r (vertex-data (bytes-append (varargs list #"\"" (reg->bytes r) #"\"")))))
    l
    g))

;; Add moves back
(define (Reg) (add-interference-edges-to-graph/live-out-state
                [s : (LiveOutState Reg)]
                [g : (Graph Reg VertexData EdgeData)]) : (Graph Reg VertexData EdgeData)
  (match-define (live-out-state live def move) s)
  (match-define def-list (set->list def))
  (case move
    [(nothing)
     (foldl
       (lambda ([r : Reg] [g : (Graph Reg VertexData EdgeData)])
         (foldl
           (lambda ([def-reg : Reg] [g : (Graph Reg VertexData EdgeData)])
             (graph-add-edge-if-absent g def-reg r (edge-data #"solid")))
           def-list
           g))
       (set->list (set-difference live def))
       g)]
    [(just v)
     (foldl
       (lambda ([r : Reg] [g : (Graph Reg VertexData EdgeData)])
         (foldl
           (lambda ([def-reg : Reg] [g : (Graph Reg VertexData EdgeData)])
             (graph-add-edge-if-absent g def-reg r (edge-data #"solid")))
           def-list
           g))
       (set->list (set-remove (set-difference live def) v))
       g)]))

(define (Reg) (add-move-edges-to-graph/live-out-state
                [s : (LiveOutState Reg)]
                [g : (Graph Reg VertexData EdgeData)]) : (Graph Reg VertexData EdgeData)
  (match-define (live-out-state live def move) s)
  (case move
    [(just v)
     (foldl
       (lambda ([def-reg : Reg] [g : (Graph Reg VertexData EdgeData)])
         (graph-add-edge-if-absent g def-reg v (edge-data #"dashed")))
       (set->list def)
       g)]
    [_ g]))


(define (Reg) (add-interference-edges-to-graph/blocks
                [blocks : (Dict Int (BlockState Reg))]
                [g : (Graph Reg VertexData EdgeData)]) : (Graph Reg VertexData EdgeData)
  (dict-fold
    blocks
    (lambda ([block-num : Int] [state : (BlockState Reg)] [acc : (Graph Reg VertexData EdgeData)])
      : (Graph Reg VertexData EdgeData)
      (foldl
        (lambda ([s : (LiveOutState Reg)] [g : (Graph Reg VertexData EdgeData)])
          (add-interference-edges-to-graph/live-out-state s g))
        (block->live-out-states state)
        acc))
    g))

(define (Reg) (add-move-edges-to-graph/blocks
                [blocks : (Dict Int (BlockState Reg))]
                [g : (Graph Reg VertexData EdgeData)]) : (Graph Reg VertexData EdgeData)
  (dict-fold
    blocks
    (lambda ([block-num : Int] [state : (BlockState Reg)] [acc : (Graph Reg VertexData EdgeData)])
      : (Graph Reg VertexData EdgeData)
      (foldl
        (lambda ([s : (LiveOutState Reg)] [g : (Graph Reg VertexData EdgeData)])
          (add-move-edges-to-graph/live-out-state s g))
        (block->live-out-states state)
        acc))
    g))

(define (Reg) (print-graph
                [blocks : (Dict Int (BlockState Reg))]
                [reg-cmp : (Reg Reg -> Ordering)]
                [reg->bytes : (Reg -> Bytes)]
                [fixed-regs : (Set Reg)]) : Bytes
  (graph->graphviz
    (add-move-edges-to-graph/blocks
      blocks
      (add-interference-edges-to-graph/blocks
        blocks
        (add-live-variables-to-graph/blocks
          blocks
          (foldl
            (lambda ([r : Reg] [g : (Graph Reg VertexData EdgeData)])
              (graph-add-vertex-if-absent
                g r (vertex-data (bytes-append (varargs list #"\"" (reg->bytes r) #"\"")))))
            (set->list fixed-regs)
            ((lambda () : (Graph Reg VertexData EdgeData) (empty-graph reg-cmp))))
          reg->bytes)))))

(define (Reg) (blocks->live-out-states [blocks : (Dict Int (BlockState Reg))])
  : (List (LiveOutState Reg))
  (append* (map (lambda ([b : (BlockState Reg)]) (block->live-out-states b))
                (dict-values blocks))))
