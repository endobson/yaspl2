#:module (lowered-live-variables)
#:import {
  (bytes)
  (data ordering)
  (dict)
  (either)
  (graphviz)
  (join-list)
  (list)
  (lowered-register-language)
  (maybe)
  (numbers)
  (prim)
  (set)
  (tuples)
  (undirected-graph)
}
(export
  #:types (LiveOutState)
  #:values (live-variables print-blocks print-graph blocks->live-out-states live-out-state->bytes
            input-registers dirtied-registers move-live-out-state def-live-out-state
            initial-live-in/terminal)
  #:patterns (def-live-out-state move-live-out-state))
(types
  (define-type (BlockState Reg)
    (block-state [instruction-states : (List (PointState Reg))]
                 [terminal-live-in : (Set Reg)]
                 [terminal-defined : (Set Reg)]))
  (define-type (PointState Reg)
    (def-point-state [live-in : (Set Reg)] [defined : (Set Reg)])
    (move-point-state [live-in : (Set Reg)] [defined : Reg] [move-source : Reg]))
  (define-type (LiveOutState Reg)
    (def-live-out-state [live-out : (Set Reg)] [defined : (Set Reg)])
    (move-live-out-state [live-out : (Set Reg)]
                         [defined : Reg]
                         [move-source : Reg])))

(define (Reg) (live-out-state->bytes [los : (LiveOutState Reg)] [reg->bytes : (Reg -> Bytes)]) : Bytes
  (case los
    [(def-live-out-state live-out defined)
     (bytes-append
       (jl->list
         (varargs append-jl*
           (list->jl (interleave (map reg->bytes (set->list defined)) #", "))
           (single-jl #" (")
           (list->jl (interleave (map reg->bytes (set->list live-out)) #", "))
           (single-jl #")"))))]
    [(move-live-out-state live-out defined move-source)
     (bytes-append
       (jl->list
         (varargs append-jl*
           (varargs join-list (reg->bytes defined) #" <- " (reg->bytes move-source) #" (")
           (list->jl (interleave (map reg->bytes (set->list live-out)) #", "))
           (single-jl #")"))))]))

(define (Reg) (live-variables [f : (FunctionDefinition Reg)]
                              [reg-cmp : (Reg Reg -> Ordering)]) : (Dict Int (BlockState Reg))
  (match-define (function-definition _ _ block-map) f)
  (match-define blocks (block-map-blocks block-map))
  (match-define jump-index (make-jump-index blocks))
  (fully-propagate-live-variables/blocks
    (dict-value-map blocks (lambda ([block : (BasicBlock Reg)])
                             (initial-block-state block reg-cmp)))
    reg-cmp
    jump-index
    (reverse-jump-index jump-index)
    (dict-keys blocks)))

(define (Reg) (make-jump-index [blocks : (Dict Int (BasicBlock Reg))]) : (Dict Int (Set Int))
  (dict-value-map
    blocks
    (lambda ([block : (BasicBlock Reg)])
      (terminal-next-blocks (basic-block-terminal block)))))

(define (reverse-jump-index [jump-index : (Dict Int (Set Int))]) : (Dict Int (Set Int))
  (dict-fold
    jump-index
    (lambda ([index : Int] [targets : (Set Int)] [acc : (Dict Int (Set Int))])
      (set-fold
        targets
        (lambda ([target : Int] [acc : (Dict Int (Set Int))])
          (dict-update
            acc
            target
            (lambda ([set : (Set Int)]) (set-add set index))
            (make-set int-cmp)))
        acc))
    (dict-value-map
      jump-index
      (lambda ([ignored : (Set Int)]) (make-set int-cmp)))))

(define (Reg) (print-blocks [blocks : (Dict Int (BlockState Reg))] [reg->bytes : (Reg -> Bytes)]) : Bytes
  (bytes-append
    (dict-map
      blocks
      (lambda ([i : Int] [block : (BlockState Reg)])
        (print-block-state i block reg->bytes)))))


(define (Reg) (print-block-state [i : Int] [block : (BlockState Reg)] [reg->bytes : (Reg -> Bytes)]) : Bytes
  (match-define (block-state instructions terminal-live terminal-def) block)
  (match-define print-live-set
    (lambda ([live : (Set Reg)]) : (JoinList Bytes)
      (list->jl (interleave (map reg->bytes (set->list live)) #", "))))
  (match-define print-point-state
    (lambda ([ps : (PointState Reg)]) : (JoinList Bytes)
      (case ps
        [(def-point-state live def)
         (varargs append-jl*
           (single-jl #"def: ")
           (list->jl (interleave (map reg->bytes (set->list def)) #", "))
           (single-jl #" live: ")
           (print-live-set live)
           (single-jl #"\n"))]
        [(move-point-state live def move-source)
         (varargs append-jl*
           (varargs join-list #"mov: " (reg->bytes def) #" <- " (reg->bytes move-source))
           (single-jl #" live: ")
           (print-live-set live)
           (single-jl #"\n"))])))
  (bytes-append
    (jl->list
      (varargs append-jl*
        (single-jl #"block: ")
        (single-jl (integer->decimal-bytes i))
        (single-jl #"\n")
        (concat-jl (map print-point-state instructions))
        (single-jl #"term-def: ")
        (list->jl (interleave (map reg->bytes (set->list terminal-def)) #", "))
        (single-jl #"live: ")
        (print-live-set terminal-live)
        (single-jl #"\n")))))

(define (Reg) (fully-propagate-live-variables/blocks
                [blocks : (Dict Int (BlockState Reg))]
                [reg-cmp : (Reg Reg -> Ordering)]
                [jump-index : (Dict Int (Set Int))]
                [reverse-jump-index : (Dict Int (Set Int))]
                [worklist : (Set Int)])
  : (Dict Int (BlockState Reg))
  (case (set-split worklist)
    [(nothing) blocks]
    [(just (tuple2 block-num worklist))
     (case (dict-ref jump-index block-num)
       [(nothing)
        (panic #"Unknown block")]
       [(just other-blocks)
        (case
          (propagate-live-variables/block
            (case (dict-ref blocks block-num)
              [(nothing)
               ((lambda () : (BlockState Reg) (panic #"Unknown block")))]
              [(just block) block])
            (set-union*
              (make-set reg-cmp)
              (map
                (lambda ([num : Int]) : (Set Reg)
                  (case (dict-ref blocks num)
                    [(nothing)
                     (panic #"Unknown block")]
                    [(just block) (block-live-in block)]))
                (set->list other-blocks))))
          [(nothing)
           (fully-propagate-live-variables/blocks
             blocks
             reg-cmp
             jump-index
             reverse-jump-index
             worklist)]
          [(just new-block)
           (fully-propagate-live-variables/blocks
             (dict-replace blocks block-num new-block)
             reg-cmp
             jump-index
             reverse-jump-index
             (set-union
               worklist
               (case (dict-ref reverse-jump-index block-num)
                 [(nothing) ((lambda () : (Set Int) (panic #"Unknown block")))]
                 [(just block-nums) block-nums])))])])]))

(define (Reg) (propagate-live-variables/block [state : (BlockState Reg)] [incoming-live-in : (Set Reg)])
  : (Maybe (BlockState Reg))
  (match-define (block-state instructions old-live-in defined) state)
  (if (set-empty? (set-difference (set-difference incoming-live-in defined) old-live-in))
      (nothing)
      (just
        (let ([new-live-in (set-union incoming-live-in old-live-in)])
          (block-state
            (propagate-live-variables/instructions (reverse instructions) (empty) new-live-in)
            new-live-in
            defined)))))

(define (Reg) (propagate-live-variables/instructions
                [rev-instructions : (List (PointState Reg))]
                [acc-instructions : (List (PointState Reg))]
                [live-out : (Set Reg)]) : (List (PointState Reg))
  (case rev-instructions
    [(empty) acc-instructions]
    [(cons (def-point-state live-in def) rev-instructions)
     (let ([live-in (set-union live-in (set-difference live-out def))])
       (propagate-live-variables/instructions
         rev-instructions
         (cons
           (def-point-state live-in def)
           acc-instructions)
         live-in))]
    [(cons (move-point-state live-in def move) rev-instructions)
     (let ([live-in (set-union live-in (set-remove live-out def))])
       (propagate-live-variables/instructions
         rev-instructions
         (cons
           (move-point-state live-in def move)
           acc-instructions)
         live-in))]))

(define (Reg) (initial-block-state [block : (BasicBlock Reg)]
                                   [reg-cmp : (Reg Reg -> Ordering)])
  : (BlockState Reg)
  (match-define (basic-block instructions terminal) block)
  (match-define terminal-live-in (initial-live-in/terminal terminal reg-cmp))
  (match-define terminal-defined (initial-defined/terminal terminal reg-cmp))
  (block-state
    (propagate-live-variables/instructions
      (reverse
        (map (lambda ([inst : (Instruction Reg)])
               (initial-point-state/instruction inst reg-cmp)) instructions))
      (empty)
      terminal-live-in)
    terminal-live-in
    terminal-defined))

(define (Reg) (initial-point-state/instruction
                [i : (Instruction Reg)]
                [reg-cmp : (Reg Reg -> Ordering)]) : (PointState Reg)
  (case i
    [(move out src)
     (move-point-state (input-registers i reg-cmp) out src)]
    [_
     (def-point-state
       (input-registers i reg-cmp)
       (dirtied-registers i reg-cmp))]))

(define (Reg) (input-registers [inst : (Instruction Reg)] [reg-cmp : (Reg Reg -> Ordering)]) : (Set Reg)
  (case inst
    [(int-literal output _)
     (make-set reg-cmp)]
    [(symbol-address output _)
     (make-set reg-cmp)]
    [(move dest src)
     (set-add (make-set reg-cmp) src)]
    [(push reg)
     (set-add (make-set reg-cmp) reg)]
    [(pop reg)
     (make-set reg-cmp)]
    [(store-least-significant-byte loc offset val)
     (set-add (set-add (make-set reg-cmp) loc) val)]
    [(store-least-significant-byte/scaled loc index scale offset val)
     (set-add (set-add (set-add (make-set reg-cmp) loc) val) index)]
    [(store-least-significant-byte-repeated loc val amount)
     (set-add (set-add (set-add (make-set reg-cmp) loc) val) amount)]
    [(load-zero-extended-byte output loc offset)
     (set-add (make-set reg-cmp) loc)]
    [(load-zero-extended-byte/scaled output loc index scale offset)
     (set-add (set-add (make-set reg-cmp) loc) index)]
    [(store-8byte loc offset val)
     (set-add (set-add (make-set reg-cmp) loc) val)]
    [(store-8byte/scaled loc index scale offset val)
     (set-add (set-add (set-add (make-set reg-cmp) loc) val) index)]
    [(store-8byte-repeated loc val amount)
     (set-add (set-add (set-add (make-set reg-cmp) loc) val) amount)]
    [(load-8byte output loc offset)
     (set-add (make-set reg-cmp) loc)]
    [(load-8byte/scaled output loc index scale offset)
     (set-add (set-add (make-set reg-cmp) loc) index)]
    [(compare-memory out size v1 v2)
     (set-add (set-add (set-add (make-set reg-cmp) size) v1) v2)]
    [(store-temporary index val)
     (set-add (make-set reg-cmp) val)]
    [(load-temporary output index)
     (make-set reg-cmp)]
    [(numeric-op-inst output _ input)
     (set-add (set-add (make-set reg-cmp) input) output)]
    [(comparison-op-inst output _ left right)
     (set-add (set-add (make-set reg-cmp) left) right)]
    [(logical-op-inst output _ input)
     (set-add (set-add (make-set reg-cmp) input) output)]
    [(numeric-op-immediate output _ _)
     (set-add (make-set reg-cmp) output)]
    [(mult-immediate output input _)
     (set-add (make-set reg-cmp) input)]
    [(quotient-remainder-inst q-out r-out high-in low-in div)
     (set-add (set-add (set-add (make-set reg-cmp) high-in) low-in) div)]
    [(comparison-op-immediate output _ left right)
     (set-add (make-set reg-cmp) left)]
    [(free-unary-op-inst output _ input)
     (set-add (make-set reg-cmp) input)]
    [(fixed-unary-op-inst input-output _)
     (set-add (make-set reg-cmp) input-output)]
    [(function-call-inst output f args conflicts)
     (let ([input (set-add-all (make-set reg-cmp) args)])
       (case f
         [(syscall num) (set-add input num)]
         [(closure-call c) (set-add input c)]
         [(direct-call f) input]
         [(indirect-function-call f) (set-add input f)]))]))

(define (Reg) (dirtied-registers [inst : (Instruction Reg)] [reg-cmp : (Reg Reg -> Ordering)]) : (Set Reg)
  (match-define empty-set (make-set reg-cmp))
  (case inst
    [(int-literal output _)
     (set-add empty-set output)]
    [(symbol-address output _)
     (set-add empty-set output)]
    [(move dest src)
     (set-add empty-set dest)]
    [(push reg)
     empty-set]
    [(pop reg)
     (set-add empty-set reg)]
    [(store-least-significant-byte loc offset val)
     empty-set]
    [(store-least-significant-byte/scaled loc index scale offset val)
     empty-set]
    [(store-least-significant-byte-repeated loc val amount)
     (set-add (set-add empty-set loc) amount)]
    [(load-zero-extended-byte output loc offset)
     (set-add empty-set output)]
    [(load-zero-extended-byte/scaled output loc index scale offset)
     (set-add empty-set output)]
    [(store-8byte loc offset val)
     empty-set]
    [(store-8byte/scaled loc index scale offset val)
     empty-set]
    [(store-8byte-repeated loc val amount)
     (set-add (set-add empty-set loc) amount)]
    [(load-8byte output loc offset)
     (set-add empty-set output)]
    [(load-8byte/scaled output loc index scale offset)
     (set-add empty-set output)]
    [(compare-memory output size v1 v2)
     (set-add (set-add (set-add (set-add empty-set output) size) v1) v2)]
    [(store-temporary index val)
     empty-set]
    [(load-temporary output index)
     (set-add empty-set output)]
    [(numeric-op-inst output _ input)
     (set-add empty-set output)]
    [(comparison-op-inst output _ left right)
     (set-add empty-set output)]
    [(logical-op-inst output _ input)
     (set-add empty-set output)]
    [(numeric-op-immediate output _ _)
     (set-add empty-set output)]
    [(mult-immediate output _ _)
     (set-add empty-set output)]
    [(quotient-remainder-inst q-out r-out high-in low-in div)
     (set-add (set-add (make-set reg-cmp) q-out) r-out)]
    [(comparison-op-immediate output _ _ _)
     (set-add empty-set output)]
    [(free-unary-op-inst output _ input)
     (set-add empty-set output)]
    [(fixed-unary-op-inst input-output _)
     (set-add empty-set input-output)]
    [(function-call-inst output f args conflicts)
     (set-add-all (set-add empty-set output) conflicts)]))

(define (Reg) (initial-live-in/terminal [t : (Terminal Reg)] [reg-cmp : (Reg Reg -> Ordering)]) : (Set Reg)
  (case t
    [(return reg) (set-add (make-set reg-cmp) reg)]
    [(halt) (make-set reg-cmp)]
    [(tail-call f args)
     (set-add-all
       (case f
         [(syscall num) (set-add (make-set reg-cmp) num)]
         [(closure-call c) (set-add (make-set reg-cmp) c)]
         [(direct-call f) (make-set reg-cmp)]
         [(indirect-function-call f) (set-add (make-set reg-cmp) f)])
       args)]
    [(jump index) (make-set reg-cmp)]
    [(fall-through index) (make-set reg-cmp)]
    [(cond-jump/false-fall-through condition true false)
     (case condition
       [(reg-condition reg) (set-add (make-set reg-cmp) reg)]
       [(negated-reg-condition reg) (set-add (make-set reg-cmp) reg)]
       [(comparison-condition _ (compare-s64 reg-mem1 reg-imm2))
        (set-add
          (case reg-imm2
            [(left r) (set-add (make-set reg-cmp) r)]
            [(right imm) (make-set reg-cmp)])
          (case reg-mem1
            [(compare-mem-arg-val r) r]
            [(compare-mem-arg-ptr r) r]))]
       [(comparison-condition _ (compare-u8 reg-mem1 reg-imm2))
        (set-add
          (case reg-imm2
            [(left r) (set-add (make-set reg-cmp) r)]
            [(right imm) (make-set reg-cmp)])
          (case reg-mem1
            [(compare-mem-arg-val r) r]
            [(compare-mem-arg-ptr r) r]))]
       [(memory-compare-condition _ size reg1 reg2)
        (set-add (set-add (set-add (make-set reg-cmp) size) reg1) reg2)])]))


(define (Reg) (initial-defined/terminal [t : (Terminal Reg)] [reg-cmp : (Reg Reg -> Ordering)]) : (Set Reg)
  (case t
    [(return reg) (make-set reg-cmp)]
    [(halt) (make-set reg-cmp)]
    [(tail-call _ _) (make-set reg-cmp)]
    [(jump index) (make-set reg-cmp)]
    [(fall-through index) (make-set reg-cmp)]
    [(cond-jump/false-fall-through condition true false)
     (case condition
       [(reg-condition reg) (make-set reg-cmp)]
       [(negated-reg-condition reg) (make-set reg-cmp)]
       [(comparison-condition _ _)
        (make-set reg-cmp)]
       [(memory-compare-condition _ size reg1 reg2)
        (set-add (set-add (set-add (make-set reg-cmp) size) reg1) reg2)])]))


(define (Reg) (block-live-in [b : (BlockState Reg)]) : (Set Reg)
  (case b
    [(block-state (cons (def-point-state live _) _) _ _) live]
    [(block-state (cons (move-point-state live _ _) _) _ _) live]
    [(block-state (empty) live _) live]))

(define (Reg) (block->live-out-states [b : (BlockState Reg)]) : (List (LiveOutState Reg))
  (match-define (block-state live-ins final-live-in _) b)
  (block->live-out-states* (reverse live-ins) final-live-in (empty)))

(define (Reg) (block->live-out-states* [live-in-states : (List (PointState Reg))]
                                       [live-out : (Set Reg)]
                                       [acc : (List (LiveOutState Reg))]) : (List (LiveOutState Reg))
  (case live-in-states
    [(empty) acc]
    [(cons (def-point-state live-in def) live-in-states)
     (block->live-out-states*
       live-in-states live-in
       (cons (def-live-out-state live-out def) acc))]
    [(cons (move-point-state live-in def move) live-in-states)
     (block->live-out-states*
       live-in-states live-in
       (cons (move-live-out-state live-out def move) acc))]))


(define (Reg) (add-live-variables-to-graph/blocks
                [blocks : (Dict Int (BlockState Reg))]
                [g : (Graph Reg VertexData EdgeData)]
                [reg->bytes : (Reg -> Bytes)]) : (Graph Reg VertexData EdgeData)
  (dict-fold
    blocks
    (lambda ([block-num : Int] [state : (BlockState Reg)] [acc : (Graph Reg VertexData EdgeData)])
      : (Graph Reg VertexData EdgeData)
      (case state
        [(block-state instructions term-live-in term-defined)
         (add-live-variables-to-graph/list
           (append (set->list term-defined) (set->list term-live-in))
           (foldl
             (lambda ([p : (PointState Reg)] [g : (Graph Reg VertexData EdgeData)])
               (add-live-variables-to-graph/point-state p g reg->bytes))
             instructions
             acc)
           reg->bytes)]))
    g))

(define (Reg) (add-live-variables-to-graph/point-state
                [p : (PointState Reg)]
                [g : (Graph Reg VertexData EdgeData)]
                [reg->bytes : (Reg -> Bytes)]) : (Graph Reg VertexData EdgeData)
  (add-live-variables-to-graph/list
    (case p
      [(def-point-state live def)
       (set->list live)]
      [(move-point-state live def move)
       (set->list live)])
    g reg->bytes))

(define (Reg) (add-live-variables-to-graph/list
                [l : (List Reg)]
                [g : (Graph Reg VertexData EdgeData)]
                [reg->bytes : (Reg -> Bytes)]) : (Graph Reg VertexData EdgeData)
  (foldl
    (lambda ([r : Reg] [g : (Graph Reg VertexData EdgeData)])
      (graph-add-vertex-if-absent
        g r (vertex-data (bytes-append (varargs list #"\"" (reg->bytes r) #"\"")))))
    l
    g))

;; Add moves back
(define (Reg) (add-interference-edges-to-graph/live-out-state
                [s : (LiveOutState Reg)]
                [g : (Graph Reg VertexData EdgeData)]) : (Graph Reg VertexData EdgeData)
  (case s
    [(def-live-out-state live def)
     (set-fold
       (set-difference live def)
       (lambda ([r : Reg] [g : (Graph Reg VertexData EdgeData)])
         (set-fold
           def
           (lambda ([def-reg : Reg] [g : (Graph Reg VertexData EdgeData)])
             (graph-add-edge-if-absent g def-reg r (edge-data #"solid")))
           g))
       g)]
    [(move-live-out-state live def move-source)
     (set-fold
       (set-remove (set-remove live def) move-source)
       (lambda ([r : Reg] [g : (Graph Reg VertexData EdgeData)])
         (graph-add-edge-if-absent g def r (edge-data #"solid")))
       g)]))

(define (Reg) (add-move-edges-to-graph/live-out-state
                [s : (LiveOutState Reg)]
                [g : (Graph Reg VertexData EdgeData)]) : (Graph Reg VertexData EdgeData)
  (case s
    [(move-live-out-state _ def move-source)
     (graph-add-edge-if-absent g def move-source (edge-data #"dashed"))]
    [_ g]))


(define (Reg) (add-interference-edges-to-graph/blocks
                [blocks : (Dict Int (BlockState Reg))]
                [g : (Graph Reg VertexData EdgeData)]) : (Graph Reg VertexData EdgeData)
  (dict-fold
    blocks
    (lambda ([block-num : Int] [state : (BlockState Reg)] [acc : (Graph Reg VertexData EdgeData)])
      : (Graph Reg VertexData EdgeData)
      (foldl
        (lambda ([s : (LiveOutState Reg)] [g : (Graph Reg VertexData EdgeData)])
          (add-interference-edges-to-graph/live-out-state s g))
        (block->live-out-states state)
        acc))
    g))

(define (Reg) (add-move-edges-to-graph/blocks
                [blocks : (Dict Int (BlockState Reg))]
                [g : (Graph Reg VertexData EdgeData)]) : (Graph Reg VertexData EdgeData)
  (dict-fold
    blocks
    (lambda ([block-num : Int] [state : (BlockState Reg)] [acc : (Graph Reg VertexData EdgeData)])
      : (Graph Reg VertexData EdgeData)
      (foldl
        (lambda ([s : (LiveOutState Reg)] [g : (Graph Reg VertexData EdgeData)])
          (add-move-edges-to-graph/live-out-state s g))
        (block->live-out-states state)
        acc))
    g))

(define (Reg) (print-graph
                [blocks : (Dict Int (BlockState Reg))]
                [reg-cmp : (Reg Reg -> Ordering)]
                [reg->bytes : (Reg -> Bytes)]
                [fixed-regs : (Set Reg)]) : Bytes
  (graph->graphviz
    (add-move-edges-to-graph/blocks
      blocks
      (add-interference-edges-to-graph/blocks
        blocks
        (add-live-variables-to-graph/blocks
          blocks
          (set-fold
            fixed-regs
            (lambda ([r : Reg] [g : (Graph Reg VertexData EdgeData)])
              (graph-add-vertex-if-absent
                g r (vertex-data (bytes-append (varargs list #"\"" (reg->bytes r) #"\"")))))
            ((lambda () : (Graph Reg VertexData EdgeData) (empty-graph reg-cmp))))
          reg->bytes)))))

(define (Reg) (blocks->live-out-states [blocks : (Dict Int (BlockState Reg))])
  : (List (LiveOutState Reg))
  (append* (map (lambda ([b : (BlockState Reg)]) (block->live-out-states b))
                (dict-values blocks))))
