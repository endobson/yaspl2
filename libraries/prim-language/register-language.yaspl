#:module register-language
#:import {
  bytes {
    #:values
      bytes-append
      bytes=?
  }
  dict {
    #:types
      Dict
  }
  list {
    #:types
      List
    #:values
      list
  }
  numbers {
    #:values
      integer->decimal-bytes
  }
  prim {
    #:types
      Boolean
      Bytes
      Int
    #:values
      =
      and
  }
  prim-language {
    #:types
      BinOp
  }
}
(export
  #:types (FunctionDefinition BasicBlock Instruction Terminal Var)
  #:values (function-definition return basic-block bin-op-inst var cond-jump jump
            var=? int-literal var->bytes var-condition)
  #:patterns (function-definition var))
(types
  (define-type FunctionDefinition
    (function-definition
      [name : Bytes]
      [entry-block : Int]
      [blocks : (Dict Int BasicBlock)]
      [next-var-number : Int]
      [next-block-number : Int]))
  (define-type Var
    (var [name : Bytes] [counter : Int]))
  (define-type BasicBlock
    (basic-block [args : (List Var)] [instructions : (List Instruction)] [terminal : Terminal]))

  (define-type Instruction
    (int-literal [output : Var] [v : Int])
    (bin-op-inst [output : Var] [op : BinOp] [left : Var] [right : Var]))

  (define-type Condition
    (var-condition [name : Var]))

  (define-type Terminal
    (return [name : Var])
    (cond-jump [cond : Condition]
               [true : Int] [true-args : (List Var)]
               [false : Int] [false-args : (List Var)])
    (jump [index : Int] [args : (List Var)])))

(define (var=? [v1 : Var] [v2 : Var]) : Boolean
  (match-define (var n1 c1) v1)
  (match-define (var n2 c2) v2)
  (and (bytes=? n1 n2) (= c1 c2)))

(define (var->bytes [v : Var]) : Bytes
  (match-define (var name counter) v)
  (bytes-append (varargs list name #"_" (integer->decimal-bytes counter))))
