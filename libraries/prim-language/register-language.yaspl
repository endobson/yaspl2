#:module (register-language)
#:import {
  (bytes) {
    #:values
      bytes-append
      bytes=?
  }
  (dict) {
    #:types
      Dict
  }
  (list) {
    #:types
      List
    #:values
      list
  }
  (numbers) {
    #:values
      integer->decimal-bytes
  }
  (prim) {
    #:types
      Boolean
      Bytes
      Int
    #:values
      =
      and
  }
  (prim-language) {
    #:types
      BinOp
      ComparisonOp
  }
  (syscalls) {
    #:types
      Syscall
  }
}
(export
  #:types (FunctionDefinition BasicBlock Instruction Terminal Var Condition UnaryOp)
  #:values (function-definition return basic-block bin-op-inst var cond-jump jump
            var=? int-literal var->bytes var-condition comparison-condition negated-var-condition
            syscall-inst function-allocate-inst pointer-set!-inst pointer-ref-inst
            eight-byte-mem-op unary-op-inst truncate-unsigned-int64->unsigned-int8)
  #:patterns (function-definition var))
(types
  (define-type FunctionDefinition
    (function-definition
      [name : Bytes]
      [entry-block : Int]
      [blocks : (Dict Int BasicBlock)]
      [next-var-number : Int]
      [next-block-number : Int]))
  (define-type Var
    (var [name : Bytes] [counter : Int]))
  (define-type BasicBlock
    (basic-block [args : (List Var)] [instructions : (List Instruction)] [terminal : Terminal]))

  (define-type Instruction
    (int-literal [output : Var] [v : Int])
    (bin-op-inst [output : Var] [op : BinOp] [left : Var] [right : Var])
    (unary-op-inst [output : Var] [op : UnaryOp] [expr : Var])
    (pointer-set!-inst [size : MemoryOperationSize] [pointer : Var] [val : Var])
    (pointer-ref-inst [output : Var] [size : MemoryOperationSize] [pointer : Var])
    (syscall-inst [output : Var] [syscall : Syscall] [args : (List Var)])
    (function-allocate-inst [output : Var] [num-bytes : Var]))

  (define-type UnaryOp
    (truncate-unsigned-int64->unsigned-int8))

  (define-type MemoryOperationSize
    (one-byte-mem-op)
    (eight-byte-mem-op))

  (define-type Condition
    (var-condition [name : Var])
    (negated-var-condition [name : Var])
    (comparison-condition [op : ComparisonOp] [left : Var] [right : Var]))

  (define-type Terminal
    (return [name : Var])
    (cond-jump [cond : Condition]
               [true : Int] [true-args : (List Var)]
               [false : Int] [false-args : (List Var)])
    (jump [index : Int] [args : (List Var)])))

(define (var=? [v1 : Var] [v2 : Var]) : Boolean
  (match-define (var n1 c1) v1)
  (match-define (var n2 c2) v2)
  (and (bytes=? n1 n2) (= c1 c2)))

(define (var->bytes [v : Var]) : Bytes
  (match-define (var name counter) v)
  (bytes-append (varargs list name #"_" (integer->decimal-bytes counter))))
