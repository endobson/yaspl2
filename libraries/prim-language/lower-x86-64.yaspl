#:module (lower-x86-64)
#:import {
  (block-number)
  (bytes)
  (data indexed-set)
  (data lifted-primitives)
  (data ordering)
  (dict)
  (either)
  (list)
  {(lowered-register-language)
    {#:types
      [BasicBlock l:BasicBlock]
      [FunctionDefinition l:FunctionDefinition]
      [Instruction l:Instruction]
      [PointerOffsetScale l:PointerOffsetScale]
      [Terminal l:Terminal]
      [UnvalidatedBlockMap l:UnvalidatedBlockMap]
    }
    {#:values
      [basic-block l:basic-block]
      [boolean-not l:boolean-not]
      [closure-call l:closure-call]
      [compare-mem-arg-ptr l:compare-mem-arg-ptr]
      [compare-mem-arg-val l:compare-mem-arg-val]
      [compare-memory l:compare-memory]
      [compare-s64 l:compare-s64]
      [compare-s8 l:compare-s8]
      [comparison-condition l:comparison-condition]
      [comparison-op-immediate l:comparison-op-immediate]
      [comparison-op-inst l:comparison-op-inst]
      [cond-jump/false-fall-through l:cond-jump/false-fall-through]
      [direct-call l:direct-call]
      [eight-byte-scale l:eight-byte-scale]
      [empty-unvalidated-block-map l:empty-unvalidated-block-map]
      [fixed-unary-op-inst l:fixed-unary-op-inst]
      [free-unary-op-inst l:free-unary-op-inst]
      [function-call-inst l:function-call-inst]
      [function-definition l:function-definition]
      [halt l:halt]
      [indirect-function-call l:indirect-function-call]
      [int-literal l:int-literal]
      [jump l:jump]
      [load-8byte l:load-8byte]
      [load-8byte/scaled l:load-8byte/scaled]
      [load-zero-extended-byte l:load-zero-extended-byte]
      [load-zero-extended-byte/scaled l:load-zero-extended-byte/scaled]
      [logical-op-inst l:logical-op-inst]
      [memory-compare-condition l:memory-compare-condition]
      [move l:move]
      [mult-immediate l:mult-immediate]
      [negated-reg-condition l:negated-reg-condition]
      [numeric-op-immediate l:numeric-op-immediate]
      [numeric-op-inst l:numeric-op-inst]
      [one-byte-scale l:one-byte-scale]
      [quotient-remainder-inst l:quotient-remainder-inst]
      [reg-condition l:reg-condition]
      [reg-or-s32-reg l:reg-or-s32-reg]
      [reg-or-s32-s32 l:reg-or-s32-s32]
      [reg-or-s8-reg l:reg-or-s8-reg]
      [reg-or-s8-s8 l:reg-or-s8-s8]
      [return l:return]
      [store-8byte l:store-8byte]
      [store-8byte/immediate l:store-8byte/immediate]
      [store-8byte/scaled l:store-8byte/scaled]
      [store-least-significant-byte l:store-least-significant-byte]
      [store-least-significant-byte/scaled l:store-least-significant-byte/scaled]
      [symbol-address l:symbol-address]
      [syscall l:syscall]
      [tail-call l:tail-call]
      [truncate-unsigned-int64->unsigned-int8 l:truncate-unsigned-int64->unsigned-int8]
      [unvalidated-block-map-add-block l:unvalidated-block-map-add-block]
      [validate-block-map l:validate-block-map]
    }
  }
  (maybe)
  (numbers)
  (panic)
  (prim)
  {(prim-language)
    {#:patterns
      comparison-bin-op
      logical-bin-op
      numeric-bin-op
    }
  }
  (prim-language variant-info)
  {(register-language)
    {#:types
      [BasicBlock r:BasicBlock]
      [CallingConvention r:CallingConvention]
      [FunctionDefinition r:FunctionDefinition]
      [Instruction r:Instruction]
      [PointerOffsetScale r:PointerOffsetScale]
      [Terminal r:Terminal]
    }
    {#:values
      [output-var r:output-var]
    }
    {#:patterns
      [basic-block r:basic-block]
      [bin-op-inst r:bin-op-inst]
      [boolean-not r:boolean-not]
      [closure-call r:closure-call]
      [closure-convention r:closure-convention]
      [compare-mem-arg-ptr r:compare-mem-arg-ptr]
      [compare-mem-arg-val r:compare-mem-arg-val]
      [compare-s64 r:compare-s64]
      [compare-s8 r:compare-s8]
      [comparison-condition r:comparison-condition]
      [cond-jump r:cond-jump]
      [direct-call r:direct-call]
      [eight-byte-mem-op r:eight-byte-mem-op]
      [eight-byte-scale r:eight-byte-scale]
      [fixed-pointer-offset r:fixed-pointer-offset]
      [function-allocate-inst r:function-allocate-inst]
      [function-call-inst r:function-call-inst]
      [function-definition r:function-definition]
      [halt r:halt]
      [heap-allocate-inst/static r:heap-allocate-inst/static]
      [indirect-function-call r:indirect-function-call]
      [int-literal r:int-literal]
      [jump r:jump]
      [jump-target r:jump-target]
      [memory-compare-condition r:memory-compare-condition]
      [memory-compare-inst r:memory-compare-inst]
      [negated-var-condition r:negated-var-condition]
      [negated-variant-tag-condition r:negated-variant-tag-condition]
      [one-byte-mem-op r:one-byte-mem-op]
      [one-byte-scale r:one-byte-scale]
      [plain-function-convention r:plain-function-convention]
      [pointer-ref-inst r:pointer-ref-inst]
      [pointer-set!-inst r:pointer-set!-inst]
      [return r:return]
      [scaled-pointer-offset r:scaled-pointer-offset]
      [symbol-address-inst r:symbol-address-inst]
      [syscall r:syscall]
      [tail-call r:tail-call]
      [truncate-unsigned-int64->unsigned-int8 r:truncate-unsigned-int64->unsigned-int8]
      [unary-op-inst r:unary-op-inst]
      [var-condition r:var-condition]
      [var-or-s32-s32 r:var-or-s32-s32]
      [var-or-s32-var r:var-or-s32-var]
      [var-or-s8-s8 r:var-or-s8-s8]
      [var-or-s8-var r:var-or-s8-var]
      [variant-allocate-inst r:variant-allocate-inst]
      [variant-ref-inst r:variant-ref-inst]
    }
  }
  {(register-language-used-vars)
    {#:values
      [used-vars/instruction r:used-vars/instruction]
      [used-vars/terminal r:used-vars/terminal]
    }
  }
  (set)
  {(simplify-register-language)
    {#:values
      [side-effect-free-instruction? r:side-effect-free-instruction?]
    }
  }
  (tuples)
  (yaspl math-operations)
  (yaspl var)
}
(export
  (#:types Reg X8664Register)
  (#:values lower-function reg->bytes x86-64-register=? x86-64-register-cmp
            x86-64-register->bytes reg=? reg-cmp
            valid-temporary-x86-64-registers
            num-valid-temporary-x86-64-registers
            all-fixed-registers
            rax rdi rsi rdx rcx r8 r9 r10 r11 r15 rbp rsp temporary-reg fixed-reg)
  (#:patterns rax rdi rsi rdx rcx r8 r9 r10 r11 r15 rbp rsp rbx r12 r13 r14
              fixed-reg temporary-reg))
(types
  (define-type X8664Register
    (rax)
    (rbx)
    (rcx)
    (rdx)
    (rdi)
    (rsi)
    (rbp)
    (rsp)
    (r8)
    (r9)
    (r10)
    (r11)
    (r12)
    (r13)
    (r14)
    (r15))
  (define-type Reg
    (fixed-reg [r : X8664Register])
    (temporary-reg [r : Var]))

  ;; Extra instructions to make constant propagation work
  (define-type ExtendedBasicBlock
    (extended-basic-block
      [number : BlockNumber]
      [args : (List Var)]
      [instructions : (List ExtendedInstruction)]
      [terminal : ExtendedTerminal]))
  (define-type ExtendedInstruction
    (extended-instruction [i : r:Instruction])
    (ex:numeric-op-immediate-inst [output : Var] [op : NumericBinOp] [input : Var] [amount : S32])
    (ex:comparison-op-immediate-inst [output : Var] [op : ComparisonBinOp] [input : Var] [amount : S32]))

  (define-type ExtendedTerminal
    (extended-terminal [t : r:Terminal])))

(define (empty-blocks [entry-block-num : BlockNumber]) : (l:UnvalidatedBlockMap Reg)
  (l:empty-unvalidated-block-map entry-block-num))

(define (valid-temporary-x86-64-registers) : (Set X8664Register)
  (set-add-all
    (make-set x86-64-register-cmp)
    (varargs list
      (rax)
      (rbx)
      (rcx)
      (rdx)
      (rdi)
      (rsi)
      (r8)
      (r9)
      (r10)
      (r11)
      (r12)
      (r13))))

(define (num-valid-temporary-x86-64-registers) : Int
  12)

(define (callee-saved-temporary-x86-64-registers) : (Set X8664Register)
  (set-add-all
    (make-set x86-64-register-cmp)
    (varargs list
      (rbx)
      (r12)
      (r13))))


(define (all-fixed-registers) : (Set Reg)
  (set-add-all
    (make-set reg-cmp)
    (map
      fixed-reg
      (varargs list
        (rax)
        (rbx)
        (rcx)
        (rdx)
        (rdi)
        (rsi)
        (rbp)
        (rsp)
        (r8)
        (r9)
        (r10)
        (r11)
        (r12)
        (r13)
        (r14)
        (r15)))))

;; Conflicts for all kinds of calls.
(define (call-conflicts) : (List Reg)
  (map
    fixed-reg
    (varargs list
      (rax)
      (rcx)
      (rdx)
      (rdi)
      (rsi)
      (r8)
      (r9)
      (r10)
      (r11))))


(define (reg->bytes [reg : Reg]) : Bytes
  (case reg
    [(fixed-reg (rax)) #"_rax"]
    [(fixed-reg (rbx)) #"_rbx"]
    [(fixed-reg (rcx)) #"_rcx"]
    [(fixed-reg (rdx)) #"_rdx"]
    [(fixed-reg (rdi)) #"_rdi"]
    [(fixed-reg (rsi)) #"_rsi"]
    [(fixed-reg (rbp)) #"_rbp"]
    [(fixed-reg (rsp)) #"_rsp"]
    [(fixed-reg (r8)) #"_r8"]
    [(fixed-reg (r9)) #"_r9"]
    [(fixed-reg (r10)) #"_r10"]
    [(fixed-reg (r11)) #"_r11"]
    [(fixed-reg (r12)) #"_r12"]
    [(fixed-reg (r13)) #"_r13"]
    [(fixed-reg (r14)) #"_r14"]
    [(fixed-reg (r15)) #"_r15"]
    [(temporary-reg v) (var->bytes v)]))


(define (x86-64-register->bytes [reg : X8664Register]) : Bytes
  (case reg
    [(rax) #"rax"]
    [(rbx) #"rbx"]
    [(rcx) #"rcx"]
    [(rdx) #"rdx"]
    [(rdi) #"rdi"]
    [(rsi) #"rsi"]
    [(rbp) #"rbp"]
    [(rsp) #"rsp"]
    [(r8) #"r8"]
    [(r9) #"r9"]
    [(r10) #"r10"]
    [(r11) #"r11"]
    [(r12) #"r12"]
    [(r13) #"r13"]
    [(r14) #"r14"]
    [(r15) #"r15"]))


(define (x86-64-register=? [reg1 : X8664Register] [reg2 : X8664Register]) : Boolean
  (case (x86-64-register-cmp reg1 reg2)
    [(equal-to) #t]
    [_ #f]))

(define (x86-64-register-cmp [reg1 : X8664Register] [reg2 : X8664Register]) : Ordering
  (case (tuple2 reg1 reg2)
    [(tuple2 (rax) (rax)) (equal-to)]
    [(tuple2 (rax) _) (less-than)]
    [(tuple2 _ (rax)) (greater-than)]
    [(tuple2 (rbx) (rbx)) (equal-to)]
    [(tuple2 (rbx) _) (less-than)]
    [(tuple2 _ (rbx)) (greater-than)]
    [(tuple2 (rcx) (rcx)) (equal-to)]
    [(tuple2 (rcx) _) (less-than)]
    [(tuple2 _ (rcx)) (greater-than)]
    [(tuple2 (rdx) (rdx)) (equal-to)]
    [(tuple2 (rdx) _) (less-than)]
    [(tuple2 _ (rdx)) (greater-than)]
    [(tuple2 (rdi) (rdi)) (equal-to)]
    [(tuple2 (rdi) _) (less-than)]
    [(tuple2 _ (rdi)) (greater-than)]
    [(tuple2 (rsi) (rsi)) (equal-to)]
    [(tuple2 (rsi) _) (less-than)]
    [(tuple2 _ (rsi)) (greater-than)]
    [(tuple2 (rsp) (rsp)) (equal-to)]
    [(tuple2 (rsp) _) (less-than)]
    [(tuple2 _ (rsp)) (greater-than)]
    [(tuple2 (rbp) (rbp)) (equal-to)]
    [(tuple2 (rbp) _) (less-than)]
    [(tuple2 _ (rbp)) (greater-than)]
    [(tuple2 (r8) (r8)) (equal-to)]
    [(tuple2 (r8) _) (less-than)]
    [(tuple2 _ (r8)) (greater-than)]
    [(tuple2 (r9) (r9)) (equal-to)]
    [(tuple2 (r9) _) (less-than)]
    [(tuple2 _ (r9)) (greater-than)]
    [(tuple2 (r10) (r10)) (equal-to)]
    [(tuple2 (r10) _) (less-than)]
    [(tuple2 _ (r10)) (greater-than)]
    [(tuple2 (r11) (r11)) (equal-to)]
    [(tuple2 (r11) _) (less-than)]
    [(tuple2 _ (r11)) (greater-than)]
    [(tuple2 (r12) (r12)) (equal-to)]
    [(tuple2 (r12) _) (less-than)]
    [(tuple2 _ (r12)) (greater-than)]
    [(tuple2 (r13) (r13)) (equal-to)]
    [(tuple2 (r13) _) (less-than)]
    [(tuple2 _ (r13)) (greater-than)]
    [(tuple2 (r14) (r14)) (equal-to)]
    [(tuple2 (r14) _) (less-than)]
    [(tuple2 _ (r14)) (greater-than)]
    [(tuple2 (r15) (r15)) (equal-to)]
    ;[(tuple2 (r15) _) (less-than)]
    ;[(tuple2 _ (r15)) (greater-than)]
    ))


(define (reg=? [reg1 : Reg] [reg2 : Reg]) : Boolean
  (case (reg-cmp reg1 reg2)
    [(equal-to) #t]
    [_ #f]))

(define (reg-cmp [reg1 : Reg] [reg2 : Reg]) : Ordering
  (case (tuple2 reg1 reg2)
    [(tuple2 (fixed-reg r1) (fixed-reg r2))
     (x86-64-register-cmp r1 r2)]
    [(tuple2 (temporary-reg v1) (temporary-reg v2)) (var-cmp v1 v2)]
    [(tuple2 (fixed-reg _) (temporary-reg _)) (greater-than)]
    [(tuple2 (temporary-reg _) (fixed-reg _)) (less-than)]))

(define (convert-scale [s : r:PointerOffsetScale]) : l:PointerOffsetScale
  (case s
    [(r:one-byte-scale) (l:one-byte-scale)]
    [(r:eight-byte-scale) (l:eight-byte-scale)]))

;; Takes number of bytes in rax.
;; Return pointer in rax.
(define (heap-allocate) : (l:Instruction Reg)
  (l:function-call-inst (fixed-reg (rax))
           (l:direct-call #"yprim_heap_allocate")
           (varargs list (fixed-reg (rax)))
           (empty)))


(define (lower-function [fun : r:FunctionDefinition]) : (l:FunctionDefinition Reg)
  (match-define (r:function-definition name convention blocks next-var next-block) fun)
  (match-define lowered-entry-block next-block)
  (match-define next-block (next-block-number next-block))

  (match-define (tuple2 saved-register-pairs _next-var)
    (compute-saved-register-pairs next-var))

  (match-define extended-blocks (extend-blocks blocks))

  (match-define (tuple2 _next-block new-blocks)
    (indexed-set-fold
      extended-blocks
      (lambda ([b : ExtendedBasicBlock] [acc : (Tuple2 BlockNumber (l:UnvalidatedBlockMap Reg))])
        (lower-block b extended-blocks saved-register-pairs acc))
      (tuple2 next-block (empty-blocks lowered-entry-block))))
  (match-define entry-block (make-entry-block convention extended-blocks saved-register-pairs))
  (match-define new-blocks
    (l:unvalidated-block-map-add-block
      new-blocks lowered-entry-block entry-block))

  (case (l:validate-block-map new-blocks)
    [(left msg) (panic msg)]
    [(right validated-new-blocks)
     (l:function-definition name 0 validated-new-blocks)]))

(define (args/registers [args : (List Var)] [registers : (List X8664Register)]
                        [overflow-register : X8664Register])
  : (List (l:Instruction Reg))
  (case registers
    [(empty)
     (args/extra-registers args 0 overflow-register)]
    [(cons reg registers)
     (case args
       [(empty) (empty)]
       [(cons arg args)
        (cons
          (l:move (temporary-reg arg) (fixed-reg reg))
          (args/registers args registers overflow-register))])]))

(define (args/extra-registers [args : (List Var)] [offset : Int] [overflow-register : X8664Register])
  : (List (l:Instruction Reg))
  (case args
    [(empty) (empty)]
    [(cons arg args)
     (cons
       (l:load-8byte (temporary-reg arg) (fixed-reg overflow-register) offset)
       (args/extra-registers args (+ offset 8) overflow-register))]))


(define (make-entry-block [convention : r:CallingConvention]
                          [blocks : (IndexedSet ExtendedBasicBlock BlockNumber)]
                          [saved-register-pairs : (List (Tuple2 X8664Register Var))])
  : (l:BasicBlock Reg)
  (match-define arg-registers (varargs list (rdi) (rsi) (rdx) (rcx) (r8) (r9)))
  (match-define overflow-arg-register (rax))
  (match-define save-register-instructions
    (map
      (lambda ([p : (Tuple2 X8664Register Var)])
        (case p
          [(tuple2 reg var)
           (l:move (temporary-reg var) (fixed-reg reg))]))
      saved-register-pairs))
  (case convention
    [(r:plain-function-convention _num-args entry-block-num)
     (case (indexed-set-ref blocks entry-block-num)
       [(nothing) (panic #"No entry block")]
       [(just (extended-basic-block _ args _ _))
        (l:basic-block
          (append
            save-register-instructions
            (args/registers args arg-registers overflow-arg-register))
          (ann (l:Terminal Reg) (l:jump entry-block-num)))])]
    [(r:closure-convention num-args entry-block-num num-free-vars)
     (case (indexed-set-ref blocks entry-block-num)
       [(nothing) (panic #"No entry block")]
       [(just (extended-basic-block _ args _ _))
        (l:basic-block
          (append
            save-register-instructions
            (append
              (args/registers (take num-args args) arg-registers overflow-arg-register)
              (case (zip (drop num-args args)
                         (build-list num-free-vars (lambda ([x : Int]) (lifted-int (* 8 (+ x 1))))))
                [(nothing) (panic #"Wrong number of free vars")]
                [(just free-vars+offsets)
                 (map
                   (lambda ([t : (Tuple2 Var LiftedInt)])
                     (case t
                       [(tuple2 v (lifted-int offset))
                        (l:load-8byte (temporary-reg v) (fixed-reg (r11)) offset)]))
                   free-vars+offsets)])))
          (ann (l:Terminal Reg) (l:jump entry-block-num)))])]))

(define (compute-saved-register-pairs [next-var : VarNumber])
  : (Tuple2 (List (Tuple2 X8664Register Var)) VarNumber)
  (set-fold
    (callee-saved-temporary-x86-64-registers)
    (lambda ([reg : X8664Register] [acc : (Tuple2 (List (Tuple2 X8664Register Var)) VarNumber)])
      (case acc
        [(tuple2 pairs next-var)
         (tuple2
           (cons
             (tuple2 reg (var #"saved" next-var))
             pairs)
           (next-var-number next-var))]))
    (tuple2
      (ann (List (Tuple2 X8664Register Var)) (empty))
      next-var)))


(define (lower-block [b : ExtendedBasicBlock]
                     [blocks : (IndexedSet ExtendedBasicBlock BlockNumber)]
                     [saved-register-pairs : (List (Tuple2 X8664Register Var))]
                     [acc : (Tuple2 BlockNumber (l:UnvalidatedBlockMap Reg))])
  : (Tuple2 BlockNumber (l:UnvalidatedBlockMap Reg))
  (match-define (extended-basic-block block-num _ instructions terminal) b)
  (match-define (tuple3 end-insts terminal (tuple2 next-block acc-blocks))
    (lower-extended-terminal terminal blocks saved-register-pairs acc))
  (tuple2
    next-block
    (l:unvalidated-block-map-add-block
      acc-blocks
      block-num
      (l:basic-block
        (append
          (append* (map lower-extended-instruction instructions))
          end-insts)
        terminal))))

(define (match-args [index : BlockNumber] [args : (List Var)]
                    [blocks : (IndexedSet ExtendedBasicBlock BlockNumber)])
  : (List (Tuple2 Var Var))
  (case (indexed-set-ref blocks index)
    [(nothing) (panic #"No block")]
    [(just (extended-basic-block _ block-args _ _))
     (case (zip block-args args)
       [(nothing)
        (panic
          (bytes-append
            (varargs list
              #"Args don't match for Block: \n"
              (block-number->bytes index)
              #"\nArgs:"
              (integer->decimal-bytes (length args))
              #" Parameters: "
              (integer->decimal-bytes (length block-args)))))]
       [(just v) v])]))

(define (move-args [args : (List (Tuple2 Var Var))]) : (List (l:Instruction Reg))
  (match-define args
    (filter
      (lambda ([arg : (Tuple2 Var Var)])
        (case arg
          [(tuple2 v1 v2)
           (not (var=? v1 v2))]))
      args))
  (match-define moves (dict-add-all (ann (Dict Var Var) (make-dict var-cmp)) args))
  (if (has-cycle? moves)
      (panic #"Cannot currently perform permutation of args when jumping to block")
      (move-args/dict moves (empty))))


;; TODO implement this to avoid the posibility of infinite loops
(define (has-cycle? [args : (Dict Var Var)]) : Boolean
  #f)

(define (move-args/dict [args : (Dict Var Var)] [list : (List (l:Instruction Reg))]) :
  (List (l:Instruction Reg))
  (case (dict-split args)
    [(nothing) list]
    [(just (tuple2 (tuple2 dest src) args))
     (match-define (tuple2 args list) (move-args/dict* args src list))
     (move-args/dict args (cons (l:move (temporary-reg dest) (temporary-reg src)) list))]))


(define (move-args/dict* [args : (Dict Var Var)] [src : Var] [list : (List (l:Instruction Reg))]) :
  (Tuple2 (Dict Var Var) (List (l:Instruction Reg)))
  (case (dict-ref args src)
    [(nothing) (tuple2 args list)]
    [(just src2)
     (match-define (tuple2 args list) (move-args/dict* (dict-remove args src) src2 list))
     (tuple2 args (cons (l:move (temporary-reg src) (temporary-reg src2)) list))]))


(define (ann-term [t : (l:Terminal Reg)]) : (l:Terminal Reg)
  t)

(define (lower-extended-terminal
          [t : ExtendedTerminal]
          [blocks : (IndexedSet ExtendedBasicBlock BlockNumber)]
          [saved-register-pairs : (List (Tuple2 X8664Register Var))]
          [acc : (Tuple2 BlockNumber (l:UnvalidatedBlockMap Reg))])
  : (Tuple3 (List (l:Instruction Reg)) (l:Terminal Reg) (Tuple2 BlockNumber (l:UnvalidatedBlockMap Reg)))
  (case t
    [(extended-terminal (r:return name))
     (tuple3
       (append
         (map
           (lambda ([p : (Tuple2 X8664Register Var)])
             (case p
               [(tuple2 reg var)
                (l:move (fixed-reg reg) (temporary-reg var))]))
           saved-register-pairs)
         (varargs list
           (l:move (fixed-reg (rax)) (temporary-reg name))
           (l:move (fixed-reg (rsp)) (fixed-reg (rbp)))))
       (ann-term (l:return (fixed-reg (rax))))
       acc)]
    [(extended-terminal (r:halt))
     (tuple3 (empty) (ann-term (l:halt)) acc)]
    [(extended-terminal (r:tail-call f args))
     (match-define (tuple2 arg-insts arg-regs)
       (put-arguments-in-registers args (varargs list (rdi) (rsi) (rdx) (rcx) (r8) (r9))))
     (tuple3
       (append
         (append
           arg-insts
           (append
             (case f
               [(r:direct-call _) (empty)]
               [(r:indirect-function-call _) (empty)]
               [(r:closure-call c)
                (varargs list (l:move (fixed-reg (r11)) (temporary-reg c)))]
               [(r:syscall n) (varargs list (l:int-literal (fixed-reg (rax)) n))])
             (map
               (lambda ([p : (Tuple2 X8664Register Var)])
                 (case p
                   [(tuple2 reg var)
                    (l:move (fixed-reg reg) (temporary-reg var))]))
               saved-register-pairs)))
         (varargs list
           (l:move (fixed-reg (rsp)) (fixed-reg (rbp)))))
       (l:tail-call
         (case f
           [(r:direct-call f) (l:direct-call f)]
           [(r:indirect-function-call f) (l:indirect-function-call (temporary-reg f))]
           [(r:closure-call _) (l:closure-call (fixed-reg (r11)))]
           [(r:syscall _) (l:syscall (fixed-reg (rax)))])
         arg-regs)
       acc)]
    [(extended-terminal (r:jump (r:jump-target index args)))
     (tuple3
       (move-args (match-args index args blocks))
       (ann-term (l:jump index))
       acc)]
    [(extended-terminal (r:cond-jump condition (r:jump-target t-index t-args)
                                               (r:jump-target f-index f-args)))
     (match-define (tuple2 next-block acc-blocks) acc)
     (match-define new-acc-blocks
       (l:unvalidated-block-map-add-block
         (l:unvalidated-block-map-add-block
            acc-blocks
            next-block
            (l:basic-block (move-args (match-args t-index t-args blocks))
                           (ann-term (l:jump t-index))))
         (next-block-number next-block)
         (l:basic-block (move-args (match-args f-index f-args blocks))
                        (ann-term (l:jump f-index)))))

     (tuple3
       (case condition
         [(r:memory-compare-condition _negated? size v1 v2)
          (varargs list
            (l:move (fixed-reg (rcx)) (temporary-reg size))
            (l:move (fixed-reg (rdi)) (temporary-reg v1))
            (l:move (fixed-reg (rsi)) (temporary-reg v2)))]
         [_
          (empty)])
       (ann-term (l:cond-jump/false-fall-through
                   (case condition
                     [(r:var-condition v)
                      (l:reg-condition (temporary-reg v))]
                     [(r:negated-var-condition v)
                      (l:negated-reg-condition (temporary-reg v))]
                     [(r:negated-variant-tag-condition v tag)
                      ;; TODO support I8 which doesn't have sign connotations.
                      (l:comparison-condition
                        (not-equal-op)
                        (l:compare-s8
                          (l:compare-mem-arg-ptr (temporary-reg v))
                          (l:reg-or-s8-s8 (s8 (u8->s64 tag)))))]
                     [(r:comparison-condition op (r:compare-s64 l r))
                      (l:comparison-condition
                        op
                        (l:compare-s64
                          (case l
                            [(r:compare-mem-arg-val v) (l:compare-mem-arg-val (temporary-reg v))]
                            [(r:compare-mem-arg-ptr v) (l:compare-mem-arg-ptr (temporary-reg v))])
                          (case r
                            [(r:var-or-s32-var r) (l:reg-or-s32-reg (temporary-reg r))]
                            [(r:var-or-s32-s32 imm) (l:reg-or-s32-s32 imm)])))]
                     [(r:comparison-condition op (r:compare-s8 l r))
                      (l:comparison-condition
                        op
                        (l:compare-s8
                          (case l
                            [(r:compare-mem-arg-val v) (l:compare-mem-arg-val (temporary-reg v))]
                            [(r:compare-mem-arg-ptr v) (l:compare-mem-arg-ptr (temporary-reg v))])
                          (case r
                            [(r:var-or-s8-var r) (l:reg-or-s8-reg (temporary-reg r))]
                            [(r:var-or-s8-s8 imm) (l:reg-or-s8-s8 imm)])))]
                     [(r:memory-compare-condition negated? _size _v1 _v2)
                      (l:memory-compare-condition
                        negated? (fixed-reg (rcx)) (fixed-reg (rdi)) (fixed-reg (rsi)))])
                   next-block
                   (next-block-number next-block)))
       (tuple2 (next-block-number (next-block-number next-block)) new-acc-blocks))]))

;; TODO make this not use the heap so that it can be used from the GC system
(define (put-arguments-in-registers
          [args : (List Var)]
          [regs : (List X8664Register)]) :
  (Tuple2 (List (l:Instruction Reg)) (List Reg))
  (case regs
    [(empty)
     (match-define overflow-register (rax))
     (case args
       [(empty) (tuple2 (empty) (empty))]
       [_
         (tuple2
           (cons
             (l:int-literal (fixed-reg overflow-register) (* 8 (length args)))
             (cons
               (heap-allocate)
               (put-arguments-in-memory args 0 overflow-register)))
           (cons (fixed-reg overflow-register) (empty)))])]
    [(cons reg regs)
     (case args
       [(empty) (tuple2 (empty) (empty))]
       [(cons arg args)
        (case (put-arguments-in-registers args regs)
          [(tuple2 arg-insts arg-regs)
           (tuple2
             (cons (l:move (fixed-reg reg) (temporary-reg arg)) arg-insts)
             (cons (fixed-reg reg) arg-regs))])])]))

(define (put-arguments-in-memory
          [args : (List Var)]
          [offset : Int]
          [overflow-register : X8664Register]) :
  (List (l:Instruction Reg))
  (case args
    [(empty) (empty)]
    [(cons arg args)
     (cons
       (l:store-8byte (fixed-reg overflow-register) offset (temporary-reg arg))
       (put-arguments-in-memory args (+ offset 8) overflow-register))]))


(define (lower-extended-instruction [i : ExtendedInstruction]) : (List (l:Instruction Reg))
  (case i
    [(extended-instruction i) (lower-register-instruction i)]
    [(ex:numeric-op-immediate-inst output (mult-op) l v)
     (varargs list
       (l:mult-immediate (temporary-reg output) (temporary-reg l) v))]
    [(ex:numeric-op-immediate-inst output op l v)
     (varargs list
       (l:move (temporary-reg output) (temporary-reg l))
       (l:numeric-op-immediate (temporary-reg output) op v))]
    [(ex:comparison-op-immediate-inst output op l v)
     (varargs list
       (l:comparison-op-immediate (temporary-reg output) op (temporary-reg l) v))]))

(define (lower-register-instruction [i : r:Instruction]) : (List (l:Instruction Reg))
  (case i
    [(r:int-literal output v)
     (varargs list (l:int-literal (temporary-reg output) v))]
    [(r:symbol-address-inst output v)
     (varargs list (l:symbol-address (temporary-reg output) v))]
    [(r:bin-op-inst output (numeric-bin-op (quotient-op)) l r)
     (varargs list
       (l:move (fixed-reg (rax)) (temporary-reg l))
       (l:int-literal (fixed-reg (rdx)) 0)
       (l:quotient-remainder-inst (fixed-reg (rax)) (fixed-reg (rdx)) (fixed-reg (rdx))
                                  (fixed-reg (rax)) (temporary-reg r))
       (l:move (temporary-reg output) (fixed-reg (rax))))]
    [(r:bin-op-inst output (numeric-bin-op (remainder-op)) l r)
     (varargs list
       (l:move (fixed-reg (rax)) (temporary-reg l))
       (l:int-literal (fixed-reg (rdx)) 0)
       (l:quotient-remainder-inst (fixed-reg (rax)) (fixed-reg (rdx)) (fixed-reg (rdx))
                                  (fixed-reg (rax)) (temporary-reg r))
       (l:move (temporary-reg output) (fixed-reg (rdx))))]
    [(r:bin-op-inst output (numeric-bin-op (logical-shift-left-op)) l r)
     (varargs list
       (l:move (fixed-reg (rcx)) (temporary-reg r))
       (l:move (temporary-reg output) (temporary-reg l))
       (l:numeric-op-inst (temporary-reg output) (logical-shift-left-op) (fixed-reg (rcx))))]
    [(r:bin-op-inst output (numeric-bin-op (logical-shift-right-op)) l r)
     (varargs list
       (l:move (fixed-reg (rcx)) (temporary-reg r))
       (l:move (temporary-reg output) (temporary-reg l))
       (l:numeric-op-inst (temporary-reg output) (logical-shift-right-op) (fixed-reg (rcx))))]
    [(r:bin-op-inst output (numeric-bin-op op) l r)
     (varargs list
       (l:move (temporary-reg output) (temporary-reg l))
       (l:numeric-op-inst (temporary-reg output) op (temporary-reg r)))]
    [(r:bin-op-inst output (comparison-bin-op op) l r)
     (varargs list
       (l:comparison-op-inst (temporary-reg output) op (temporary-reg l) (temporary-reg r)))]
    [(r:bin-op-inst output (logical-bin-op op) l r)
     (varargs list
       (l:move (temporary-reg output) (temporary-reg l))
       (l:logical-op-inst (temporary-reg output) op (temporary-reg r)))]
    [(r:unary-op-inst output (r:truncate-unsigned-int64->unsigned-int8) input)
     (varargs list
       (l:free-unary-op-inst (temporary-reg output) (l:truncate-unsigned-int64->unsigned-int8)
                             (temporary-reg input)))]
    [(r:unary-op-inst output (r:boolean-not) input)
     (varargs list
       (l:move (temporary-reg output) (temporary-reg input))
       (l:fixed-unary-op-inst (temporary-reg output) (l:boolean-not)))]
    [(r:function-allocate-inst output num-bytes)
     (varargs list
       (l:numeric-op-inst (fixed-reg (rsp)) (sub-op) (temporary-reg num-bytes))
       (l:move (temporary-reg output) (fixed-reg (rsp))))]
    [(r:heap-allocate-inst/static output num-bytes)
     (varargs list
       (l:int-literal (fixed-reg (rax)) (s32->s64 num-bytes))
       (heap-allocate)
       (l:move (temporary-reg output) (fixed-reg (rax))))]
    [(r:variant-allocate-inst output (variant-info tag) fields)
     (append
       (varargs list
         (l:int-literal (fixed-reg (rax)) (+ 8 (* 8 (length fields))))
         (heap-allocate)
         (l:move (temporary-reg output) (fixed-reg (rax)))
         (l:store-8byte/immediate (temporary-reg output) 0 (s32 (u8->s64 tag))))
       (map/indexed
         (lambda ([v : Var] [field-number : Int])
           (l:store-8byte (temporary-reg output) (+ 8 (* 8 field-number)) (temporary-reg v)))
         fields))]
    [(r:pointer-set!-inst (r:eight-byte-mem-op) ptr (r:fixed-pointer-offset offset) val)
     (varargs list (l:store-8byte (temporary-reg ptr) offset (temporary-reg val)))]
    [(r:pointer-set!-inst (r:eight-byte-mem-op) ptr (r:scaled-pointer-offset index scale offset) val)
     (varargs list (l:store-8byte/scaled (temporary-reg ptr) (temporary-reg index)
                                         (convert-scale scale) offset (temporary-reg val)))]
    [(r:pointer-ref-inst output (r:eight-byte-mem-op) loc (r:fixed-pointer-offset offset))
     (varargs list (l:load-8byte (temporary-reg output) (temporary-reg loc) offset))]
    [(r:pointer-ref-inst output (r:eight-byte-mem-op) loc (r:scaled-pointer-offset index scale offset))
     (varargs list
       (l:load-8byte/scaled (temporary-reg output) (temporary-reg loc)
                            (temporary-reg index) (convert-scale scale) offset))]
    [(r:pointer-set!-inst (r:one-byte-mem-op) ptr (r:fixed-pointer-offset offset) val)
     (varargs list (l:store-least-significant-byte (temporary-reg ptr) offset (temporary-reg val)))]
    [(r:pointer-set!-inst (r:one-byte-mem-op) ptr (r:scaled-pointer-offset index scale offset) val)
     (varargs list (l:store-least-significant-byte/scaled (temporary-reg ptr) (temporary-reg index)
                                                          (convert-scale scale) offset
                                                          (temporary-reg val)))]
    [(r:pointer-ref-inst output (r:one-byte-mem-op) loc (r:fixed-pointer-offset offset))
     (varargs list (l:load-zero-extended-byte (temporary-reg output) (temporary-reg loc) offset))]
    [(r:pointer-ref-inst output (r:one-byte-mem-op) loc (r:scaled-pointer-offset index scale offset))
     (varargs list
       (l:load-zero-extended-byte/scaled
         (temporary-reg output) (temporary-reg loc)
         (temporary-reg index) (convert-scale scale) offset))]
    [(r:variant-ref-inst output variant index)
     (varargs list (l:load-8byte (temporary-reg output) (temporary-reg variant) (+ 8 (* 8 index))))]
    [(r:memory-compare-inst output size v1 v2)
     (varargs list
       (l:move (fixed-reg (rcx)) (temporary-reg size))
       (l:move (fixed-reg (rdi)) (temporary-reg v1))
       (l:move (fixed-reg (rsi)) (temporary-reg v2))
       (l:compare-memory (temporary-reg output) (fixed-reg (rcx)) (fixed-reg (rdi)) (fixed-reg (rsi))))]
    [(r:function-call-inst output f args)
     (match-define (tuple2 arg-insts arg-regs)
       (put-arguments-in-registers args (varargs list (rdi) (rsi) (rdx) (rcx) (r8) (r9))))
     (append
       arg-insts
       (append
         (case f
           [(r:direct-call _) (empty)]
           [(r:indirect-function-call _) (empty)]
           [(r:closure-call c)
            (varargs list (l:move (fixed-reg (r11)) (temporary-reg c)))]
           [(r:syscall n) (varargs list (l:int-literal (fixed-reg (rax)) n))])
         (varargs list
           (l:function-call-inst
             (fixed-reg (rax))
             (case f
               [(r:direct-call f) (l:direct-call f)]
               [(r:indirect-function-call f) (l:indirect-function-call (temporary-reg f))]
               [(r:closure-call _) (l:closure-call (fixed-reg (r11)))]
               [(r:syscall _) (l:syscall (fixed-reg (rax)))])
             arg-regs
             (call-conflicts))
           (l:move (temporary-reg output) (fixed-reg (rax))))))]))


(define (extend-blocks [b : (IndexedSet r:BasicBlock BlockNumber)])
  : (IndexedSet ExtendedBasicBlock BlockNumber)
  (remove-dead-instructions
    (specialize-instructions-to-immediate b)))


(define (specialize-instructions-to-immediate [blocks : (IndexedSet r:BasicBlock BlockNumber)])
  : (IndexedSet ExtendedBasicBlock BlockNumber)
  (indexed-set-fold
    blocks
    (lambda ([block : r:BasicBlock] [acc : (IndexedSet ExtendedBasicBlock BlockNumber)])
      (indexed-set-add acc (specialize-instructions-to-immediate/block block)))
    (make-indexed-set extended-basic-block-number block-number-cmp)))


(define (specialize-instructions-to-immediate/block [b : r:BasicBlock])
  : ExtendedBasicBlock
  (match-define (r:basic-block block-num vars instructions terminal) b)
  (match-define (tuple2 instructions terminal)
    (specialize-instructions-to-immediate/block*
      instructions
      terminal
      (make-dict var-cmp)
      (empty)))
  (extended-basic-block block-num vars instructions terminal))

(define (specialize-instructions-to-immediate/block*
          [instructions : (List r:Instruction)]
          [terminal : r:Terminal]
          [constants : (Dict Var LiftedInt)]
          [rev-instructions : (List ExtendedInstruction)])
  : (Tuple2 (List ExtendedInstruction) ExtendedTerminal)
  (case instructions
    [(cons i instructions)
     (match-define new-instruction
       (case i
         ;; TODO Handle more operations
         [(r:bin-op-inst v (numeric-bin-op (sub-op)) left right)
          (case (dict-ref constants right)
            [(nothing) (extended-instruction i)]
            [(just (lifted-int val))
             (case (maybe-s32 val)
               [(just (lifted-s32 val))
                (ex:numeric-op-immediate-inst v (sub-op) left val)]
               [(nothing)
                (extended-instruction i)])])]
         [(r:bin-op-inst v (numeric-bin-op (add-op)) left right)
          (case (dict-ref constants left)
            [(just (lifted-int val))
             (case (maybe-s32 val)
               [(just (lifted-s32 val))
                (ex:numeric-op-immediate-inst v (add-op) right val)]
               [(nothing)
                (extended-instruction i)])]
            [(nothing)
             (case (dict-ref constants right)
               [(just (lifted-int val))
                (case (maybe-s32 val)
                  [(just (lifted-s32 val))
                   (ex:numeric-op-immediate-inst v (add-op) left val)]
                  [(nothing)
                   (extended-instruction i)])]
               [(nothing)
                (extended-instruction i)])])]
         [(r:bin-op-inst v (numeric-bin-op (mult-op)) left right)
          (case (dict-ref constants left)
            [(just (lifted-int val))
             (case (maybe-s32 val)
               [(just (lifted-s32 val))
                (ex:numeric-op-immediate-inst v (mult-op) right val)]
               [(nothing)
                (extended-instruction i)])]
            [(nothing)
             (case (dict-ref constants right)
               [(just (lifted-int val))
                (case (maybe-s32 val)
                  [(just (lifted-s32 val))
                   (ex:numeric-op-immediate-inst v (mult-op) left val)]
                  [(nothing)
                   (extended-instruction i)])]
               [(nothing)
                (extended-instruction i)])])]
         [(r:bin-op-inst v (comparison-bin-op op) left right)
          (case (dict-ref constants right)
            [(just (lifted-int val))
             (case (maybe-s32 val)
               [(nothing)
                (extended-instruction i)]
               [(just (lifted-s32 val))
                (ex:comparison-op-immediate-inst v op left val)])]
            [(nothing)
             (case (dict-ref constants left)
               [(just (lifted-int val))
                (case (maybe-s32 val)
                  [(nothing)
                   (extended-instruction i)]
                  [(just (lifted-s32 val))
                   (ex:comparison-op-immediate-inst v (flip-comparison op) right val)])]
               [(nothing) (extended-instruction i)])])]
         [i (extended-instruction i)]))
     (match-define new-constants
       (case i
         [(r:int-literal output v)
          (dict-set constants output (lifted-int v))]
         [_ constants]))
     (specialize-instructions-to-immediate/block*
       instructions
       terminal
       new-constants
       (cons new-instruction rev-instructions))]
    [(empty)
     (match-define new-terminal
       (case terminal
         [term (extended-terminal term)]))
     (tuple2
       (reverse rev-instructions)
       new-terminal)]))

(define (flip-comparison [c : ComparisonBinOp]) : ComparisonBinOp
  (case c
    [(less-than-op) (greater-than-op)]
    [(greater-than-op) (less-than-op)]
    [(less-than-or-equal-op) (greater-than-or-equal-op)]
    [(greater-than-or-equal-op) (less-than-or-equal-op)]
    [(equal-op) (equal-op)]
    [(not-equal-op) (not-equal-op)]))


(define (remove-dead-instructions [blocks : (IndexedSet ExtendedBasicBlock BlockNumber)])
  : (IndexedSet ExtendedBasicBlock BlockNumber)
  (match-define used-vars (compute-used-vars blocks))
  (indexed-set-value-map
    blocks
    (lambda ([b : ExtendedBasicBlock]) (remove-dead-instructions/block b used-vars))))

(define (remove-dead-instructions/block [b : ExtendedBasicBlock]
                                        [used-vars : (Set Var)]) : ExtendedBasicBlock
  (match-define (extended-basic-block block-num args instructions terminal) b)
  (extended-basic-block
    block-num
    args
    (filter
      (lambda ([i : ExtendedInstruction])
        (if (side-effect-free-instruction? i)
            (case (output-var i)
              [(just v) (set-member? used-vars v)]
              [(nothing) (panic/boolean #"Pure instruction didn't have output var")])
            #t))
      instructions)
    terminal))

(define (compute-used-vars [blocks : (IndexedSet ExtendedBasicBlock BlockNumber)]) : (Set Var)
  (indexed-set-fold
    blocks
    (lambda ([block : ExtendedBasicBlock] [acc : (Set Var)])
      (set-union acc (compute-used-vars/block block)))
    (make-set var-cmp)))

(define (compute-used-vars/block [b : ExtendedBasicBlock]) : (Set Var)
  (match-define (extended-basic-block _ _ instructions terminal) b)
  (foldl
    (lambda ([i : ExtendedInstruction] [acc : (Set Var)])
      (case i
        [(extended-instruction i) (r:used-vars/instruction i acc)]
        [(ex:numeric-op-immediate-inst _ _ v _) (set-add acc v)]
        [(ex:comparison-op-immediate-inst _ _ v _) (set-add acc v)]))
    instructions
    (used-vars/terminal terminal)))

(define (used-vars/terminal [t : ExtendedTerminal]) : (Set Var)
  (case t
    [(extended-terminal t) (r:used-vars/terminal t)]))

(define (side-effect-free-instruction? [i : ExtendedInstruction]) : Boolean
  (case i
    [(extended-instruction i) (r:side-effect-free-instruction? i)]
    [(ex:numeric-op-immediate-inst _ _ _ _) #t]
    [(ex:comparison-op-immediate-inst _ _ _ _) #t]))

(define (output-var [i : ExtendedInstruction]) : (Maybe Var)
  (case i
    [(extended-instruction i) (r:output-var i)]
    [(ex:numeric-op-immediate-inst v _ _ _) (just v)]
    [(ex:comparison-op-immediate-inst v _ _ _) (just v)]))
