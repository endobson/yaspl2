#:module lower-x86-64
#:import {
  dict {
    #:types
      Dict
    #:values
      dict-add
      dict-fold
      dict-ref
      make-dict
  }
  list {
    #:types
      List
    #:values
      append
      append*
      cons
      empty
      list
      map
      zip
  }
  lowered-register-language {
    #:types
      [BasicBlock l:BasicBlock]
      [FunctionDefinition l:FunctionDefinition]
      [Instruction l:Instruction]
      [Terminal l:Terminal]
    #:values
      [basic-block l:basic-block]
      [bin-op-inst l:bin-op-inst]
      [cond-jump l:cond-jump]
      [function-definition l:function-definition]
      [int-literal l:int-literal]
      [jump l:jump]
      [move l:move]
      [return l:return]
  }
  maybe {
    #:patterns
      just
      nothing
  }
  prim {
    #:types
      Bytes
      Int
    #:values
      +
      =
      panic
  }
  register-language {
    #:types
      [BasicBlock r:BasicBlock]
      [FunctionDefinition r:FunctionDefinition]
      [Instruction r:Instruction]
      [Terminal r:Terminal]
      [Var r:Var]
    #:values
      var->bytes
    #:patterns
      [basic-block r:basic-block]
      [bin-op-inst r:bin-op-inst]
      [cond-jump r:cond-jump]
      [function-definition r:function-definition]
      [int-literal r:int-literal]
      [jump r:jump]
      [return r:return]
  }
  tuples {
    #:types
      Tuple2
      Tuple3
    #:values
      tuple2
      tuple3
    #:patterns
      tuple2
      tuple3
  }
}
(export
  #:types (Reg)
  #:values (lower-function reg->bytes)
  #:patterns ())
(types
  (define-type X8664Register
    (rax)
    (rcx))
  (define-type Reg
    (fixed-reg [r : X8664Register])
    (temporary-reg [r : r:Var])))

(define (empty-blocks) : (Dict Int (l:BasicBlock Reg))
  (make-dict =))

(define (reg->bytes [reg : Reg]) : Bytes
  (case reg
    [(fixed-reg (rax)) #"%rax"]
    [(fixed-reg (rcx)) #"%rcx"]
    [(temporary-reg v) (var->bytes v)]))

(define (lower-function [fun : r:FunctionDefinition]) : (l:FunctionDefinition Reg)
  (match-define (r:function-definition name blocks _ next-block) fun)
  (match-define (tuple2 next-block new-blocks)
    (dict-fold
      blocks
      (lambda ([index : Int]  [b : r:BasicBlock]
               [acc : (Tuple2 Int (Dict Int (l:BasicBlock Reg)))])
        (lower-block index b blocks acc))
      (tuple2 next-block (empty-blocks))))

  (l:function-definition name 0 new-blocks))

(define (lower-block [index : Int]  [b : r:BasicBlock]
                     [blocks : (Dict Int r:BasicBlock)]
                     [acc : (Tuple2 Int (Dict Int (l:BasicBlock Reg)))])
  : (Tuple2 Int (Dict Int (l:BasicBlock Reg)))
  (match-define (r:basic-block _ instructions terminal) b)
  (match-define (tuple3 end-insts terminal (tuple2 next-block acc-blocks))
    (lower-terminal terminal blocks acc))
  (tuple2
    next-block
    (dict-add
      acc-blocks
      index
      (l:basic-block
        (append
          (append* (map lower-instruction instructions))
          end-insts)
        terminal))))

(define (match-args [index : Int] [args : (List r:Var)] [blocks : (Dict Int r:BasicBlock)])
  : (List (Tuple2 r:Var r:Var))
  (case (dict-ref blocks index)
    [(nothing) (panic #"No block")]
    [(just (r:basic-block block-args _ _))
     (case (zip args block-args)
       [(nothing) (panic #"Args don't match")]
       [(just v) v])]))

(define (move-args [args : (List (Tuple2 r:Var r:Var))]) : (List (l:Instruction Reg))
  (map (lambda ([t : (Tuple2 r:Var r:Var)])
         (case t
           [(tuple2 src dest)
            (l:move (temporary-reg dest) (temporary-reg src))]))
       args))

(define (ann-term [t : (l:Terminal Reg)]) : (l:Terminal Reg)
  t)

(define (lower-terminal [t : r:Terminal] [blocks : (Dict Int r:BasicBlock)]
                        [acc : (Tuple2 Int (Dict Int (l:BasicBlock Reg)))])
  : (Tuple3 (List (l:Instruction Reg)) (l:Terminal Reg) (Tuple2 Int (Dict Int (l:BasicBlock Reg))))
  (case t
    [(r:return name)
     (tuple3
       (cons (l:move (fixed-reg (rax)) (temporary-reg name)) (empty))
       (ann-term (l:return (fixed-reg (rax))))
       acc)]
    [(r:jump index args)
     (tuple3
       (move-args (match-args index args blocks))
       (ann-term (l:jump index))
       acc)]
    [(r:cond-jump v t-index t-args f-index f-args)
     (match-define (tuple2 next-block acc-blocks) acc)
     (match-define new-acc-blocks
       (dict-add
         (dict-add acc-blocks next-block
            (l:basic-block (move-args (match-args t-index t-args blocks))
                           (ann-term (l:jump t-index))))
         (+ 1 next-block)
         (l:basic-block (move-args (match-args f-index f-args blocks))
                        (ann-term (l:jump f-index)))))
     (tuple3
       (cons (l:move (fixed-reg (rcx)) (temporary-reg v)) (empty))
       (ann-term (l:cond-jump (fixed-reg (rcx)) next-block (+ next-block 1)))
       (tuple2 (+ next-block 2) new-acc-blocks))]))

(define (lower-instruction [i : r:Instruction]) : (List (l:Instruction Reg))
  (case i
    [(r:int-literal output v)
     (varargs list (l:int-literal (temporary-reg output) v))]
    [(r:bin-op-inst output op l r)
     (varargs list
       (l:move (temporary-reg output) (temporary-reg l))
       (l:bin-op-inst (temporary-reg output) op (temporary-reg r)))]))
