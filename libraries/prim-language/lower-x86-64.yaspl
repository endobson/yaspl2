#:module (lower-x86-64)
#:import {
  (dict)
  (either)
  (list)
  (lowered-register-language) {
    #:types
      [BasicBlock l:BasicBlock]
      [FunctionDefinition l:FunctionDefinition]
      [Instruction l:Instruction]
      [Terminal l:Terminal]
      [UnvalidatedBlockMap l:UnvalidatedBlockMap]
    #:values
      [basic-block l:basic-block]
      [bin-op-inst l:bin-op-inst]
      [closure-call l:closure-call]
      [compare-memory l:compare-memory]
      [comparison-condition l:comparison-condition]
      [cond-jump/false-fall-through l:cond-jump/false-fall-through]
      [empty-unvalidated-block-map l:empty-unvalidated-block-map]
      [function-call-inst l:function-call-inst]
      [function-definition l:function-definition]
      [halt l:halt]
      [indirect-function-call l:indirect-function-call]
      [int-literal l:int-literal]
      [jump l:jump]
      [load-8byte l:load-8byte]
      [load-zero-extended-byte l:load-zero-extended-byte]
      [move l:move]
      [negated-reg-condition l:negated-reg-condition]
      [reg-condition l:reg-condition]
      [return l:return]
      [store-8byte l:store-8byte]
      [store-least-significant-byte l:store-least-significant-byte]
      [symbol-address l:symbol-address]
      [syscall l:syscall]
      [unary-op-inst l:unary-op-inst]
      [unvalidated-block-map-add-block l:unvalidated-block-map-add-block]
      [validate-block-map l:validate-block-map]
  }
  (maybe)
  (prim)
  (prim-language) {
    #:values
      numeric-bin-op
      plus
      sub
  }
  (register-language) {
    #:types
      [BasicBlock r:BasicBlock]
      [FunctionDefinition r:FunctionDefinition]
      [Instruction r:Instruction]
      [Terminal r:Terminal]
      [Var r:Var]
    #:values
      var->bytes
      var=?
    #:patterns
      [basic-block r:basic-block]
      [bin-op-inst r:bin-op-inst]
      [closure-call r:closure-call]
      [comparison-condition r:comparison-condition]
      [cond-jump r:cond-jump]
      [eight-byte-mem-op r:eight-byte-mem-op]
      [function-allocate-inst r:function-allocate-inst]
      [function-call-inst r:function-call-inst]
      [function-definition r:function-definition]
      [halt r:halt]
      [heap-allocate-inst r:heap-allocate-inst]
      [indirect-function-call r:indirect-function-call]
      [int-literal r:int-literal]
      [jump r:jump]
      [memory-compare-inst r:memory-compare-inst]
      [negated-var-condition r:negated-var-condition]
      [one-byte-mem-op r:one-byte-mem-op]
      [pointer-ref-inst r:pointer-ref-inst]
      [pointer-set!-inst r:pointer-set!-inst]
      [return r:return]
      [symbol-address-inst r:symbol-address-inst]
      [syscall r:syscall]
      [unary-op-inst r:unary-op-inst]
      [var-condition r:var-condition]
  }
  (set)
  (syscalls)
  (tuples)
}
(export
  #:types (Reg X8664Register)
  #:values (lower-function reg->bytes x86-64-register=?  x86-64-register->bytes reg=?
            valid-temporary-x86-64-registers all-fixed-registers)
  #:patterns ())
(types
  (define-type X8664Register
    (rax)
    (rdi)
    (rsi)
    (rdx)
    (rcx)
    (r8)
    (r9)
    (r10)
    (r11)
    (r15)
    (rbp)
    (rsp))
  (define-type Reg
    (fixed-reg [r : X8664Register])
    (temporary-reg [r : r:Var])))

(define (empty-blocks [entry-block-num : Int]) : (l:UnvalidatedBlockMap Reg)
  (l:empty-unvalidated-block-map entry-block-num))


(define (valid-temporary-x86-64-registers) : (Set X8664Register)
  (set-add-all
    (make-set x86-64-register=?)
    (varargs list
      (rax)
      (rcx)
      (rdx)
      (rdi)
      (rsi)
      (r8)
      (r9)
      (r10)
      (r11))))

(define (all-fixed-registers) : (Set Reg)
  (set-add-all
    (make-set reg=?)
    (map
      fixed-reg
      (varargs list
        (rax)
        (rcx)
        (rdx)
        (rdi)
        (rsi)
        (r8)
        (r9)
        (r10)
        (r11)
        (r15)
        (rbp)
        (rsp)))))

;; Conflicts for all kinds of calls.
(define (call-conflicts) : (List Reg)
  (map
    fixed-reg
    (varargs list
      (rax)
      (rcx)
      (rdx)
      (rdi)
      (rsi)
      (r8)
      (r9)
      (r10)
      (r11))))


(define (reg->bytes [reg : Reg]) : Bytes
  (case reg
    [(fixed-reg (rax)) #"_rax"]
    [(fixed-reg (rcx)) #"_rcx"]
    [(fixed-reg (rdx)) #"_rdx"]
    [(fixed-reg (rdi)) #"_rdi"]
    [(fixed-reg (rsi)) #"_rsi"]
    [(fixed-reg (r8)) #"_r8"]
    [(fixed-reg (r9)) #"_r9"]
    [(fixed-reg (r10)) #"_r10"]
    [(fixed-reg (r11)) #"_r11"]
    [(fixed-reg (r15)) #"_r15"]
    [(fixed-reg (rbp)) #"_rbp"]
    [(fixed-reg (rsp)) #"_rsp"]
    [(temporary-reg v) (var->bytes v)]))


(define (x86-64-register->bytes [reg : X8664Register]) : Bytes
  (case reg
    [(rax) #"rax"]
    [(rcx) #"rcx"]
    [(rdx) #"rdx"]
    [(rdi) #"rdi"]
    [(rsi) #"rsi"]
    [(r8) #"r8"]
    [(r9) #"r9"]
    [(r10) #"r10"]
    [(r11) #"r11"]
    [(r15) #"r15"]
    [(rbp) #"rbp"]
    [(rsp) #"rsp"]))


(define (x86-64-register=? [reg1 : X8664Register] [reg2 : X8664Register]) : Boolean
  (case (tuple2 reg1 reg2)
    [(tuple2 (rax) (rax)) #t]
    [(tuple2 (rax) _) #f]
    [(tuple2 (rcx) (rcx)) #t]
    [(tuple2 (rcx) _) #f]
    [(tuple2 (rdx) (rdx)) #t]
    [(tuple2 (rdx) _) #f]
    [(tuple2 (rdi) (rdi)) #t]
    [(tuple2 (rdi) _) #f]
    [(tuple2 (rsi) (rsi)) #t]
    [(tuple2 (rsi) _) #f]
    [(tuple2 (r8) (r8)) #t]
    [(tuple2 (r8) _) #f]
    [(tuple2 (r9) (r9)) #t]
    [(tuple2 (r9) _) #f]
    [(tuple2 (r10) (r10)) #t]
    [(tuple2 (r10) _) #f]
    [(tuple2 (r11) (r11)) #t]
    [(tuple2 (r11) _) #f]
    [(tuple2 (r15) (r15)) #t]
    [(tuple2 (r15) _) #f]
    [(tuple2 (rsp) (rsp)) #t]
    [(tuple2 (rsp) _) #f]
    [(tuple2 (rbp) (rbp)) #t]
    [(tuple2 (rbp) _) #f]))

(define (reg=? [reg1 : Reg] [reg2 : Reg]) : Boolean
  (case (tuple2 reg1 reg2)
    [(tuple2 (fixed-reg r1) (fixed-reg r2))
     (x86-64-register=? r1 r2)]
    [(tuple2 (temporary-reg v1) (temporary-reg v2)) (var=? v1 v2)]
    [(tuple2 (fixed-reg _) (temporary-reg _)) #f]
    [(tuple2 (temporary-reg _) (fixed-reg _)) #f]))

(define (lower-function [fun : r:FunctionDefinition]) : (l:FunctionDefinition Reg)
  (match-define (r:function-definition name entry-block-num blocks _ next-block) fun)
  (match-define lowered-entry-block next-block)
  (match-define next-block (+ 1 next-block))

  (match-define (tuple2 next-block new-blocks)
    (dict-fold
      blocks
      (lambda ([index : Int]  [b : r:BasicBlock]
               [acc : (Tuple2 Int (l:UnvalidatedBlockMap Reg))])
        (lower-block index b blocks acc))
      (tuple2 next-block (empty-blocks lowered-entry-block))))
  (match-define new-blocks
    (l:unvalidated-block-map-add-block
      new-blocks lowered-entry-block (make-entry-block entry-block-num blocks)))

  (case (l:validate-block-map new-blocks)
    [(left msg) (panic msg)]
    [(right validated-new-blocks)
     (l:function-definition name 0 validated-new-blocks)]))


(define (make-entry-block [entry-block-num : Int] [blocks : (Dict Int r:BasicBlock)])
  : (l:BasicBlock Reg)
  (case (dict-ref blocks entry-block-num)
    [(nothing) (panic #"No entry block")]
    [(just (r:basic-block args _ _))
     (l:basic-block
       (case (zip/left args (varargs list (rdi) (rsi) (rdx) (rcx) (r8) (r9)))
         [(nothing) (panic #"Too long initial args")]
         [(just linked-args)
          (map
            (lambda ([t : (Tuple2 r:Var X8664Register)])
              (case t
                [(tuple2 v reg)
                 (l:move (temporary-reg v) (fixed-reg reg))]))
            linked-args)])
       ((lambda () : (l:Terminal Reg) (l:jump entry-block-num))))]))

(define (lower-block [index : Int]  [b : r:BasicBlock]
                     [blocks : (Dict Int r:BasicBlock)]
                     [acc : (Tuple2 Int (l:UnvalidatedBlockMap Reg))])
  : (Tuple2 Int (l:UnvalidatedBlockMap Reg))
  (match-define (r:basic-block _ instructions terminal) b)
  (match-define (tuple3 end-insts terminal (tuple2 next-block acc-blocks))
    (lower-terminal terminal blocks acc))
  (tuple2
    next-block
    (l:unvalidated-block-map-add-block
      acc-blocks
      index
      (l:basic-block
        (append
          (append* (map lower-instruction instructions))
          end-insts)
        terminal))))

(define (match-args [index : Int] [args : (List r:Var)] [blocks : (Dict Int r:BasicBlock)])
  : (List (Tuple2 r:Var r:Var))
  (case (dict-ref blocks index)
    [(nothing) (panic #"No block")]
    [(just (r:basic-block block-args _ _))
     (case (zip block-args args)
       [(nothing) (panic #"Args don't match")]
       [(just v) v])]))

(define (move-args [args : (List (Tuple2 r:Var r:Var))]) : (List (l:Instruction Reg))
  (match-define moves (dict-add-all ((lambda () : (Dict r:Var r:Var) (make-dict var=?))) args))
  (if (has-cycle? moves)
      (panic #"Cannot currently perform permutation of args when jumping to block")
      (move-args/dict moves (empty))))


;; TODO implement this to avoid the posibility of infinite loops
(define (has-cycle? [args : (Dict r:Var r:Var)]) : Boolean
  #f)

(define (move-args/dict [args : (Dict r:Var r:Var)] [list : (List (l:Instruction Reg))]) :
  (List (l:Instruction Reg))
  (case (dict-split args)
    [(nothing) list]
    [(just (tuple2 (tuple2 dest src) args))
     (match-define (tuple2 args list) (move-args/dict* args src list))
     (move-args/dict args (cons (l:move (temporary-reg dest) (temporary-reg src)) list))]))


(define (move-args/dict* [args : (Dict r:Var r:Var)] [src : r:Var] [list : (List (l:Instruction Reg))]) :
  (Tuple2 (Dict r:Var r:Var) (List (l:Instruction Reg)))
  (case (dict-ref args src)
    [(nothing) (tuple2 args list)]
    [(just src2)
     (match-define (tuple2 args list) (move-args/dict* (dict-remove args src) src2 list))
     (tuple2 args (cons (l:move (temporary-reg src) (temporary-reg src2)) list))]))


(define (ann-term [t : (l:Terminal Reg)]) : (l:Terminal Reg)
  t)

(define (lower-terminal [t : r:Terminal] [blocks : (Dict Int r:BasicBlock)]
                        [acc : (Tuple2 Int (l:UnvalidatedBlockMap Reg))])
  : (Tuple3 (List (l:Instruction Reg)) (l:Terminal Reg) (Tuple2 Int (l:UnvalidatedBlockMap Reg)))
  (case t
    [(r:return name)
     (tuple3
       (varargs list
         (l:move (fixed-reg (rax)) (temporary-reg name)))
       (ann-term (l:return (fixed-reg (rax))))
       acc)]
    [(r:halt)
     (tuple3 (empty) (ann-term (l:halt)) acc)]
    [(r:jump index args)
     (tuple3
       (move-args (match-args index args blocks))
       (ann-term (l:jump index))
       acc)]
    [(r:cond-jump condition t-index t-args f-index f-args)
     (match-define (tuple2 next-block acc-blocks) acc)
     (match-define new-acc-blocks
       (l:unvalidated-block-map-add-block
         (l:unvalidated-block-map-add-block
            acc-blocks
            next-block
            (l:basic-block (move-args (match-args t-index t-args blocks))
                           (ann-term (l:jump t-index))))
         (+ 1 next-block)
         (l:basic-block (move-args (match-args f-index f-args blocks))
                        (ann-term (l:jump f-index)))))
     (tuple3
       (empty)
       (ann-term (l:cond-jump/false-fall-through
                   (case condition
                     [(r:var-condition v)
                      (l:reg-condition (temporary-reg v))]
                     [(r:negated-var-condition v)
                      (l:negated-reg-condition (temporary-reg v))]
                     [(r:comparison-condition op left right)
                      (l:comparison-condition op (temporary-reg left) (temporary-reg right))])
                   next-block
                   (+ next-block 1)))
       (tuple2 (+ next-block 2) new-acc-blocks))]))

(define (lower-instruction [i : r:Instruction]) : (List (l:Instruction Reg))
  (case i
    [(r:int-literal output v)
     (varargs list (l:int-literal (temporary-reg output) v))]
    [(r:symbol-address-inst output v)
     (varargs list (l:symbol-address (temporary-reg output) v))]
    [(r:bin-op-inst output op l r)
     (varargs list
       (l:move (temporary-reg output) (temporary-reg l))
       (l:bin-op-inst (temporary-reg output) op (temporary-reg r)))]
    [(r:unary-op-inst output op input)
     (varargs list
       (l:unary-op-inst (temporary-reg output) op (temporary-reg input)))]
    [(r:function-allocate-inst output num-bytes)
     (varargs list
       (l:bin-op-inst (fixed-reg (rsp)) (numeric-bin-op (sub)) (temporary-reg num-bytes))
       (l:move (temporary-reg output) (fixed-reg (rsp))))]
    [(r:heap-allocate-inst output num-bytes)
     (varargs list
       (l:move (temporary-reg output) (fixed-reg (r15)))
       (l:bin-op-inst (fixed-reg (r15)) (numeric-bin-op (plus)) (temporary-reg num-bytes)))]
    [(r:pointer-set!-inst (r:eight-byte-mem-op) ptr val)
     (varargs list (l:store-8byte (temporary-reg ptr) (temporary-reg val)))]
    [(r:pointer-ref-inst output (r:eight-byte-mem-op) loc)
     (varargs list (l:load-8byte (temporary-reg output) (temporary-reg loc)))]
    [(r:pointer-set!-inst (r:one-byte-mem-op) ptr val)
     (varargs list (l:store-least-significant-byte (temporary-reg ptr) (temporary-reg val)))]
    [(r:pointer-ref-inst output (r:one-byte-mem-op) loc)
     (varargs list (l:load-zero-extended-byte (temporary-reg output) (temporary-reg loc)))]
    [(r:memory-compare-inst output size v1 v2)
     (varargs list
       (l:move (fixed-reg (rcx)) (temporary-reg size))
       (l:move (fixed-reg (rdi)) (temporary-reg v1))
       (l:move (fixed-reg (rsi)) (temporary-reg v2))
       (l:compare-memory (temporary-reg output) (fixed-reg (rcx)) (fixed-reg (rdi)) (fixed-reg (rsi))))]
    [(r:function-call-inst output f args)
     (case (zip/left args (varargs list (rdi) (rsi) (rdx) (r10) (r8) (r9)))
       [(nothing) (panic #"Too long function call args")]
       [(just linked-args)
        (append
          (map
            (lambda ([t : (Tuple2 r:Var X8664Register)])
              (case t
                [(tuple2 v reg)
                 (l:move (fixed-reg reg) (temporary-reg v))]))
            linked-args)
          (append
            (case f
              [(r:indirect-function-call f) (empty)]
              [(r:closure-call c)
               (varargs list (l:move (fixed-reg (r11)) (temporary-reg c)))]
              [(r:syscall s) (varargs list (l:int-literal (fixed-reg (rax)) (syscall-number s)))])
            (varargs list
              (l:function-call-inst
                (fixed-reg (rax))
                (case f
                  [(r:indirect-function-call f) (l:indirect-function-call (temporary-reg f))]
                  [(r:closure-call _) (l:closure-call (fixed-reg (r11)))]
                  [(r:syscall _) (l:syscall (fixed-reg (rax)))])
                (map (lambda ([t : (Tuple2 r:Var X8664Register)])
                       (case t
                         [(tuple2 v reg)
                          (fixed-reg reg)]))
                     linked-args)
                (call-conflicts))
              (l:move (temporary-reg output) (fixed-reg (rax))))))])]))
