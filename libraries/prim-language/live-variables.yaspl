(module live-variables
  (import
    (bytes bytes-append)
    (dict
      #:types (Dict)
      #:values (dict-map dict-ref dict-value-map dict=? )
      #:patterns ())
    (join-list
      #:types (JoinList)
      #:values (append-jl append-jl* concat-jl empty-jl jl->list join-list single-jl )
      #:patterns ())
    (list
      #:types (List)
      #:values (append cons empty interleave list list=? map reverse zip)
      #:patterns (cons empty))
    (maybe
      #:types ()
      #:values ()
      #:patterns (just nothing))
    (numbers integer->decimal-bytes)
    (prim
      #:types (Boolean Bytes Int)
      #:values (= and panic)
      #:patterns ())
    (register-language
      #:types (BasicBlock FunctionDefinition Instruction Terminal Var)
      #:values (var=?)
      #:patterns (basic-block bin-op-inst cond-jump function-definition int-literal jump return var))
    (set
      #:types (Set)
      #:values (make-set set->list set-add set-add-all set-count set-difference set-union set-union*
                set=? )
      #:patterns ())
    (tuples
      #:types (Tuple2)
      #:values (tuple2 tuple2=?)
      #:patterns (tuple2)))
  (export
    #:types ()
    #:values (live-variables print-blocks)
    #:patterns ())
  (types
    (define-type BlockState
      (block-state [defined : (Set Var)] [live : (Set Var)]
                   [instructions : (List PointState)] [terminal : PointState]
                   [next-blocks : (Set Int)]))
    (define-type PointState
      (point-state [defined : (Set Var)] [live : (Set Var)]
                   [moves : (Set (Tuple2 Var Var))])))

  (define (live-variables [f : FunctionDefinition]) : (Dict Int BlockState)
    (match-define (function-definition _ blocks) f)
    (fully-propagate-live-variables/blocks
      (dict-value-map blocks (lambda ([block : BasicBlock])
                               (initial-block-state block blocks)))))

  (define (block-state=? [b1 : BlockState] [b2 : BlockState]) : Boolean
    (match-define (block-state def1 live1 instructions1 terminal1 next1) b1)
    (match-define (block-state def2 live2 instructions2 terminal2 next2) b2)
    (and
      (set=? def1 def2)
      (and
        (set=? live1 live2)
        (and ((list=? point-state=?) instructions1 instructions2)
             (and (point-state=? terminal1 terminal2)
                  (set=? next1 next2))))))

  (define (point-state=? [p1 : PointState] [p2 : PointState]) : Boolean
    (match-define (point-state def1 live1 moves1) p1)
    (match-define (point-state def2 live2 moves2) p2)
    (and
      (and
        (set=? def1 def2)
        (set=? live1 live2))
      (set=? moves1 moves2)))

  (define (print-var [v : Var]) : (JoinList Bytes)
    (case v
      [(var name counter)
       (varargs join-list name #"_" (integer->decimal-bytes counter))]))

  (define (print-blocks [blocks : (Dict Int BlockState)]) : Bytes
    (bytes-append (dict-map blocks print-block-state)))


  (define (print-block-state [i : Int] [block : BlockState]) : Bytes
    (match-define (block-state args _ instructions terminal _) block)
    (match-define print-point-state
      (lambda ([ps : PointState]) : (JoinList Bytes)
        (let ([print-move
                (lambda ([t : (Tuple2 Var Var)])
                  (case t
                    [(tuple2 v1 v2)
                     (varargs append-jl*
                       (single-jl #"[")
                       (print-var v1)
                       (single-jl #", ")
                       (print-var v2)
                       (single-jl #"]"))]))])
          (case ps
            [(point-state _ live moves)
             (varargs append-jl*
               (single-jl #"live: ")
               (concat-jl (interleave (map print-var (set->list live)) (single-jl #", ")))
               (if (= (set-count moves) 0)
                   (empty-jl)
                   (append-jl
                     (single-jl #", moves: ")
                     (concat-jl (interleave (map print-move (set->list moves)) (single-jl #", ")))))
               (single-jl #"\n"))]))))
    (bytes-append
      (jl->list
        (varargs append-jl*
          (single-jl #"block: ")
          (single-jl (integer->decimal-bytes i))
          (single-jl #"(")
          (concat-jl (interleave (map print-var (set->list args)) (single-jl #", ")))
          (single-jl #")\n")
          (concat-jl (map print-point-state instructions))
          (print-point-state terminal)))))


  (define (blocks=?) : ((Dict Int BlockState) (Dict Int BlockState) -> Boolean)
    (dict=? block-state=?))


  (define (fully-propagate-live-variables/blocks [blocks : (Dict Int BlockState)])
    : (Dict Int BlockState)
    (let ([new-blocks (propagate-live-variables/blocks blocks)])
      (if ((blocks=?) blocks new-blocks)
          blocks
          (fully-propagate-live-variables/blocks new-blocks))))

  (define (propagate-live-variables/blocks [blocks : (Dict Int BlockState)])
    : (Dict Int BlockState)
    (dict-value-map blocks
      (lambda ([state : BlockState]) (propagate-live-variables/block state blocks))))

  (define (propagate-live-variables/block [state : BlockState] [other-blocks : (Dict Int BlockState)])
    : BlockState
    (match-define (block-state defined live instructions terminal next-blocks) state)
    (match-define new-live
      (set-union*
        (make-set var=?)
        (map (lambda ([block : Int]) : (Set Var)
               (case (dict-ref other-blocks block)
                 [(nothing) (panic #"bad terminal")]
                 [(just (block-state _ live _ _ _))
                  live]))
             (set->list next-blocks))))
    (match-define (tuple2 new-terminal new-live)
      (propagate-live-variables/point-state terminal new-live))
    (match-define (tuple2 new-instructions new-live)
      (propagate-live-variables/instructions (reverse instructions) (empty) new-live))
    (match-define new-live (set-union live (set-difference new-live defined)))
    (block-state defined new-live new-instructions new-terminal next-blocks))

  (define (propagate-live-variables/instructions
            [rev-instructions : (List PointState)]
            [acc-instructions : (List PointState)]
            [new-live : (Set Var)]) : (Tuple2 (List PointState) (Set Var))
    (case rev-instructions
      [(empty) (tuple2 acc-instructions new-live)]
      [(cons inst rev-instructions)
       (match-define (tuple2 new-state new-live)
         (propagate-live-variables/point-state inst new-live))
       (propagate-live-variables/instructions
         rev-instructions
         (cons
           new-state
           acc-instructions)
         new-live)]))

  (define (propagate-live-variables/point-state [ps : PointState] [new-live : (Set Var)])
    : (Tuple2 PointState (Set Var))
    (match-define (point-state defined live moves) ps)
    (let ([new-live (set-union live (set-difference new-live defined))])
      (tuple2 (point-state defined new-live moves) new-live)))

  (define (initial-block-state [block : BasicBlock] [blocks : (Dict Int BasicBlock)]) : BlockState
    (match-define (basic-block args instructions terminal) block)
    (block-state
      (set-add-all (make-set var=?) args)
      (make-set var=?)
      (map initial-point-state/instruction instructions)
      (initial-point-state/terminal terminal blocks)
      (terminal-next-blocks terminal)))

  (define (initial-point-state/instruction [i : Instruction]) : PointState
    (point-state
      (defined-variables/instruction i)
      (used-variables/instruction i)
      (make-set (tuple2=? var=? var=?))))

  (define (initial-point-state/terminal [t : Terminal] [blocks : (Dict Int BasicBlock)]) : PointState
    (point-state
      (make-set var=?)
      (used-variables/terminal t)
      (moves/terminal t blocks)))

  (define (terminal-next-blocks [t : Terminal]) : (Set Int)
    (set-add-all
      (make-set =)
      (case t
        [(return _) (empty)]
        [(jump b _) (varargs list b)]
        [(cond-jump _ t _ f _) (varargs list t f)])))

  (define (used-variables/terminal [t : Terminal]) : (Set Var)
    (set-add-all
      (make-set var=?)
      (case t
        [(return v) (varargs list v)]
        [(jump _ vs) vs]
        [(cond-jump v _ tvs _ fvs) (cons v (append tvs fvs))])))

  (define (moves/terminal [t : Terminal] [blocks : (Dict Int BasicBlock)]) : (Set (Tuple2 Var Var))
    (set-add-all
      (make-set (tuple2=? var=? var=?))
      (case t
        [(return v) (empty)]
        [(jump i vs)
         (case (dict-ref blocks i)
           [(nothing) (panic #"Bad block")]
           [(just (basic-block args _ _))
            (case (zip vs args)
              [(nothing) (panic #"Bad args")]
              [(just merged)
               merged])])]
        [(cond-jump _ t tvs f fvs)
         (append
           (case (dict-ref blocks t)
             [(nothing) (panic #"Bad block")]
             [(just (basic-block args _ _))
              (case (zip tvs args)
                [(nothing) (panic #"Bad args")]
                [(just merged)
                 merged])])
           (case (dict-ref blocks f)
             [(nothing) (panic #"Bad block")]
             [(just (basic-block args _ _))
              (case (zip fvs args)
                [(nothing) (panic #"Bad args")]
                [(just merged)
                 merged])]))])))

  (define (used-variables/instruction [i : Instruction]) : (Set Var)
    (set-add-all
      (make-set var=?)
      (case i
        [(int-literal _ _) (empty)]
        [(bin-op-inst _ _ left right) (varargs list left right)])))

  (define (defined-variables/instruction [i : Instruction]) : (Set Var)
    (set-add
      (make-set var=?)
      (case i
        [(int-literal v _) v]
        [(bin-op-inst v _ _ _) v]))))
