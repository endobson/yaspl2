#:module live-variables
#:import {
  bytes {
    #:values
      bytes-append
  }
  dict {
    #:types
      Dict
    #:values
      dict-fold
      dict-map
      dict-ref
      dict-value-map
      dict=?
  }
  graphviz {
    #:types
      EdgeData
      VertexData
    #:values
      edge-data
      graph->graphviz
      vertex-data
  }
  join-list {
    #:types
      JoinList
    #:values
      append-jl
      append-jl*
      concat-jl
      empty-jl
      jl->list
      join-list
      single-jl
  }
  list {
    #:types
      List
    #:values
      append
      cons
      empty
      foldl
      interleave
      list
      list=?
      map
      reverse
      zip
    #:patterns
      cons
      empty
  }
  maybe {
    #:patterns
      just
      nothing
  }
  numbers {
    #:values
      integer->decimal-bytes
  }
  prim {
    #:types
      Boolean
      Bytes
      Int
    #:values
      =
      and
      panic
  }
  register-language {
    #:types
      BasicBlock
      FunctionDefinition
      Instruction
      Terminal
      Var
    #:values
      var=?
    #:patterns
      basic-block
      bin-op-inst
      cond-jump
      function-definition
      int-literal
      jump
      return
      var
  }
  set {
    #:types
      Set
    #:values
      make-set
      set->list
      set-add
      set-add-all
      set-count
      set-difference
      set-split
      set-union
      set-union*
      set=?
  }
  tuples {
    #:types
      Tuple2
    #:values
      tuple2
      tuple2=?
    #:patterns
      tuple2
  }
  undirected-graph {
    #:types
      Graph
    #:values
      empty-graph
      graph-add-edge-if-absent
      graph-add-vertex-if-absent
  }
}
(export
  #:types ()
  #:values (live-variables print-blocks print-graph)
  #:patterns ())
(types
  (define-type BlockState
    (block-state [defined : (Set Var)] [live : (Set Var)]
                 [instructions : (List PointState)] [terminal : PointState]
                 [next-blocks : (Set Int)]))
  (define-type PointState
    (point-state [defined : (Set Var)] [live : (Set Var)]
                 [moves : (Set (Tuple2 Var Var))])))

(define (live-variables [f : FunctionDefinition]) : (Dict Int BlockState)
  (match-define (function-definition _ blocks _ _) f)
  (fully-propagate-live-variables/blocks
    (dict-value-map blocks (lambda ([block : BasicBlock])
                             (initial-block-state block blocks)))))

(define (block-state=? [b1 : BlockState] [b2 : BlockState]) : Boolean
  (match-define (block-state def1 live1 instructions1 terminal1 next1) b1)
  (match-define (block-state def2 live2 instructions2 terminal2 next2) b2)
  (and
    (set=? def1 def2)
    (and
      (set=? live1 live2)
      (and ((list=? point-state=?) instructions1 instructions2)
           (and (point-state=? terminal1 terminal2)
                (set=? next1 next2))))))

(define (point-state=? [p1 : PointState] [p2 : PointState]) : Boolean
  (match-define (point-state def1 live1 moves1) p1)
  (match-define (point-state def2 live2 moves2) p2)
  (and
    (and
      (set=? def1 def2)
      (set=? live1 live2))
    (set=? moves1 moves2)))

(define (print-var [v : Var]) : (JoinList Bytes)
  (case v
    [(var name counter)
     (varargs join-list name #"_" (integer->decimal-bytes counter))]))

(define (var->bytes [v : Var]) : Bytes
  (case v
    [(var name counter)
     (bytes-append
       (varargs list name #"_" (integer->decimal-bytes counter)))]))


(define (print-blocks [blocks : (Dict Int BlockState)]) : Bytes
  (bytes-append (dict-map blocks print-block-state)))


(define (print-block-state [i : Int] [block : BlockState]) : Bytes
  (match-define (block-state args _ instructions terminal _) block)
  (match-define print-point-state
    (lambda ([ps : PointState]) : (JoinList Bytes)
      (let ([print-move
              (lambda ([t : (Tuple2 Var Var)])
                (case t
                  [(tuple2 v1 v2)
                   (varargs append-jl*
                     (single-jl #"[")
                     (print-var v1)
                     (single-jl #", ")
                     (print-var v2)
                     (single-jl #"]"))]))])
        (case ps
          [(point-state _ live moves)
           (varargs append-jl*
             (single-jl #"live: ")
             (concat-jl (interleave (map print-var (set->list live)) (single-jl #", ")))
             (if (= (set-count moves) 0)
                 (empty-jl)
                 (append-jl
                   (single-jl #", moves: ")
                   (concat-jl (interleave (map print-move (set->list moves)) (single-jl #", ")))))
             (single-jl #"\n"))]))))
  (bytes-append
    (jl->list
      (varargs append-jl*
        (single-jl #"block: ")
        (single-jl (integer->decimal-bytes i))
        (single-jl #"(")
        (concat-jl (interleave (map print-var (set->list args)) (single-jl #", ")))
        (single-jl #")\n")
        (concat-jl (map print-point-state instructions))
        (print-point-state terminal)))))


(define (blocks=?) : ((Dict Int BlockState) (Dict Int BlockState) -> Boolean)
  (dict=? block-state=?))


(define (fully-propagate-live-variables/blocks [blocks : (Dict Int BlockState)])
  : (Dict Int BlockState)
  (let ([new-blocks (propagate-live-variables/blocks blocks)])
    (if ((blocks=?) blocks new-blocks)
        blocks
        (fully-propagate-live-variables/blocks new-blocks))))

(define (propagate-live-variables/blocks [blocks : (Dict Int BlockState)])
  : (Dict Int BlockState)
  (dict-value-map blocks
    (lambda ([state : BlockState]) (propagate-live-variables/block state blocks))))

(define (propagate-live-variables/block [state : BlockState] [other-blocks : (Dict Int BlockState)])
  : BlockState
  (match-define (block-state defined live instructions terminal next-blocks) state)
  (match-define new-live
    (set-union*
      (make-set var=?)
      (map (lambda ([block : Int]) : (Set Var)
             (case (dict-ref other-blocks block)
               [(nothing) (panic #"bad terminal")]
               [(just (block-state _ live _ _ _))
                live]))
           (set->list next-blocks))))
  (match-define (tuple2 new-terminal new-live)
    (propagate-live-variables/point-state terminal new-live))
  (match-define (tuple2 new-instructions new-live)
    (propagate-live-variables/instructions (reverse instructions) (empty) new-live))
  (match-define new-live (set-union live (set-difference new-live defined)))
  (block-state defined new-live new-instructions new-terminal next-blocks))

(define (propagate-live-variables/instructions
          [rev-instructions : (List PointState)]
          [acc-instructions : (List PointState)]
          [new-live : (Set Var)]) : (Tuple2 (List PointState) (Set Var))
  (case rev-instructions
    [(empty) (tuple2 acc-instructions new-live)]
    [(cons inst rev-instructions)
     (match-define (tuple2 new-state new-live)
       (propagate-live-variables/point-state inst new-live))
     (propagate-live-variables/instructions
       rev-instructions
       (cons
         new-state
         acc-instructions)
       new-live)]))

(define (propagate-live-variables/point-state [ps : PointState] [new-live : (Set Var)])
  : (Tuple2 PointState (Set Var))
  (match-define (point-state defined live moves) ps)
  (let ([new-live (set-union live (set-difference new-live defined))])
    (tuple2 (point-state defined new-live moves) new-live)))

(define (initial-block-state [block : BasicBlock] [blocks : (Dict Int BasicBlock)]) : BlockState
  (match-define (basic-block args instructions terminal) block)
  (block-state
    (set-add-all (make-set var=?) args)
    (make-set var=?)
    (map initial-point-state/instruction instructions)
    (initial-point-state/terminal terminal blocks)
    (terminal-next-blocks terminal)))

(define (initial-point-state/instruction [i : Instruction]) : PointState
  (point-state
    (defined-variables/instruction i)
    (used-variables/instruction i)
    (make-set (tuple2=? var=? var=?))))

(define (initial-point-state/terminal [t : Terminal] [blocks : (Dict Int BasicBlock)]) : PointState
  (point-state
    (make-set var=?)
    (used-variables/terminal t)
    (moves/terminal t blocks)))

(define (terminal-next-blocks [t : Terminal]) : (Set Int)
  (set-add-all
    (make-set =)
    (case t
      [(return _) (empty)]
      [(jump b _) (varargs list b)]
      [(cond-jump _ t _ f _) (varargs list t f)])))

(define (used-variables/terminal [t : Terminal]) : (Set Var)
  (set-add-all
    (make-set var=?)
    (case t
      [(return v) (varargs list v)]
      [(jump _ vs) vs]
      [(cond-jump v _ tvs _ fvs) (cons v (append tvs fvs))])))

(define (moves/terminal [t : Terminal] [blocks : (Dict Int BasicBlock)]) : (Set (Tuple2 Var Var))
  (set-add-all
    (make-set (tuple2=? var=? var=?))
    (case t
      [(return v) (empty)]
      [(jump i vs)
       (case (dict-ref blocks i)
         [(nothing) (panic #"Bad block")]
         [(just (basic-block args _ _))
          (case (zip vs args)
            [(nothing) (panic #"Bad args")]
            [(just merged)
             merged])])]
      [(cond-jump _ t tvs f fvs)
       (append
         (case (dict-ref blocks t)
           [(nothing) (panic #"Bad block")]
           [(just (basic-block args _ _))
            (case (zip tvs args)
              [(nothing) (panic #"Bad args")]
              [(just merged)
               merged])])
         (case (dict-ref blocks f)
           [(nothing) (panic #"Bad block")]
           [(just (basic-block args _ _))
            (case (zip fvs args)
              [(nothing) (panic #"Bad args")]
              [(just merged)
               merged])]))])))

(define (used-variables/instruction [i : Instruction]) : (Set Var)
  (set-add-all
    (make-set var=?)
    (case i
      [(int-literal _ _) (empty)]
      [(bin-op-inst _ _ left right) (varargs list left right)])))

(define (defined-variables/instruction [i : Instruction]) : (Set Var)
  (set-add
    (make-set var=?)
    (case i
      [(int-literal v _) v]
      [(bin-op-inst v _ _ _) v])))

(define (add-live-variables-to-graph/point-state
          [p : PointState]
          [g : (Graph Var VertexData EdgeData)]) : (Graph Var VertexData EdgeData)
  (match-define (point-state _ live moves) p)
  (foldl
    (lambda ([v : Var] [g : (Graph Var VertexData EdgeData)])
      (graph-add-vertex-if-absent g v (vertex-data (var->bytes v))))
    (set->list live)
    g))

(define (add-live-edges-to-graph/point-state
          [p : PointState]
          [g : (Graph Var VertexData EdgeData)]) : (Graph Var VertexData EdgeData)
  (match-define (point-state _ live moves) p)
  (foldl
    (lambda ([vs : (Tuple2 Var Var)] [g : (Graph Var VertexData EdgeData)])
      (case vs
        [(tuple2 v1 v2)
         (graph-add-edge-if-absent g v1 v2 (edge-data #"dashed"))]))
    (set->list moves)
    (foldl
      (lambda ([vs : (Tuple2 Var Var)] [g : (Graph Var VertexData EdgeData)])
        (case vs
          [(tuple2 v1 v2)
           (graph-add-edge-if-absent g v1 v2 (edge-data #"solid"))]))
      (all-choose-two-options live)
      g)))

(define (all-choose-two-options [s : (Set Var)]) : (List (Tuple2 Var Var))
  (case (set-split s)
    [(nothing) (empty)]
    [(just (tuple2 v s))
     (append
       (map
         (lambda ([v2 : Var]) (tuple2 v v2))
         (set->list s))
       (all-choose-two-options s))]))

(define (add-live-variables-to-graph/blocks
          [blocks : (Dict Int BlockState)]
          [g : (Graph Var VertexData EdgeData)]) : (Graph Var VertexData EdgeData)
  (dict-fold
    blocks
    (lambda ([block-num : Int] [state : BlockState] [acc : (Graph Var VertexData EdgeData)])
      : (Graph Var VertexData EdgeData)
      (case state
        [(block-state _ _ instructions terminal _)
         (add-live-variables-to-graph/point-state
           terminal
           (foldl add-live-variables-to-graph/point-state instructions acc))]))
    g))

(define (add-live-edges-to-graph/blocks
          [blocks : (Dict Int BlockState)]
          [g : (Graph Var VertexData EdgeData)]) : (Graph Var VertexData EdgeData)
  (dict-fold
    blocks
    (lambda ([block-num : Int] [state : BlockState] [acc : (Graph Var VertexData EdgeData)])
      : (Graph Var VertexData EdgeData)
      (case state
        [(block-state _ _ instructions terminal _)
         (add-live-edges-to-graph/point-state
           terminal
           (foldl add-live-edges-to-graph/point-state instructions acc))]))
    g))


(define (print-graph [blocks : (Dict Int BlockState)]) : Bytes
  (graph->graphviz
    (add-live-edges-to-graph/blocks
      blocks
      (add-live-variables-to-graph/blocks
        blocks
        (empty-graph var=?)))))
