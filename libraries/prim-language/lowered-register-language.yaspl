#:module lowered-register-language
#:import {
  dict {
    #:types
      Dict
    #:values
      dict-add
      dict-fold
      dict-has-key?
      dict-keys
      dict-ref
      dict-remove
      dict-value-map
      make-dict
  }
  either {
    #:types
      Either
    #:values
      left
      right
  }
  find-chains {
    #:values
      find-chains
  }
  list {
    #:types
      List
    #:values
      empty
      foldl
      list
      map
  }
  maybe {
    #:types
      Maybe
    #:values
      just
      nothing
    #:patterns
      just
      nothing
  }
  prim {
    #:types
      Boolean
      Bytes
      Int
    #:values
      =
      panic
  }
  prim-language {
    #:types
      BinOp
  }
  set {
    #:types
      Set
    #:values
      make-set
      set->list
      set-add-all
  }
  set-multi-dict {
    #:types
      SetMultiDict
    #:values
      make-set-multi-dict
      set-multi-dict-add
      set-multi-dict-empty?
      set-multi-dict-ref/empty
      set-multi-dict-remove
  }
  unique-dict {
    #:types
      UniqueDict
    #:values
      make-unique-dict
      unique-dict-add
      unique-dict-remove
  }
}
(export
  #:types (FunctionDefinition BasicBlock Instruction Terminal BlockMap UnvalidatedBlockMap)
  #:values (function-definition return jump cond-jump move basic-block
            bin-op-inst int-literal basic-block-terminal rename-registers/function-definition
            function-definition-name terminal-next-blocks empty-unvalidated-block-map block-map-blocks
            unvalidated-block-map-map unvalidated-block-map-add-block block-map->unvalidated-block-map
            unvalidated-block-map-filter validate-block-map fallthrough block-map-block-chains)
  #:patterns ())
(types
  (define-type (FunctionDefinition Reg)
    (function-definition
      [name : Bytes]
      [num-extra-temporary : Int]
      [entry-block : Int]
      [blocks : (BlockMap Reg)]))
  (define-type (BasicBlock Reg)
    (basic-block [instructions : (List (Instruction Reg))] [terminal : (Terminal Reg)]))

  (define-type (BlockMap Reg)
    (block-map
      [blocks : (Dict Int (BasicBlock Reg))]
      [predecessors : (SetMultiDict Int Int)]
      [fallthrough : (UniqueDict Int Int)]))

  (define-type (UnvalidatedBlockMap Reg)
    (unvalidated-block-map
      [blocks : (Dict Int (BasicBlock Reg))]
      [predecessors : (SetMultiDict Int Int)]
      [fallthrough : (UniqueDict Int Int)]
      [missing-edges : (SetMultiDict Int Int)]))


  (define-type (Instruction Reg)
    (int-literal [output : Reg] [v : Int])
    ;(load-temporary [output : Reg] [offset : Int])
    ;(store-temporary [offset : Int] [reg : Reg])
    (move [output : Reg] [input : Reg])
    (bin-op-inst [output : Reg] [op : BinOp] [right : Reg]))

  (define-type (Terminal Reg)
    (return [reg : Reg])
    (jump [block : Int])
    (fallthrough [block : Int])
    (cond-jump [reg : Reg] [true : Int] [false : Int])))

(define (RegA RegB) (rename-registers/function-definition
                      [f : (FunctionDefinition RegA)]
                      [rename : (RegA -> RegB)]) : (FunctionDefinition RegB)
  (match-define (function-definition name extras entry (block-map blocks pred fallthrough)) f)
  (function-definition
    name
    extras
    entry
    (block-map
      (dict-value-map
        blocks
        (lambda ([b : (BasicBlock RegA)]) (rename-registers/block b rename)))
      pred
      fallthrough)))


(define (RegA RegB) (rename-registers/block
                      [b : (BasicBlock RegA)]
                      [rename : (RegA -> RegB)]) : (BasicBlock RegB)
  (match-define (basic-block instructions terminal) b)
  (basic-block
    (map
      (lambda ([i : (Instruction RegA)])
        (rename-registers/instruction i rename))
      instructions)
    (rename-registers/terminal terminal rename)))

(define (RegA RegB) (rename-registers/instruction
                      [i : (Instruction RegA)]
                      [rename : (RegA -> RegB)]) : (Instruction RegB)
  (case i
    [(int-literal out v)
     (int-literal (rename out) v)]
    [(move out in)
     (move (rename out) (rename in))]
    [(bin-op-inst out op in)
     (bin-op-inst (rename out) op (rename in))]))

(define (RegA RegB) (rename-registers/terminal
                      [t : (Terminal RegA)]
                      [rename : (RegA -> RegB)]) : (Terminal RegB)
  (case t
    [(return r)
     (return (rename r))]
    [(jump block)
     (jump block)]
    [(fallthrough block)
     (fallthrough block)]
    [(cond-jump reg true false)
     (cond-jump (rename reg) true false)]))

(define (Reg) (validate-block-map [uv : (UnvalidatedBlockMap Reg)]) : (Either Bytes (BlockMap Reg))
  (match-define (unvalidated-block-map blocks pred fallthrough missing) uv)
  (if (set-multi-dict-empty? missing)
      (right (block-map blocks pred fallthrough))
      (left #"Some blocks are not missing")))

(define (Reg) (block-map->unvalidated-block-map [bm : (BlockMap Reg)]) : (UnvalidatedBlockMap Reg)
  (match-define (block-map blocks pred fallthrough) bm)
  (unvalidated-block-map blocks pred fallthrough (make-set-multi-dict = =)))

(define (Reg) (empty-unvalidated-block-map) : (UnvalidatedBlockMap Reg)
  (unvalidated-block-map (make-dict =) (make-set-multi-dict = =) (make-unique-dict = =) (make-set-multi-dict = =)))


(define (Reg) (unvalidated-block-map-add-block
                [uv : (UnvalidatedBlockMap Reg)]
                [index : Int]
                [block : (BasicBlock Reg)]) : (UnvalidatedBlockMap Reg)
  (match-define (unvalidated-block-map blocks pred fallthrough missing) uv)
  (case (dict-ref blocks index)
    [(just block) (panic #"Existing block")]
    [(nothing)
     (let ([next-blocks (set->list (terminal-next-blocks (basic-block-terminal block)))])
       (let ([new-blocks (dict-add blocks index block)])
         (unvalidated-block-map
           new-blocks
           (foldl
             (lambda ([target : Int] [pred : (SetMultiDict Int Int)])
               (set-multi-dict-add pred target index))
             next-blocks
             pred)
           (case (terminal-maybe-fallthrough (basic-block-terminal block))
             [(nothing) fallthrough]
             [(just next-block)
              (unique-dict-add fallthrough index next-block)])
           (foldl
             (lambda ([target : Int] [missing : (SetMultiDict Int Int)])
               (if (dict-has-key? new-blocks target)
                   missing
                   (set-multi-dict-add missing index target)))
             next-blocks
             (foldl
               (lambda ([pred : Int] [missing : (SetMultiDict Int Int)])
                 (set-multi-dict-remove missing pred index))
               (set->list (set-multi-dict-ref/empty pred index))
               missing)))))]))

(define (Reg) (unvalidated-block-map-remove-block
                [uv : (UnvalidatedBlockMap Reg)]
                [index : Int]) : (UnvalidatedBlockMap Reg)
  (match-define (unvalidated-block-map blocks pred fallthrough missing) uv)
  (case (dict-ref blocks index)
    [(nothing) (panic #"No existing block")]
    [(just block)
     (let ([next-blocks (set->list (terminal-next-blocks (basic-block-terminal block)))])
       (let ([new-blocks (dict-remove blocks index)])
         (let ([new-predecessors
                (foldl
                  (lambda ([target : Int] [pred : (SetMultiDict Int Int)])
                    (set-multi-dict-remove pred target index))
                  next-blocks
                  pred)])
         (unvalidated-block-map
           new-blocks
           new-predecessors
           (unique-dict-remove fallthrough index)
           (foldl
             (lambda ([pred : Int] [missing : (SetMultiDict Int Int)])
               (set-multi-dict-add missing pred index))
             (set->list (set-multi-dict-ref/empty new-predecessors index))
             (foldl
               (lambda ([target : Int] [missing : (SetMultiDict Int Int)])
                 (set-multi-dict-remove missing index target))
               next-blocks
               missing))))))]))


(define (Reg) (unvalidated-block-map-map
                [uv : (UnvalidatedBlockMap Reg)]
                [f : (Int (BasicBlock Reg) -> (BasicBlock Reg))]) : (UnvalidatedBlockMap Reg)
  (match-define (unvalidated-block-map blocks _ _ _) uv)
  (dict-fold
    blocks
    (lambda ([index : Int] [block : (BasicBlock Reg)] [acc : (UnvalidatedBlockMap Reg)])
      (unvalidated-block-map-add-block acc index (f index block)))
    ((lambda () : (UnvalidatedBlockMap Reg) (empty-unvalidated-block-map)))))


(define (Reg) (unvalidated-block-map-filter
                [uv : (UnvalidatedBlockMap Reg)]
                [f : (Int (BasicBlock Reg) -> Boolean)]) : (UnvalidatedBlockMap Reg)
  (match-define (unvalidated-block-map blocks pred _ _) uv)
  (dict-fold
    blocks
    (lambda ([index : Int] [block : (BasicBlock Reg)] [acc : (UnvalidatedBlockMap Reg)])
      (if (f index block)
          acc
          (unvalidated-block-map-remove-block acc index)))
    uv))

(define (Reg) (block-map-block-chains [bm : (BlockMap Reg)]) : (List (List Int))
  (match-define (block-map blocks _ fallthrough) bm)
  (find-chains (dict-keys blocks) fallthrough))

(define (Reg) (terminal-next-blocks [t : (Terminal Reg)]) : (Set Int)
  (set-add-all
    (make-set =)
    (case t
      [(return _) (empty)]
      [(jump b) (varargs list b)]
      [(fallthrough b) (varargs list b)]
      [(cond-jump _ t f) (varargs list t f)])))

(define (Reg) (terminal-maybe-fallthrough [t : (Terminal Reg)]) : (Maybe Int)
  (case t
    [(return _) (nothing)]
    [(jump b) (nothing)]
    [(fallthrough b) (just b)]
    [(cond-jump _ t f) (nothing)]))
