#:module (lowered-register-language)
#:import {
  (dict)
  (either)
  (find-chains)
  (list)
  (maybe)
  (numbers)
  (prim)
  (register-language) {
    #:types
      UnaryOp
  }
  (set)
  (set-multi-dict)
  (tuples)
  (unique-dict)
  (yaspl math-operations)
}
(export
  #:types (FunctionDefinition BasicBlock Instruction Terminal BlockMap UnvalidatedBlockMap Condition
           FunctionKind AssignedRegistersFunctionDefinition CompareMemArg)
  #:values (function-definition return jump cond-jump/false-fall-through move basic-block
            numeric-op-inst comparison-op-inst int-literal basic-block-terminal
            rename-registers/block-map
            rename-registers/instruction
            assigned-registers-function-definition assigned-registers-function-definition-name
            function-definition-name terminal-next-blocks empty-unvalidated-block-map block-map-blocks
            unvalidated-block-map-map unvalidated-block-map-map/acc
            unvalidated-block-map-set-entry unvalidated-block-map-add-block
            unvalidated-block-map-remove-block block-map->unvalidated-block-map
            unvalidated-block-map-filter validate-block-map
            fall-through block-map-block-chains block-map-predecessors block-map-fall-through
            negated-reg-condition reg-condition comparison-condition
            block-map-entry-block store-8byte store-8byte-repeated load-8byte push pop
            load-zero-extended-byte store-least-significant-byte store-least-significant-byte-repeated
            unary-op-inst load-temporary store-temporary
            function-call-inst syscall indirect-function-call closure-call symbol-address
            halt tail-call compare-memory memory-compare-condition numeric-op-immediate direct-call
            compare-mem-arg-val compare-mem-arg-ptr)
  #:patterns (int-literal symbol-address load-temporary store-temporary push pop
              load-zero-extended-byte store-least-significant-byte
              store-least-significant-byte-repeated load-8byte store-8byte store-8byte-repeated
              compare-memory move function-call-inst unary-op-inst numeric-op-inst comparison-op-inst
              return halt tail-call jump fall-through cond-jump/false-fall-through
              reg-condition negated-reg-condition comparison-condition memory-compare-condition
              syscall indirect-function-call closure-call direct-call
              function-definition assigned-registers-function-definition
              basic-block numeric-op-immediate compare-mem-arg-val compare-mem-arg-ptr))
(types
  (define-type (FunctionDefinition Reg)
    (function-definition
      [name : Bytes]
      [num-extra-temporary : Int]
      [blocks : (BlockMap Reg)]))
  (define-type (AssignedRegistersFunctionDefinition Reg)
    (assigned-registers-function-definition
      [name : Bytes]
      [blocks : (BlockMap Reg)]))
  (define-type (BasicBlock Reg)
    (basic-block [instructions : (List (Instruction Reg))] [terminal : (Terminal Reg)]))

  (define-type (BlockMap Reg)
    (block-map
      [entry-block : Int]
      [blocks : (Dict Int (BasicBlock Reg))]
      [predecessors : (SetMultiDict Int Int)]
      [fall-through : (UniqueDict Int Int)]))

  (define-type (UnvalidatedBlockMap Reg)
    (unvalidated-block-map
      [entry-block : Int]
      [blocks : (Dict Int (BasicBlock Reg))]
      [predecessors : (SetMultiDict Int Int)]
      [fall-through : (UniqueDict Int Int)]
      [missing-edges : (SetMultiDict Int Int)]))


  (define-type (Instruction Reg)
    (int-literal [output : Reg] [v : Int])
    (load-temporary [output : Reg] [index : Int])
    (store-temporary [index : Int] [reg : Reg])
    (symbol-address [output : Reg] [name : Bytes])
    (push [reg : Reg])
    (pop [reg : Reg])
    (load-zero-extended-byte [output : Reg] [location : Reg] [offset : Int])
    (store-least-significant-byte [location : Reg] [offset : Int] [val : Reg])
    (store-least-significant-byte-repeated [location : Reg] [val : Reg] [count : Reg])
    (load-8byte [output : Reg] [location : Reg] [offset : Int])
    (store-8byte [location : Reg] [offset : Int] [val : Reg])
    (store-8byte-repeated [location : Reg] [val : Reg] [count : Reg])
    (compare-memory [output : Reg] [size : Reg] [v1 : Reg] [v2 : Reg])
    (move [output : Reg] [input : Reg])
    ;; TODO Make conflict a set when equality is easier to deal with
    (function-call-inst [output : Reg] [f : (FunctionKind Reg)] [args : (List Reg)] [conflicts : (List Reg)])
    (unary-op-inst [output : Reg] [op : UnaryOp] [input : Reg])
    (numeric-op-inst [output : Reg] [op : NumericBinOp] [right : Reg])
    (comparison-op-inst [output : Reg] [op : ComparisonBinOp] [right : Reg])
    (numeric-op-immediate [output : Reg] [op : NumericBinOp] [amount : S32]))

  (define-type (FunctionKind Reg)
    (direct-call [f : Bytes])
    (indirect-function-call [f : Reg])
    (closure-call [c : Reg])
    (syscall [num : Reg]))

  (define-type (Condition Reg)
    (reg-condition [reg : Reg])
    (negated-reg-condition [reg : Reg])
    (comparison-condition [op : ComparisonBinOp] [reg1 : (CompareMemArg Reg)] [reg-imm2 : (Either Reg S32)])
    (memory-compare-condition [negated? : Boolean] [size : Reg] [reg1 : Reg] [reg2 : Reg]))

  (define-type (CompareMemArg Reg)
    (compare-mem-arg-val [v : Reg])
    (compare-mem-arg-ptr [v : Reg]))

  (define-type (Terminal Reg)
    (return [reg : Reg])
    (halt)
    (tail-call [f : (FunctionKind Reg)] [args : (List Reg)])
    (jump [block : Int])
    (fall-through [block : Int])
    (cond-jump/false-fall-through [cond : (Condition Reg)] [true : Int] [false : Int])))

(define (RegA RegB) (rename-registers/block-map
                      [b : (BlockMap RegA)]
                      [rename : (RegA -> RegB)]) : (BlockMap RegB)
  (match-define (block-map entry-block blocks pred fall-through) b)
  (block-map
    entry-block
    (dict-value-map
      blocks
      (lambda ([b : (BasicBlock RegA)]) (rename-registers/block b rename)))
    pred
    fall-through))

(define (RegA RegB) (rename-registers/block
                      [b : (BasicBlock RegA)]
                      [rename : (RegA -> RegB)]) : (BasicBlock RegB)
  (match-define (basic-block instructions terminal) b)
  (basic-block
    (map
      (lambda ([i : (Instruction RegA)])
        (rename-registers/instruction i rename))
      instructions)
    (rename-registers/terminal terminal rename)))

(define (RegA RegB) (rename-registers/instruction
                      [i : (Instruction RegA)]
                      [rename : (RegA -> RegB)]) : (Instruction RegB)
  (case i
    [(int-literal out v)
     (int-literal (rename out) v)]
    [(symbol-address out v)
     (symbol-address (rename out) v)]
    [(move out in)
     (move (rename out) (rename in))]
    [(push reg)
     (push (rename reg))]
    [(pop reg)
     (pop (rename reg))]
    [(load-zero-extended-byte out ptr offset)
     (load-zero-extended-byte (rename out) (rename ptr) offset)]
    [(store-least-significant-byte loc offset val)
     (store-least-significant-byte (rename loc) offset (rename val))]
    [(store-least-significant-byte-repeated loc val amount)
     (store-least-significant-byte-repeated (rename loc) (rename val) (rename amount))]
    [(load-8byte out ptr offset)
     (load-8byte (rename out) (rename ptr) offset)]
    [(store-8byte loc offset val)
     (store-8byte (rename loc) offset (rename val))]
    [(store-8byte-repeated loc val amount)
     (store-8byte-repeated (rename loc) (rename val) (rename amount))]
    [(compare-memory out size v1 v2)
     (compare-memory (rename out) (rename size) (rename v1) (rename v2))]
    [(load-temporary out index)
     (load-temporary (rename out) index)]
    [(store-temporary index reg)
     (store-temporary index (rename reg))]
    [(numeric-op-inst out op in)
     (numeric-op-inst (rename out) op (rename in))]
    [(comparison-op-inst out op in)
     (comparison-op-inst (rename out) op (rename in))]
    [(unary-op-inst out op in)
     (unary-op-inst (rename out) op (rename in))]
    [(function-call-inst out f args conflicts)
     (function-call-inst (rename out) (rename-registers/function-kind f rename)
                         (map rename args) (map rename conflicts))]
    [(numeric-op-immediate out op amt)
     (numeric-op-immediate (rename out) op amt)]))


(define (RegA RegB) (rename-registers/function-kind
                      [f : (FunctionKind RegA)]
                      [rename : (RegA -> RegB)]) : (FunctionKind RegB)
  (case f
    [(direct-call f) (direct-call f)]
    [(indirect-function-call f) (indirect-function-call (rename f))]
    [(closure-call c) (closure-call (rename c))]
    [(syscall n) (syscall (rename n))]))

(define (RegA RegB) (rename-registers/terminal
                      [t : (Terminal RegA)]
                      [rename : (RegA -> RegB)]) : (Terminal RegB)
  (case t
    [(return r)
     (return (rename r))]
    [(halt)
     (halt)]
    [(tail-call f args)
     (tail-call (rename-registers/function-kind f rename) (map rename args))]
    [(jump block)
     (jump block)]
    [(fall-through block)
     (fall-through block)]
    [(cond-jump/false-fall-through condition true false)
     (cond-jump/false-fall-through
       (case condition
         [(reg-condition reg) (reg-condition (rename reg))]
         [(negated-reg-condition reg) (negated-reg-condition (rename reg))]
         [(comparison-condition op reg-mem1 reg-imm2)
          (comparison-condition op
                                (case reg-mem1
                                  [(compare-mem-arg-val r) (compare-mem-arg-val (rename r))]
                                  [(compare-mem-arg-ptr r) (compare-mem-arg-ptr (rename r))])
                                (case reg-imm2
                                  [(left r) (left (rename r))]
                                  [(right imm) (right imm)]))]
         [(memory-compare-condition negated? size reg1 reg2)
          (memory-compare-condition negated? (rename size) (rename reg1) (rename reg2))])
       true false)]))


(define (Reg) (validate-block-map [uv : (UnvalidatedBlockMap Reg)]) : (Either Bytes (BlockMap Reg))
  (match-define (unvalidated-block-map entry-block blocks pred fall-through missing) uv)
  (if (set-multi-dict-empty? missing)
      (if (dict-has-key? blocks entry-block)
          (right (block-map entry-block blocks pred fall-through))
          (left #"No entry block"))
      (left #"Some blocks are missing")))


(define (Reg) (block-map->unvalidated-block-map [bm : (BlockMap Reg)]) : (UnvalidatedBlockMap Reg)
  (match-define (block-map entry-block blocks pred fall-through) bm)
  (unvalidated-block-map entry-block blocks pred fall-through (make-set-multi-dict int-cmp int-cmp)))

(define (Reg) (empty-unvalidated-block-map [entry-block : Int]) : (UnvalidatedBlockMap Reg)
  (unvalidated-block-map entry-block (make-dict int-cmp) (make-set-multi-dict int-cmp int-cmp)
                         (make-unique-dict int-cmp int-cmp)
                         (make-set-multi-dict int-cmp int-cmp)))

(define (Reg) (unvalidated-block-map-set-entry [uv : (UnvalidatedBlockMap Reg)] [entry-block : Int])
  : (UnvalidatedBlockMap Reg)
  (match-define (unvalidated-block-map _ blocks pred fall-through missing) uv)
  (unvalidated-block-map entry-block blocks pred fall-through missing))

(define (Reg) (unvalidated-block-map-add-block
                [uv : (UnvalidatedBlockMap Reg)]
                [index : Int]
                [block : (BasicBlock Reg)]) : (UnvalidatedBlockMap Reg)
  (match-define (unvalidated-block-map entry-block blocks pred fall-through missing) uv)
  (case (dict-ref blocks index)
    [(just block) (panic #"Existing block")]
    [(nothing)
     (let ([fall-through-target (terminal-maybe-fall-through (basic-block-terminal block))])
       (if (case fall-through-target
             [(nothing) #f]
             [(just target) (= entry-block target)])
           (panic #"Cannot fall through to entry-block")
           (let ([next-blocks (set->list (terminal-next-blocks (basic-block-terminal block)))])
             (let ([new-blocks (dict-add blocks index block)])
               (unvalidated-block-map
                 entry-block
                 new-blocks
                 (foldl
                   (lambda ([target : Int] [pred : (SetMultiDict Int Int)])
                     (set-multi-dict-add pred target index))
                   next-blocks
                   pred)
                 (case fall-through-target
                   [(nothing) fall-through]
                   [(just next-block)
                    (unique-dict-add fall-through index next-block)])
                 (foldl
                   (lambda ([target : Int] [missing : (SetMultiDict Int Int)])
                     (if (dict-has-key? new-blocks target)
                         missing
                         (set-multi-dict-add missing index target)))
                   next-blocks
                   (foldl
                     (lambda ([pred : Int] [missing : (SetMultiDict Int Int)])
                       (set-multi-dict-remove missing pred index))
                     (set->list (set-multi-dict-ref/empty pred index))
                     missing)))))))]))

(define (Reg) (unvalidated-block-map-remove-block
                [uv : (UnvalidatedBlockMap Reg)]
                [index : Int]) : (UnvalidatedBlockMap Reg)
  (match-define (unvalidated-block-map entry-block blocks pred fall-through missing) uv)
  (case (dict-ref blocks index)
    [(nothing) (panic #"No existing block")]
    [(just block)
     (let ([next-blocks (set->list (terminal-next-blocks (basic-block-terminal block)))])
       (let ([new-blocks (dict-remove blocks index)])
         (let ([new-predecessors
                (foldl
                  (lambda ([target : Int] [pred : (SetMultiDict Int Int)])
                    (set-multi-dict-remove pred target index))
                  next-blocks
                  pred)])
         (unvalidated-block-map
           entry-block
           new-blocks
           new-predecessors
           (unique-dict-remove fall-through index)
           (foldl
             (lambda ([pred : Int] [missing : (SetMultiDict Int Int)])
               (set-multi-dict-add missing pred index))
             (set->list (set-multi-dict-ref/empty new-predecessors index))
             (foldl
               (lambda ([target : Int] [missing : (SetMultiDict Int Int)])
                 (set-multi-dict-remove missing index target))
               next-blocks
               missing))))))]))


(define (Reg) (unvalidated-block-map-map
                [uv : (UnvalidatedBlockMap Reg)]
                [f : (Int (BasicBlock Reg) -> (BasicBlock Reg))]) : (UnvalidatedBlockMap Reg)
  (match-define (unvalidated-block-map entry-block blocks _ _ _) uv)
  (dict-fold
    blocks
    (lambda ([index : Int] [block : (BasicBlock Reg)] [acc : (UnvalidatedBlockMap Reg)])
      (unvalidated-block-map-add-block acc index (f index block)))
    ((lambda () : (UnvalidatedBlockMap Reg) (empty-unvalidated-block-map entry-block)))))

(define (Reg Acc) (unvalidated-block-map-map/acc
                    [uv : (UnvalidatedBlockMap Reg)]
                    [f : (Int (BasicBlock Reg) Acc -> (Tuple2 (BasicBlock Reg) Acc))]
                    [acc : Acc]) : (Tuple2 (UnvalidatedBlockMap Reg) Acc)
  (match-define (unvalidated-block-map entry-block blocks _ _ _) uv)
  (dict-fold
    blocks
    (lambda ([index : Int] [block : (BasicBlock Reg)] [acc : (Tuple2 (UnvalidatedBlockMap Reg) Acc)])
      (case acc
        [(tuple2 block-map acc)
         (match-define (tuple2 block acc) (f index block acc))
         (tuple2
           (unvalidated-block-map-add-block block-map index block)
           acc)]))
    (tuple2
      ((lambda () : (UnvalidatedBlockMap Reg) (empty-unvalidated-block-map entry-block)))
      acc)))



(define (Reg) (unvalidated-block-map-filter
                [uv : (UnvalidatedBlockMap Reg)]
                [f : (Int (BasicBlock Reg) -> Boolean)]) : (UnvalidatedBlockMap Reg)
  (match-define (unvalidated-block-map _ blocks pred _ _) uv)
  (dict-fold
    blocks
    (lambda ([index : Int] [block : (BasicBlock Reg)] [acc : (UnvalidatedBlockMap Reg)])
      (if (f index block)
          acc
          (unvalidated-block-map-remove-block acc index)))
    uv))

(define (Reg) (block-map-block-chains [bm : (BlockMap Reg)]) : (List (List Int))
  (match-define (block-map entry-block blocks _ fall-through) bm)
  (sort
    (find-chains (dict-keys blocks) fall-through)
    (lambda ([chain-a : (List Int)] [chain-b : (List Int)])
      (case (findf (lambda ([elem : Int]) (= elem entry-block)) chain-a)
        [(nothing) #f]
        [(just _) #t]))))

(define (Reg) (terminal-next-blocks [t : (Terminal Reg)]) : (Set Int)
  (set-add-all
    (make-set int-cmp)
    (case t
      [(return _) (empty)]
      [(halt) (empty)]
      [(tail-call _ _) (empty)]
      [(jump b) (varargs list b)]
      [(fall-through b) (varargs list b)]
      [(cond-jump/false-fall-through _ t f) (varargs list t f)])))

(define (Reg) (terminal-maybe-fall-through [t : (Terminal Reg)]) : (Maybe Int)
  (case t
    [(return _) (nothing)]
    [(halt) (nothing)]
    [(tail-call _ _) (nothing)]
    [(jump b) (nothing)]
    [(fall-through b) (just b)]
    [(cond-jump/false-fall-through _ _ f) (just f)]))
