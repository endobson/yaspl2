#:module print-lowered-register-language
#:import {
  bytes {
    #:values
      bytes-append
  }
  dict {
    #:values
      dict-map
  }
  join-list {
    #:types
      JoinList
    #:values
      append-jl
      append-jl*
      concat-jl
      jl->list
      join-list
      list->jl
      single-jl
  }
  list {
    #:values
      interleave
      map
  }
  lowered-register-language {
    #:types
      BasicBlock
      FunctionDefinition
      Instruction
      Terminal
    #:values
      block-map-blocks
    #:patterns
      basic-block
      bin-op-inst
      comparison-condition
      cond-jump/false-fall-through
      fall-through
      function-definition
      int-literal
      jump
      load
      move
      negated-reg-condition
      pop
      push
      reg-condition
      return
      store
      syscall-inst
  }
  numbers {
    #:values
      integer->decimal-bytes
      integer->hex-bytes
  }
  prim {
    #:types
      Bytes
      Int
  }
  prim-language {
    #:types
      BinOp
      ComparisonOp
    #:patterns
      and
      comparison-bin-op
      equal
      greater-than
      greater-than-or-equal
      less-than
      less-than-or-equal
      logical-bin-op
      mul
      not-equal
      numeric-bin-op
      or
      plus
      sub
  }
}
(export
  #:types ()
  #:values (print-function)
  #:patterns ())
(types)

(define (Reg) (print-function [f : (FunctionDefinition Reg)]
                              [print-reg : (Reg -> Bytes)]) : Bytes
  (case f
    [(function-definition name _ blocks)
     (bytes-append
       (jl->list
         (append-jl
           (varargs join-list
              name
              #"\n")
           (concat-jl
             (dict-map (block-map-blocks blocks)
                       (lambda ([i : Int] [b : (BasicBlock Reg)])
                         (print-basic-block i b print-reg)))))))]))

(define (Reg) (print-basic-block [index : Int] [b : (BasicBlock Reg)]
                                 [print-reg : (Reg -> Bytes)]) : (JoinList Bytes)
  (case b
    [(basic-block instructions terminal)
     (varargs append-jl*
       (varargs join-list
         #"block: "
         (integer->decimal-bytes index)
         #"\n")
       (concat-jl (map (lambda ([i : (Instruction Reg)])
                         (print-instruction i print-reg))
                       instructions))
       (print-terminal terminal print-reg))]))

(define (Reg) (print-instruction [i : (Instruction Reg)] [print-reg : (Reg -> Bytes)]) : (JoinList Bytes)
  (case i
    [(bin-op-inst out op right)
     (varargs append-jl*
       (single-jl (print-reg out))
       (varargs join-list #" = (" (print-bin-op op) #" ")
       (single-jl (print-reg out))
       (single-jl #" ")
       (single-jl (print-reg right))
       (single-jl #")\n"))]
    [(syscall-inst out num args _)
     (varargs append-jl*
       (single-jl (print-reg out))
       (varargs join-list #" = syscall[0x" (integer->hex-bytes num) #"](")
       (list->jl (interleave (map print-reg args) #", "))
       (single-jl #")\n"))]
    [(push reg)
     (varargs join-list
       #"push " (print-reg reg) #"\n")]
    [(pop reg)
     (varargs join-list
       #"pop " (print-reg reg) #"\n")]

    [(store loc val)
     (varargs join-list
       #"*" (print-reg loc) #" := " (print-reg val) #"\n")]
    [(load out loc)
     (varargs join-list
       (print-reg out) #" = *" (print-reg loc) #"\n")]
    [(int-literal out v)
     (append-jl
       (single-jl (print-reg out))
       (varargs join-list #" = " (integer->decimal-bytes v) #"\n"))]
    [(move dest src)
     (varargs join-list
       (print-reg dest)
       #" = "
       (print-reg src)
       #"\n")]))


(define (print-bin-op [op : BinOp]) : Bytes
  (case op
    [(numeric-bin-op (plus)) #"+"]
    [(numeric-bin-op (mul)) #"*"]
    [(numeric-bin-op (sub)) #"-"]
    [(logical-bin-op (and)) #"and"]
    [(logical-bin-op (or)) #"or"]
    [(comparison-bin-op c) (print-comparison-op c)]))

(define (print-comparison-op [op : ComparisonOp]) : Bytes
  (case op
    [(less-than) #"<"]
    [(less-than-or-equal) #"<="]
    [(greater-than) #">"]
    [(greater-than-or-equal) #">="]
    [(equal) #"="]
    [(not-equal) #"!="]))

(define (Reg) (print-terminal [t : (Terminal Reg)] [print-reg : (Reg -> Bytes)]) : (JoinList Bytes)
  (case t
    [(return reg)
     (varargs join-list
       #"return "
       (print-reg reg)
       #"\n")]
    [(jump block-num)
     (varargs join-list
       #"jump "
       (integer->decimal-bytes block-num)
       #"\n")]
    [(fall-through block-num)
     (varargs join-list
       #"fall-through "
       (integer->decimal-bytes block-num)
       #"\n")]
    [(cond-jump/false-fall-through (reg-condition reg) t-block-num f-block-num)
     (varargs join-list
       #"cond-jump "
       (print-reg reg)
       #" "
       (integer->decimal-bytes t-block-num)
       #" "
       (integer->decimal-bytes f-block-num)
       #"\n")]
    [(cond-jump/false-fall-through (negated-reg-condition reg) t-block-num f-block-num)
     (varargs join-list
       #"cond-jump (not "
       (print-reg reg)
       #") "
       (integer->decimal-bytes t-block-num)
       #" "
       (integer->decimal-bytes f-block-num)
       #"\n")]
    [(cond-jump/false-fall-through (comparison-condition op reg1 reg2) t-block-num f-block-num)
     (varargs join-list
       #"cond-jump ("
       (print-comparison-op op)
       #" "
       (print-reg reg1)
       #" "
       (print-reg reg2)
       #") "
       (integer->decimal-bytes t-block-num)
       #" "
       (integer->decimal-bytes f-block-num)
       #"\n")]))
