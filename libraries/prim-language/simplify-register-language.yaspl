#:module (simplify-register-language)
#:import {
  (dict)
  (list)
  (maybe)
  (numbers)
  (prim)
  (prim-language) {
    #:types
      ComparisonOp
    #:values
      equal
      greater-than
      greater-than-or-equal
      less-than
      less-than-or-equal
      not-equal
      plus
    #:patterns
      comparison-bin-op
      equal
      greater-than
      greater-than-or-equal
      less-than
      less-than-or-equal
      not-equal
      numeric-bin-op
      plus
  }
  (register-language)
  (set)
  (tuples)
}

(export
  #:types ()
  #:values (simplify-function-definition)
  #:patterns ())
(types
  (define-type AbstractValue
    (av-comparison [op : ComparisonOp] [left : Var] [right : Var])
    (av-memory-comparison [size : Var] [v1 : Var] [v2 : Var])
    (av-int [val : Int])
    (av-symbol [val : Bytes])
    (av-unknown)))

(define (simplify-function-definition
          [f : FunctionDefinition]
          [known-functions : (Dict Bytes Bytes)]) : FunctionDefinition
  (match-define (function-definition name entry-block blocks next-var-number next-block-number) f)
  (match-define abstract-values (compute-abstract-values blocks))
  (match-define new-blocks
    (remove-dead-instructions
      (optimize-constants abstract-values
        (optimize-known-functions abstract-values known-functions
          (optimize-conditional-jumps abstract-values blocks)))))
  (function-definition name entry-block new-blocks next-var-number next-block-number))

(define (optimize-conditional-jumps
          [abstract-values : (Dict Var AbstractValue)]
          [blocks : (Dict Int BasicBlock)]) : (Dict Int BasicBlock)
  (dict-value-map blocks
    (lambda ([b : BasicBlock])
      (optimize-conditional-jumps/block abstract-values b))))

(define (optimize-conditional-jumps/block
          [abstract-values : (Dict Var AbstractValue)]
          [b : BasicBlock]) : BasicBlock
  (match-define (basic-block args instructions terminal) b)
  (case terminal
    [(cond-jump c t t-args f f-args)
     (case (case c
             [(var-condition v) (just (tuple2 v #f))]
             [(negated-var-condition v) (just (tuple2 v #t))]
             [_ ((lambda () : (Maybe (Tuple2 Var Boolean)) (nothing)))])
       [(nothing) b]
       [(just (tuple2 v negated?))
        (case (dict-ref abstract-values v)
          [(just (av-comparison c left right))
           (basic-block args instructions
             (cond-jump
               (comparison-condition (if negated? (flip-comparison c) c) left right)
               t t-args f f-args))]
          [(just (av-memory-comparison size v1 v2))
           (basic-block args instructions
             (cond-jump
               (memory-compare-condition negated? size v1 v2)
               t t-args f f-args))]
          [_ b])])]
    [_ b]))

(define (flip-comparison [c : ComparisonOp]) : ComparisonOp
  (case c
    [(less-than) (greater-than-or-equal)]
    [(greater-than) (less-than-or-equal)]
    [(less-than-or-equal) (greater-than)]
    [(greater-than-or-equal) (less-than)]
    [(equal) (not-equal)]
    [(not-equal) (equal)]))

(define (remove-dead-instructions [blocks : (Dict Int BasicBlock)]) : (Dict Int BasicBlock)
  (match-define used-vars (compute-used-vars blocks))
  (dict-value-map blocks
    (lambda ([b : BasicBlock])
      (remove-dead-instructions/block b used-vars))))

(define (remove-dead-instructions/block [b : BasicBlock] [used-vars : (Set Var)]) : BasicBlock
  (match-define (basic-block args instructions terminal) b)
  (basic-block
    args
    (filter
      (lambda ([i : Instruction])
        (if (pure-instruction? i)
            (case (output-var i)
              [(just v) (set-member? used-vars v)]
              [(nothing) (panic #"Pure instruction didn't have output var")])
            #t))
      instructions)
    terminal))

(define (compute-used-vars [blocks : (Dict Int BasicBlock)]) : (Set Var)
  (dict-fold
    blocks
    (lambda ([k : Int] [v : BasicBlock] [s : (Set Var)])
      (set-union s (used-vars/block v)))
    (make-set var-cmp)))

(define (used-vars/block [b : BasicBlock]) : (Set Var)
  (match-define (basic-block args instructions terminal) b)
  (foldl
    (lambda ([instruction : Instruction] [acc : (Set Var)])
      (case instruction
        [(int-literal _ _) acc]
        [(symbol-address-inst _ _) acc]
        [(function-allocate-inst _ var) (set-add acc var)]
        [(heap-allocate-inst _ var) (set-add acc var)]
        [(memory-compare-inst _ size v1 v2) (set-add (set-add (set-add acc size) v1) v2)]
        [(pointer-set!-inst _ ptr _ val) (set-add (set-add acc ptr) val)]
        [(pointer-ref-inst _ _ ptr _) (set-add acc ptr)]
        [(function-call-inst _ (direct-call _) vars)
         (set-add-all acc vars)]
        [(function-call-inst _ (indirect-function-call f) vars)
         (set-add (set-add-all acc vars) f)]
        [(function-call-inst _ (closure-call c) vars)
         (set-add (set-add-all acc vars) c)]
        [(function-call-inst _ (syscall _) vars)
         (set-add-all acc vars)]
        [(bin-op-inst _ _ left right)
         (set-add (set-add acc left) right)]
        [(numeric-op-immediate _ _ v _)
         (set-add acc v)]
        [(unary-op-inst _ _ var) (set-add acc var)]))
    instructions
    (used-vars/terminal terminal)))

(define (used-vars/terminal [t : Terminal]) : (Set Var)
  (set-add-all
    (make-set var-cmp)
    (case t
      [(return var) (varargs list var)]
      [(halt) (empty)]
      [(cond-jump con _ t-args _ f-args)
       (append
         (case con
           [(var-condition var) (varargs list var)]
           [(negated-var-condition var) (varargs list var)]
           [(comparison-condition op v1 v2) (varargs list v1 v2)]
           [(memory-compare-condition _ size v1 v2) (varargs list size v1 v2)])
         (append t-args f-args))]
      [(jump _ args) args])))

(define (pure-instruction? [i : Instruction]) : Boolean
  (case i
    [(function-call-inst _ _ _) #f]
    [(function-allocate-inst _ _) #f]
    [(heap-allocate-inst _ _) #f]
    [(memory-compare-inst _ _ _ _) #f]
    [(pointer-set!-inst _ _ _ _) #f]
    [(pointer-ref-inst _ _ _ _) #f]
    [(int-literal _ _) #t]
    [(symbol-address-inst _ _) #t]
    [(bin-op-inst _ _ _ _) #t]
    [(numeric-op-immediate _ _ _ _) #t]
    [(unary-op-inst _ _ _) #t]))

(define (optimize-known-functions
          [abstract-values : (Dict Var AbstractValue)]
          [known-closures : (Dict Bytes Bytes)]
          [blocks : (Dict Int BasicBlock)]) : (Dict Int BasicBlock)
  (dict-value-map blocks
    (lambda ([b : BasicBlock])
      (optimize-known-functions/block abstract-values known-closures b))))

(define (optimize-known-functions/block
          [abstract-values : (Dict Var AbstractValue)]
          [known-closures : (Dict Bytes Bytes)]
          [b : BasicBlock]) : BasicBlock
  (match-define (basic-block args instructions terminal) b)
  (basic-block
    args
    (map
      (lambda ([i : Instruction])
        (case i
          [(function-call-inst v (closure-call c) args)
           (case (dict-ref abstract-values c)
             [(just (av-symbol sym))
              (case (dict-ref known-closures sym)
                [(nothing) i]
                [(just fun-sym)
                 (function-call-inst v (direct-call fun-sym) args)])]
             [_ i])]
          [(function-call-inst v (indirect-function-call f) args)
           (case (dict-ref abstract-values f)
             [(just (av-symbol fun-sym))
              (function-call-inst v (direct-call fun-sym) args)]
             [_ i])]
          [_ i]))
      instructions)
    terminal))

(define (optimize-constants
          [abstract-values : (Dict Var AbstractValue)]
          [blocks : (Dict Int BasicBlock)]) : (Dict Int BasicBlock)
  (dict-value-map blocks
    (lambda ([b : BasicBlock])
      (optimize-constants/block abstract-values b))))

(define (optimize-constants/block
          [abstract-values : (Dict Var AbstractValue)]
          [b : BasicBlock]) : BasicBlock
  (match-define (basic-block args instructions terminal) b)
  (basic-block
    args
    (map
      (lambda ([i : Instruction])
        (case i
          ;; TODO Handle more operations
          [(bin-op-inst v (numeric-bin-op (plus)) left right)
           (case (tuple2 (dict-ref abstract-values left) (dict-ref abstract-values right))
             ;; TODO do constant folding
             [(tuple2 (just (av-int lv)) _)
              (case (maybe-s32 lv)
                [(nothing) i]
                [(just lv)
                 (numeric-op-immediate v (plus) right lv)])]
             [(tuple2 _ (just (av-int rv)))
              (case (maybe-s32 rv)
                [(nothing) i]
                [(just rv)
                 (numeric-op-immediate v (plus) left rv)])]
             [_ i])]
          [_ i]))
      instructions)
    terminal))

;; TODO Use better flow analysis across blocks
(define (compute-abstract-values [blocks : (Dict Int BasicBlock)])
  : (Dict Var AbstractValue)
  (dict-fold
    blocks
    (lambda ([i : Int] [b : BasicBlock] [acc : (Dict Var AbstractValue)])
      (case b
        [(basic-block args instructions terminal)
         (foldl
           (lambda ([arg : Var] [acc : (Dict Var AbstractValue)])
             (dict-set acc arg (av-unknown)))
           args
           (foldl
             (lambda ([i : Instruction] [acc : (Dict Var AbstractValue)])
               (case i
                 [(int-literal var v)
                  (dict-set acc var (av-int v))]
                 [(bin-op-inst var (comparison-bin-op c) left right)
                  (dict-set acc var (av-comparison c left right))]
                 [(memory-compare-inst var size v1 v2)
                  (dict-set acc var (av-memory-comparison size v1 v2))]
                 [(symbol-address-inst var v)
                  (dict-set acc var (av-symbol v))]
                 [_
                  (case (output-var i)
                    [(nothing) acc]
                    [(just v) (dict-set acc v (av-unknown))])]))
             instructions
             acc))]))
    ((lambda () : (Dict Var AbstractValue) (make-dict var-cmp)))))
