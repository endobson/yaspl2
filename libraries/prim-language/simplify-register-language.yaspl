#:module (simplify-register-language)
#:import {
  (dict)
  (either)
  (list)
  (maybe)
  (numbers)
  (prim)
  (prim-language) {
    {#:patterns
      comparison-bin-op
      numeric-bin-op
    }
  }
  (register-language)
  (set)
  (tuples)
  (yaspl math-operations)
  (yaspl var)
}

(export
  #:types ()
  #:values (simplify-function-definition)
  #:patterns ())
(types
  (define-type AbstractValue
    (av-negated [v : Var])
    (av-comparison [op : ComparisonBinOp] [left : Var] [right : Var])
    (av-memory-comparison [size : Var] [v1 : Var] [v2 : Var])
    (av-int [val : Int])
    (av-symbol [val : Bytes])
    (av-unknown)))

(define (simplify-function-definition [f : FunctionDefinition]) : FunctionDefinition
  (match-define (function-definition name entry-block blocks next-var-number next-block-number) f)
  (match-define abstract-values (compute-abstract-values blocks))
  (match-define new-blocks
    (remove-dead-instructions
      (optimize-constants abstract-values
        (optimize-conditional-jumps abstract-values blocks))))
  (function-definition name entry-block new-blocks next-var-number next-block-number))

(define (optimize-conditional-jumps
          [abstract-values : (Dict Var AbstractValue)]
          [blocks : (Dict Int BasicBlock)]) : (Dict Int BasicBlock)
  (dict-value-map blocks
    (lambda ([b : BasicBlock])
      (optimize-conditional-jumps/block abstract-values b))))

(define (optimize-conditional-jumps/block
          [abstract-values : (Dict Var AbstractValue)]
          [b : BasicBlock]) : BasicBlock
  (match-define (basic-block args instructions terminal) b)
  (case terminal
    [(cond-jump c t t-args f f-args)
     (case (case c
             [(var-condition v) (just (tuple2 v #f))]
             [(negated-var-condition v) (just (tuple2 v #t))]
             [_ (ann (Maybe (Tuple2 Var Boolean)) (nothing))])
       [(nothing) b]
       [(just (tuple2 v negated?))
        (case (abstract-value-resolve abstract-values v)
          [(av-comparison c l r)
           (basic-block args instructions
             (cond-jump
               (comparison-condition (if negated? (negate-comparison c) c)
                                     (compare-s64 (compare-mem-arg-val l) (left r)))
               t t-args f f-args))]
          [(av-memory-comparison size v1 v2)
           (basic-block args instructions
             (cond-jump
               (memory-compare-condition negated? size v1 v2)
               t t-args f f-args))]
          [_ b])])]
    [_ b]))

(define (negate-comparison [c : ComparisonBinOp]) : ComparisonBinOp
  (case c
    [(less-than-op) (greater-than-or-equal-op)]
    [(greater-than-op) (less-than-or-equal-op)]
    [(less-than-or-equal-op) (greater-than-op)]
    [(greater-than-or-equal-op) (less-than-op)]
    [(equal-op) (not-equal-op)]
    [(not-equal-op) (equal-op)]))

(define (remove-dead-instructions [blocks : (Dict Int BasicBlock)]) : (Dict Int BasicBlock)
  (match-define used-vars (compute-used-vars blocks))
  (dict-value-map blocks
    (lambda ([b : BasicBlock])
      (remove-dead-instructions/block b used-vars))))

(define (remove-dead-instructions/block [b : BasicBlock] [used-vars : (Set Var)]) : BasicBlock
  (match-define (basic-block args instructions terminal) b)
  (basic-block
    args
    (filter
      (lambda ([i : Instruction])
        (if (side-effect-free-instruction? i)
            (case (output-var i)
              [(just v) (set-member? used-vars v)]
              [(nothing) (panic #"Pure instruction didn't have output var")])
            #t))
      instructions)
    terminal))

(define (compute-used-vars [blocks : (Dict Int BasicBlock)]) : (Set Var)
  (dict-fold
    blocks
    (lambda ([k : Int] [v : BasicBlock] [s : (Set Var)])
      (set-union s (used-vars/block v)))
    (make-set var-cmp)))

(define (used-vars/block [b : BasicBlock]) : (Set Var)
  (match-define (basic-block args instructions terminal) b)
  (foldl
    (lambda ([instruction : Instruction] [acc : (Set Var)])
      (case instruction
        [(int-literal _ _) acc]
        [(symbol-address-inst _ _) acc]
        [(function-allocate-inst _ var) (set-add acc var)]
        [(heap-allocate-inst/static _ _) acc]
        [(memory-compare-inst _ size v1 v2) (set-add (set-add (set-add acc size) v1) v2)]
        [(pointer-set!-inst _ ptr (fixed-pointer-offset _) val) (set-add (set-add acc ptr) val)]
        [(pointer-set!-inst _ ptr (scaled-pointer-offset index _ _) val)
         (set-add (set-add (set-add acc ptr) val) index)]
        [(pointer-ref-inst _ _ ptr (fixed-pointer-offset _)) (set-add acc ptr)]
        [(pointer-ref-inst _ _ ptr (scaled-pointer-offset index _ _)) (set-add (set-add acc ptr) index)]
        [(function-call-inst _ f vars)
         (set-add-all (set-add-all acc vars) (used-vars/function-kind f))]
        [(bin-op-inst _ _ left right)
         (set-add (set-add acc left) right)]
        [(numeric-op-immediate-inst _ _ v _)
         (set-add acc v)]
        [(comparison-op-immediate-inst _ _ v _)
         (set-add acc v)]
        [(unary-op-inst _ _ var) (set-add acc var)]))
    instructions
    (used-vars/terminal terminal)))

(define (used-vars/function-kind [f : FunctionKind]) : (List Var)
  (case f
   [(direct-call _)
    (empty)]
   [(indirect-function-call f)
    (cons f (empty))]
   [(closure-call c)
    (cons c (empty))]
   [(syscall _)
    (empty)]))

(define (used-vars/terminal [t : Terminal]) : (Set Var)
  (set-add-all
    (make-set var-cmp)
    (case t
      [(return var) (varargs list var)]
      [(halt) (empty)]
      [(tail-call f args)
       (append
         (used-vars/function-kind f)
         args)]
      [(cond-jump con _ t-args _ f-args)
       (append
         (case con
           [(var-condition var) (varargs list var)]
           [(negated-var-condition var) (varargs list var)]
           [(comparison-condition op args)
            (used-vars/compare-args args)]
           [(memory-compare-condition _ size v1 v2) (varargs list size v1 v2)])
         (append t-args f-args))]
      [(jump _ args) args])))

(define (used-vars/compare-args [args : CompareArgs]) : (List Var)
  (case args
    [(compare-s64 mem-arg imm-arg)
     (cons
       (used-vars/compare-mem-arg mem-arg)
       (case imm-arg
         [(left v) (varargs list v)]
         [(right _) (empty)]))]
    [(compare-u8 mem-arg imm-arg)
     (cons
       (used-vars/compare-mem-arg mem-arg)
       (case imm-arg
         [(left v) (varargs list v)]
         [(right _) (empty)]))]))


(define (used-vars/compare-mem-arg [mem-arg : CompareMemArg]) : Var
  (case mem-arg
    [(compare-mem-arg-val v) v]
    [(compare-mem-arg-ptr v) v]))

(define (side-effect-free-instruction? [i : Instruction]) : Boolean
  (case i
    [(function-call-inst _ _ _) #f]
    [(function-allocate-inst _ _) #f]
    [(heap-allocate-inst/static _ _) #f]
    [(memory-compare-inst _ _ _ _) #f]
    [(pointer-set!-inst _ _ _ _) #f]
    [(pointer-ref-inst _ _ _ _) #t]
    [(int-literal _ _) #t]
    [(symbol-address-inst _ _) #t]
    [(bin-op-inst _ _ _ _) #t]
    [(numeric-op-immediate-inst _ _ _ _) #t]
    [(comparison-op-immediate-inst _ _ _ _) #t]
    [(unary-op-inst _ _ _) #t]))

(define (optimize-constants
          [abstract-values : (Dict Var AbstractValue)]
          [blocks : (Dict Int BasicBlock)]) : (Dict Int BasicBlock)
  (dict-value-map blocks
    (lambda ([b : BasicBlock])
      (optimize-constants/block abstract-values b))))

(define (optimize-constants/block
          [abstract-values : (Dict Var AbstractValue)]
          [b : BasicBlock]) : BasicBlock
  (match-define (basic-block args instructions terminal) b)
  (basic-block
    args
    (map
      (lambda ([i : Instruction])
        (case i
          ;; TODO Handle more operations
          ;; TODO do constant folding
          [(bin-op-inst v (numeric-bin-op (add-op)) left right)
           (case (tuple2 (abstract-value-resolve abstract-values left)
                         (abstract-value-resolve abstract-values right))
             [(tuple2 (av-int lv) _)
              (case (maybe-s32 lv)
                [(nothing) i]
                [(just lv)
                 (numeric-op-immediate-inst v (add-op) right lv)])]
             [(tuple2 _ (av-int rv))
              (case (maybe-s32 rv)
                [(nothing) i]
                [(just rv)
                 (numeric-op-immediate-inst v (add-op) left rv)])]
             [_ i])]
          [(bin-op-inst v (numeric-bin-op (sub-op)) left right)
           (case (abstract-value-resolve abstract-values right)
             [(av-int rv)
              (case (maybe-s32 rv)
                [(nothing) i]
                [(just rv)
                 (numeric-op-immediate-inst v (sub-op) left rv)])]
             [_ i])]
          [(bin-op-inst v (numeric-bin-op (mult-op)) left right)
           (case (tuple2 (abstract-value-resolve abstract-values left)
                         (abstract-value-resolve abstract-values right))
             [(tuple2 (av-int lv) _)
              (case (maybe-s32 lv)
                [(nothing) i]
                [(just lv)
                 (numeric-op-immediate-inst v (mult-op) right lv)])]
             [(tuple2 _ (av-int rv))
              (case (maybe-s32 rv)
                [(nothing) i]
                [(just rv)
                 (numeric-op-immediate-inst v (mult-op) left rv)])]
             [_ i])]
          [(bin-op-inst v (comparison-bin-op op) left right)
           (case (tuple2 (abstract-value-resolve abstract-values left)
                         (abstract-value-resolve abstract-values right))
             [(tuple2 _ (av-int rv))
              (case (maybe-s32 rv)
                [(nothing) i]
                [(just rv)
                 (comparison-op-immediate-inst v op left rv)])]
             [(tuple2 (av-int lv) _)
              (case (maybe-s32 lv)
                [(nothing) i]
                [(just lv)
                 (comparison-op-immediate-inst v (flip-comparison op) right lv)])]
             [_ i])]
          [(pointer-ref-inst v size pointer (scaled-pointer-offset amount scale fixed-offset))
           (case (abstract-value-resolve abstract-values amount)
             [(av-int amount)
              (match-define scale-amount
                (case scale
                  [(one-byte-scale) 1]
                  [(eight-byte-scale) 8]))
              (match-define offset (+ (* amount scale-amount) fixed-offset))
              (pointer-ref-inst v size pointer (fixed-pointer-offset offset))]
             [_ i])]
          [(pointer-set!-inst size pointer (scaled-pointer-offset amount scale fixed-offset) val)
           (case (abstract-value-resolve abstract-values amount)
             [(av-int amount)
              (match-define scale-amount
                (case scale
                  [(one-byte-scale) 1]
                  [(eight-byte-scale) 8]))
              (match-define offset (+ (* amount scale-amount) fixed-offset))
              (pointer-set!-inst size pointer (fixed-pointer-offset offset) val)]
             [_ i])]
          [_ i]))
      instructions)
    (case terminal
      [(cond-jump cond t t-args f f-args)
       (case cond
         [(comparison-condition op (compare-s64 l (left r)))
          (case (abstract-value-resolve abstract-values r)
            [(av-int rv)
             (case (maybe-s32 rv)
               [(just rv)
                (cond-jump (comparison-condition op (compare-s64 l (right rv))) t t-args f f-args)]
               [_ terminal])]
            [_ terminal])]
         [_ terminal])]
      [_ terminal])))

(define (flip-comparison [c : ComparisonBinOp]) : ComparisonBinOp
  (case c
    [(less-than-op) (greater-than-op)]
    [(greater-than-op) (less-than-op)]
    [(less-than-or-equal-op) (greater-than-or-equal-op)]
    [(greater-than-or-equal-op) (less-than-or-equal-op)]
    [(equal-op) (equal-op)]
    [(not-equal-op) (not-equal-op)]))

;; TODO Use better flow analysis across blocks
(define (compute-abstract-values [blocks : (Dict Int BasicBlock)])
  : (Dict Var AbstractValue)
  (dict-fold
    blocks
    (lambda ([i : Int] [b : BasicBlock] [acc : (Dict Var AbstractValue)])
      (case b
        [(basic-block args instructions terminal)
         (foldl
           (lambda ([arg : Var] [acc : (Dict Var AbstractValue)])
             (dict-set acc arg (av-unknown)))
           args
           (foldl
             (lambda ([i : Instruction] [acc : (Dict Var AbstractValue)])
               (case i
                 [(int-literal var v)
                  (dict-set acc var (av-int v))]
                 [(bin-op-inst var (comparison-bin-op c) left right)
                  (dict-set acc var (av-comparison c left right))]
                 [(memory-compare-inst var size v1 v2)
                  (dict-set acc var (av-memory-comparison size v1 v2))]
                 [(symbol-address-inst var v)
                  (dict-set acc var (av-symbol v))]
                 [(unary-op-inst var (boolean-not) v)
                  (dict-set acc var (av-negated v))]
                 [_
                  (case (output-var i)
                    [(nothing) acc]
                    [(just v) (dict-set acc v (av-unknown))])]))
             instructions
             acc))]))
    (ann (Dict Var AbstractValue) (make-dict var-cmp))))

(define (abstract-value-resolve [abstract-values : (Dict Var AbstractValue)] [v : Var])
  : AbstractValue
  (case (dict-ref abstract-values v)
    [(just (av-negated var))
     (case (abstract-value-resolve abstract-values var)
       [(av-comparison op left right)
        (av-comparison (negate-comparison op) left right)]
       ;; TODO support negated memory comparison
       [_ (av-unknown)])]
    [(just val)
     val]
    [(nothing) (panic #"No abstract value for var")]))
