#:module (simplify-register-language)
#:import {
  (dict)
  (list)
  (maybe)
  (prim)
  (prim-language) {
    #:types
      ComparisonOp
    #:values
      equal
      greater-than
      greater-than-or-equal
      less-than
      less-than-or-equal
      not-equal
    #:patterns
      comparison-bin-op
      equal
      greater-than
      greater-than-or-equal
      less-than
      less-than-or-equal
      not-equal
  }
  (register-language)
  (set)
  (tuples)
}

(export
  #:types ()
  #:values (simplify-function-definition)
  #:patterns ())
(types)

(define (Reg) (simplify-function-definition [f : FunctionDefinition]) : FunctionDefinition
  (match-define (function-definition name entry-block blocks next-var-number next-block-number) f)
  (match-define new-blocks
    (remove-dead-instructions
      (optimize-conditional-jumps blocks)))
  (function-definition name entry-block new-blocks next-var-number next-block-number))

(define (optimize-conditional-jumps [blocks : (Dict Int BasicBlock)]) : (Dict Int BasicBlock)
  (dict-value-map blocks optimize-conditional-jumps/block))

;; TODO Use better flow analysis
(define (optimize-conditional-jumps/block [b : BasicBlock]) : BasicBlock
  (match-define (basic-block args instructions terminal) b)
  (case terminal
    [(cond-jump c t t-args f f-args)
     (case (case c
             [(var-condition v) (just (tuple2 v #f))]
             [(negated-var-condition v) (just (tuple2 v #t))]
             [_ ((lambda () : (Maybe (Tuple2 Var Boolean)) (nothing)))])
       [(nothing) b]
       [(just (tuple2 v negated?))
        (case (find/maybe
                (lambda ([i : Instruction]) : (Maybe Condition)
                  (case i
                    [(bin-op-inst out (comparison-bin-op c) left right)
                     (if (var=? out v)
                         (just (comparison-condition (if negated? (flip-comparison c) c) left right))
                         (nothing))]
                    [(memory-compare-inst out size v1 v2)
                     (if (var=? out v)
                         (just (memory-compare-condition negated? size v1 v2))
                         (nothing))]
                    [_ (nothing)]))
                instructions)
          [(nothing) b]
          [(just c)
           (basic-block args instructions (cond-jump c t t-args f f-args))])])]
    [_ b]))

(define (flip-comparison [c : ComparisonOp]) : ComparisonOp
  (case c
    [(less-than) (greater-than-or-equal)]
    [(greater-than) (less-than-or-equal)]
    [(less-than-or-equal) (greater-than)]
    [(greater-than-or-equal) (less-than)]
    [(equal) (not-equal)]
    [(not-equal) (equal)]))

(define (remove-dead-instructions [blocks : (Dict Int BasicBlock)]) : (Dict Int BasicBlock)
  (dict-value-map blocks remove-dead-instructions/block))

(define (remove-dead-instructions/block [b : BasicBlock]) : BasicBlock
  (match-define (basic-block args instructions terminal) b)
  (match-define used-variables
    (set-add-all
      (foldl
        (lambda ([instruction : Instruction] [acc : (Set Var)])
          (case instruction
            [(int-literal _ _) acc]
            [(symbol-address-inst _ _) acc]
            [(function-allocate-inst _ var) (set-add acc var)]
            [(heap-allocate-inst _ var) (set-add acc var)]
            [(memory-compare-inst _ size v1 v2) (set-add (set-add (set-add acc size) v1) v2)]
            [(pointer-set!-inst _ ptr val) (set-add (set-add acc ptr) val)]
            [(pointer-ref-inst _ _ ptr) (set-add acc ptr)]
            [(function-call-inst _ (indirect-function-call f) vars)
             (set-add (set-add-all acc vars) f)]
            [(function-call-inst _ (closure-call c) vars)
             (set-add (set-add-all acc vars) c)]
            [(function-call-inst _ (syscall _) vars)
             (set-add-all acc vars)]
            [(bin-op-inst _ _ left right)
             (set-add (set-add acc left) right)]
            [(unary-op-inst _ _ var) (set-add acc var)]))
        instructions
        (make-set var=?))
      (terminal-used-vars terminal)))
  (basic-block
    args
    (filter
      (lambda ([i : Instruction])
        (if (pure-instruction? i)
            (case (instruction-output-var i)
              [(just v) (set-member? used-variables v)]
              [(nothing) (panic #"Pure instruction didn't have output var")])
            #t))
      instructions)
    terminal))

(define (terminal-used-vars [t : Terminal]) : (List Var)
  (case t
    [(return var) (varargs list var)]
    [(halt) (empty)]
    [(cond-jump con _ t-args _ f-args)
     (append
       (case con
         [(var-condition var) (varargs list var)]
         [(negated-var-condition var) (varargs list var)]
         [(comparison-condition op v1 v2) (varargs list v1 v2)]
         [(memory-compare-condition _ size v1 v2) (varargs list size v1 v2)])
       (append t-args f-args))]
    [(jump _ args) args]))

(define (pure-instruction? [i : Instruction]) : Boolean
  (case i
    [(function-call-inst _ _ _) #f]
    [(function-allocate-inst _ _) #f]
    [(heap-allocate-inst _ _) #f]
    [(memory-compare-inst _ _ _ _) #f]
    [(pointer-set!-inst _ _ _) #f]
    [(pointer-ref-inst _ _ _) #f]
    [(int-literal _ _) #t]
    [(symbol-address-inst _ _) #t]
    [(bin-op-inst _ _ _ _) #t]
    [(unary-op-inst _ _ _) #t]))

(define (instruction-output-var [i : Instruction]) : (Maybe Var)
  (case i
    [(function-call-inst v _ _) (just v)]
    [(function-allocate-inst v _) (just v)]
    [(heap-allocate-inst v _) (just v)]
    [(memory-compare-inst v _ _ _) (just v)]
    [(pointer-set!-inst _ _ _) (nothing)]
    [(pointer-ref-inst v _ _) (just v)]
    [(int-literal v _) (just v)]
    [(symbol-address-inst v _) (just v)]
    [(bin-op-inst v _ _ _) (just v)]
    [(unary-op-inst v _ _) (just v)]))
