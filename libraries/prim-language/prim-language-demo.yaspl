#:module (prim-language-demo)
#:import {
  (bytes)
  {(color-graph)
    {#:values
      color-graph
      initial-state
    }
  }
  (dict)
  (either)
  (io)
  (list)
  {(lower-x86-64)
    {#:types
      Reg
      X8664Register
    }
    {#:values
      all-fixed-registers
      lower-function
      reg->bytes
      reg-cmp
      x86-64-register->bytes
      x86-64-register=?
    }
    {#:patterns
      fixed-reg
      temporary-reg
    }
  }
  {(lowered-live-variables)
    {#:types
      LiveOutState
    }
    {#:values
      blocks->live-out-states
      live-out-state->bytes
      live-variables
      print-blocks
      print-graph
    }
  }
  {(lowered-register-language)
    {#:types
      [FunctionDefinition l:FunctionDefinition]
    }
  }
  {(lowered-register-language-to-x86-64)
    {#:values
      assign-registers
    }
  }
  (maybe)
  (prim)
  {(prim-language)
    {#:patterns
      module
    }
  }
  {(prim-language-parser)
    {#:values
      parse-module
    }
  }
  {(prim-to-register)
    {#:values
      convert-function
    }
  }
  {(print-lowered-register-language)
    {#:values
      [print-assigned-registers-function l:print-assigned-registers-function]
      [print-function l:print-function]
    }
  }
  {(print-register-language)
    {#:values
      print-function
    }
  }
  {(register-language)
    {#:types
      [FunctionDefinition r:FunctionDefinition]
    }
  }
  (set)
  {(sexp-parser)
    {#:values
      parse-single-sexp
    }
  }
  {(simplify-lowered-register-language)
    {#:values
      [simplify-function-definition l:simplify-function-definition]
    }
  }
  {(simplify-register-language)
    {#:values
      [simplify-function-definition r:simplify-function-definition]
    }
  }
  {(spill-lowered-register-language)
    {#:values
      spill-variables
    }
  }
  (tuples)
  (yaspl var)
}
(export)
(types)

(define (handle-lowered [lowered : (l:FunctionDefinition Reg)] [stdout : OutputPort])
  : (Either (Set Var) (Dict Var X8664Register))
  (let ([live (live-variables lowered reg-cmp)])
    (begin
      (write-all-bytes (l:print-function lowered reg->bytes) stdout)
      (newline stdout)
      (write-all-bytes (print-blocks live reg->bytes) stdout)
      (newline stdout)
      (write-all-bytes (print-graph live reg-cmp reg->bytes (all-fixed-registers)) stdout)
      (newline stdout)
      (let ([live-outs (blocks->live-out-states live)])
        (begin
          (write-all-bytes
            (bytes-append
              (interleave
                (map (lambda ([los : (LiveOutState Reg)])
                       (live-out-state->bytes los reg->bytes)) live-outs)
                #"\n"))
            stdout)
          (newline stdout)
          (newline stdout)
          (color-graph (initial-state live-outs)))))))

(define (lowered-loop [lowered : (l:FunctionDefinition Reg)] [stdout : OutputPort])
  : (Tuple2 (l:FunctionDefinition Reg) (Dict Var X8664Register))
  (case (handle-lowered lowered stdout)
    [(left vs)
     (begin
       (write-all-bytes #"Spilling vertices: " stdout)
       (write-all-bytes (bytes-append (interleave (map var->bytes
                                                       (set->list vs))
                                                  #", ")) stdout)
       (newline stdout)
       (lowered-loop (spill-variables lowered vs) stdout))]
    [(right assignments)
     (tuple2 lowered assignments)]))


(define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]): Int
  (case (array->list args)
    [(empty)
     (begin
       (write-line #"No executable???" stderr)
       1)]
    [(cons _ (empty))
     (begin
       (write-line #"No file name provided." stderr)
       1)]
    [(cons _ (cons _ (empty)))
     (begin
       (write-line #"No output file name provided." stderr)
       1)]
    [(cons _ (cons _ (cons _ (cons _ _))))
     (begin
       (write-line #"Too many arguments." stderr)
       1)]
    [(cons _ (cons file-name (cons out-file-name (empty))))
     (let ([file-bytes (call-with-input-file file-name read-all-bytes)])
       (case (parse-single-sexp file-bytes)
         [(left v)
          (begin
            (write-line v stderr)
            1)]
         [(right sexp)
          (case (parse-module sexp)
            [(left v)
             (begin
               (write-line v stderr)
               1)]
            [(right (module name _ functions))
             (begin
               (for-each
                 (lambda ([f : r:FunctionDefinition])
                   (let ([f (r:simplify-function-definition f)])
                     (begin
                       (write-all-bytes (print-function f) stdout)
                       (newline stdout)
                       (let ([lowered (lower-function f)])
                         (case (lowered-loop lowered stdout)
                           [(tuple2 lowered assignments)
                            (begin
                              (write-line #"Colored graph" stdout)
                              (write-line
                                (bytes-append
                                  (interleave
                                    (dict-map
                                      assignments
                                      (lambda ([var : Var] [reg : X8664Register])
                                        (bytes-append
                                          (varargs list
                                            (var->bytes var)
                                            #" -> "
                                            (x86-64-register->bytes reg)))))
                                    #"\n"))
                                stdout)
                              (newline stdout)
                              (let ([opt-f
                                     (l:simplify-function-definition
                                       (assign-registers
                                         lowered
                                         (lambda ([r : Reg]) : X8664Register
                                           (case r
                                             [(fixed-reg r) r]
                                             [(temporary-reg v)
                                              (case (dict-ref assignments v)
                                                [(nothing) (panic #"No assignment")]
                                                [(just r) r])])))
                                       x86-64-register=?)])
                                (begin
                                  (write-line (l:print-assigned-registers-function opt-f x86-64-register->bytes)
                                              stdout)
                                  )))])))))
                 (map convert-function functions))
               0)])]))]))
