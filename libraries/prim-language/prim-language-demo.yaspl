#:module (prim-language-demo)
#:import {
  (bytes)
  {(color-graph)
    {#:values
      color-graph
      initial-state
    }
  }
  (color-lowered-register-language)
  (dict)
  (either)
  (io)
  (list)
  {(lower-x86-64)
    {#:types
      Reg
      X8664Register
    }
    {#:values
      all-fixed-registers
      lower-function
      reg->bytes
      reg-cmp
      x86-64-register->bytes
      x86-64-register=?
    }
    {#:patterns
      fixed-reg
      temporary-reg
    }
  }
  {(lowered-live-variables)
    {#:types
      LiveOutState
    }
    {#:values
      blocks->live-out-states
      live-out-state->bytes
      live-variables
      print-blocks
      print-graph
    }
  }
  {(lowered-register-language)
    {#:types
      [FunctionDefinition l:FunctionDefinition]
    }
  }
  (prim)
  {(prim-language)
    {#:types
      [FunctionDefinition p:FunctionDefinition]
    }
    {#:patterns
      module
    }
  }
  {(prim-language-parser)
    {#:values
      parse-module
    }
    {#:patterns
      parse-error
    }
  }
  {(prim-to-register)
    {#:values
      convert-function
    }
  }
  {(print-assigned-register-language)
    {#:values
      [print-function ar:print-function]
    }
  }
  {(print-lowered-register-language)
    {#:values
      [print-function l:print-function]
    }
  }
  {(print-register-language)
    {#:values
      print-function
    }
  }
  {(register-language)
    {#:types
      [FunctionDefinition r:FunctionDefinition]
    }
  }
  (set)
  {(sexp-parser)
    {#:values
      parse-single-sexp
    }
    {#:patterns
      sexp-error
    }
  }
  {(simplify-assigned-register-language)
    {#:values
      [simplify-function-definition ar:simplify-function-definition]
    }
  }
  {(simplify-register-language)
    {#:values
      [simplify-function-definition r:simplify-function-definition]
      [static-info r:static-info]
    }
  }
  {(spill-lowered-register-language)
    {#:values
      spill-variables
    }
  }
  (system-abi)
  (tuples)
  (yaspl var)
}
(export
  (#:values main))
(types)

(define (handle-lowered [name : Bytes] [lowered : (l:FunctionDefinition Reg)] [stdout : OutputPort])
  : (Either (Set Var) (Dict Var X8664Register))
  (let ([live (live-variables lowered reg-cmp)])
    (begin
      (write-all-bytes (l:print-function name lowered reg->bytes) stdout)
      (newline stdout)
      (write-all-bytes (print-blocks live reg->bytes) stdout)
      (newline stdout)
      (write-all-bytes (print-graph live reg-cmp reg->bytes (all-fixed-registers)) stdout)
      (newline stdout)
      (let ([live-outs (blocks->live-out-states live)])
        (begin
          (write-all-bytes
            (bytes-append
              (interleave
                (map (lambda ([los : (LiveOutState Reg)])
                       (live-out-state->bytes los reg->bytes)) live-outs)
                #"\n"))
            stdout)
          (newline stdout)
          (newline stdout)
          (color-graph (initial-state live-outs)))))))

(define (lowered-loop [name : Bytes] [lowered : (l:FunctionDefinition Reg)] [stdout : OutputPort])
  : (Tuple2 (l:FunctionDefinition Reg) (Dict Var X8664Register))
  (case (handle-lowered name lowered stdout)
    [(left vs)
     (begin
       (write-all-bytes #"Spilling vertices: " stdout)
       (write-all-bytes (bytes-append (interleave (map var->bytes
                                                       (set->list vs))
                                                  #", ")) stdout)
       (newline stdout)
       (lowered-loop name (spill-variables lowered vs) stdout))]
    [(right assignments)
     (tuple2 lowered assignments)]))


(define (main [args : Bytes] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]): Int
  (case (args->list args)
    [(empty)
     (begin
       (write-line #"No executable???" stderr)
       1)]
    [(cons _ (empty))
     (begin
       (write-line #"No file name provided." stderr)
       1)]
    [(cons _ (cons _ (empty)))
     (begin
       (write-line #"No output file name provided." stderr)
       1)]
    [(cons _ (cons _ (cons _ (cons _ _))))
     (begin
       (write-line #"Too many arguments." stderr)
       1)]
    [(cons _ (cons file-name (cons _out-file-name (empty))))
     (case (parse-single-sexp (sourced-bytes-from-file file-name))
       [(left (sexp-error v _))
        (begin
          (write-line v stderr)
          1)]
       [(right sexp)
        (case (parse-module sexp)
          [(left (parse-error v _))
           (begin
             (write-line v stderr)
             1)]
          [(right (module _ _ functions))
           (begin
             (for-each
               (lambda ([(tuple2 name f) : (Tuple2 Bytes r:FunctionDefinition)])
                 (let ([f (r:simplify-function-definition name f (r:static-info (make-dict bytes-cmp)))])
                   (begin
                     (write-all-bytes (print-function name f) stdout)
                     (newline stdout)
                     (let ([lowered (lower-function f)])
                       (case (lowered-loop name lowered stdout)
                         [(tuple2 lowered assignments)
                          (begin
                            (write-line #"Colored graph" stdout)
                            (write-line
                              (bytes-append
                                (interleave
                                  (dict-map
                                    assignments
                                    (lambda ([var : Var] [reg : X8664Register])
                                      (bytes-append
                                        (varargs list
                                          (var->bytes var)
                                          #" -> "
                                          (x86-64-register->bytes reg)))))
                                  #"\n"))
                              stdout)
                            (newline stdout)
                            (let ([opt-f
                                   (ar:simplify-function-definition
                                     (assign-registers
                                       lowered
                                       (lambda ([r : Reg]) : X8664Register
                                         (case r
                                           [(fixed-reg r) r]
                                           [(temporary-reg v)
                                            (dict-ref/panic assignments v) ])))
                                     x86-64-register=?)])
                              (begin
                                (write-line (ar:print-function name opt-f x86-64-register->bytes)
                                            stdout)
                                )))])))))
               (map (lambda ([f : p:FunctionDefinition]) (convert-function f (osx-abi))) functions))
             0)])])]))
