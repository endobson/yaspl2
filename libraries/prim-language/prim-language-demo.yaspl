#:module prim-language-demo
#:import {
  color-graph {
    #:values
      color-graph
      initial-state
  }
  either {
    #:patterns
      left
      right
  }
  dict {
    #:values
      dict-map
  }
  bytes {
    #:values
      bytes-append
  }
  io {
    #:values
      call-with-input-file
      newline
      read-all-bytes
      write-all-bytes
      write-line
  }
  list {
    #:values
      array->list
      for-each
      interleave
      list
      map
    #:patterns
      cons
      empty
  }
  lower-x86-64 {
    #:types
      X8664Register
    #:values
      all-fixed-registers
      lower-function
      reg->bytes
      reg=?
      x86-64-register->bytes
  }
  lowered-live-variables {
    #:values
      blocks->live-out-states
      live-variables
      print-blocks
      print-graph
  }
  prim {
    #:types
      Array
      Bytes
      InputPort
      Int
      OutputPort
    #:values
      void
  }
  prim-language {
    #:patterns
      module
  }
  prim-language-parser {
    #:values
      parse-module
  }
  prim-to-register {
    #:values
      convert-function
  }
  print-lowered-register-language {
    #:values
      [print-function l:print-function]
  }
  print-register-language {
    #:values
      print-function
  }
  register-language {
    #:types
      [FunctionDefinition r:FunctionDefinition]
      Var
    #:values
      var->bytes
  }
  sexp-parser {
    #:values
      parse-single-sexp
  }
}
(export)
(types)

(define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]): Int
  (case (array->list args)
    [(empty)
     (begin
       (write-line #"No executable???" stderr)
       1)]
    [(cons _ (empty))
     (begin
       (write-line #"No file name provided." stderr)
       1)]
    [(cons _ (cons _ (cons _ _)))
     (begin
       (write-line #"Too many arguments." stderr)
       1)]
    [(cons _ (cons file-name (empty)))
     (let ([file-bytes (call-with-input-file file-name read-all-bytes)])
       (case (parse-single-sexp file-bytes)
         [(left v)
          (begin
            (write-line v stderr)
            1)]
         [(right sexp)
          (case (parse-module sexp)
            [(left v)
             (begin
               (write-line v stderr)
               1)]
            [(right (module name functions))
             (begin
               ; (write-all-bytes #"parsed module: " stdout)
               ; (write-line name stdout)
               (for-each
                 (lambda ([f : r:FunctionDefinition])
                   (let ([lowered (lower-function f)])
                     (let ([live (live-variables lowered reg=?)])
                       (if #t
                         (begin
                           (write-all-bytes (print-function f) stdout)
                           (newline stdout)
                           (write-all-bytes (l:print-function lowered reg->bytes) stdout)
                           (newline stdout)
                           (write-all-bytes (print-blocks live reg->bytes) stdout)
                           (newline stdout)
                           (if #t
                               (let ([live-outs (blocks->live-out-states live)])
                                 (case (color-graph (initial-state live-outs))
                                   [(left v)
                                    (begin
                                      (write-all-bytes #"Couldn't color vertex: " stdout)
                                      (write-all-bytes (var->bytes v) stdout)
                                      (newline stdout))]
                                   [(right assignments)
                                    (begin
                                      (write-line #"Colored graph" stdout)
                                      (write-line
                                        (bytes-append
                                          (interleave
                                            (dict-map
                                              assignments
                                              (lambda ([var : Var] [reg : X8664Register])
                                                (bytes-append
                                                  (varargs list
                                                    (var->bytes var)
                                                    #" -> "
                                                    (x86-64-register->bytes reg)))))
                                            #"\n"))
                                        stdout))]))
                               (void)))
                         (begin
                           (write-all-bytes (print-graph live reg=? reg->bytes (all-fixed-registers)) stdout)
                           (newline stdout))))))
                 (map convert-function functions))
               0)])]))]))
