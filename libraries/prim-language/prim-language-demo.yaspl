#:module prim-language-demo
#:import {
  either {
    #:patterns
      left
      right
  }
  io {
    #:values
      call-with-input-file
      newline
      read-all-bytes
      write-all-bytes
      write-line
  }
  list {
    #:values
      array->list
      for-each
      map
    #:patterns
      cons
      empty
  }
  lower-x86-64 {
    #:values
      all-fixed-registers
      lower-function
      reg->bytes
      reg=?
  }
  lowered-live-variables {
    #:values
      live-variables
      print-blocks
      print-graph
  }
  prim {
    #:types
      Array
      Bytes
      InputPort
      Int
      OutputPort
  }
  prim-language {
    #:patterns
      module
  }
  prim-language-parser {
    #:values
      parse-module
  }
  prim-to-register {
    #:values
      convert-function
  }
  print-lowered-register-language {
    #:values
      [print-function l:print-function]
  }
  print-register-language {
    #:values
      print-function
  }
  register-language {
    #:types
      [FunctionDefinition r:FunctionDefinition]
  }
  sexp-parser {
    #:values
      parse-single-sexp
  }
}
(export)
(types)

(define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]): Int
  (case (array->list args)
    [(empty)
     (begin
       (write-line #"No executable???" stderr)
       1)]
    [(cons _ (empty))
     (begin
       (write-line #"No file name provided." stderr)
       1)]
    [(cons _ (cons _ (cons _ _)))
     (begin
       (write-line #"Too many arguments." stderr)
       1)]
    [(cons _ (cons file-name (empty)))
     (let ([file-bytes (call-with-input-file file-name read-all-bytes)])
       (case (parse-single-sexp file-bytes)
         [(left v)
          (begin
            (write-line v stderr)
            1)]
         [(right sexp)
          (case (parse-module sexp)
            [(left v)
             (begin
               (write-line v stderr)
               1)]
            [(right (module name functions))
             (begin
               ; (write-all-bytes #"parsed module: " stdout)
               ; (write-line name stdout)
               (for-each
                 (lambda ([f : r:FunctionDefinition])
                   (let ([lowered (lower-function f)])
                     (let ([live (live-variables lowered reg=?)])
                       (if #f
                         (begin
                           (write-all-bytes (print-function f) stdout)
                           (newline stdout)
                           (write-all-bytes (l:print-function lowered reg->bytes) stdout)
                           (newline stdout)
                           (write-all-bytes (print-blocks live reg->bytes) stdout)
                           (newline stdout))
                         (begin
                           (write-all-bytes (print-graph live reg=? reg->bytes (all-fixed-registers)) stdout)
                           (newline stdout))))))
                 (map convert-function functions))
               0)])]))]))
