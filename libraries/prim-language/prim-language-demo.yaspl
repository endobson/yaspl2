#:module (prim-language-demo)
#:import {
  (bytes) {
    #:values
      bytes-append
  }
  (color-graph) {
    #:values
      color-graph
      initial-state
  }
  (dict) {
    #:values
      dict-map
      dict-ref
  }
  (either) {
    #:patterns
      left
      right
  }
  (io) {
    #:values
      call-with-input-file
      newline
      read-all-bytes
      write-all-bytes
      write-line
  }
  (join-list) {
    #:values
      join-list
  }
  (list) {
    #:values
      array->list
      for-each
      interleave
      list
      map
    #:patterns
      cons
      empty
  }
  (lower-x86-64) {
    #:types
      Reg
      X8664Register
    #:values
      all-fixed-registers
      lower-function
      reg->bytes
      reg=?
      x86-64-register->bytes
      x86-64-register=?
    #:patterns
      fixed-reg
      temporary-reg
  }
  (lowered-live-variables) {
    #:values
      blocks->live-out-states
      live-variables
      print-blocks
      print-graph
  }
  (lowered-register-language) {
    #:values
      function-definition-name
      rename-registers/function-definition
  }
  (lowered-register-language-to-x86-64) {
    #:values
      function-definition->assembly-fragment
  }
  (mach-o-writer2) {
    #:values
      write-mach-o-library/fragments
  }
  (maybe) {
    #:patterns
      just
      nothing
  }
  (prim) {
    #:types
      Array
      Bytes
      InputPort
      Int
      OutputPort
    #:values
      panic
      void
  }
  (prim-language) {
    #:patterns
      module
  }
  (prim-language-parser) {
    #:values
      parse-module
  }
  (prim-to-register) {
    #:values
      convert-function
  }
  (print-lowered-register-language) {
    #:values
      [print-function l:print-function]
  }
  (print-register-language) {
    #:values
      print-function
  }
  (register-language) {
    #:types
      [FunctionDefinition r:FunctionDefinition]
      Var
    #:values
      var->bytes
  }
  (sexp-parser) {
    #:values
      parse-single-sexp
  }
  (simplify-lowered-register-language) {
    #:values
      [simplify-function-definition l:simplify-function-definition]
  }
  (simplify-register-language) {
    #:values
      [simplify-function-definition r:simplify-function-definition]
  }
  (x86-64-stack-machine) {
    #:types
      AssemblyFragment
    #:values
      basic-block
      call
      function-fragment
      imm
      jmp
      mem
      movq
      rax
      rdi
      reg
      rsp
      section
      syscall
  }
}
(export)
(types)


(define (start-function-fragment [main-function-name : Bytes]) : AssemblyFragment
  (function-fragment
    #"start"
    (varargs list
      (section
        (varargs list
          (basic-block #"start"
            (varargs join-list
              (jmp #"start_break")))
          (basic-block #"start_break"
            (varargs join-list
              (movq (mem (rsp) 0) (reg (rdi)))
              (call main-function-name)
              (movq (reg (rax)) (reg (rdi)))
              (movq (imm #x2000001) (reg (rax)))
              (syscall))))))))


(define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]): Int
  (case (array->list args)
    [(empty)
     (begin
       (write-line #"No executable???" stderr)
       1)]
    [(cons _ (empty))
     (begin
       (write-line #"No file name provided." stderr)
       1)]
    [(cons _ (cons _ (empty)))
     (begin
       (write-line #"No output file name provided." stderr)
       1)]
    [(cons _ (cons _ (cons _ (cons _ _))))
     (begin
       (write-line #"Too many arguments." stderr)
       1)]
    [(cons _ (cons file-name (cons out-file-name (empty))))
     (let ([file-bytes (call-with-input-file file-name read-all-bytes)])
       (case (parse-single-sexp file-bytes)
         [(left v)
          (begin
            (write-line v stderr)
            1)]
         [(right sexp)
          (case (parse-module sexp)
            [(left v)
             (begin
               (write-line v stderr)
               1)]
            [(right (module name functions))
             (begin
               ; (write-all-bytes #"parsed module: " stdout)
               ; (write-line name stdout)
               (for-each
                 (lambda ([f : r:FunctionDefinition])
                   (let ([f (r:simplify-function-definition f)])
                     (let ([lowered (lower-function f)])
                       (let ([live (live-variables lowered reg=?)])
                         (if #t
                           (begin
                             (write-all-bytes (print-function f) stdout)
                             (newline stdout)
                             (write-all-bytes (l:print-function lowered reg->bytes) stdout)
                             (newline stdout)
                             (write-all-bytes (print-blocks live reg->bytes) stdout)
                             (newline stdout)
                             (if #t
                                 (let ([live-outs (blocks->live-out-states live)])
                                   (case (color-graph (initial-state live-outs))
                                     [(left vs)
                                      (begin
                                        (write-all-bytes #"Couldn't color verticesx:" stdout)
                                        (newline stdout))]
                                     [(right assignments)
                                      (begin
                                        (write-line #"Colored graph" stdout)
                                        (write-line
                                          (bytes-append
                                            (interleave
                                              (dict-map
                                                assignments
                                                (lambda ([var : Var] [reg : X8664Register])
                                                  (bytes-append
                                                    (varargs list
                                                      (var->bytes var)
                                                      #" -> "
                                                      (x86-64-register->bytes reg)))))
                                              #"\n"))
                                          stdout)
                                        (let ([opt-f
                                               (l:simplify-function-definition
                                                 (rename-registers/function-definition
                                                   lowered
                                                   (lambda ([r : Reg]) : X8664Register
                                                     (case r
                                                       [(fixed-reg r) r]
                                                       [(temporary-reg v)
                                                        (case (dict-ref assignments v)
                                                          [(nothing) (panic #"No assignment")]
                                                          [(just r) r])])))
                                                 x86-64-register=?)])
                                          (begin
                                            (write-line (l:print-function opt-f x86-64-register->bytes)
                                                        stdout)
                                            (let ([fragment (function-definition->assembly-fragment
                                                              opt-f)])
                                              (case (write-mach-o-library/fragments
                                                      out-file-name
                                                      (varargs list
                                                        (start-function-fragment
                                                          (function-definition-name opt-f))
                                                        fragment))
                                                [(left v)
                                                 (begin
                                                   (write-line v stderr)
                                                   (void))]
                                                [(right _)
                                                 (void)])))))]))
                                 (void)))
                           (begin
                             (write-all-bytes (print-graph live reg=? reg->bytes (all-fixed-registers)) stdout)
                             (newline stdout)))))))
                 (map convert-function functions))
               0)])]))]))
