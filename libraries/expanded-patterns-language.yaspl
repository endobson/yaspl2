#:module (expanded-patterns-language)
#:import {
  (bytes)
  (dict)
  (list)
  (maybe)
  (module-name)
  (module-signature)
  (panic)
  (prim)
  {(resolved-vars-language)
    {#:types
      [CaseClause rv:CaseClause]
      DatatypeDefinition
      Exports
      [Expression rv:Expression]
      FunctionArg
      [FunctionDefinition rv:FunctionDefinition]
      Imports
      [Module rv:Module]
      [Pattern rv:Pattern]
      PatternExport
      TypeExport
      ValueExport
    }
    {#:values
      function-arg-name
      function-arg-type
    }
    {#:patterns
      [abstraction-pattern rv:abstraction-pattern]
      [app-expr rv:app-expr]
      [begin-expr rv:begin-expr]
      [boolean-literal rv:boolean-literal]
      [bytes-literal rv:bytes-literal]
      [bytes-pattern rv:bytes-pattern]
      [case-clause rv:case-clause]
      [case-expr rv:case-expr]
      exports
      function-arg
      [function-definition rv:function-definition]
      [global-var-expr rv:global-var-expr]
      [if-expr rv:if-expr]
      imports
      [int-literal rv:int-literal]
      [int-pattern rv:int-pattern]
      [lambda-expr rv:lambda-expr]
      [let-expr rv:let-expr]
      [local-var-expr rv:local-var-expr]
      [module rv:module]
      pattern-export
      type-export
      value-export
      [varargs-app-expr rv:varargs-app-expr]
      [variable-pattern rv:variable-pattern]
      variant-accessor
      variant-constructor
    }
  }
  (set)
  (top-level-name)
  (tuples)
  (types)
  (variant-info)
  (yaspl var)
}
(export
  (#:types DatatypeDefinition Exports Expression FunctionDefinition FunctionArg Imports Module
           PatternExport TypeExport ValueExport VariantCaseClause BytesCaseClause IntCaseClause
           DefaultCaseClause)
  (#:values expand-patterns module-definitions module-imports module-name function-arg-type
            function-arg-name)
  (#:patterns app-expr begin-expr boolean-literal bytes-literal exports
              function-definition function-arg global-var-expr if-expr imports int-literal lambda-expr let-expr
              local-var-expr module pattern-export type-export value-export varargs-app-expr
              variant-constructor variant-accessor join-point-expr join-expr halt-expr
              variant-case-expr int-case-expr bytes-case-expr int-case-clause variant-case-clause
              bytes-case-clause default-case-clause))
(types
  (define-type Module
    (module [name : ModName]
            [imports : Imports]
            [exports : Exports]
            [definitions : (List FunctionDefinition)]
            [datatype-definitions : (List DatatypeDefinition)]))

  (define-type FunctionDefinition
    (function-definition
      [function-name : TopLevelName]
      [closure-name : TopLevelName]
      [type-vars : (List Bytes)]
      [args : (List FunctionArg)]
      [return-type : Type]
      [next-var : VarNumber]
      [body : Expression]))

  (define-type Expression
    (int-literal [v : Int])
    (bytes-literal [v : Bytes])
    (boolean-literal [v : Boolean])
    (local-var-expr [v : Var])
    (global-var-expr [v : TopLevelName])
    (if-expr [cond : Expression] [true : Expression] [false : Expression])
    (begin-expr [exprs : (List Expression)] [last-expr : Expression])
    (app-expr [tail-position : Boolean] [op : Expression] [args : (List Expression)])
    (varargs-app-expr [tail-position : Boolean] [op : Expression] [args : (List Expression)])
    (let-expr [var : Var] [expr : Expression] [body : Expression])
    (lambda-expr [args : (List FunctionArg)] [type : (Maybe Type)] [body : Expression])

    (variant-case-expr
      [expr : Expression]
      [clauses : (List VariantCaseClause)]
      [default : (Maybe DefaultCaseClause)])
    (int-case-expr
      [expr : Expression]
      [clause : IntCaseClause]
      [default : DefaultCaseClause])
    (bytes-case-expr
      [expr : Expression]
      [clause : BytesCaseClause]
      [default : DefaultCaseClause])
    (join-point-expr
      [join-var : Var]
      [join-expr : Expression]
      [body : Expression])
    (join-expr [join-var : Var])
    (halt-expr))

  (define-type DefaultCaseClause
    (default-case-clause [expr : Expression]))
  (define-type VariantCaseClause
    (variant-case-clause
      [sig : PatternSignature]
      [fields : (List Var)]
      [expr : Expression]))
  (define-type IntCaseClause
    (int-case-clause [val : Int] [expr : Expression]))
  (define-type BytesCaseClause
    (bytes-case-clause [val : Bytes] [expr : Expression]))

  (define-type State
    (state
      [next-var : VarNumber]))
  (define-type PatternRow
    (pattern-row [pats : (List rv:Pattern)] [expr : Expression]))

  (define-type SplitMatrix
    (abstraction-matrix
      [rows : (List (Tuple2 PatternSignature PatternRow))])
    (abstraction-split-matrix
      [top : (List (Tuple2 PatternSignature PatternRow))]
      [bottom : (List PatternRow)])
    (variable-matrix
      [rows : (List (Tuple2 Var PatternRow))])
    (variable-split-matrix
      [top : (List (Tuple2 Var PatternRow))]
      [bottom : (List PatternRow)])
    (int-split-matrix
      [v : Int]
      [top : PatternRow]
      [bottom : (List PatternRow)])
    (bytes-split-matrix
      [v : Bytes]
      [top : PatternRow]
      [bottom : (List PatternRow)])))

(define (expand-patterns [mod : rv:Module]) : Module
  (case mod
    [(rv:module name imports exports funcs datatype-defs)
     (module name imports exports (map expand-patterns/function-definition funcs) datatype-defs)]))

(define (expand-patterns/function-definition [fun : rv:FunctionDefinition]) : FunctionDefinition
  (case fun
    [(rv:function-definition function-name closure-name type-vars args return-type next-var body)
     (match-define state (state next-var))
     (match-define (tuple2 body (state next-var)) (expand-patterns/expression body state))
     (function-definition function-name closure-name type-vars args return-type next-var body)]))

(define (expand-patterns/expression [expr : rv:Expression] [state : State])
  : (Tuple2 Expression State)
  (case expr
    [(rv:case-expr expr clauses)
     (match-define (tuple2 expr state) (expand-patterns/expression expr state))
     (match-define (tuple2 expr-var state) (fresh-var #"case-val" state))
     (match-define (tuple2 pattern-rows state) (case-clauses->pattern-rows clauses state))
     (match-define (tuple2 fail-var state) (fresh-var #"fail" state))
     (match-define (tuple2 body state)
       (expand-patterns/matrix
         (varargs list expr-var)
         pattern-rows
         fail-var
         state))
     (tuple2 (join-point-expr fail-var (halt-expr) (let-expr expr-var expr body)) state)]
    ;; Recur structurally
    [(rv:int-literal v)
     (tuple2 (int-literal v) state)]
    [(rv:bytes-literal v)
     (tuple2 (bytes-literal v) state)]
    [(rv:boolean-literal v)
     (tuple2 (boolean-literal v) state)]
    [(rv:local-var-expr v)
     (tuple2 (local-var-expr v) state)]
    [(rv:global-var-expr v)
     (tuple2 (global-var-expr v) state)]
    [(rv:if-expr c t f )
     (match-define (tuple2 c state) (expand-patterns/expression c state))
     (match-define (tuple2 t state) (expand-patterns/expression t state))
     (match-define (tuple2 f state) (expand-patterns/expression f state))
     (tuple2 (if-expr c t f) state)]
    [(rv:begin-expr exprs last)
     (match-define (tuple2 exprs state) (expand-patterns/expressions exprs state))
     (match-define (tuple2 last state) (expand-patterns/expression last state))
     (tuple2 (begin-expr exprs last) state)]
    [(rv:app-expr tail op args)
     (match-define (tuple2 op state) (expand-patterns/expression op state))
     (match-define (tuple2 args state) (expand-patterns/expressions args state))
     (tuple2 (app-expr tail op args) state)]
    [(rv:varargs-app-expr tail op args)
     (match-define (tuple2 op state) (expand-patterns/expression op state))
     (match-define (tuple2 args state) (expand-patterns/expressions args state))
     (tuple2 (varargs-app-expr tail op args) state)]
    [(rv:let-expr name expr body)
     (match-define (tuple2 expr state) (expand-patterns/expression expr state))
     (match-define (tuple2 body state) (expand-patterns/expression body state))
     (tuple2 (let-expr name expr body) state)]
    [(rv:lambda-expr args type body)
     (match-define (tuple2 body state) (expand-patterns/expression body state))
     (tuple2 (lambda-expr args type body) state)]))


(define (expand-patterns/expressions [es : (List rv:Expression)] [state : State])
  : (Tuple2 (List Expression) State)
  (case es
    [(empty) (tuple2 (empty) state)]
    [(cons e es)
     (match-define (tuple2 e state) (expand-patterns/expression e state))
     (match-define (tuple2 es state) (expand-patterns/expressions es state))
     (tuple2 (cons e es) state)]))

(define (case-clauses->pattern-rows [cs : (List rv:CaseClause)] [state : State])
  : (Tuple2 (List PatternRow) State)
  (case cs
    [(empty)
     (tuple2 (empty) state)]
    [(cons (rv:case-clause pattern expr) cs)
     (match-define (tuple2 expr state) (expand-patterns/expression expr state))
     (match-define (tuple2 rows state) (case-clauses->pattern-rows cs state))
     (tuple2
       (cons (pattern-row (varargs list pattern) expr) rows)
       state)]))

(define (expand-patterns/matrix
          [vars : (List Var)]
          [rows : (List PatternRow)]
          [fail-var : Var]
          [state : State])
  : (Tuple2 Expression State)
  (case rows
    [(empty)
     (tuple2 (join-expr fail-var) state)]
    [(cons (pattern-row (empty) succ-expr) _)
     (tuple2 succ-expr state)]
    [(cons top-row other-rows)
     (match-define (tuple2 first-var other-vars) : (Tuple2 Var (List Var))
       (case vars
         [(cons first-var other-vars)
          (tuple2 first-var other-vars)]
         [_ (panic #"Bad matrix")]))

     (case (split-matrix top-row other-rows)
       [(abstraction-matrix rows)
        (expand-patterns/abstraction-matrix first-var other-vars rows fail-var state)]
       [(variable-matrix rows)
        (expand-patterns/variable-matrix first-var other-vars rows fail-var state)]
       [(abstraction-split-matrix top-rows bottom-rows)
        (match-define (tuple2 inner-fail state) (fresh-var #"fail" state))
        (match-define (tuple2 top-cases state)
          (expand-patterns/abstraction-matrix first-var other-vars top-rows inner-fail state))
        (match-define (tuple2 bottom-cases state)
          (expand-patterns/matrix vars bottom-rows fail-var state))
        (tuple2
          (join-point-expr inner-fail bottom-cases top-cases)
          state)]
       [(variable-split-matrix top-rows bottom-rows)
        (match-define (tuple2 inner-fail state) (fresh-var #"fail" state))
        (match-define (tuple2 top-cases state)
          (expand-patterns/variable-matrix first-var other-vars top-rows inner-fail state))
        (match-define (tuple2 bottom-cases state)
          (expand-patterns/matrix vars bottom-rows fail-var state))
        (tuple2
          (join-point-expr inner-fail bottom-cases top-cases)
          state)]
       [(int-split-matrix val top-row bottom-rows)
        (match-define (tuple2 inner-fail state) (fresh-var #"fail" state))
        (match-define (tuple2 top-case state)
          (expand-patterns/matrix other-vars (varargs list top-row) inner-fail state))
        (match-define (tuple2 bottom-cases state)
          (expand-patterns/matrix vars bottom-rows fail-var state))
        (tuple2
          (join-point-expr inner-fail
            bottom-cases
            (int-case-expr (local-var-expr first-var)
              (int-case-clause val top-case)
              (default-case-clause (join-expr inner-fail))))
          state)]
       [(bytes-split-matrix val top-row bottom-rows)
        (match-define (tuple2 inner-fail state) (fresh-var #"fail" state))
        (match-define (tuple2 top-case state)
          (expand-patterns/matrix other-vars (varargs list top-row) inner-fail state))
        (match-define (tuple2 bottom-cases state)
          (expand-patterns/matrix vars bottom-rows fail-var state))
        (tuple2
          (join-point-expr inner-fail
            bottom-cases
            (bytes-case-expr (local-var-expr first-var)
              (bytes-case-clause val top-case)
              (default-case-clause (join-expr inner-fail))))
          state)])]))

(define (expand-patterns/abstraction-matrix
          [first-var : Var]
          [other-vars : (List Var)]
          [rows : (List (Tuple2 PatternSignature PatternRow))]
          [fail-var : Var]
          [state : State])
  : (Tuple2 Expression State)
  (match-define grouped-rows (group-rows rows))
  (match-define (tuple2 clauses state)
    (all-grouped-rows->variant-case-clauses other-vars fail-var grouped-rows state))
  (match-define all-variants-covered
    (all-variants-covered? (map (lambda ([t : (Tuple2 PatternSignature (List PatternRow))])
                                  (case t [(tuple2 sig _) sig])) grouped-rows)))
  (tuple2
    (variant-case-expr
      (local-var-expr first-var)
      clauses
      (if all-variants-covered
          (nothing)
          (just (default-case-clause (join-expr fail-var)))))
    state))

(define (expand-patterns/variable-matrix
          [first-var : Var]
          [other-vars : (List Var)]
          [rows : (List (Tuple2 Var PatternRow))]
          [fail-var : Var]
          [state : State])
  : (Tuple2 Expression State)
  (expand-patterns/matrix
    other-vars
    (map
      (lambda ([row : (Tuple2 Var PatternRow)])
        (case row
          [(tuple2 inner-var (pattern-row pats succ))
           (pattern-row pats (let-expr inner-var (local-var-expr first-var) succ))]))
      rows)
    fail-var
    state))

(define (split-matrix [top-row : PatternRow] [rows : (List PatternRow)])
  : SplitMatrix
  (case top-row
    [(pattern-row (empty) _) (panic #"No columns")]
    [(pattern-row (cons (rv:abstraction-pattern sig sub-pats) pats) succ)
     (split-matrix/abstraction-prefix
       rows
       (varargs list (tuple2 sig (pattern-row (append sub-pats pats) succ))))]
    [(pattern-row (cons (rv:variable-pattern var) pats) succ)
     (split-matrix/variable-prefix
       rows
       (varargs list (tuple2 var (pattern-row pats succ))))]
    [(pattern-row (cons (rv:int-pattern val) pats) succ)
     (int-split-matrix val (pattern-row pats succ) rows)]
    [(pattern-row (cons (rv:bytes-pattern val) pats) succ)
     (bytes-split-matrix val (pattern-row pats succ) rows)]))

(define (split-matrix/abstraction-prefix
          [rows : (List PatternRow)]
          [acc : (List (Tuple2 PatternSignature PatternRow))])
  : SplitMatrix
  (case rows
    [(empty)
     (abstraction-matrix (reverse acc))]
    [(cons
       (pattern-row (cons (rv:abstraction-pattern sig sub-pats) pats) succ)
       rows)
     (split-matrix/abstraction-prefix
       rows
       (cons (tuple2 sig (pattern-row (append sub-pats pats) succ)) acc))]
    [rows
     (abstraction-split-matrix (reverse acc) rows)]))

(define (split-matrix/variable-prefix
          [rows : (List PatternRow)]
          [acc : (List (Tuple2 Var PatternRow))])
  : SplitMatrix
  (case rows
    [(empty)
     (variable-matrix (reverse acc))]
    [(cons
       (pattern-row (cons (rv:variable-pattern var) pats) succ)
       rows)
     (split-matrix/variable-prefix
       rows
       (cons
         (tuple2 var (pattern-row pats succ))
         acc))]
    [rows
     (variable-split-matrix (reverse acc) rows)]))

(define (group-rows [rows : (List (Tuple2 PatternSignature PatternRow))])
  : (List (Tuple2 PatternSignature (List PatternRow)))
  (group-rows* (reverse rows) (make-dict bytes-cmp)))

(define (group-rows* [rows : (List (Tuple2 PatternSignature PatternRow))]
                     [acc : (Dict Bytes (Tuple2 PatternSignature (List PatternRow)))])
  : (List (Tuple2 PatternSignature (List PatternRow)))
  (case rows
    [(empty)
     (dict-values acc)]
    [(cons (tuple2 sig pat-row) rows)
     (match-define (pattern-signature (variant-info variant-name _ _) _ _ _ _ _) sig)
     (group-rows*
       rows
       (dict-update
         acc
         variant-name
         (lambda ([v : (Tuple2 PatternSignature (List PatternRow))])
           (case v
             [(tuple2 sig pat-rows)
              (tuple2 sig (cons pat-row pat-rows))]))
         (tuple2 sig (empty))))]))

(define (all-grouped-rows->variant-case-clauses
          [vars : (List Var)]
          [fail-var : Var]
          [grouped-rows : (List (Tuple2 PatternSignature (List PatternRow)))]
          [state : State])
  : (Tuple2 (List VariantCaseClause) State)
  (case grouped-rows
    [(empty)
     (tuple2 (empty) state)]
    [(cons rows other-grouped-rows)
     (match-define (tuple2 clause state)
       (grouped-rows->variant-case-clause vars fail-var rows state))
     (match-define (tuple2 clauses state)
       (all-grouped-rows->variant-case-clauses vars fail-var other-grouped-rows state))
     (tuple2 (cons clause clauses) state)]))

(define (grouped-rows->variant-case-clause
          [vars : (List Var)]
          [fail-var : Var]
          [grouped-rows : (Tuple2 PatternSignature (List PatternRow))]
          [state : State])
  : (Tuple2 VariantCaseClause State)
  (case grouped-rows
    [(tuple2 sig rows)
     (match-define (pattern-signature _ _ _ _ fields _) sig)
     (match-define (tuple2 field-vars state) (fresh-field-vars fields state))
     (match-define (tuple2 expr state)
       (expand-patterns/matrix (append field-vars vars) rows fail-var state))
     (tuple2 (variant-case-clause sig field-vars expr) state)]))

(define (all-variants-covered? [sigs : (List PatternSignature)]) : Boolean
  (case sigs
    [(empty)
     (panic/boolean #"Cannot try to cover with no rows")]
    [(cons (pattern-signature _ _ _ _ _ (type-signature all-variants)) _)
     (set=?
       (set-add-all
         (make-set bytes-cmp)
         (map (lambda ([sig : PatternSignature])
                (match-define (pattern-signature (variant-info name _ _) _ _ _ _ _) sig)
                name)
              sigs))
       (set-add-all (make-set bytes-cmp) all-variants))]))

(define (fresh-var [base : Bytes] [s : State]) : (Tuple2 Var State)
  (case s
    [(state counter)
     (tuple2 (var base counter) (state (next-var-number counter)))]))

(define (fresh-field-vars [ts : (List Type)] [state : State]) : (Tuple2 (List Var) State)
  (case ts
    [(empty) (tuple2 (empty) state)]
    [(cons _t ts)
     (match-define (tuple2 var state) (fresh-var #"field" state))
     (match-define (tuple2 vars state) (fresh-field-vars ts state))
     (tuple2 (cons var vars) state)]))
