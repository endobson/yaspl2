#:module (expanded-patterns-language)
#:import {
  (bytes)
  (dict)
  (list)
  (maybe)
  (module-name)
  (module-signature)
  (panic)
  (prim)
  {(resolved-vars-language)
    {#:types
      [CaseClause rv:CaseClause]
      Exports
      [Expression rv:Expression]
      [FunctionDefinition rv:FunctionDefinition]
      Imports
      [Module rv:Module]
      [Pattern rv:Pattern]
      PatternExport
      TypeExport
      ValueExport
    }
    {#:patterns
      [abstraction-pattern rv:abstraction-pattern]
      [annotated-expr rv:annotated-expr]
      [app-expr rv:app-expr]
      [begin-expr rv:begin-expr]
      [boolean-literal rv:boolean-literal]
      [bytes-literal rv:bytes-literal]
      [bytes-pattern rv:bytes-pattern]
      [case-clause rv:case-clause]
      [case-expr rv:case-expr]
      exports
      [function-definition rv:function-definition]
      [global-var-expr rv:global-var-expr]
      [if-expr rv:if-expr]
      imports
      [int-literal rv:int-literal]
      [int-pattern rv:int-pattern]
      [lambda-expr rv:lambda-expr]
      [let-expr rv:let-expr]
      [local-var-expr rv:local-var-expr]
      [module rv:module]
      pattern-export
      type-export
      value-export
      [varargs-app-expr rv:varargs-app-expr]
      [variable-pattern rv:variable-pattern]
      [variant-accessor rv:variant-accessor]
      [variant-constructor rv:variant-constructor]
    }
  }
  (set)
  (top-level-name)
  (tuples)
  (types)
  (yaspl var)
}
(export
  (#:types Exports Expression FunctionDefinition Imports Module PatternExport
           TypeExport ValueExport VariantCaseClause BytesCaseClause IntCaseClause
           DefaultCaseClause)
  (#:values expand-patterns module-definitions module-imports module-name)
  (#:patterns annotated-expr app-expr begin-expr boolean-literal bytes-literal exports
              function-definition global-var-expr if-expr imports int-literal lambda-expr let-expr
              local-var-expr module pattern-export type-export value-export varargs-app-expr
              variant-constructor variant-accessor join-point-expr join-expr halt-expr
              variant-case-expr int-case-expr bytes-case-expr int-case-clause variant-case-clause
              bytes-case-clause default-case-clause))
(types
  (define-type Module
    (module [name : ModName]
            [imports : Imports]
            [exports : Exports]
            [definitions : (List FunctionDefinition)]))

  (define-type FunctionDefinition
    (function-definition [name : Bytes]
                         [type-vars : (List Bytes)]
                         [args : (List (Tuple2 Var Type))]
                         [return-type : Type]
                         [next-var : VarNumber]
                         [body : Expression])
    (variant-constructor
      [name : Bytes]
      ;; TODO include something more useful than field names here
      [fields : (List Bytes)]
      [tag : U8])
    (variant-accessor
      [name : Bytes]
      [field-offset : Int]))

  (define-type Expression
    (int-literal [v : Int])
    (bytes-literal [v : Bytes])
    (boolean-literal [v : Boolean])
    (local-var-expr [v : Var])
    (global-var-expr [v : TopLevelName])
    (annotated-expr [t : Type] [e : Expression])
    (if-expr [cond : Expression] [true : Expression] [false : Expression])
    (begin-expr [exprs : (List Expression)] [last-expr : Expression])
    (app-expr [tail-position : Boolean] [op : Expression] [args : (List Expression)])
    (varargs-app-expr [tail-position : Boolean] [op : Expression] [args : (List Expression)])
    (let-expr [var : Var] [expr : Expression] [body : Expression])
    (lambda-expr [args : (List (Tuple2 Var Type))] [type : (Maybe Type)] [body : Expression])

    (variant-case-expr
      [expr : Expression]
      [clause : (List VariantCaseClause)]
      [default : (Maybe DefaultCaseClause)])
    (int-case-expr
      [expr : Expression]
      [clause : IntCaseClause]
      [default : DefaultCaseClause])
    (bytes-case-expr
      [expr : Expression]
      [clause : BytesCaseClause]
      [default : DefaultCaseClause])
    (join-point-expr
      [join-var : Var]
      [join-expr : Expression]
      [body : Expression])
    (join-expr [join-var : Var])
    (halt-expr))

  (define-type DefaultCaseClause
    (default-case-clause [expr : Expression]))
  (define-type VariantCaseClause
    (variant-case-clause
      [sig : PatternSignature]
      [fields : (List Var)]
      [expr : Expression]))
  (define-type IntCaseClause
    (int-case-clause [val : Int] [expr : Expression]))
  (define-type BytesCaseClause
    (bytes-case-clause [val : Bytes] [expr : Expression]))

  (define-type State
    (state
      [next-var : VarNumber]))
  (define-type PatternRow
    (pattern-row [pats : (List rv:Pattern)] [expr : Expression]))
  (define-type AbstractionPattern
    (abstraction-pattern [sig : PatternSignature] [sub-patterns : (List rv:Pattern)]))

  (define-type SplitMatrix
    (abstraction-matrix
      [rows : (List (Tuple2 AbstractionPattern PatternRow))])
    (abstraction-split-matrix
      [top : (List (Tuple2 AbstractionPattern PatternRow))]
      [bottom : (List PatternRow)])
    (variable-matrix
      [rows : (List (Tuple2 Var PatternRow))])
    (variable-split-matrix
      [top : (List (Tuple2 Var PatternRow))]
      [bottom : (List PatternRow)])
    (single-row-split-matrix
      [top : PatternRow]
      [bottom : (List PatternRow)])))

(define (expand-patterns [mod : rv:Module]) : Module
  (case mod
    [(rv:module name imports exports funcs)
     (module name imports exports (map expand-patterns/function-definition funcs))]))

(define (expand-patterns/function-definition [fun : rv:FunctionDefinition]) : FunctionDefinition
  (case fun
    [(rv:variant-constructor name fields tag)
     (variant-constructor name fields tag)]
    [(rv:variant-accessor name offset)
     (variant-accessor name offset)]
    [(rv:function-definition name type-vars args return-type next-var body)
     (match-define state (state next-var))
     (match-define (tuple2 body (state next-var)) (expand-patterns/expression body state))
     (function-definition name type-vars args return-type next-var body)]))

(define (expand-patterns/expression [expr : rv:Expression] [state : State])
  : (Tuple2 Expression State)
  (case expr
    [(rv:case-expr expr clauses)
     (match-define (tuple2 expr state) (expand-patterns/expression expr state))
     (match-define (tuple2 expr-var state) (fresh-var #"case-val" state))
     (match-define (tuple2 pattern-rows state) (case-clauses->pattern-rows clauses state))
     (match-define (tuple2 fail-var state) (fresh-var #"fail" state))
     (match-define (tuple2 body state)
       (expand-patterns/matrix
         (varargs list expr-var)
         pattern-rows
         fail-var
         state))
     (tuple2 (join-point-expr fail-var (halt-expr) (let-expr expr-var expr body)) state)]
    ;; Recur structurally
    [(rv:int-literal v)
     (tuple2 (int-literal v) state)]
    [(rv:bytes-literal v)
     (tuple2 (bytes-literal v) state)]
    [(rv:boolean-literal v)
     (tuple2 (boolean-literal v) state)]
    [(rv:local-var-expr v)
     (tuple2 (local-var-expr v) state)]
    [(rv:global-var-expr v)
     (tuple2 (global-var-expr v) state)]
    [(rv:annotated-expr t e)
     (match-define (tuple2 e state) (expand-patterns/expression e state))
     (tuple2 (annotated-expr t e) state)]
    [(rv:if-expr c t f )
     (match-define (tuple2 c state) (expand-patterns/expression c state))
     (match-define (tuple2 t state) (expand-patterns/expression t state))
     (match-define (tuple2 f state) (expand-patterns/expression f state))
     (tuple2 (if-expr c t f) state)]
    [(rv:begin-expr exprs last)
     (match-define (tuple2 exprs state) (expand-patterns/expressions exprs state))
     (match-define (tuple2 last state) (expand-patterns/expression last state))
     (tuple2 (begin-expr exprs last) state)]
    [(rv:app-expr tail op args)
     (match-define (tuple2 op state) (expand-patterns/expression op state))
     (match-define (tuple2 args state) (expand-patterns/expressions args state))
     (tuple2 (app-expr tail op args) state)]
    [(rv:varargs-app-expr tail op args)
     (match-define (tuple2 op state) (expand-patterns/expression op state))
     (match-define (tuple2 args state) (expand-patterns/expressions args state))
     (tuple2 (varargs-app-expr tail op args) state)]
    [(rv:let-expr name expr body)
     (match-define (tuple2 expr state) (expand-patterns/expression expr state))
     (match-define (tuple2 body state) (expand-patterns/expression body state))
     (tuple2 (let-expr name expr body) state)]
    [(rv:lambda-expr args type body)
     (match-define (tuple2 body state) (expand-patterns/expression body state))
     (tuple2 (lambda-expr args type body) state)]))


(define (expand-patterns/expressions [es : (List rv:Expression)] [state : State])
  : (Tuple2 (List Expression) State)
  (case es
    [(empty) (tuple2 (empty) state)]
    [(cons e es)
     (match-define (tuple2 e state) (expand-patterns/expression e state))
     (match-define (tuple2 es state) (expand-patterns/expressions es state))
     (tuple2 (cons e es) state)]))

(define (case-clauses->pattern-rows [cs : (List rv:CaseClause)] [state : State])
  : (Tuple2 (List PatternRow) State)
  (case cs
    [(empty)
     (tuple2 (empty) state)]
    [(cons (rv:case-clause pattern expr) cs)
     (match-define (tuple2 expr state) (expand-patterns/expression expr state))
     (match-define (tuple2 rows state) (case-clauses->pattern-rows cs state))
     (tuple2
       (cons (pattern-row (varargs list pattern) expr) rows)
       state)]))

(define (expand-patterns/pattern/simple
          [v : Var] [pat : rv:Pattern] [fail-var : Var] [succ : Expression] [state : State])
  : (Tuple2 Expression State)
  (case pat
    [(rv:variable-pattern pat-v)
     (tuple2 (let-expr pat-v (local-var-expr v) succ)
             state)]
    [(rv:bytes-pattern val)
     (tuple2
       (bytes-case-expr (local-var-expr v)
          (bytes-case-clause val succ)
          (default-case-clause (join-expr fail-var)))
       state)]
    [(rv:int-pattern val)
     (tuple2
       (int-case-expr (local-var-expr v)
          (int-case-clause val succ)
          (default-case-clause (join-expr fail-var)))
       state)]
    [(rv:abstraction-pattern sig pats)
     (match-define (tuple2 annotated-pats state) (fresh-sub-pattern-vars pats state))
     (match-define new-vars (map (lambda ([t : (Tuple2 Var rv:Pattern)])
                                   (case t [(tuple2 v _ ) v])) annotated-pats))
     (match-define (tuple2 succ state)
       (expand-patterns/patterns/simple annotated-pats fail-var succ state))
     (tuple2
       (variant-case-expr (local-var-expr v)
         (varargs list (variant-case-clause sig new-vars succ))
         (just (default-case-clause (join-expr fail-var))))
       state)]))

(define (expand-patterns/patterns/simple
          [ann-pats : (List (Tuple2 Var rv:Pattern))] [fail-var : Var] [succ : Expression] [state : State])
  : (Tuple2 Expression State)
  (case ann-pats
    [(empty) (tuple2 succ state)]
    [(cons (tuple2 v pat) ann-pats)
     (match-define (tuple2 succ state) (expand-patterns/patterns/simple ann-pats fail-var succ state))
     (expand-patterns/pattern/simple v pat fail-var succ state)]))

(define (expand-patterns/matrix
          [vars : (List Var)]
          [rows : (List PatternRow)]
          [fail-var : Var]
          [state : State])
  : (Tuple2 Expression State)
  (case rows
    [(empty)
     (tuple2 (join-expr fail-var) state)]
    [(cons (pattern-row (empty) succ-expr) _)
     (tuple2 succ-expr state)]
    [(cons top-row other-rows)
     (match-define (tuple2 first-var other-vars) : (Tuple2 Var (List Var))
       (case vars
         [(cons first-var other-vars)
          (tuple2 first-var other-vars)]
         [_ (panic #"Bad matrix")]))

     (case (split-matrix top-row other-rows)
       [(abstraction-matrix rows)
        (expand-patterns/abstraction-matrix first-var other-vars rows fail-var state)]
       [(variable-matrix rows)
        (expand-patterns/variable-matrix first-var other-vars rows fail-var state)]
       [(abstraction-split-matrix top-rows bottom-rows)
        (match-define (tuple2 inner-fail state) (fresh-var #"fail" state))
        (match-define (tuple2 top-cases state)
          (expand-patterns/abstraction-matrix first-var other-vars top-rows inner-fail state))
        (match-define (tuple2 bottom-cases state)
          (expand-patterns/matrix vars bottom-rows fail-var state))
        (tuple2
          (join-point-expr inner-fail bottom-cases top-cases)
          state)]
       [(variable-split-matrix top-rows bottom-rows)
        (match-define (tuple2 inner-fail state) (fresh-var #"fail" state))
        (match-define (tuple2 top-cases state)
          (expand-patterns/variable-matrix first-var other-vars top-rows inner-fail state))
        (match-define (tuple2 bottom-cases state)
          (expand-patterns/matrix vars bottom-rows fail-var state))
        (tuple2
          (join-point-expr inner-fail bottom-cases top-cases)
          state)]
       [(single-row-split-matrix top-row other-rows)
        (expand-pattern/split-top-row-matrix vars top-row other-rows fail-var state)])]))

(define (expand-patterns/abstraction-matrix
          [first-var : Var]
          [other-vars : (List Var)]
          [rows : (List (Tuple2 AbstractionPattern PatternRow))]
          [fail-var : Var]
          [state : State])
  : (Tuple2 Expression State)
  (match-define grouped-rows (group-rows rows))
  (match-define (tuple2 clauses state)
    (all-grouped-rows->variant-case-clauses other-vars fail-var grouped-rows state))
  (match-define all-variants-covered
    (all-variants-covered? (map (lambda ([t : (Tuple2 PatternSignature (List PatternRow))])
                                  (case t [(tuple2 sig _) sig])) grouped-rows)))
  (tuple2
    (variant-case-expr
      (local-var-expr first-var)
      clauses
      (if all-variants-covered
          (nothing)
          (just (default-case-clause (join-expr fail-var)))))
    state))

(define (expand-patterns/variable-matrix
          [first-var : Var]
          [other-vars : (List Var)]
          [rows : (List (Tuple2 Var PatternRow))]
          [fail-var : Var]
          [state : State])
  : (Tuple2 Expression State)
  (expand-patterns/matrix
    other-vars
    (map
      (lambda ([row : (Tuple2 Var PatternRow)])
        (case row
          [(tuple2 inner-var (pattern-row pats succ))
           (pattern-row pats (let-expr inner-var (local-var-expr first-var) succ))]))
      rows)
    fail-var
    state))

(define (split-matrix [top-row : PatternRow] [rows : (List PatternRow)])
  : SplitMatrix
  (case top-row
    [(pattern-row (empty) _) (panic #"No columns")]
    [(pattern-row (cons (rv:abstraction-pattern sig sub-pats) pats) succ)
     (split-matrix/abstraction-prefix
       rows
       (varargs list (tuple2 (abstraction-pattern sig sub-pats) (pattern-row pats succ))))]
    [(pattern-row (cons (rv:variable-pattern var) pats) succ)
     (split-matrix/variable-prefix
       rows
       (varargs list (tuple2 var (pattern-row pats succ))))]
    [_
     (single-row-split-matrix top-row rows)]))

(define (split-matrix/abstraction-prefix
          [rows : (List PatternRow)]
          [acc : (List (Tuple2 AbstractionPattern PatternRow))])
  : SplitMatrix
  (case rows
    [(empty)
     (abstraction-matrix (reverse acc))]
    [(cons
       (pattern-row (cons (rv:abstraction-pattern sig sub-pats) pats) succ)
       rows)
     (split-matrix/abstraction-prefix
       rows
       (cons
         (tuple2 (abstraction-pattern sig sub-pats) (pattern-row pats succ))
         acc))]
    [rows
     (abstraction-split-matrix (reverse acc) rows)]))

(define (split-matrix/variable-prefix
          [rows : (List PatternRow)]
          [acc : (List (Tuple2 Var PatternRow))])
  : SplitMatrix
  (case rows
    [(empty)
     (variable-matrix (reverse acc))]
    [(cons
       (pattern-row (cons (rv:variable-pattern var) pats) succ)
       rows)
     (split-matrix/variable-prefix
       rows
       (cons
         (tuple2 var (pattern-row pats succ))
         acc))]
    [rows
     (variable-split-matrix (reverse acc) rows)]))

(define (group-rows [rows : (List (Tuple2 AbstractionPattern PatternRow))])
  : (List (Tuple2 PatternSignature (List PatternRow)))
  (group-rows* (reverse rows) (make-dict bytes-cmp)))

(define (group-rows* [rows : (List (Tuple2 AbstractionPattern PatternRow))]
                     [acc : (Dict Bytes (Tuple2 PatternSignature (List PatternRow)))])
  : (List (Tuple2 PatternSignature (List PatternRow)))
  (case rows
    [(empty)
     (dict-values acc)]
    [(cons (tuple2 (abstraction-pattern sig sub-patterns) (pattern-row pats succ)) rows)
     (match-define (pattern-signature variant-name _ _ _ _ _ _) sig)
     (group-rows*
       rows
       (dict-update
         acc
         variant-name
         (lambda ([v : (Tuple2 PatternSignature (List PatternRow))])
           (case v
             [(tuple2 sig pat-rows)
              (tuple2 sig (cons (pattern-row (append sub-patterns pats) succ) pat-rows))]))
         (tuple2 sig (empty))))]))

(define (all-grouped-rows->variant-case-clauses
          [vars : (List Var)]
          [fail-var : Var]
          [grouped-rows : (List (Tuple2 PatternSignature (List PatternRow)))]
          [state : State])
  : (Tuple2 (List VariantCaseClause) State)
  (case grouped-rows
    [(empty)
     (tuple2 (empty) state)]
    [(cons rows other-grouped-rows)
     (match-define (tuple2 clause state)
       (grouped-rows->variant-case-clause vars fail-var rows state))
     (match-define (tuple2 clauses state)
       (all-grouped-rows->variant-case-clauses vars fail-var other-grouped-rows state))
     (tuple2 (cons clause clauses) state)]))

(define (grouped-rows->variant-case-clause
          [vars : (List Var)]
          [fail-var : Var]
          [grouped-rows : (Tuple2 PatternSignature (List PatternRow))]
          [state : State])
  : (Tuple2 VariantCaseClause State)
  (case grouped-rows
    [(tuple2 sig rows)
     (match-define (pattern-signature variant-name tag _ _ _ fields _) sig)
     (match-define (tuple2 field-vars state) (fresh-field-vars fields state))
     (match-define (tuple2 expr state)
       (expand-patterns/matrix (append field-vars vars) rows fail-var state))
     (tuple2 (variant-case-clause sig field-vars expr) state)]))

(define (all-variants-covered? [sigs : (List PatternSignature)]) : Boolean
  (case sigs
    [(empty)
     (panic/boolean #"Cannot try to cover with no rows")]
    [(cons (pattern-signature _ _ _ _ _ _ (type-signature all-variants)) _)
     (set=?
       (set-add-all (make-set bytes-cmp) (map pattern-signature-variant-name sigs))
       (set-add-all (make-set bytes-cmp) all-variants))]))

(define (expand-pattern/split-top-row-matrix
          [vars : (List Var)]
          [row : PatternRow]
          [other-rows : (List PatternRow)]
          [fail-var : Var]
          [state : State])
  : (Tuple2 Expression State)
 (match-define (pattern-row pats succ-expr) row)
 (match-define ann-pats : (List (Tuple2 Var rv:Pattern))
   (case (zip vars pats)
     [(nothing) (panic #"Bad pattern matrix")]
     [(just v) v]))
 (match-define (tuple2 new-fail-var state) (fresh-var #"fail" state))
 (match-define (tuple2 first-row-expr state)
   (expand-patterns/patterns/simple ann-pats new-fail-var succ-expr state))
 (match-define (tuple2 other-rows-expr state)
   (expand-patterns/matrix vars other-rows fail-var state))
 (tuple2
   (join-point-expr new-fail-var other-rows-expr first-row-expr)
   state))

(define (fresh-var [base : Bytes] [s : State]) : (Tuple2 Var State)
  (case s
    [(state counter)
     (tuple2 (var base counter) (state (next-var-number counter)))]))

(define (fresh-field-vars [ts : (List Type)] [state : State]) : (Tuple2 (List Var) State)
  (case ts
    [(empty) (tuple2 (empty) state)]
    [(cons t ts)
     (match-define (tuple2 var state) (fresh-var #"field" state))
     (match-define (tuple2 vars state) (fresh-field-vars ts state))
     (tuple2 (cons var vars) state)]))

(define (fresh-sub-pattern-vars [pats : (List rv:Pattern)] [state : State])
  : (Tuple2 (List (Tuple2 Var rv:Pattern)) State)
  (case pats
    [(empty) (tuple2 (empty) state)]
    [(cons pat pats)
     (match-define (tuple2 var state) (fresh-var #"pat-field" state))
     (match-define (tuple2 ann-pats state) (fresh-sub-pattern-vars pats state))
     (tuple2 (cons (tuple2 var pat) ann-pats) state)]))
