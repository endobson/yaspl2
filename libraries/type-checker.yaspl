(module type-checker
  (import
    (prim
      #:types (Bytes)
      #:values (panic =)
      #:patterns ())
    (bytes bytes=? bytes-append)
    (source-language
      #:types (Module FunctionDefinition TypeDefinition Imports PreType Import
               VariantDefinition VariantField)
      #:values (type-definition-name function-definition-name)
      #:patterns (module type-definition imports function-definition
                  variant-definition variant-field
                  var-pre-type fun-pre-type type-app-pre-type
                  import))
    (module-signature
      #:types (ModuleSignature PatternSignature)
      #:values (module-signature-name
                module-signature-type-bindings
                module-signature-pattern-exports
                module-signature-value-types)
      #:patterns (pattern-signature))
    (sexp-printer print-sexp)
    (types
      #:types (Type)
      #:values (star-kind abstract-type type-constructor var-type fun-type
                type->sexp)
      #:patterns (type-constructor))
    (dict
      #:types (Dict)
      #:values (make-dict merge-dicts dict-add dict-add-all dict-ref dict-set)
      #:patterns ())
    (list
      #:types (List)
      #:values (map cons empty findf extract-rights list length)
      #:patterns (cons empty))
    (either
      #:types (Either)
      #:values (left right)
      #:patterns (left right))
    (tuples
      #:types (Tuple2)
      #:values (tuple2)
      #:patterns (tuple2))
    (maybe
      #:types (Maybe)
      #:values ()
      #:patterns (nothing just)))
  (export
    #:types (Context)
    #:values (type-check
              context
              context-types context-values)
    #:patterns ())
  (types
    (define-type Context
      (context
        [types (Dict Bytes Type)]
        [patterns (Dict Bytes PatternDescriptor)]
        [values (Dict Bytes Type)]))
    (define-type PatternDescriptor
      (pattern-descriptor
        [type-vars (List Bytes)]
        [input-type Type]
        [field-types (List Type)])))

  (define (context-add-types [context : Context] [vs : (List (Tuple2 Bytes Type))]) : Context
    (case vs
      [(empty) context]
      [(cons (tuple2 name type) vs)
       (context-add-types
         (context-add-type context name type)
         vs)]))

  (define (context-add-type [ctx : Context] [name : Bytes] [type : Type]) : Context
    (case ctx
      [(context types patterns values)
       (context (dict-add types name type) patterns values)]))

  (define (context-set-values [context : Context] [vs : (List (Tuple2 Bytes Type))]) : Context
    (case vs
      [(empty) context]
      [(cons (tuple2 name type) vs)
       (context-set-values
         (context-set-value context name type)
         vs)]))

  (define (context-set-value [ctx : Context] [name : Bytes] [type : Type]) : Context
    (case ctx
      [(context types patterns values)
       (context types patterns (dict-set values name type))]))

  (define (context-ref-value [ctx : Context] [name : Bytes]) : (Maybe Type)
    (case ctx
      [(context _ _ values)
       (dict-ref values name)]))

  (define (context-ref-type [ctx : Context] [name : Bytes]) : (Maybe Type)
    (case ctx
      [(context types _ _)
       (dict-ref types name)]))

  (define (context-ref-pattern [ctx : Context] [name : Bytes]) : (Maybe PatternDescriptor)
    (case ctx
      [(context _ patterns _)
       (dict-ref patterns name)]))

  (define (merge-contexts* [cs : (List Context)]) : Context
    (case cs
      [(empty)
       (context
         (make-dict bytes=?)
         (make-dict bytes=?)
         (make-dict bytes=?))]
      [(cons c (empty)) c]
      [(cons c1 (cons c2 cs))
       (merge-contexts* (cons (merge-contexts c1 c2) cs))]))

  (define (merge-contexts [c1 : Context] [c2 : Context]) : Context
    (case c1
      [(context t1 p1 v1)
       (case c2
         [(context t2 p2 v2)
          (context
            (merge-dicts t1 t2)
            (merge-dicts p1 p2)
            (merge-dicts v1 v2))])]))

  (define (extract-imports
            [imports : (List Import)]
            [exports : (Dict Bytes Type)]
            [acc : (Dict Bytes Type)])
    : (Dict Bytes Type)
    (case imports
      [(empty) acc]
      [(cons (import exported-name local-name) imports)
       (extract-imports
         imports
         exports
         (case (dict-ref exports exported-name)
           [(nothing) (panic (bytes-append (varargs list #"Couldn't find export: " exported-name)))]
           [(just type)
            (dict-add acc local-name type)]))]))

  (define (extract-imports/patterns
            [imports : (List Import)]
            [exports : (Dict Bytes PatternSignature)]
            [acc : (Dict Bytes PatternDescriptor)])
    : (Dict Bytes PatternDescriptor)
    (case imports
      [(empty) acc]
      [(cons (import exported-name local-name) imports)
       (extract-imports/patterns
         imports
         exports
         (case (dict-ref exports exported-name)
           [(nothing) (panic (bytes-append (varargs list #"Couldn't find pattern export: " exported-name)))]
           [(just (pattern-signature tag type-vars self-type field-types))
            (dict-add
              acc
              local-name
              (pattern-descriptor type-vars self-type field-types))]))]))

  (define (imports->context [imports : Imports] [sigs : (List ModuleSignature)]) : Context
    (case imports
      [(imports name types values patterns)
       (case (find-signature name sigs)
         [(nothing) (panic #"Couldn't find signature")]
         [(just sig)
          (context
            (extract-imports types (module-signature-type-bindings sig) (make-dict bytes=?))
            (extract-imports/patterns patterns (module-signature-pattern-exports sig) (make-dict bytes=?))
            (extract-imports values (module-signature-value-types sig) (make-dict bytes=?)))])]))

  (define (type-definitions->types
            [mod-name : Bytes]
            [defs : (List TypeDefinition)]
            [acc : (Dict Bytes Type)]) : (Dict Bytes Type)
    (case defs
      [(empty) acc]
      [(cons def defs)
       (type-definitions->types
         mod-name
         defs
         (dict-add
           acc
           (type-definition-name def)
           (type-definition->type mod-name def)))]))

  (define (type-definition->type [mod-name : Bytes] [def : TypeDefinition]) : Type
    (case def
      [(type-definition name (nothing) _)
       (abstract-type mod-name name (empty))]
      [(type-definition name (just vars) _)
       (type-constructor mod-name name (map (lambda ([v : Bytes]) (star-kind)) vars))]))


  (define (panic/type [msg : Bytes]) : Type
    (panic msg))

  (define (variant-definition->context
            [def : VariantDefinition]
            [type-vars : (List Bytes)]
            [self-type : Type]
            [ctx : Context]) : Context
    (case def
      [(variant-definition name fields)
       (context
         (make-dict bytes=?)
         (dict-add
           (make-dict bytes=?)
           name
           (pattern-descriptor
             type-vars
             self-type
             (map (lambda ([field : VariantField])
                    (case field
                      [(variant-field _ pre-type)
                       (case (pre-type->type pre-type
                                (context-add-types
                                  ctx
                                  (map (lambda ([v : Bytes]) (tuple2 v (var-type v))) type-vars)))
                         [(left v) (panic/type v)]
                         [(right t) t])]))
                  fields)))
         (dict-add-all
           (make-dict bytes=?)
           (cons
             (tuple2 name
               (fun-type
                 type-vars
                 (map (lambda ([field-definition : VariantField])
                        (case field-definition
                          [(variant-field field-name pre-type)
                           (case (pre-type->type pre-type
                                    (context-add-types
                                      ctx
                                      (map (lambda ([v : Bytes]) (tuple2 v (var-type v))) type-vars)))
                             [(left v) (panic/type v)]
                             [(right t) t])]))
                      fields)
                 self-type))
             (map (lambda ([field-definition : VariantField])
                    (case field-definition
                      [(variant-field field-name pre-type)
                       (tuple2 (bytes-append (varargs list name #"-" field-name))
                               (fun-type
                                 type-vars
                                 (varargs list self-type)
                                 (case (pre-type->type pre-type
                                          (context-add-types
                                            ctx
                                            (map (lambda ([v : Bytes]) (tuple2 v (var-type v))) type-vars)))
                                   [(left v) (panic/type v)]
                                   [(right t) t])))]))
                  fields))))]))

  (define (simplify-type-vars [type-vars : (Maybe (List Bytes))]) : (List Bytes)
    (case type-vars
      [(nothing) (empty)]
      [(just vars) vars]))

  (define (type-definition->context [mod-name : Bytes] [def : TypeDefinition] [ctx : Context]) : Context
    (case def
      [(type-definition name type-vars variants)
       (let ([simple-type-vars (simplify-type-vars type-vars)])
         (let ([self-type (abstract-type mod-name name (map var-type simple-type-vars))])
           (merge-contexts*
             (map (lambda ([v : VariantDefinition])
                    (variant-definition->context v simple-type-vars self-type ctx))
                  variants))))]))

  (define (find-signature [name : Bytes] [sigs : (List ModuleSignature)]) : (Maybe ModuleSignature)
    (findf (lambda ([sig : ModuleSignature]) (bytes=? name (module-signature-name sig))) sigs))

  (define (function-definition->type [def : FunctionDefinition] [context : Context])
    : (Either Bytes Type)
    (case def
      [(function-definition _ pre-type _ _)
       (pre-type->type pre-type context)]))

  (define (pre-type->type [pre : PreType] [context : Context]) : (Either Bytes Type)
    (case pre
      [(var-pre-type v)
       (case (context-ref-type context v)
         [(nothing) (left (bytes-append (varargs list #"Unbound type variable: " v)))]
         [(just v) (right v)])]
      [(fun-pre-type type-vars args result)
       (let ([context (context-add-types context
                        (map (lambda ([v : Bytes])
                               (tuple2 v (var-type v))) type-vars))])
         (let ([recur (lambda ([pre : PreType]) (pre-type->type pre context))])
           (case (extract-rights (map recur args))
             [(left v) (left v)]
             [(right args)
              (case (recur result)
                [(left v) (left v)]
                [(right result)
                 (right (fun-type type-vars args result))])])))]
      [(type-app-pre-type constructor args)
       (case (context-ref-type context constructor)
         [(nothing) (left (bytes-append (varargs list #"Unbound type constructor: " constructor)))]
         ;; TODO actually check that the kind of the argument types match the expected kinds
         [(just (type-constructor mod-name name arg-kinds))
          (if (= (length args) (length arg-kinds))
              (case (extract-rights
                      (map (lambda ([pre : PreType]) (pre-type->type pre context)) args))
                [(left v) (left v)]
                [(right types)
                 (right (abstract-type mod-name name types))])
              (left #"Number of arguments to type constructor doesn't match."))]
         [(just t)
          (left
            (bytes-append
              (varargs list
                #"Cannot apply non constructor type: "
                (print-sexp (type->sexp t)))))])]))

  (define (get-function-type [def : FunctionDefinition] [context : Context])
    : (Either Bytes (Tuple2 Bytes Type))
    (case (function-definition->type def context)
      [(left v) (left v)]
      [(right type)
       (right (tuple2 (function-definition-name def) type))]))

  (define (get-function-types [defs : (List FunctionDefinition)] [context : Context])
    : (Either Bytes (List (Tuple2 Bytes Type)))
    (extract-rights
      (map (lambda ([def : FunctionDefinition]) (get-function-type def context)) defs)))

  (define (create-context [mod : Module] [sigs : (List ModuleSignature)]) : (Either Bytes Context)
    (case mod
      [(module mod-name imports _ types defs)
       (let ([init-context
               (merge-contexts*
                 (map (lambda ([imports : Imports]) (imports->context imports sigs)) imports))])
         (let ([context/local-types
                 (merge-contexts
                   init-context
                   (context
                     (type-definitions->types mod-name types (make-dict bytes=?))
                     (make-dict bytes=?)
                     (make-dict bytes=?)))])
           (case (get-function-types defs context/local-types)
             [(left v) (left v)]
             [(right fun-types)
              (right
                (merge-contexts*
                  (cons
                    context/local-types
                    (cons
                      (context
                        (make-dict bytes=?)
                        (make-dict bytes=?)
                        (dict-add-all (make-dict bytes=?) fun-types))
                      (map (lambda ([def : TypeDefinition])
                             (type-definition->context mod-name def context/local-types))
                           types)))))])))]))

  (define (type-check [mod : Module] [sigs : (List ModuleSignature)]) : (Either Bytes Context)
    (case (create-context mod sigs)
      [(left v) (left v)]
      [(right context)
       ;; TODO actually run type checking.
       (right context)])))
