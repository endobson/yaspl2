#:module (type-checker)
#:import {
  (bytes)
  (data source-location)
  (dict)
  (either)
  (list)
  (maybe)
  (module-name)
  (module-signature)
  (numbers)
  (prim)
  (prim-types)
  {(resolved-types-language)
    {#:types
      Block
      BlockDefinition
      CaseClause
      Export
      Expression
      FunctionArg
      FunctionDefinition
      Imports
      Module
      Pattern
      TypeDefinition
      VariantDefinition
      VariantField
    }
    {#:values
      case-clause-pattern
      function-arg-type
      function-definition-name
      pattern-source-span
      variant-definition-name
      variant-field-type
    }
    {#:patterns
      abstraction-pattern
      annotated-expr
      app-expr
      begin-expr
      block
      boolean-literal
      bytes-literal
      bytes-pattern
      case-clause
      case-expr
      export
      exports
      function-arg
      function-definition
      if-expr
      ignore-pattern
      imports
      int-literal
      int-pattern
      lambda-expr
      let-expr
      match-def
      module
      type-definition
      var-expr
      varargs-app-expr
      variable-pattern
      variant-definition
      variant-field
    }
  }
  (set)
  (sexp-printer)
  (totality-checker)
  (tuples)
  {(type-checked-language)
    {#:types
      [Module tc:Module]
      [ValueExport tc:ValueExport]
    }
    {#:values
      [exports tc:exports]
      [module tc:module]
      [value-export tc:value-export]
    }
  }
  (type-checker-context)
  (type-unification)
  (types)
}
(export
  (#:types)
  (#:values type-check
            type-check/expr
            attempt-result-based-unification
            type-check-errors->bytes)
  (#:patterns type-check-error))
(types
  (define-type TypeCheckErrors
    (type-check-errors
      [module-name : ModName]
      [errors : (List TypeCheckError)]))
  (define-type TypeCheckError
    (type-check-error
      [message : Bytes]
      [source : SourceSpan])))

(define (type-check-errors->bytes [err : TypeCheckErrors]) : Bytes
  (match-define (type-check-errors name errors) err)
  (bytes-append (append (varargs list #"Module: " (mod-name->bytes name) #"\n")
                        (interleave (map type-check-error-message errors) #"\n\n"))))

(define (imports->context [imports : Imports]) : Context
  (case imports
    [(imports values _)
     (context (dict-value-map values value-signature-type))]))

(define (variant-definition->context
          [def : VariantDefinition]
          [type-vars : (List Bytes)]
          [gen-accessors : Boolean]
          [self-type : Type]
          [index : Int]
          [mod-name : ModName]
          [type-name : Bytes]
          [all-variants : (List Bytes)]) : Context
  (case def
    [(variant-definition name fields)
     (context
       (dict-add-all
         (make-dict bytes-cmp)
         (cons
           (tuple2 name
             (fun-type
               type-vars
               (map variant-field-type fields)
               self-type))
           (if gen-accessors
               (map (lambda ([field-definition : VariantField]) : (Tuple2 Bytes Type)
                      (case field-definition
                        [(variant-field field-name field-type)
                         (tuple2 (bytes-append (varargs list name #"-" field-name))
                                 (fun-type
                                   type-vars
                                   (varargs list self-type)
                                   field-type))]))
                    fields)
               (empty)))))]))

(define (simplify-type-vars [type-vars : (Maybe (List Bytes))]) : (List Bytes)
  (case type-vars
    [(nothing) (empty)]
    [(just vars) vars]))


(define (type-definitions->context [mod-name : ModName] [defs : (List TypeDefinition)]) : Context
  (merge-contexts*
    (map (lambda ([def : TypeDefinition]) (type-definition->context mod-name def)) defs)))

(define (type-definition->context [mod-name : ModName] [def : TypeDefinition]) : Context
  (case def
    [(type-definition name type-vars variants)
     (let ([simple-type-vars (simplify-type-vars type-vars)])
       (let ([self-type (abstract-type mod-name name (map var-type simple-type-vars) (star-kind))])
         (let ([gen-accessors (case variants
                                [(cons _ (empty)) #t]
                                [_ #f])])
           (let ([all-variants (map variant-definition-name variants)])
             (merge-contexts*
               (map/indexed (lambda ([v : VariantDefinition] [index : Int])
                              (variant-definition->context v simple-type-vars gen-accessors self-type
                                                           index mod-name name all-variants))
                             variants))))))]))

(define (function-definition->type [def : FunctionDefinition]) : Type
  (case def
    [(function-definition _ type-vars args (source-span-annotated result-type _) _)
     (match-define arg-types (map function-arg-type args))
     (fun-type type-vars arg-types result-type)]))

(define (function-definitions->context [defs : (List FunctionDefinition)])
  : Context
  (context
    (dict-add-all
      (make-dict bytes-cmp)
      (map (lambda ([def : FunctionDefinition]) : (Tuple2 Bytes Type)
             (tuple2 (function-definition-name def)
                     (function-definition->type def)))
        defs))))

(define (create-context [mod : Module]) : Context
  (case mod
    [(module mod-name imports _ types defs)
     (merge-contexts*
       (varargs list
         (imports->context imports)
         (function-definitions->context defs)
         (type-definitions->context mod-name types)))]))

(define (type-check/definition
          [def : FunctionDefinition]
          [context : Context]) : (Maybe TypeCheckError)
  (match-define (function-definition name _ args result body) def)
  (case (type-check/function-args args context)
    [(left v) (just v)]
    [(right context)
     (case result
       [(source-span-annotated (type-constructor mod-name type-name _) src)
        (just (type-check-error
                (bytes-append (varargs list
                                       #"Function: " name #"\n"
                                       #"Return type cannot be a type constructor. Got: "
                                       (mod-name->bytes mod-name) #" " type-name))
                src))]

       [(source-span-annotated result _)
        (case (type-check/block body context (just result))
          [(left (type-check-error v src))
           (just (type-check-error (bytes-append (varargs list #"Function: " name #"\n" v)) src))]
          [(right _) (nothing)])])]))

(define (check-expected [type : Type] [expected : (Maybe Type)] [source : SourceSpan])
  : (Either TypeCheckError Type)
  (case expected
    [(nothing) (right type)]
    [(just ex-type)
     (if (type=? type ex-type)
         (right type)
         (left
           (type-check-error
             (bytes-append
               (varargs list
                 #"Types don't match:\nGot: "
                 (print-sexp (type->sexp type))
                 #"\nExpected: "
                 (print-sexp (type->sexp ex-type))))
             source)))]))

(define (type-check/begin-exprs
          [exprs : (List Expression)]
          [context : Context]) : (Maybe TypeCheckError)
  (case exprs
    [(empty)
     (nothing)]
    [(cons expr exprs)
     (case (type-check/expr expr context (just (void-type)))
       [(left v) (just v)]
       [(right _)
        (type-check/begin-exprs exprs context)])]))


(define (attempt-result-based-unification
          [type-vars : (List Bytes)]
          [result-type : Type]
          [expected-type : (Maybe Type)])
  : (Maybe (Dict Bytes Type))
  (case expected-type
    [(nothing)
     (case type-vars
       [(empty) (just (make-dict bytes-cmp))]
       [_ (nothing)])]
    [(just t)
     (case (map-state
             (lambda ([type-var : Bytes] [s : UnificationVarSource])
               (case (uvar-source-next s)
                 [(tuple2 u s)
                  (tuple2 (tuple2 type-var u) s)]))
             type-vars
             (new-uvar-source))
       [(tuple2 type-var-uvars _s)
        (let ([constraints
                (cons
                  (eq-constraint
                    (type->constrainable t (make-dict bytes-cmp))
                    (type->constrainable
                      result-type
                      (dict-add-all (make-dict bytes-cmp) type-var-uvars)))
                  (map
                    (lambda ([t : (Tuple2 Bytes UnificationVar)])
                      (case t
                        [(tuple2 _ uvar)
                         (star-kind-constraint uvar)]))
                    type-var-uvars))])
          (case (unify constraints)
            [(nothing) (nothing)]
            [(just uvar-dict)
             (case (extract-justs
                     (map
                       (lambda ([t : (Tuple2 Bytes UnificationVar)]) : (Maybe (Tuple2 Bytes Type))
                         (case t
                           [(tuple2 tvar uvar)
                            (case (dict-ref uvar-dict uvar)
                              [(nothing) (nothing)]
                              [(just type) (just (tuple2 tvar type))])]))
                       type-var-uvars))
               [(nothing)
                (nothing)]
               [(just tvar-types)
                (just (dict-add-all (make-dict bytes-cmp) tvar-types))])]))])]))

(define (type-check/expr
          [expr : Expression]
          [context : Context]
          [expected-type : (Maybe Type)]) : (Either TypeCheckError Type)
  (case expr
    [(var-expr v src)
     (case (context-ref-value context v)
       [(nothing) (left (type-check-error (bytes-append (varargs list #"Untyped variable: " v)) src))]
       [(just t) (check-expected t expected-type src)])]
    [(int-literal _ src)
     (check-expected (int-type) expected-type src)]
    [(bytes-literal _ src)
     (check-expected (bytes-type) expected-type src)]
    [(boolean-literal _ src)
     (check-expected (boolean-type) expected-type src)]
    [(if-expr c t f src)
     (case (type-check/expr c context (just (boolean-type)))
       [(left v) (left v)]
       [(right _)
        (case (type-check/expr t context expected-type)
          [(left v) (left v)]
          [(right t-type)
           (case (type-check/expr f context expected-type)
             [(left v) (left v)]
             [(right f-type)
              (if (type=? t-type f-type)
                  (right t-type)
                  (left (type-check-error #"Branches of if don't match" src)))])])])]
    [(begin-expr void-exprs last-expr _)
     (case (type-check/begin-exprs void-exprs context)
       [(just v) (left v)]
       [(nothing)
        (type-check/expr last-expr context expected-type)])]
    [(let-expr name expr body _)
     (case (type-check/expr expr context (nothing))
       [(left v) (left v)]
       [(right expr-type)
        (type-check/block
          body
          (context-set-value context name expr-type)
          expected-type)])]
    [(annotated-expr type expr src)
     (case (type-check/expr expr context (just type))
       [(left v) (left v)]
       [(right actual-type)
        (check-expected actual-type expected-type src)])]
    [(lambda-expr args maybe-return-type body src)
     (case
       (ann (Either TypeCheckError (Maybe Type))
         (case maybe-return-type
           [(just return-type)
            (right (just return-type))]
           [(nothing)
            (case expected-type
              [(nothing) (right (nothing))]
              [(just expected-type)
               (case expected-type
                 [(fun-type (empty) _ expected-body-type)
                  (right (just expected-body-type))]
                 [_
                  (left (type-check-error #"Lambda can only match monomorphic function type." src))])])]))
       [(left v) (left v)]
       [(right inner-expected-type)
        (case (type-check/function-args args context)
          [(left v) (left v)]
          [(right context)
           (case (type-check/block body context inner-expected-type)
             [(left v) (left v)]
             [(right return-type)
              (check-expected
               (fun-type (empty) (map function-arg-type args) return-type)
               expected-type
               src)])])])]
    [(app-expr _ op args src)
     (case (type-check/expr op context (nothing))
       [(left v) (left v)]
       [(right (fun-type type-vars arg-types result-type))
        (case (zip args arg-types)
          [(nothing)
           (left
             (type-check-error
               (bytes-append
                 (varargs list
                   #"Cannot apply function: wrong number of arguments."
                   #"\nGot: " (integer->decimal-bytes (length args))
                   #"\nExpected: " (integer->decimal-bytes (length arg-types))))
               src))]
          [(just merged-args)
           (match-define maybe-subst
             (attempt-result-based-unification type-vars result-type expected-type))
           (case
             (extract-rights
               (map (lambda ([arg : (Tuple2 Expression Type)])
                      (case arg
                        [(tuple2 arg type)
                         (case maybe-subst
                           [(nothing) (type-check/expr arg context (nothing))]
                           [(just subst) (type-check/expr arg context
                                                          (just (substitute-types type subst)))])]))
                    merged-args))
             [(left v) (left v)]
             [(right actual-arg-types)
              (match-define (tuple2 type-var-uvars s)
                (map-state
                  (lambda ([type-var : Bytes] [s : UnificationVarSource])
                    (case (uvar-source-next s)
                      [(tuple2 u s)
                       (tuple2 (tuple2 type-var u) s)]))
                  type-vars
                  (new-uvar-source)))
              (match-define (tuple2 u _s) (uvar-source-next s))
              (match-define constraints
                  (cons
                    (eq-constraint
                      (type->constrainable
                        (fun-type (empty) arg-types result-type)
                        (dict-add-all (make-dict bytes-cmp) type-var-uvars))
                      (constrain-fun-type
                        (map (lambda ([arg-type : Type])
                               (type->constrainable arg-type (make-dict bytes-cmp)))
                             actual-arg-types)
                        (constrain-uvar u)))
                    (map
                      (lambda ([type-var-uvar : (Tuple2 Bytes UnificationVar)])
                        (case type-var-uvar
                          [(tuple2 _ uvar)
                           (star-kind-constraint uvar)]))
                      type-var-uvars)))
              (match-define constraints
                (case expected-type
                  [(nothing) constraints]
                  [(just t)
                   (cons
                     (eq-constraint
                       (constrain-uvar u)
                       (type->constrainable t (make-dict bytes-cmp)))
                     constraints)]))
              (case (unify constraints)
                [(nothing)
                 (left
                   (type-check-error
                     (bytes-append
                       (map
                         (lambda ([c : Constraint])
                           (bytes-append (varargs list (constraint->bytes c) #"\n")))
                         constraints))
                     src))]
                [(just uvar-dict)
                 (case (dict-ref uvar-dict u)
                   [(nothing)
                    (left (type-check-error #"No binding for uvar in output of unification" src))]
                   [(just type)
                    (check-expected type expected-type src)])])])])]
       [(right t)
        (left
          (type-check-error
            (bytes-append
              (varargs list #"Cannot apply non function: " (print-sexp (type->sexp t))))
            src))])]
    [(varargs-app-expr _ op args src)
     (case (type-check/expr op context (nothing))
       [(left v) (left v)]
       [(right (fun-type type-vars
                         (cons (abstract-type (mod-name (cons #"prim" (empty)))
                                              #"Array"
                                              (cons arg-type (empty))
                                              _) (empty))
                         result-type))
        (match-define maybe-subst
          (attempt-result-based-unification type-vars result-type expected-type))
        (case
          (extract-rights
            (map (lambda ([arg : Expression])
                   (case maybe-subst
                     [(nothing)
                      (type-check/expr arg context (nothing))]
                     [(just subst)
                      (type-check/expr arg context (just (substitute-types arg-type subst)))]))
                 args))
          [(left v) (left v)]
          [(right actual-types)
           (match-define (tuple2 type-var-uvars s)
             (map-state
               (lambda ([type-var : Bytes] [s : UnificationVarSource])
                 (case (uvar-source-next s)
                   [(tuple2 u s)
                    (tuple2 (tuple2 type-var u) s)]))
               type-vars
               (new-uvar-source)))
           (match-define type-var-uvar-dict : (Dict Bytes UnificationVar)
             (dict-add-all (make-dict bytes-cmp) type-var-uvars))
           (match-define (tuple2 u _s) (uvar-source-next s))
           (match-define constraints
             (cons
               (eq-constraint
                 (type->constrainable result-type type-var-uvar-dict)
                 (constrain-uvar u))
               (append
                 (map
                   (lambda ([t : Type])
                     (eq-constraint
                       (type->constrainable t type-var-uvar-dict)
                       (type->constrainable arg-type type-var-uvar-dict)))
                   actual-types)
                 (map
                   (lambda ([type-var-uvar : (Tuple2 Bytes UnificationVar)])
                     (case type-var-uvar
                       [(tuple2 _ uvar)
                        (star-kind-constraint uvar)]))
                   type-var-uvars))))
           (case (unify constraints)
             [(nothing)
              (left
                (type-check-error
                  (bytes-append
                    (map
                      (lambda ([c : Constraint])
                        (bytes-append (varargs list (constraint->bytes c) #"\n")))
                      constraints))
                  src))]
             [(just uvar-dict)
              (case (dict-ref uvar-dict u)
                [(nothing)
                 (left (type-check-error #"No binding for uvar in output of unification" src))]
                [(just type)
                 (check-expected type expected-type src)])])])]
       [(right t)
        (case t
          [(fun-type _ _ _)
           (left
             (type-check-error
               (bytes-append
                 (varargs list #"Cannot varargs apply function that doesn't take a single arary: "
                          (print-sexp (type->sexp t))))
               src))]
          [_
           (left
             (type-check-error
               (bytes-append
                 (varargs list #"Cannot apply non function: " (print-sexp (type->sexp t))))
               src))])])]
    [(case-expr op clauses src)
     (case (type-check/expr op context (nothing))
       [(left v) (left v)]
       [(right type)
        (case (extract-rights
                (map
                  (lambda ([clause : CaseClause])
                    (case clause
                      [(case-clause p body)
                       (type-check/case-clause p body context type expected-type)]))
                  clauses))
          [(left v) (left v)]
          [(right types)
           (case (set-split (set-add-all (make-set type-cmp) types))
             [(nothing)
              (left (type-check-error #"Cannot have case expression with no clauses" src))]
             [(just (tuple2 type other-types))
              (if (set-empty? other-types)
                  (case (totality-check-patterns (map case-clause-pattern clauses))
                    [(just v) (left (type-check-error v src))]
                    [(nothing) (right type)])
                  (left (type-check-error
                          (bytes-append
                            (cons
                              #"Conflicting types in case clauses:\n"
                              (interleave
                                (map
                                  (lambda ([t : Type]) (print-sexp (type->sexp t)))
                                  types)
                                #"\n")))
                          src)))])])])]))

(define (type-check/block
          [body : Block]
          [context : Context]
          [expected-type : (Maybe Type)]) : (Either TypeCheckError Type)
  (match-define (block defs expr) body)
  (type-check/block* defs expr context expected-type))

(define (type-check/block*
          [defs : (List BlockDefinition)]
          [body : Expression]
          [context : Context]
          [expected-type : (Maybe Type)]) : (Either TypeCheckError Type)
  (case defs
    [(empty) (type-check/expr body context expected-type)]
    [(cons (match-def pattern def-expected-type expr) defs)
     (case (totality-check-patterns (varargs list pattern))
       [(just v) (left (type-check-error v (pattern-source-span pattern)))]
       [(nothing)
        (case (type-check/expr expr context def-expected-type)
          [(left v) (left v)]
          [(right type)
           (case (type-check/pattern pattern context type)
             [(left v) (left v)]
             [(right context)
              (type-check/block* defs body context expected-type)])])])]))

(define (type-check/pattern [pattern : Pattern] [context : Context] [arg-type : Type])
  : (Either TypeCheckError Context)
  (case (type-check/pattern* pattern context arg-type (empty))
    [(left v) (left v)]
    [(right var-types)
     (right (context-set-values context var-types))]))

(define (type-check/pattern* [pattern : Pattern] [context : Context] [arg-type : Type]
                             [var-types : (List (Tuple2 Bytes Type))])
  : (Either TypeCheckError (List (Tuple2 Bytes Type)))
  (case pattern
    [(bytes-pattern _ src)
     (if (type=? arg-type (bytes-type))
         (right var-types)
         (left (type-check-error #"Cannot match _ against bytes literal" src)))]
    [(int-pattern _ src)
     (if (type=? arg-type (int-type))
         (right var-types)
         (left (type-check-error #"Cannot match _ against int literal" src)))]
    [(variable-pattern v _)
     (right (cons (tuple2 v arg-type) var-types))]
    [(ignore-pattern _)
     (right var-types)]
    [(abstraction-pattern
       (pattern-signature variant-name _ pat-mod-name pat-type-name type-vars input-field-types _)
       sub-patterns
       src)
     (case arg-type
       [(abstract-type arg-mod-name arg-type-name arg-sub-types _)
        (if (and (mod-name=? arg-mod-name pat-mod-name)
                 (bytes=? arg-type-name pat-type-name))
            (let ([field-types
                   (map (lambda ([field-type : Type]) : Type
                          (case (zip type-vars arg-sub-types)
                                  [(nothing) (panic #"Bad number of types")]
                                  [(just var-types)
                                   (substitute-types
                                     field-type
                                     (dict-add-all (make-dict bytes-cmp) var-types))]))
                        input-field-types)])
              (case (zip sub-patterns field-types)
                [(nothing)
                 (left (type-check-error
                         (bytes-append
                           (varargs list
                             #"Number of fields doesn't match number of subpatterns:"
                             #" Pattern: " variant-name
                             #" [" (mod-name->bytes pat-mod-name) #" " pat-type-name #"]"
                             #" Fields: " (integer->decimal-bytes (length field-types))
                             #" Subpatterns: " (integer->decimal-bytes (length sub-patterns))))
                         src))]
                [(just sub-pattern-types)
                 (type-check/patterns* sub-pattern-types context var-types)]))
            (left (type-check-error
                    (bytes-append
                      (varargs list
                        #"Got pattern for different type:"
                        #" Pattern: " variant-name
                        #" Expected: " (mod-name->bytes arg-mod-name) #" " arg-type-name
                        #" Got: " (mod-name->bytes pat-mod-name) #" " pat-type-name))
                    src)))]
       [_ (left (type-check-error #"Abstraction pattern cannot match non abstract-type" src))])]))

(define (type-check/patterns* [zipped : (List (Tuple2 Pattern Type))] [context : Context]
                              [var-types : (List (Tuple2 Bytes Type))])
  : (Either TypeCheckError (List (Tuple2 Bytes Type)))
  (case zipped
    [(empty) (right var-types)]
    [(cons (tuple2 pat type) zipped)
     (case (type-check/pattern* pat context type var-types)
       [(left v) (left v)]
       [(right var-types)
        (type-check/patterns* zipped context var-types)])]))

(define (type-check/case-clause
          [pattern : Pattern]
          [body : Block]
          [context : Context]
          [argument-type : Type]
          [expected-type : (Maybe Type)]) : (Either TypeCheckError Type)
  (case (type-check/pattern pattern context argument-type)
    [(left v) (left v)]
    [(right context)
     (type-check/block body context expected-type)]))


(define (type-check/function-args [args : (List FunctionArg)] [context : Context])
  : (Either TypeCheckError Context)
  (case (find/maybe
          (lambda ([arg : FunctionArg]) : (Maybe TypeCheckError)
            (case arg
              [(function-arg pattern _type)
               (case (totality-check-patterns (varargs list pattern))
                 [(just v) (just (type-check-error v (pattern-source-span pattern)))]
                 [(nothing) (nothing)])]))
          args)
    [(just v) (left v)]
    [(nothing)
     (type-check/function-args* args context)]))

(define (type-check/function-args* [args : (List FunctionArg)] [context : Context])
  : (Either TypeCheckError Context)
  (case args
    [(empty) (right context)]
    [(cons (function-arg pattern arg-type) args)
     (case (type-check/pattern* pattern context arg-type (empty))
       [(left v) (left v)]
       [(right var-types)
        (type-check/function-args* args (context-set-values context var-types))])]))


(define [a b s] (map-state [f : (a s -> (Tuple2 b s))] [l : (List a)] [s : s]) : (Tuple2 (List b) s)
  (case l
    [(empty) (tuple2 (empty) s)]
    [(cons e l)
     (case (f e s)
       [(tuple2 v s)
        (case (map-state f l s)
          [(tuple2 vs s)
           (tuple2 (cons v vs) s)])])]))

(define (convert-exports [m : Module] [ctx : Context]) : tc:Module
  (match-define (module name imports exports types definitions) m)
  (match-define (exports exported-types exported-values exported-patterns) exports)
  (tc:module
    name
    imports
    (tc:exports
      exported-types
      (map
        (lambda ([export : Export]) : tc:ValueExport
          (case export
            [(export local exported)
             (case (context-ref-value ctx local)
               [(nothing) (panic #"Unbound export")]
               [(just type)
                (tc:value-export local exported type)])]))
        exported-values)
      exported-patterns)
    types
    definitions))

(define (type-check [mod : Module]) : (Either TypeCheckErrors tc:Module)
  (match-define (module name _ _ _ definitions) mod)
  (match-define context (create-context mod))
  (case (filter-map
          (lambda ([def : FunctionDefinition]) (type-check/definition def context))
          definitions)
    [(empty)
     (right (convert-exports mod context))]
    [vs
     (left (type-check-errors name vs))]))
