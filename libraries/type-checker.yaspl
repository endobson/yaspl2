#:module (type-checker)
#:import {
  (bytes)
  (dict)
  (either)
  (join-list)
  (list)
  (maybe)
  (module-name)
  (module-signature)
  (numbers)
  (prim)
  (prim-types)
  {(resolved-imports-language)
    {#:types
      Imports
    }
    {#:patterns
      imports
    }
  }
  {(resolved-types-language)
    {#:types
      Block
      BlockDefinition
      CaseClause
      Expression
      FunctionDefinition
      Module
      TypeDefinition
      VariantDefinition
      VariantField
    }
    {#:values
      case-clause-pattern
      function-definition-name
      variant-definition-name
      variant-field-type
    }
    {#:patterns
      annotated-expr
      app-expr
      begin-expr
      block
      boolean-literal
      bytes-literal
      case-clause
      case-expr
      function-definition
      if-expr
      int-literal
      lambda-expr
      let-expr
      match-def
      module
      type-definition
      var-expr
      varargs-app-expr
      variant-definition
      variant-field
    }
  }
  (set)
  (sexp-printer)
  {(source-language)
    {#:types
      Pattern
    }
    {#:patterns
      abstraction-pattern
      bytes-pattern
      ignore-pattern
      int-pattern
      variable-pattern
    }
  }
  (totality-checker)
  (tuples)
  (type-checker-context)
  (type-unification)
  (types)
}
(export
  (#:types)
  (#:values type-check
            type-check/expr
            attempt-result-based-unification
            type-check-error->bytes)
  (#:patterns))
(types
  (define-type TypeCheckError
    (type-check-error
      [module-name : ModName]
      [errors : (List Bytes)])))

(define (type-check-error->bytes [err : TypeCheckError]) : Bytes
  (match-define (type-check-error name errors) err)
  (bytes-append (append (varargs list #"Module: " (mod-name->bytes name) #"\n") (interleave errors #"\n\n"))))

(define (imports->context [imports : Imports]) : Context
  (case imports
    [(imports types values patterns _)
     (context
       (dict-value-map patterns
         (lambda ([p : PatternSignature])
           (case p
            [(pattern-signature var-name tag type-vars self-type field-types
                                (type-signature all-variant-names))
             (pattern-descriptor type-vars self-type field-types var-name all-variant-names)])))
       (dict-value-map values value-signature-type))]))

(define (variant-definition->context
          [def : VariantDefinition]
          [type-vars : (List Bytes)]
          [gen-accessors : Boolean]
          [self-type : Type]
          [all-variants : (List Bytes)]) : Context
  (case def
    [(variant-definition name fields)
     (context
       (dict-add
         (make-dict bytes-cmp)
         name
         (pattern-descriptor
           type-vars
           self-type
           (map variant-field-type fields)
           name
           all-variants))
       (dict-add-all
         (make-dict bytes-cmp)
         (cons
           (tuple2 name
             (fun-type
               type-vars
               (map variant-field-type fields)
               self-type))
           (if gen-accessors
               (map (lambda ([field-definition : VariantField]) : (Tuple2 Bytes Type)
                      (case field-definition
                        [(variant-field field-name field-type)
                         (tuple2 (bytes-append (varargs list name #"-" field-name))
                                 (fun-type
                                   type-vars
                                   (varargs list self-type)
                                   field-type))]))
                    fields)
               (empty)))))]))

(define (simplify-type-vars [type-vars : (Maybe (List Bytes))]) : (List Bytes)
  (case type-vars
    [(nothing) (empty)]
    [(just vars) vars]))


(define (type-definitions->context [mod-name : ModName] [defs : (List TypeDefinition)]) : Context
  (merge-contexts*
    (map (lambda ([def : TypeDefinition]) (type-definition->context mod-name def)) defs)))

(define (type-definition->context [mod-name : ModName] [def : TypeDefinition]) : Context
  (case def
    [(type-definition name type-vars variants)
     (let ([simple-type-vars (simplify-type-vars type-vars)])
       (let ([self-type (abstract-type mod-name name (map var-type simple-type-vars) (star-kind))])
         (let ([gen-accessors (case variants
                                [(cons _ (empty)) #t]
                                [_ #f])])
           (let ([all-variants (map variant-definition-name variants)])
             (merge-contexts*
               (map (lambda ([v : VariantDefinition])
                      (variant-definition->context v simple-type-vars gen-accessors self-type
                                                   all-variants))
                    variants))))))]))

(define (function-definition->type [def : FunctionDefinition]) : Type
  (case def
    [(function-definition _ type-vars args result-type _)
     (match-define arg-types
        (map (lambda ([t : (Tuple2 Bytes Type)]) (case t [(tuple2 _ t) t])) args))
     (fun-type type-vars arg-types result-type)]))

(define (function-definitions->context [defs : (List FunctionDefinition)])
  : Context
  (context
    (make-dict bytes-cmp)
    (dict-add-all
      (make-dict bytes-cmp)
      (map (lambda ([def : FunctionDefinition]) : (Tuple2 Bytes Type)
             (tuple2 (function-definition-name def)
                     (function-definition->type def)))
        defs))))

(define (create-context [mod : Module]) : Context
  (case mod
    [(module mod-name imports _ types defs)
     (merge-contexts*
       (varargs list
         (imports->context imports)
         (function-definitions->context defs)
         (type-definitions->context mod-name types)))]))

(define (type-check/definition
          [def : FunctionDefinition]
          [context : Context]) : (Maybe Bytes)
  (case def
    [(function-definition name _ args _ (block defs body))
     (case (context-ref-value context name)
       [(nothing) (just #"Internal Error: Function doesn't have a type")]
       [(just (fun-type type-vars arg-types result))
        (case (zip (map (lambda ([t : (Tuple2 Bytes Type)]) (case t [(tuple2 n _) n])) args) arg-types)
          [(nothing) (just #"Internal Error: number of arg types doesn't match number of args")]
          [(just merged-args)
           (let ([new-context (context-set-values context merged-args)])
             (case result
               [(type-constructor mod-name type-name _)
                (just (bytes-append (varargs list
                                             #"Function: " name #"\n"
                                             #"Return type cannot be a type constructor. Got: "
                                             (mod-name->bytes mod-name) #" " type-name)))]

               [_
                (case (type-check/block defs body new-context (just result))
                  [(left v)
                   (just (bytes-append (varargs list #"Function: " name #"\n" v)))]
                  [(right v) (nothing)])]))])]
       [(just _)
        (just #"Internal Error: Function doesn't have a function type")])]))

(define (check-expected [type : Type] [expected : (Maybe Type)]) : (Either Bytes Type)
  (case expected
    [(nothing) (right type)]
    [(just ex-type)
     (if (type=? type ex-type)
         (right type)
         (left (bytes-append
                 (varargs list
                   #"Types don't match:\nGot: "
                   (print-sexp (type->sexp type))
                   #"\nExpected: "
                   (print-sexp (type->sexp ex-type))))))]))

(define (type-check/begin-exprs
          [exprs : (List Expression)]
          [context : Context]) : (Maybe Bytes)
  (case exprs
    [(empty)
     (nothing)]
    [(cons expr exprs)
     (case (type-check/expr expr context (just (void-type)))
       [(left v) (just v)]
       [(right _)
        (type-check/begin-exprs exprs context)])]))

(define (substitute [t : Type] [subst : (Dict Bytes Type)]) : Type
  (case t
    [(var-type v)
     (case (dict-ref subst v)
       [(nothing) t]
       [(just t) t])]
    [(abstract-type mod-name name args kind)
     (abstract-type mod-name name
                    (map
                      (lambda ([arg : Type]) (substitute arg subst))
                      args) kind)]
    [(type-constructor mod-name name kinds)
     (type-constructor mod-name name kinds)]
    [(fun-type (empty) arg-types result-type)
     (fun-type
       (empty)
       (map
         (lambda ([arg : Type]) (substitute arg subst))
         arg-types)
       (substitute result-type subst))]
    [(fun-type _ _ _)
     (panic #"Substitute doesn't work on polymorphic functions.")]))

(define (attempt-result-based-unification
          [type-vars : (List Bytes)]
          [result-type : Type]
          [expected-type : (Maybe Type)])
  : (Maybe (Dict Bytes Type))
  (case expected-type
    [(nothing)
     (case type-vars
       [(empty) (just (make-dict bytes-cmp))]
       [_ (nothing)])]
    [(just t)
     (case (map-state
             (lambda ([type-var : Bytes] [s : UnificationVarSource])
               (case (uvar-source-next s)
                 [(tuple2 u s)
                  (tuple2 (tuple2 type-var u) s)]))
             type-vars
             (new-uvar-source))
       [(tuple2 type-var-uvars s)
        (let ([constraints
                (varargs list
                  (eq-constraint
                    (type->constrainable t (make-dict bytes-cmp))
                    (type->constrainable
                      result-type
                      (dict-add-all (make-dict bytes-cmp) type-var-uvars))))])
          (case (unify constraints)
            [(nothing) (nothing)]
            [(just uvar-dict)
             (case (extract-justs
                     (map
                       (lambda ([t : (Tuple2 Bytes UnificationVar)]) : (Maybe (Tuple2 Bytes Type))
                         (case t
                           [(tuple2 tvar uvar)
                            (case (dict-ref uvar-dict uvar)
                              [(nothing) (nothing)]
                              [(just type) (just (tuple2 tvar type))])]))
                       type-var-uvars))
               [(nothing)
                (nothing)]
               [(just tvar-types)
                (just (dict-add-all (make-dict bytes-cmp) tvar-types))])]))])]))

(define (type-check/expr
          [expr : Expression]
          [context : Context]
          [expected-type : (Maybe Type)]) : (Either Bytes Type)
  (case expr
    [(var-expr v)
     (case (context-ref-value context v)
       [(nothing) (left (bytes-append (varargs list #"Untyped variable: " v)))]
       [(just t) (check-expected t expected-type)])]
    [(int-literal v)
     (check-expected (int-type) expected-type)]
    [(bytes-literal v)
     (check-expected (bytes-type) expected-type)]
    [(boolean-literal v)
     (check-expected (boolean-type) expected-type)]
    [(if-expr c t f)
     (case (type-check/expr c context (just (boolean-type)))
       [(left v) (left v)]
       [(right _)
        (case (type-check/expr t context expected-type)
          [(left v) (left v)]
          [(right t-type)
           (case (type-check/expr f context expected-type)
             [(left v) (left v)]
             [(right f-type)
              (if (type=? t-type f-type)
                  (right t-type)
                  (left #"Branches of if don't match"))])])])]
    [(begin-expr void-exprs last-expr)
     (case (type-check/begin-exprs void-exprs context)
       [(just v) (left v)]
       [(nothing)
        (type-check/expr last-expr context expected-type)])]
    [(let-expr name expr body)
     (case (type-check/expr expr context (nothing))
       [(left v) (left v)]
       [(right expr-type)
        (type-check/expr
          body
          (context-set-value context name expr-type)
          expected-type)])]
    [(annotated-expr type expr)
     (case (type-check/expr expr context (just type))
       [(left v) (left v)]
       [(right actual-type)
        (check-expected actual-type expected-type)])]
    [(lambda-expr named-arg-types maybe-return-type body)
        (match-define arg-types
          (map (lambda ([t : (Tuple2 Bytes Type)]) (case t [(tuple2 _ ty) ty])) named-arg-types))
        (case
          (ann (Either Bytes (Maybe Type))
            (case maybe-return-type
              [(just return-type)
               (right (just return-type))]
              [(nothing)
               (case expected-type
                 [(nothing) (right (nothing))]
                 [(just expected-type)
                  (case expected-type
                    [(fun-type (empty) _ expected-body-type)
                     (right (just expected-body-type))]
                    [_
                     (left #"Lambda can only match monomorphic function type.")])])]))
          [(left v) (left v)]
          [(right inner-expected-type)
           (case (type-check/expr
                   body
                   (context-set-values context named-arg-types)
                   inner-expected-type)
              [(left v) (left v)]
              [(right return-type)
               (check-expected
                (fun-type (empty) arg-types return-type)
                expected-type)])])]
    [(app-expr _ op args)
     (case (type-check/expr op context (nothing))
       [(left v) (left v)]
       [(right (fun-type type-vars arg-types result-type))
        (case (zip args arg-types)
          [(nothing)
           (left
             (bytes-append
               (varargs list
                 #"Cannot apply function: wrong number of arguments."
                 #"\nGot: " (integer->decimal-bytes (length args))
                 #"\nExpected: " (integer->decimal-bytes (length arg-types)))))]
          [(just merged-args)
           (case
             (case (attempt-result-based-unification type-vars result-type expected-type)
               [(nothing)
                (extract-rights (map (lambda ([arg : (Tuple2 Expression Type)])
                                       (case arg
                                         [(tuple2 arg _)
                                          (type-check/expr arg context (nothing))]))
                                     merged-args))]
               [(just subst)
                (extract-rights (map (lambda ([arg : (Tuple2 Expression Type)])
                                        (case arg
                                          [(tuple2 arg type)
                                           (type-check/expr
                                             arg
                                             context
                                             (just (substitute type subst)))]))
                                     merged-args))])
             [(left v)
              (left v)]
             [(right actual-arg-types)
              (case (map-state
                      (lambda ([type-var : Bytes] [s : UnificationVarSource])
                        (case (uvar-source-next s)
                          [(tuple2 u s)
                           (tuple2 (tuple2 type-var u) s)]))
                      type-vars
                      (new-uvar-source))
                [(tuple2 type-var-uvars s)
                 (case (uvar-source-next s)
                   [(tuple2 u s)
                    (let ([constraints
                           (varargs list
                             (eq-constraint
                               (constrain-uvar u)
                               (case expected-type
                                 [(nothing)
                                  (constrain-uvar u)]
                                 [(just t)
                                  (type->constrainable t (make-dict bytes-cmp))]))
                             (eq-constraint
                               (type->constrainable
                                 (fun-type (empty) arg-types result-type)
                                 (dict-add-all (make-dict bytes-cmp) type-var-uvars))
                               (constrain-fun-type
                                 (map (lambda ([arg-type : Type])
                                        (type->constrainable arg-type (make-dict bytes-cmp)))
                                      actual-arg-types)
                                 (constrain-uvar u))))])
                      (case (unify constraints)
                        [(nothing)
                         (left
                           (bytes-append
                             (map
                               (lambda ([c : Constraint])
                                 (bytes-append (varargs list (constraint->bytes c) #"\n")))
                               constraints)))]
                        [(just uvar-dict)
                         (case (dict-ref uvar-dict u)
                           [(nothing)
                            (left #"No binding for uvar in output of unification")]
                           [(just type)
                            (check-expected type expected-type)])]))])])])])]
       [(right t)
        (left
          (bytes-append
            (varargs list #"Cannot apply non function: " (print-sexp (type->sexp t)))))])]
    [(varargs-app-expr _ op args)
     (case (type-check/expr op context (nothing))
       [(left v)
        (left v)]
       [(right (fun-type type-vars
                         (cons (abstract-type (mod-name (cons #"prim" (empty)))
                                              #"Array"
                                              (cons arg-type (empty))
                                              _) (empty))
                         result-type))
        (case
          (case (attempt-result-based-unification type-vars result-type expected-type)
            [(nothing)
             (extract-rights (map (lambda ([arg : Expression])
                                    (type-check/expr arg context (nothing)))
                                  args))]
            [(just subst)
             (extract-rights (map (lambda ([arg : Expression])
                                    (type-check/expr arg context (just (substitute arg-type subst))))
                                  args))])
          [(left v) (left v)]
          [(right actual-types)
           (case (map-state
                   (lambda ([type-var : Bytes] [s : UnificationVarSource])
                     (case (uvar-source-next s)
                       [(tuple2 u s)
                        (tuple2 (tuple2 type-var u) s)]))
                   type-vars
                   (new-uvar-source))
             [(tuple2 type-var-uvars s)
              (case (uvar-source-next s)
                [(tuple2 u s)
                 (let ([constraints
                         (cons
                           (eq-constraint
                             (type->constrainable
                               result-type
                               (dict-add-all (make-dict bytes-cmp) type-var-uvars))
                             (constrain-uvar u))
                           (map
                             (lambda ([t : Type])
                               (eq-constraint
                                 (type->constrainable
                                   t
                                   (dict-add-all (make-dict bytes-cmp) type-var-uvars))
                                 (type->constrainable
                                   arg-type
                                   (dict-add-all (make-dict bytes-cmp) type-var-uvars))))
                             actual-types))])
                   (case (unify constraints)
                     [(nothing)
                      (left
                        (bytes-append
                          (map
                            (lambda ([c : Constraint])
                              (bytes-append (varargs list (constraint->bytes c) #"\n")))
                            constraints)))]
                     [(just uvar-dict)
                      (case (dict-ref uvar-dict u)
                        [(nothing)
                         (left #"No binding for uvar in output of unification")]
                        [(just type)
                         (check-expected type expected-type)])]))])])])]
       [(right t)
        (case t
          [(fun-type _ _ _)
           (left
             (bytes-append
               (varargs list #"Cannot varargs apply function that doesn't take a single arary: "
                        (print-sexp (type->sexp t)))))]
          [_
           (left
             (bytes-append
               (varargs list #"Cannot apply non function: " (print-sexp (type->sexp t)))))])])]
    [(case-expr op clauses)
     (case (type-check/expr op context (nothing))
       [(left v) (left v)]
       [(right type)
        (case (extract-rights
                (map
                  (lambda ([clause : CaseClause])
                    (case clause
                      [(case-clause p body)
                       (type-check/case-clause p body context type expected-type)]))
                  clauses))
          [(left v) (left v)]
          [(right types)
           (case (set-split (set-add-all (make-set type-cmp) types))
             [(nothing)
              (left #"Cannot have case expression with no clauses")]
             [(just (tuple2 type other-types))
              (if (set-empty? other-types)
                  (case (totality-check-patterns context (map case-clause-pattern clauses))
                    [(just v) (left v)]
                    [(nothing) (right type)])
                  (left (bytes-append
                          (cons
                            #"Conflicting types in case clauses:\n"
                            (interleave
                              (map
                                (lambda ([t : Type]) (print-sexp (type->sexp t)))
                                types)
                              #"\n")))))])])])]))

(define (type-check/block
          [defs : (List BlockDefinition)]
          [body : Expression]
          [context : Context]
          [expected-type : (Maybe Type)]) : (Either Bytes Type)
  (case defs
    [(empty) (type-check/expr body context expected-type)]
    [(cons (match-def pattern expr) defs)
     (case (totality-check-patterns context (varargs list pattern))
       [(just v) (left v)]
       [(nothing)
        (case (type-check/expr expr context (nothing))
          [(left v) (left v)]
          [(right type)
           (case (unify-pattern pattern context type)
             [(left v) (left v)]
             [(right var-types)
              (type-check/block
                defs
                body
                (context-set-values context var-types)
                expected-type)])])])]))

(define (unify-pattern
          [pattern : Pattern]
          [context : Context]
          [argument-type : Type]) : (Either Bytes (List (Tuple2 Bytes Type)))
  (case
    (pattern-constrainable->constraints
      pattern
      (type->constrainable argument-type (make-dict bytes-cmp))
      (new-uvar-source)
      context)
    [(left v) (left v)]
    [(right (tuple2 (tuple2 vars constraints) source))
     (case (unify (jl->list constraints))
       [(nothing)
        (left
          (bytes-append
            (cons
              (bytes-append
                (varargs list
                  #"Type: "
                  (print-sexp (type->sexp argument-type))
                  #"\n"))
              (map
                (lambda ([c : Constraint])
                  (bytes-append (varargs list (constraint->bytes c) #"\n")))
                (jl->list constraints)))))]
       [(just uvar-types)
        (case (extract-justs
                (dict-map
                  vars
                  (lambda ([var : Bytes] [uvar : UnificationVar]) : (Maybe (Tuple2 Bytes Type))
                    (case (dict-ref uvar-types uvar)
                      [(nothing) (nothing)]
                      [(just type) (just (tuple2 var type))]))))
          [(nothing)
           (left #"Unification didn't have a value for a variable")]
          [(just var-types)
           (right var-types)])])]))


(define (type-check/case-clause
          [pattern : Pattern]
          [block : Block]
          [context : Context]
          [argument-type : Type]
          [expected-type : (Maybe Type)]) : (Either Bytes Type)
  (case (unify-pattern pattern context argument-type)
    [(left v) (left v)]
    [(right var-types)
     (case block
       [(block defs body)
        (type-check/block
          defs
          body
          (context-set-values context var-types)
          expected-type)])]))

(define (a b s) (map-state [f : (a s -> (Tuple2 b s))] [l : (List a)] [s : s]) : (Tuple2 (List b) s)
  (case l
    [(empty) (tuple2 (empty) s)]
    [(cons e l)
     (case (f e s)
       [(tuple2 v s)
        (case (map-state f l s)
          [(tuple2 vs s)
           (tuple2 (cons v vs) s)])])]))

(define (a b e s) (map-either-state [f : (a s -> (Either e (Tuple2 b s)))] [l : (List a)] [s : s]) :
  (Either e (Tuple2 (List b) s))
  (case l
    [(empty) (right (tuple2 (empty) s))]
    [(cons e l)
     (case (f e s)
       [(left v) (left v)]
       [(right (tuple2 v s))
        (case (map-either-state f l s)
          [(left v) (left v)]
          [(right (tuple2 vs s))
           (right (tuple2 (cons v vs) s))])])]))


(define (pattern-constrainable->constraints
          [p : Pattern]
          [c : Constrainable]
          [s : UnificationVarSource]
          [ctx : Context]) :
  (Either
    Bytes
    (Tuple2
      (Tuple2
        (Dict Bytes UnificationVar)
        (JoinList Constraint))
      UnificationVarSource))
  (case (uvar-source-next s)
    [(tuple2 u s)
     (case (pattern->constraints p u s ctx)
       [(left v) (left v)]
       [(right (tuple2 (tuple2 vars constraints) s))
        (right
          (tuple2
            (tuple2
              vars
              (cons-jl
                (eq-constraint (constrain-uvar u) c)
                constraints))
            s))])]))

(define (pattern->constraints
          [p : Pattern]
          [u : UnificationVar]
          [s : UnificationVarSource]
          [ctx : Context]) :
  (Either
    Bytes
    (Tuple2
      (Tuple2
        (Dict Bytes UnificationVar)
        (JoinList Constraint))
      UnificationVarSource))
  (case p
    [(bytes-pattern _)
     (right
       (tuple2
         (tuple2
           (make-dict bytes-cmp)
           (single-jl
             (eq-constraint
               (constrain-abstract-type (mod-name (varargs list #"prim")) #"Bytes" (empty) (star-kind))
               (constrain-uvar u))))
         s))]
    [(int-pattern _)
     (right
       (tuple2
         (tuple2
           (make-dict bytes-cmp)
           (single-jl
             (eq-constraint
               (constrain-abstract-type (mod-name (varargs list #"prim")) #"Int" (empty) (star-kind))
               (constrain-uvar u))))
         s))]
    [(variable-pattern v)
     (right
       (tuple2
         (tuple2
           (dict-add (make-dict bytes-cmp) v u)
           (empty-jl))
         s))]
    [(ignore-pattern)
     (right (tuple2 (tuple2 (make-dict bytes-cmp) (empty-jl)) s))]
    [(abstraction-pattern name patterns)
     (case (context-ref-pattern ctx name)
       ;; TODO add name here
       [(nothing) (left #"Couldn't find pattern in context")]
       [(just (pattern-descriptor type-vars input-type field-types _ _))
        (case (map-state (lambda ([tv : Bytes] [s : UnificationVarSource])
                           (case (uvar-source-next s)
                             [(tuple2 u s)
                              (tuple2 (tuple2 tv u) s)]))
                         type-vars s)
          [(tuple2 type-var-uvars s)
           (let ([field-constrainables
                   (map (lambda ([t : Type])
                          ;; TODO make the dictionary construction happen once instead of once
                          ;; per field.
                          (type->constrainable t (dict-add-all (make-dict bytes-cmp) type-var-uvars)))
                        field-types)])
             (case (zip field-constrainables patterns)
               [(nothing)
                (left (bytes-append
                        (varargs list
                                 #"Number of fields doesn't match number of subpatterns:"
                                 #" Pattern: " name
                                 #" Fields " (integer->decimal-bytes (length field-constrainables))
                                 #" Subpatterns " (integer->decimal-bytes (length patterns)))))]
               [(just zipped-patterns)
                (case
                  (map-either-state
                    (lambda ([t : (Tuple2 Constrainable Pattern)] [s : UnificationVarSource])
                      (case t
                        [(tuple2 t p)
                         (pattern-constrainable->constraints p t s ctx)]))
                    zipped-patterns
                    s)
                  [(left v) (left v)]
                  [(right (tuple2 sub-matches s))
                   (case (unzip sub-matches)
                     [(tuple2 varss constraintss)
                      (right
                        (tuple2
                          (tuple2
                            (merge-dicts* (make-dict bytes-cmp) varss)
                            (cons-jl
                              (eq-constraint
                                (constrain-uvar u)
                                (type->constrainable
                                  input-type
                                  (dict-add-all (make-dict bytes-cmp) type-var-uvars)))
                              (concat-jl constraintss)))
                          s))])])]))])])]))

(define (type-check [mod : Module]) : (Either TypeCheckError Context)
  (match-define (module name _ _ _ definitions) mod)
  (match-define context (create-context mod))
  (case (filter-map
          (lambda ([def : FunctionDefinition]) (type-check/definition def context))
          definitions)
    [(empty) (right context)]
    [vs
     (left (type-check-error name vs))]))
