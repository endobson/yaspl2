#:module (type-checker)
#:import {
  (bytes)
  (dict)
  (either)
  (list)
  (maybe)
  (module-name)
  (module-signature)
  (numbers)
  (prim)
  (prim-types)
  {(resolved-imports-language)
    {#:types
      Imports
    }
    {#:patterns
      imports
    }
  }
  {(resolved-types-language)
    {#:types
      Block
      BlockDefinition
      CaseClause
      Expression
      FunctionDefinition
      Module
      Pattern
      TypeDefinition
      VariantDefinition
      VariantField
    }
    {#:values
      case-clause-pattern
      function-definition-name
      pattern-descriptor
      variant-definition-name
      variant-field-type
    }
    {#:patterns
      abstraction-pattern
      annotated-expr
      app-expr
      begin-expr
      block
      boolean-literal
      bytes-literal
      bytes-pattern
      case-clause
      case-expr
      function-definition
      if-expr
      ignore-pattern
      int-literal
      int-pattern
      lambda-expr
      let-expr
      match-def
      module
      pattern-descriptor
      type-definition
      var-expr
      varargs-app-expr
      variable-pattern
      variant-definition
      variant-field
    }
  }
  (set)
  (sexp-printer)
  (totality-checker)
  (tuples)
  (type-checker-context)
  (type-unification)
  (types)
}
(export
  (#:types)
  (#:values type-check
            type-check/expr
            attempt-result-based-unification
            type-check-error->bytes)
  (#:patterns))
(types
  (define-type TypeCheckError
    (type-check-error
      [module-name : ModName]
      [errors : (List Bytes)])))

(define (type-check-error->bytes [err : TypeCheckError]) : Bytes
  (match-define (type-check-error name errors) err)
  (bytes-append (append (varargs list #"Module: " (mod-name->bytes name) #"\n") (interleave errors #"\n\n"))))

(define (imports->context [imports : Imports]) : Context
  (case imports
    [(imports types values patterns _)
     (context
       (dict-value-map patterns
         (lambda ([p : PatternSignature])
           (case p
            [(pattern-signature var-name tag mod-name type-name
                                type-vars field-types (type-signature all-variant-names))
             (pattern-descriptor mod-name type-name
                                 (map (type-var-abstract type-vars) field-types)
                                 tag var-name all-variant-names)])))
       (dict-value-map values value-signature-type))]))

(define (type-var-abstract [type-vars : (List Bytes)]) : (Type -> ((List Type) -> Type))
  (lambda ([t : Type])
    (lambda ([sub-types : (List Type)]) : Type
      (case (zip type-vars sub-types)
        [(nothing) (panic #"Bad number of types")]
        [(just var-types)
         (substitute t (dict-add-all (make-dict bytes-cmp) var-types))]))))


(define (variant-definition->context
          [def : VariantDefinition]
          [type-vars : (List Bytes)]
          [gen-accessors : Boolean]
          [self-type : Type]
          [index : Int]
          [mod-name : ModName]
          [type-name : Bytes]
          [all-variants : (List Bytes)]) : Context
  (case def
    [(variant-definition name fields)
     (context
       (dict-add
         (make-dict bytes-cmp)
         name
         (pattern-descriptor
           mod-name
           type-name
           (map (type-var-abstract type-vars) (map variant-field-type fields))
           (u8 index)
           name
           all-variants))
       (dict-add-all
         (make-dict bytes-cmp)
         (cons
           (tuple2 name
             (fun-type
               type-vars
               (map variant-field-type fields)
               self-type))
           (if gen-accessors
               (map (lambda ([field-definition : VariantField]) : (Tuple2 Bytes Type)
                      (case field-definition
                        [(variant-field field-name field-type)
                         (tuple2 (bytes-append (varargs list name #"-" field-name))
                                 (fun-type
                                   type-vars
                                   (varargs list self-type)
                                   field-type))]))
                    fields)
               (empty)))))]))

(define (simplify-type-vars [type-vars : (Maybe (List Bytes))]) : (List Bytes)
  (case type-vars
    [(nothing) (empty)]
    [(just vars) vars]))


(define (type-definitions->context [mod-name : ModName] [defs : (List TypeDefinition)]) : Context
  (merge-contexts*
    (map (lambda ([def : TypeDefinition]) (type-definition->context mod-name def)) defs)))

(define (type-definition->context [mod-name : ModName] [def : TypeDefinition]) : Context
  (case def
    [(type-definition name type-vars variants)
     (let ([simple-type-vars (simplify-type-vars type-vars)])
       (let ([self-type (abstract-type mod-name name (map var-type simple-type-vars) (star-kind))])
         (let ([gen-accessors (case variants
                                [(cons _ (empty)) #t]
                                [_ #f])])
           (let ([all-variants (map variant-definition-name variants)])
             (merge-contexts*
               (map/indexed (lambda ([v : VariantDefinition] [index : Int])
                              (variant-definition->context v simple-type-vars gen-accessors self-type
                                                           index mod-name name all-variants))
                             variants))))))]))

(define (function-definition->type [def : FunctionDefinition]) : Type
  (case def
    [(function-definition _ type-vars args result-type _)
     (match-define arg-types
        (map (lambda ([t : (Tuple2 Bytes Type)]) (case t [(tuple2 _ t) t])) args))
     (fun-type type-vars arg-types result-type)]))

(define (function-definitions->context [defs : (List FunctionDefinition)])
  : Context
  (context
    (make-dict bytes-cmp)
    (dict-add-all
      (make-dict bytes-cmp)
      (map (lambda ([def : FunctionDefinition]) : (Tuple2 Bytes Type)
             (tuple2 (function-definition-name def)
                     (function-definition->type def)))
        defs))))

(define (create-context [mod : Module]) : Context
  (case mod
    [(module mod-name imports _ types defs)
     (merge-contexts*
       (varargs list
         (imports->context imports)
         (function-definitions->context defs)
         (type-definitions->context mod-name types)))]))

(define (type-check/definition
          [def : FunctionDefinition]
          [context : Context]) : (Maybe Bytes)
  (case def
    [(function-definition name _ args _ (block defs body))
     (case (context-ref-value context name)
       [(nothing) (just #"Internal Error: Function doesn't have a type")]
       [(just (fun-type type-vars arg-types result))
        (case (zip (map (lambda ([t : (Tuple2 Bytes Type)]) (case t [(tuple2 n _) n])) args) arg-types)
          [(nothing) (just #"Internal Error: number of arg types doesn't match number of args")]
          [(just merged-args)
           (let ([new-context (context-set-values context merged-args)])
             (case result
               [(type-constructor mod-name type-name _)
                (just (bytes-append (varargs list
                                             #"Function: " name #"\n"
                                             #"Return type cannot be a type constructor. Got: "
                                             (mod-name->bytes mod-name) #" " type-name)))]

               [_
                (case (type-check/block defs body new-context (just result))
                  [(left v)
                   (just (bytes-append (varargs list #"Function: " name #"\n" v)))]
                  [(right v) (nothing)])]))])]
       [(just _)
        (just #"Internal Error: Function doesn't have a function type")])]))

(define (check-expected [type : Type] [expected : (Maybe Type)]) : (Either Bytes Type)
  (case expected
    [(nothing) (right type)]
    [(just ex-type)
     (if (type=? type ex-type)
         (right type)
         (left (bytes-append
                 (varargs list
                   #"Types don't match:\nGot: "
                   (print-sexp (type->sexp type))
                   #"\nExpected: "
                   (print-sexp (type->sexp ex-type))))))]))

(define (type-check/begin-exprs
          [exprs : (List Expression)]
          [context : Context]) : (Maybe Bytes)
  (case exprs
    [(empty)
     (nothing)]
    [(cons expr exprs)
     (case (type-check/expr expr context (just (void-type)))
       [(left v) (just v)]
       [(right _)
        (type-check/begin-exprs exprs context)])]))

(define (substitute [t : Type] [subst : (Dict Bytes Type)]) : Type
  (case t
    [(var-type v)
     (case (dict-ref subst v)
       [(nothing) t]
       [(just t) t])]
    [(abstract-type mod-name name args kind)
     (abstract-type mod-name name
                    (map
                      (lambda ([arg : Type]) (substitute arg subst))
                      args) kind)]
    [(type-constructor mod-name name kinds)
     (type-constructor mod-name name kinds)]
    [(fun-type (empty) arg-types result-type)
     (fun-type
       (empty)
       (map
         (lambda ([arg : Type]) (substitute arg subst))
         arg-types)
       (substitute result-type subst))]
    [(fun-type _ _ _)
     (panic #"Substitute doesn't work on polymorphic functions.")]))

(define (attempt-result-based-unification
          [type-vars : (List Bytes)]
          [result-type : Type]
          [expected-type : (Maybe Type)])
  : (Maybe (Dict Bytes Type))
  (case expected-type
    [(nothing)
     (case type-vars
       [(empty) (just (make-dict bytes-cmp))]
       [_ (nothing)])]
    [(just t)
     (case (map-state
             (lambda ([type-var : Bytes] [s : UnificationVarSource])
               (case (uvar-source-next s)
                 [(tuple2 u s)
                  (tuple2 (tuple2 type-var u) s)]))
             type-vars
             (new-uvar-source))
       [(tuple2 type-var-uvars s)
        (let ([constraints
                (cons
                  (eq-constraint
                    (type->constrainable t (make-dict bytes-cmp))
                    (type->constrainable
                      result-type
                      (dict-add-all (make-dict bytes-cmp) type-var-uvars)))
                  (map
                    (lambda ([t : (Tuple2 Bytes UnificationVar)])
                      (case t
                        [(tuple2 _ uvar)
                         (star-kind-constraint uvar)]))
                    type-var-uvars))])
          (case (unify constraints)
            [(nothing) (nothing)]
            [(just uvar-dict)
             (case (extract-justs
                     (map
                       (lambda ([t : (Tuple2 Bytes UnificationVar)]) : (Maybe (Tuple2 Bytes Type))
                         (case t
                           [(tuple2 tvar uvar)
                            (case (dict-ref uvar-dict uvar)
                              [(nothing) (nothing)]
                              [(just type) (just (tuple2 tvar type))])]))
                       type-var-uvars))
               [(nothing)
                (nothing)]
               [(just tvar-types)
                (just (dict-add-all (make-dict bytes-cmp) tvar-types))])]))])]))

(define (type-check/expr
          [expr : Expression]
          [context : Context]
          [expected-type : (Maybe Type)]) : (Either Bytes Type)
  (case expr
    [(var-expr v)
     (case (context-ref-value context v)
       [(nothing) (left (bytes-append (varargs list #"Untyped variable: " v)))]
       [(just t) (check-expected t expected-type)])]
    [(int-literal v)
     (check-expected (int-type) expected-type)]
    [(bytes-literal v)
     (check-expected (bytes-type) expected-type)]
    [(boolean-literal v)
     (check-expected (boolean-type) expected-type)]
    [(if-expr c t f)
     (case (type-check/expr c context (just (boolean-type)))
       [(left v) (left v)]
       [(right _)
        (case (type-check/expr t context expected-type)
          [(left v) (left v)]
          [(right t-type)
           (case (type-check/expr f context expected-type)
             [(left v) (left v)]
             [(right f-type)
              (if (type=? t-type f-type)
                  (right t-type)
                  (left #"Branches of if don't match"))])])])]
    [(begin-expr void-exprs last-expr)
     (case (type-check/begin-exprs void-exprs context)
       [(just v) (left v)]
       [(nothing)
        (type-check/expr last-expr context expected-type)])]
    [(let-expr name expr body)
     (case (type-check/expr expr context (nothing))
       [(left v) (left v)]
       [(right expr-type)
        (type-check/expr
          body
          (context-set-value context name expr-type)
          expected-type)])]
    [(annotated-expr type expr)
     (case (type-check/expr expr context (just type))
       [(left v) (left v)]
       [(right actual-type)
        (check-expected actual-type expected-type)])]
    [(lambda-expr named-arg-types maybe-return-type body)
     (match-define arg-types
       (map (lambda ([t : (Tuple2 Bytes Type)]) (case t [(tuple2 _ ty) ty])) named-arg-types))
     (case
       (ann (Either Bytes (Maybe Type))
         (case maybe-return-type
           [(just return-type)
            (right (just return-type))]
           [(nothing)
            (case expected-type
              [(nothing) (right (nothing))]
              [(just expected-type)
               (case expected-type
                 [(fun-type (empty) _ expected-body-type)
                  (right (just expected-body-type))]
                 [_
                  (left #"Lambda can only match monomorphic function type.")])])]))
       [(left v) (left v)]
       [(right inner-expected-type)
        (case (type-check/expr
                body
                (context-set-values context named-arg-types)
                inner-expected-type)
           [(left v) (left v)]
           [(right return-type)
            (check-expected
             (fun-type (empty) arg-types return-type)
             expected-type)])])]
    [(app-expr _ op args)
     (case (type-check/expr op context (nothing))
       [(left v) (left v)]
       [(right (fun-type type-vars arg-types result-type))
        (case (zip args arg-types)
          [(nothing)
           (left
             (bytes-append
               (varargs list
                 #"Cannot apply function: wrong number of arguments."
                 #"\nGot: " (integer->decimal-bytes (length args))
                 #"\nExpected: " (integer->decimal-bytes (length arg-types)))))]
          [(just merged-args)
           (match-define maybe-subst
             (attempt-result-based-unification type-vars result-type expected-type))
           (case
             (extract-rights
               (map (lambda ([arg : (Tuple2 Expression Type)])
                      (case arg
                        [(tuple2 arg type)
                         (case maybe-subst
                           [(nothing) (type-check/expr arg context (nothing))]
                           [(just subst) (type-check/expr arg context
                                                          (just (substitute type subst)))])]))
                    merged-args))
             [(left v) (left v)]
             [(right actual-arg-types)
              (match-define (tuple2 type-var-uvars s)
                (map-state
                  (lambda ([type-var : Bytes] [s : UnificationVarSource])
                    (case (uvar-source-next s)
                      [(tuple2 u s)
                       (tuple2 (tuple2 type-var u) s)]))
                  type-vars
                  (new-uvar-source)))
              (match-define (tuple2 u s) (uvar-source-next s))
              (match-define constraints
                  (cons
                    (eq-constraint
                      (type->constrainable
                        (fun-type (empty) arg-types result-type)
                        (dict-add-all (make-dict bytes-cmp) type-var-uvars))
                      (constrain-fun-type
                        (map (lambda ([arg-type : Type])
                               (type->constrainable arg-type (make-dict bytes-cmp)))
                             actual-arg-types)
                        (constrain-uvar u)))
                    (map
                      (lambda ([type-var-uvar : (Tuple2 Bytes UnificationVar)])
                        (case type-var-uvar
                          [(tuple2 _ uvar)
                           (star-kind-constraint uvar)]))
                      type-var-uvars)))
             (match-define constraints
               (case expected-type
                 [(nothing) constraints]
                 [(just t)
                  (cons
                    (eq-constraint
                      (constrain-uvar u)
                      (type->constrainable t (make-dict bytes-cmp)))
                    constraints)]))
              (case (unify constraints)
                [(nothing)
                 (left
                   (bytes-append
                     (map
                       (lambda ([c : Constraint])
                         (bytes-append (varargs list (constraint->bytes c) #"\n")))
                       constraints)))]
                [(just uvar-dict)
                 (case (dict-ref uvar-dict u)
                   [(nothing)
                    (left #"No binding for uvar in output of unification")]
                   [(just type)
                    (check-expected type expected-type)])])])])]
       [(right t)
        (left
          (bytes-append
            (varargs list #"Cannot apply non function: " (print-sexp (type->sexp t)))))])]
    [(varargs-app-expr _ op args)
     (case (type-check/expr op context (nothing))
       [(left v) (left v)]
       [(right (fun-type type-vars
                         (cons (abstract-type (mod-name (cons #"prim" (empty)))
                                              #"Array"
                                              (cons arg-type (empty))
                                              _) (empty))
                         result-type))
        (match-define maybe-subst
          (attempt-result-based-unification type-vars result-type expected-type))
        (case
          (extract-rights
            (map (lambda ([arg : Expression])
                   (case maybe-subst
                     [(nothing)
                      (type-check/expr arg context (nothing))]
                     [(just subst)
                      (type-check/expr arg context (just (substitute arg-type subst)))]))
                 args))
          [(left v) (left v)]
          [(right actual-types)
           (match-define (tuple2 type-var-uvars s)
             (map-state
               (lambda ([type-var : Bytes] [s : UnificationVarSource])
                 (case (uvar-source-next s)
                   [(tuple2 u s)
                    (tuple2 (tuple2 type-var u) s)]))
               type-vars
               (new-uvar-source)))
           (match-define type-var-uvar-dict : (Dict Bytes UnificationVar)
             (dict-add-all (make-dict bytes-cmp) type-var-uvars))
           (match-define (tuple2 u s) (uvar-source-next s))
           (match-define constraints
             (cons
               (eq-constraint
                 (type->constrainable result-type type-var-uvar-dict)
                 (constrain-uvar u))
               (append
                 (map
                   (lambda ([t : Type])
                     (eq-constraint
                       (type->constrainable t type-var-uvar-dict)
                       (type->constrainable arg-type type-var-uvar-dict)))
                   actual-types)
                 (map
                   (lambda ([type-var-uvar : (Tuple2 Bytes UnificationVar)])
                     (case type-var-uvar
                       [(tuple2 _ uvar)
                        (star-kind-constraint uvar)]))
                   type-var-uvars))))
           (case (unify constraints)
             [(nothing)
              (left
                (bytes-append
                  (map
                    (lambda ([c : Constraint])
                      (bytes-append (varargs list (constraint->bytes c) #"\n")))
                    constraints)))]
             [(just uvar-dict)
              (case (dict-ref uvar-dict u)
                [(nothing)
                 (left #"No binding for uvar in output of unification")]
                [(just type)
                 (check-expected type expected-type)])])])]
       [(right t)
        (case t
          [(fun-type _ _ _)
           (left
             (bytes-append
               (varargs list #"Cannot varargs apply function that doesn't take a single arary: "
                        (print-sexp (type->sexp t)))))]
          [_
           (left
             (bytes-append
               (varargs list #"Cannot apply non function: " (print-sexp (type->sexp t)))))])])]
    [(case-expr op clauses)
     (case (type-check/expr op context (nothing))
       [(left v) (left v)]
       [(right type)
        (case (extract-rights
                (map
                  (lambda ([clause : CaseClause])
                    (case clause
                      [(case-clause p body)
                       (type-check/case-clause p body context type expected-type)]))
                  clauses))
          [(left v) (left v)]
          [(right types)
           (case (set-split (set-add-all (make-set type-cmp) types))
             [(nothing)
              (left #"Cannot have case expression with no clauses")]
             [(just (tuple2 type other-types))
              (if (set-empty? other-types)
                  (case (totality-check-patterns context (map case-clause-pattern clauses))
                    [(just v) (left v)]
                    [(nothing) (right type)])
                  (left (bytes-append
                          (cons
                            #"Conflicting types in case clauses:\n"
                            (interleave
                              (map
                                (lambda ([t : Type]) (print-sexp (type->sexp t)))
                                types)
                              #"\n")))))])])])]))

(define (type-check/block
          [defs : (List BlockDefinition)]
          [body : Expression]
          [context : Context]
          [expected-type : (Maybe Type)]) : (Either Bytes Type)
  (case defs
    [(empty) (type-check/expr body context expected-type)]
    [(cons (match-def pattern def-expected-type expr) defs)
     (case (totality-check-patterns context (varargs list pattern))
       [(just v) (left v)]
       [(nothing)
        (case (type-check/expr expr context def-expected-type)
          [(left v) (left v)]
          [(right type)
           (case (type-check/pattern pattern context type)
             [(left v) (left v)]
             [(right context)
              (type-check/block defs body context expected-type)])])])]))

(define (type-check/pattern [pattern : Pattern] [context : Context] [arg-type : Type])
  : (Either Bytes Context)
  (case (type-check/pattern* pattern context arg-type (empty))
    [(left v) (left v)]
    [(right var-types)
     (right (context-set-values context var-types))]))

(define (type-check/pattern* [pattern : Pattern] [context : Context] [arg-type : Type]
                             [var-types : (List (Tuple2 Bytes Type))])
  : (Either Bytes (List (Tuple2 Bytes Type)))
  (case pattern
    [(bytes-pattern _)
     (if (type=? arg-type (bytes-type))
         (right var-types)
         (left #"Cannot match _ against bytes literal"))]
    [(int-pattern _)
     (if (type=? arg-type (int-type))
         (right var-types)
         (left #"Cannot match _ against int literal"))]
    [(variable-pattern v)
     (right (cons (tuple2 v arg-type) var-types))]
    [(ignore-pattern)
     (right var-types)]
    [(abstraction-pattern name sub-patterns)
     (case (context-ref-pattern context name)
       [(nothing)
        (left (bytes-append (varargs list #"Couldn't find pattern \"" name #"\"in context")))]
       [(just (pattern-descriptor pat-mod-name pat-type-name input-field-types _ _ _))
        (case arg-type
          [(abstract-type arg-mod-name arg-type-name arg-sub-types _)
           (if (and (mod-name=? arg-mod-name pat-mod-name)
                    (bytes=? arg-type-name pat-type-name))
               (let ([field-types
                      (map (lambda ([f : ((List Type) -> Type)]) (f arg-sub-types))
                           input-field-types)])
                 (case (zip sub-patterns field-types)
                   [(nothing)
                    (left (bytes-append
                            (varargs list
                              #"Number of fields doesn't match number of subpatterns:"
                              #" Pattern: " name
                              #" Fields: " (integer->decimal-bytes (length field-types))
                              #" Subpatterns: " (integer->decimal-bytes (length sub-patterns)))))]
                   [(just sub-pattern-types)
                    (type-check/patterns* sub-pattern-types context var-types)]))
               (left #"Got pattern for different type"))]
          [_ (left #"Abstraction pattern cannot match non abstract-type")])])]))

(define (type-check/patterns* [zipped : (List (Tuple2 Pattern Type))] [context : Context]
                              [var-types : (List (Tuple2 Bytes Type))])
  : (Either Bytes (List (Tuple2 Bytes Type)))
  (case zipped
    [(empty) (right var-types)]
    [(cons (tuple2 pat type) zipped)
     (case (type-check/pattern* pat context type var-types)
       [(left v) (left v)]
       [(right var-types)
        (type-check/patterns* zipped context var-types)])]))

(define (type-check/case-clause
          [pattern : Pattern]
          [block : Block]
          [context : Context]
          [argument-type : Type]
          [expected-type : (Maybe Type)]) : (Either Bytes Type)
  (case (type-check/pattern pattern context argument-type)
    [(left v) (left v)]
    [(right context)
     (case block
       [(block defs body)
        (type-check/block defs body context expected-type)])]))

(define (a b s) (map-state [f : (a s -> (Tuple2 b s))] [l : (List a)] [s : s]) : (Tuple2 (List b) s)
  (case l
    [(empty) (tuple2 (empty) s)]
    [(cons e l)
     (case (f e s)
       [(tuple2 v s)
        (case (map-state f l s)
          [(tuple2 vs s)
           (tuple2 (cons v vs) s)])])]))



(define (type-check [mod : Module]) : (Either TypeCheckError Context)
  (match-define (module name _ _ _ definitions) mod)
  (match-define context (create-context mod))
  (case (filter-map
          (lambda ([def : FunctionDefinition]) (type-check/definition def context))
          definitions)
    [(empty) (right context)]
    [vs
     (left (type-check-error name vs))]))
