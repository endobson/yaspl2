#:module (type-checker)
#:import {
  (bytes)
  (data source-location)
  (dict)
  (either)
  {(expanded-datatypes-language)
    {#:types
      Block
      BlockDefinition
      CaseClause
      DatatypeDefinition
      Export
      Expression
      FunctionArg
      FunctionDefinition
      Imports
      Module
      Pattern
      StaticDefinition
    }
    {#:values
      case-clause-pattern
      function-arg-type
      function-definition-name
      pattern-source-span
    }
    {#:patterns
      abstraction-pattern
      annotated-expr
      app-expr
      begin-expr
      block
      boolean-literal
      bytes-literal
      bytes-pattern
      case-clause
      case-expr
      export
      exports
      function-arg
      function-definition
      if-expr
      ignore-pattern
      imports
      int-literal
      int-pattern
      lambda-expr
      let-expr
      match-def
      module
      var-expr
      varargs-app-expr
      varargs-definition
      variable-pattern
      variant-accessor
      variant-constructor
    }
  }
  (list)
  (maybe)
  (module-name)
  (module-signature)
  (numbers)
  (prim)
  (prim-types)
  (set)
  (sexp-printer)
  (totality-checker)
  (tuples)
  {(type-checked-language)
    {#:types
      [Module tc:Module]
      [ValueExport tc:ValueExport]
    }
    {#:values
      [exports tc:exports]
      [module tc:module]
      [value-export tc:value-export]
    }
  }
  (type-checker-context)
  (type-unification)
  (types)
}
(export
  (#:values type-check
            type-check/expr
            attempt-result-based-unification
            type-check-errors->bytes)
  (#:patterns type-check-error))
(types
  (define-type TypeCheckErrors
    (type-check-errors
      [module-name : ModName]
      [errors : (List TypeCheckError)]))
  (define-type TypeCheckError
    (type-check-error
      [message : Bytes]
      [source : SourceSpan])))

(define (type-check-errors->bytes [err : TypeCheckErrors]) : Bytes
  (match-define (type-check-errors name errors) err)
  (bytes-append (append (varargs list #"Module: " (mod-name->bytes name) #"\n")
                        (interleave (map type-check-error->bytes errors) #"\n\n"))))

(define (type-check-error->bytes [err : TypeCheckError]) : Bytes
  (match-define (type-check-error message source) err)
  (bytes-append
    (varargs list
      #"Location: " (source-span->start-location-bytes source) #"\n" message)))

(define (imports->context [imports : Imports]) : Context
  (case imports
    [(imports values statics _)
     (context (dict-value-map values value-signature-type)
              (make-dict bytes-cmp)
              (dict-value-map
                statics
                (lambda ([sig : StaticSignature])
                  (case sig
                    [(varargs-signature type-vars arg-type return-type _ _)
                     (varargs-info type-vars arg-type return-type)]))))]))

(define (datatype-definitions->context [defs : (List DatatypeDefinition)]) : Context
  (context
    (dict-add-all
      (make-dict bytes-cmp)
      (map
        (lambda ([def : DatatypeDefinition])
          (case def
            [(variant-constructor variant-name type _ _ _ _)
             (tuple2 variant-name type)]
            [(variant-accessor name type _ _)
             (tuple2 name type)]))
        defs))
    (make-dict bytes-cmp)
    (make-dict bytes-cmp)))

(define (patterns->context [patterns : (Dict Bytes PatternSignature)]) : Context
  (context
    (make-dict bytes-cmp)
    (dict-value-map
      patterns
      (lambda ([sig : PatternSignature])
        (case sig
          [(pattern-signature
             (source-variant-info variant-name pat-mod-name pat-type-name type-vars
                                  input-field-types all-variants)
             _)
           (pattern-info variant-name all-variants pat-mod-name pat-type-name type-vars
                         input-field-types)])))
    (make-dict bytes-cmp)))

(define (function-definition->type [def : FunctionDefinition]) : Type
  (case def
    [(function-definition _ type-vars args (source-span-annotated result-type _) _)
     (match-define arg-types (map function-arg-type args))
     (fun-type type-vars arg-types result-type)]))

(define (function-definitions->context [defs : (List FunctionDefinition)])
  : Context
  (context
    (dict-add-all
      (make-dict bytes-cmp)
      (map
        (lambda ([def : FunctionDefinition]) : (Tuple2 Bytes Type)
          (tuple2 (function-definition-name def)
                  (function-definition->type def)))
        defs))
    (make-dict bytes-cmp)
    (make-dict bytes-cmp)))

(define (static-definitions->context [defs : (List StaticDefinition)])
  : Context
  (context
    (make-dict bytes-cmp)
    (make-dict bytes-cmp)
    (dict-add-all
      (make-dict bytes-cmp)
      (map
        (lambda ([def : StaticDefinition]) : (Tuple2 Bytes StaticInfo)
          (case def
            [(varargs-definition name type-vars arg-type return-type _ _)
             (tuple2 name (varargs-info type-vars arg-type return-type))]))
        defs))))

(define (create-context [mod : Module]) : Context
  (case mod
    [(module _ imports _ fun-defs datatypes patterns static-defs)
     (merge-contexts*
       (varargs list
         (imports->context imports)
         (function-definitions->context fun-defs)
         (static-definitions->context static-defs)
         (datatype-definitions->context datatypes)
         (patterns->context patterns)))]))

(define (type-check/definition
          [def : FunctionDefinition]
          [context : Context]) : (Maybe TypeCheckError)
  (match-define (function-definition name _ args result body) def)
  (case (type-check/function-args args context)
    [(left v) (just v)]
    [(right context)
     (case result
       [(source-span-annotated (type-constructor mod-name type-name _) src)
        (just (type-check-error
                (bytes-append (varargs list
                                       #"Function: " name #"\n"
                                       #"Return type cannot be a type constructor. Got: "
                                       (mod-name->bytes mod-name) #" " type-name))
                src))]

       [(source-span-annotated result _)
        (case (type-check/block body context (just result))
          [(left (type-check-error v src))
           (just (type-check-error (bytes-append (varargs list #"Function: " name #"\n" v)) src))]
          [(right _) (nothing)])])]))

(define (check-expected [type : Type] [expected : (Maybe Type)] [source : SourceSpan])
  : (Either TypeCheckError Type)
  (case expected
    [(nothing) (right type)]
    [(just ex-type)
     (if (type=? type ex-type)
         (right type)
         (left
           (type-check-error
             (bytes-append
               (varargs list
                 #"Types don't match:\nGot: "
                 (print-sexp (type->sexp type))
                 #"\nExpected: "
                 (print-sexp (type->sexp ex-type))))
             source)))]))

(define (type-check/begin-exprs
          [exprs : (List Expression)]
          [context : Context]) : (Maybe TypeCheckError)
  (case exprs
    [(empty)
     (nothing)]
    [(cons expr exprs)
     (case (type-check/expr expr context (just (void-type)))
       [(left v) (just v)]
       [(right _)
        (type-check/begin-exprs exprs context)])]))


(define (attempt-result-based-unification
          [type-vars : (List Bytes)]
          [result-type : Type]
          [expected-type : (Maybe Type)])
  : (Maybe (Dict Bytes Type))
  (case expected-type
    [(nothing)
     (case type-vars
       [(empty) (just (make-dict bytes-cmp))]
       [_ (nothing)])]
    [(just t)
     (attempt-unification type-vars result-type t)]))

(define (attempt-unification [type-vars : (List Bytes)] [t : Type] [final-type : Type])
  : (Maybe (Dict Bytes Type))
  (match-define (tuple2 type-var-uvars _s)
    (type-vars->unification-vars type-vars))
  (match-define constraints
    (cons
      (eq-constraint
        (type->constrainable final-type (make-dict bytes-cmp))
        (type->constrainable
          t
          (dict-add-all (make-dict bytes-cmp) type-var-uvars)))
      (tvar-star-kind-constraints type-var-uvars)))
  (case (unify constraints)
    [(nothing) (nothing)]
    [(just uvar-dict)
     (case (extract-justs
             (map
               (lambda ([t : (Tuple2 Bytes UnificationVar)]) : (Maybe (Tuple2 Bytes Type))
                 (case t
                   [(tuple2 tvar uvar)
                    (case (dict-ref uvar-dict uvar)
                      [(nothing) (nothing)]
                      [(just type) (just (tuple2 tvar type))])]))
               type-var-uvars))
       [(nothing)
        (nothing)]
       [(just tvar-types)
        (just (dict-add-all (make-dict bytes-cmp) tvar-types))])]))

(define (instantiates-as? [s : Type] [t : Type]) : Boolean
  (case s
    [(fun-type type-vars args result)
     (case (attempt-unification type-vars (fun-type (empty) args result) t)
       [(nothing) #f]
       [(just _) #t])]
    [_ (type=? s t)]))

(define (type-check/expr
          [expr : Expression]
          [context : Context]
          [expected-type : (Maybe Type)]) : (Either TypeCheckError Type)
  (case expr
    [(var-expr v src)
     (case (context-ref-value context v)
       [(nothing) (left (type-check-error (bytes-append (varargs list #"Untyped variable: " v)) src))]
       [(just t) (check-expected t expected-type src)])]
    [(int-literal _ src)
     (check-expected (int-type) expected-type src)]
    [(bytes-literal _ src)
     (check-expected (bytes-type) expected-type src)]
    [(boolean-literal _ src)
     (check-expected (boolean-type) expected-type src)]
    [(if-expr c t f src)
     (case (type-check/expr c context (just (boolean-type)))
       [(left v) (left v)]
       [(right _)
        (case (type-check/expr t context expected-type)
          [(left v) (left v)]
          [(right t-type)
           (case (type-check/expr f context expected-type)
             [(left v) (left v)]
             [(right f-type)
              (if (type=? t-type f-type)
                  (right t-type)
                  (left (type-check-error #"Branches of if don't match" src)))])])])]
    [(begin-expr void-exprs last-expr _)
     (case (type-check/begin-exprs void-exprs context)
       [(just v) (left v)]
       [(nothing)
        (type-check/expr last-expr context expected-type)])]
    [(let-expr name expr body _)
     (case (type-check/expr expr context (nothing))
       [(left v) (left v)]
       [(right expr-type)
        (type-check/block
          body
          (context-set-value context name expr-type)
          expected-type)])]
    [(annotated-expr type expr src)
     (case (type-check/expr expr context (just type))
       [(left v) (left v)]
       [(right actual-type)
        (check-expected actual-type expected-type src)])]
    [(lambda-expr args maybe-return-type body src)
     (case
       (ann (Either TypeCheckError (Maybe Type))
         (case maybe-return-type
           [(just return-type)
            (right (just return-type))]
           [(nothing)
            (case expected-type
              [(nothing) (right (nothing))]
              [(just expected-type)
               (case expected-type
                 [(fun-type (empty) _ expected-body-type)
                  (right (just expected-body-type))]
                 [_
                  (left (type-check-error #"Lambda can only match monomorphic function type." src))])])]))
       [(left v) (left v)]
       [(right inner-expected-type)
        (case (type-check/function-args args context)
          [(left v) (left v)]
          [(right context)
           (case (type-check/block body context inner-expected-type)
             [(left v) (left v)]
             [(right return-type)
              (check-expected
               (fun-type (empty) (map function-arg-type args) return-type)
               expected-type
               src)])])])]
    [(app-expr _ op args src)
     (case (type-check/expr op context (nothing))
       [(left v) (left v)]
       [(right (fun-type type-vars arg-types result-type))
        (case (zip args arg-types)
          [(nothing)
           (left
             (type-check-error
               (bytes-append
                 (varargs list
                   #"Cannot apply function: wrong number of arguments."
                   #"\nGot: " (integer->decimal-bytes (length args))
                   #"\nExpected: " (integer->decimal-bytes (length arg-types))))
               src))]
          [(just merged-args)
           (match-define maybe-subst
             (attempt-result-based-unification type-vars result-type expected-type))
           (case
             (extract-rights
               (map (lambda ([arg : (Tuple2 Expression Type)])
                      (case arg
                        [(tuple2 arg type)
                         (case maybe-subst
                           [(nothing) (type-check/expr arg context (nothing))]
                           [(just subst) (type-check/expr arg context
                                                          (just (substitute-types type subst)))])]))
                    merged-args))
             [(left v) (left v)]
             [(right actual-arg-types)
              (match-define (tuple2 type-var-uvars s)
                (type-vars->unification-vars type-vars))
              (match-define (tuple2 u _s) (uvar-source-next s))
              (match-define constraints
                  (cons
                    (eq-constraint
                      (type->constrainable
                        (fun-type (empty) arg-types result-type)
                        (dict-add-all (make-dict bytes-cmp) type-var-uvars))
                      (constrain-fun-type
                        (map (lambda ([arg-type : Type])
                               (type->constrainable arg-type (make-dict bytes-cmp)))
                             actual-arg-types)
                        (constrain-uvar u)))
                    (tvar-star-kind-constraints type-var-uvars)))
              (match-define constraints
                (case expected-type
                  [(nothing) constraints]
                  [(just t)
                   (cons
                     (eq-constraint
                       (constrain-uvar u)
                       (type->constrainable t (make-dict bytes-cmp)))
                     constraints)]))
              (case (unify constraints)
                [(nothing)
                 (left
                   (type-check-error
                     (bytes-append
                       (map
                         (lambda ([c : Constraint])
                           (bytes-append (varargs list (constraint->bytes c) #"\n")))
                         constraints))
                     src))]
                [(just uvar-dict)
                 (case (dict-ref uvar-dict u)
                   [(nothing)
                    (left (type-check-error #"No binding for uvar in output of unification" src))]
                   [(just type)
                    (check-expected type expected-type src)])])])])]
       [(right t)
        (left
          (type-check-error
            (bytes-append
              (varargs list #"Cannot apply non function: " (print-sexp (type->sexp t))))
            src))])]
    [(varargs-app-expr _ (source-span-annotated op op-src) args src)
     (case (context-ref-static context op)
       [(nothing)
        (left (type-check-error #"Unbound static" op-src))]
       [(just (varargs-info type-vars arg-type return-type))
        (match-define expected-arg-type : (Maybe Type)
          (case (attempt-result-based-unification type-vars return-type expected-type)
            [(nothing) (nothing)]
            [(just subst)
             (just (substitute-types arg-type subst))]))
        (case
          (extract-rights
            (map (lambda ([arg : Expression])
                   (type-check/expr arg context expected-arg-type))
                 args))
          [(left v) (left v)]
          [(right actual-types)
           (match-define (tuple2 type-var-uvars s)
             (type-vars->unification-vars type-vars))
           (match-define type-var-uvar-dict : (Dict Bytes UnificationVar)
             (dict-add-all (make-dict bytes-cmp) type-var-uvars))
           (match-define (tuple2 u _s) (uvar-source-next s))
           (match-define constraints
             (cons
               (eq-constraint
                 (type->constrainable return-type type-var-uvar-dict)
                 (constrain-uvar u))
               (append
                 (map
                   (lambda ([t : Type])
                     (eq-constraint
                       (type->constrainable t type-var-uvar-dict)
                       (type->constrainable arg-type type-var-uvar-dict)))
                   actual-types)
                 (tvar-star-kind-constraints type-var-uvars))))
           (case (unify constraints)
             [(nothing)
              (left
                (type-check-error
                  (bytes-append
                    (map
                      (lambda ([c : Constraint])
                        (bytes-append (varargs list (constraint->bytes c) #"\n")))
                      constraints))
                  src))]
             [(just uvar-dict)
              (case (dict-ref uvar-dict u)
                [(nothing)
                 (left (type-check-error #"No binding for uvar in output of unification" src))]
                [(just type)
                 (check-expected type expected-type src)])])])])]
    [(case-expr op clauses src)
     (case (type-check/expr op context (nothing))
       [(left v) (left v)]
       [(right type)
        (case (extract-rights
                (map
                  (lambda ([clause : CaseClause])
                    (case clause
                      [(case-clause p body)
                       (type-check/case-clause p body context type expected-type)]))
                  clauses))
          [(left v) (left v)]
          [(right types)
           (case (set-split (set-add-all (make-set type-cmp) types))
             [(nothing)
              (left (type-check-error #"Cannot have case expression with no clauses" src))]
             [(just (tuple2 type other-types))
              (if (set-empty? other-types)
                  (case (totality-check-patterns context (map case-clause-pattern clauses))
                    [(just v) (left (type-check-error v src))]
                    [(nothing) (right type)])
                  (left (type-check-error
                          (bytes-append
                            (cons
                              #"Conflicting types in case clauses:\n"
                              (interleave
                                (map
                                  (lambda ([t : Type]) (print-sexp (type->sexp t)))
                                  types)
                                #"\n")))
                          src)))])])])]))

(define (type-check/block
          [body : Block]
          [context : Context]
          [expected-type : (Maybe Type)]) : (Either TypeCheckError Type)
  (match-define (block defs expr) body)
  (type-check/block* defs expr context expected-type))

(define (type-check/block*
          [defs : (List BlockDefinition)]
          [body : Expression]
          [context : Context]
          [expected-type : (Maybe Type)]) : (Either TypeCheckError Type)
  (case defs
    [(empty) (type-check/expr body context expected-type)]
    [(cons (match-def pattern def-expected-type expr) defs)
     (case (totality-check-patterns context (varargs list pattern))
       [(just v) (left (type-check-error v (pattern-source-span pattern)))]
       [(nothing)
        (case (type-check/expr expr context def-expected-type)
          [(left v) (left v)]
          [(right type)
           (case (type-check/pattern pattern context type)
             [(left v) (left v)]
             [(right context)
              (type-check/block* defs body context expected-type)])])])]))

(define (type-check/pattern [pattern : Pattern] [context : Context] [arg-type : Type])
  : (Either TypeCheckError Context)
  (case (type-check/pattern* pattern context arg-type (empty))
    [(left v) (left v)]
    [(right var-types)
     (right (context-set-values context var-types))]))

(define (type-check/pattern* [pattern : Pattern] [context : Context] [arg-type : Type]
                             [var-types : (List (Tuple2 Bytes Type))])
  : (Either TypeCheckError (List (Tuple2 Bytes Type)))
  (case pattern
    [(bytes-pattern _ src)
     (if (type=? arg-type (bytes-type))
         (right var-types)
         (left (type-check-error #"Cannot match _ against bytes literal" src)))]
    [(int-pattern _ src)
     (if (type=? arg-type (int-type))
         (right var-types)
         (left (type-check-error #"Cannot match _ against int literal" src)))]
    [(variable-pattern v _)
     (right (cons (tuple2 v arg-type) var-types))]
    [(ignore-pattern _)
     (right var-types)]
    [(abstraction-pattern pattern-name sub-patterns src)
     (case (context-ref-pattern context pattern-name)
       [(nothing) (left (type-check-error #"Unbound pattern" src))]
       [(just (pattern-info variant-name _ pat-mod-name pat-type-name type-vars input-field-types))
        (case arg-type
          [(abstract-type arg-mod-name arg-type-name arg-sub-types _)
           (if (and (mod-name=? arg-mod-name pat-mod-name)
                    (bytes=? arg-type-name pat-type-name))
               (let ([field-types
                      (map (lambda ([field-type : Type]) : Type
                             (case (zip type-vars arg-sub-types)
                                     [(nothing) (panic #"Bad number of types")]
                                     [(just var-types)
                                      (substitute-types
                                        field-type
                                        (dict-add-all (make-dict bytes-cmp) var-types))]))
                           input-field-types)])
                 (case (zip sub-patterns field-types)
                   [(nothing)
                    (left (type-check-error
                            (bytes-append
                              (varargs list
                                #"Number of fields doesn't match number of subpatterns:"
                                #" Pattern: " variant-name
                                #" [" (mod-name->bytes pat-mod-name) #" " pat-type-name #"]"
                                #" Fields: " (integer->decimal-bytes (length field-types))
                                #" Subpatterns: " (integer->decimal-bytes (length sub-patterns))))
                            src))]
                   [(just sub-pattern-types)
                    (type-check/patterns* sub-pattern-types context var-types)]))
               (left (type-check-error
                       (bytes-append
                         (varargs list
                           #"Got pattern for different type:"
                           #" Pattern: " variant-name
                           #" Expected: " (mod-name->bytes arg-mod-name) #" " arg-type-name
                           #" Got: " (mod-name->bytes pat-mod-name) #" " pat-type-name))
                       src)))]
          [_ (left (type-check-error #"Abstraction pattern cannot match non abstract-type" src))])])]))

(define (type-check/patterns* [zipped : (List (Tuple2 Pattern Type))] [context : Context]
                              [var-types : (List (Tuple2 Bytes Type))])
  : (Either TypeCheckError (List (Tuple2 Bytes Type)))
  (case zipped
    [(empty) (right var-types)]
    [(cons (tuple2 pat type) zipped)
     (case (type-check/pattern* pat context type var-types)
       [(left v) (left v)]
       [(right var-types)
        (type-check/patterns* zipped context var-types)])]))

(define (type-check/case-clause
          [pattern : Pattern]
          [body : Block]
          [context : Context]
          [argument-type : Type]
          [expected-type : (Maybe Type)]) : (Either TypeCheckError Type)
  (case (type-check/pattern pattern context argument-type)
    [(left v) (left v)]
    [(right context)
     (type-check/block body context expected-type)]))


(define (type-check/function-args [args : (List FunctionArg)] [context : Context])
  : (Either TypeCheckError Context)
  (case (find/maybe
          (lambda ([arg : FunctionArg]) : (Maybe TypeCheckError)
            (case arg
              [(function-arg pattern _type)
               (case (totality-check-patterns context (varargs list pattern))
                 [(just v) (just (type-check-error v (pattern-source-span pattern)))]
                 [(nothing) (nothing)])]))
          args)
    [(just v) (left v)]
    [(nothing)
     (type-check/function-args* args context)]))

(define (type-check/function-args* [args : (List FunctionArg)] [context : Context])
  : (Either TypeCheckError Context)
  (case args
    [(empty) (right context)]
    [(cons (function-arg pattern arg-type) args)
     (case (type-check/pattern* pattern context arg-type (empty))
       [(left v) (left v)]
       [(right var-types)
        (type-check/function-args* args (context-set-values context var-types))])]))

(define (type-check/static-definition
          [def : StaticDefinition]
          [context : Context]) : (Maybe TypeCheckError)
  (case def
    [(varargs-definition _ _ arg-type return-type
                         (source-span-annotated cons-func cons-span)
                         (source-span-annotated empty-func empty-span))
     (case (context-ref-value context cons-func)
       [(nothing)
        (just (type-check-error #"Unbound varargs cons function" cons-span))]
       [(just cons-type)
        (if (instantiates-as? cons-type
                              (fun-type (empty) (varargs list arg-type return-type) return-type))
            (case (context-ref-value context empty-func)
              [(nothing)
               (just (type-check-error #"Unbound varargs empty function" empty-span))]
              [(just empty-type)
               (if (instantiates-as? empty-type (fun-type (empty) (empty) return-type))
                   (nothing)
                   (just (type-check-error #"Varargs empty function has bad type" empty-span)))])
            (just (type-check-error #"Varargs cons function has bad type" cons-span)))])]))

(define (type-vars->unification-vars [type-vars : (List Bytes)])
  : (Tuple2 (List (Tuple2 Bytes UnificationVar)) UnificationVarSource)
  (map/state
    (lambda ([type-var : Bytes] [s : UnificationVarSource])
      (case (uvar-source-next s)
        [(tuple2 u s)
         (tuple2 (tuple2 type-var u) s)]))
    type-vars
    (new-uvar-source)))

(define (tvar-star-kind-constraints [type-var-uvars : (List (Tuple2 Bytes UnificationVar))])
  : (List Constraint)
  (map
    (lambda ([type-var-uvar : (Tuple2 Bytes UnificationVar)])
      (case type-var-uvar
        [(tuple2 _ uvar)
         (star-kind-constraint uvar)]))
    type-var-uvars))

(define (convert-exports [m : Module] [ctx : Context]) : tc:Module
  (match-define (module name imports exports definitions datatypes patterns statics) m)
  (match-define (exports exported-types exported-values exported-patterns exported-statics) exports)
  (tc:module
    name
    imports
    (tc:exports
      exported-types
      (map
        (lambda ([export : Export]) : tc:ValueExport
          (case export
            [(export local exported)
             (case (context-ref-value ctx local)
               [(nothing) (panic #"Unbound export")]
               [(just type)
                (tc:value-export local exported type)])]))
        exported-values)
      exported-patterns
      exported-statics)
    definitions
    datatypes
    patterns
    statics))

(define (type-check [mod : Module]) : (Either TypeCheckErrors tc:Module)
  (match-define (module name _ _ definitions _ _ statics) mod)
  (match-define context (create-context mod))
  (case
    (append
      (filter-map
        (lambda ([def : FunctionDefinition]) (type-check/definition def context))
        definitions)
      (filter-map
        (lambda ([def : StaticDefinition]) (type-check/static-definition def context))
        statics))
    [(empty)
     (right (convert-exports mod context))]
    [vs
     (left (type-check-errors name vs))]))
