#:module (grammar-parser)
#:import {
  (bytes)
  (either)
  (list)
  (dict)
  (maybe)
  (prim)
  (sexp-parser)
}
(export
  (#:types)
  (#:values parse-grammar run-grammar)
  (#:patterns))
(types
  (define-type ParsedGrammar
    (parsed-grammar
      [rules : (List RawGrammarRule)]))
  (define-type RawGrammarRule
    (raw-grammar-full-rule [name : Bytes] [contents : RawGrammarExpr])
    (raw-grammar-sub-rule [name : Bytes] [sub-name : Bytes] [default : Boolean] [contents : RawGrammarExpr]))
  (define-type RawGrammarExprs
    (cons-rgexpr [head : RawGrammarExpr] [tail : RawGrammarExprs])
    (repeating-end-rgexpr [non-terminal : Bytes])
    (repeating-all-but-end-rgexpr [non-terminal-rep : Bytes] [non-terminal-end : Bytes])
    (empty-end-rgexpr))
  (define-type RawGrammarExpr
    (specific-keyword-rgexpr [kw : Bytes])
    (specific-symbol-rgexpr [sym : Bytes])
    (symbol-rgexpr)
    (sexp-rgexpr)
    (number-rgexpr)
    (bytes-rgexpr)
    (boolean-rgexpr)
    (non-terminal-rgexpr [name : Bytes])
    (node-rgexpr [body : RawGrammarExprs])
    (bracket-node-rgexpr [body : RawGrammarExprs])
    (brace-node-rgexpr [body : RawGrammarExprs]))

  (define-type JoinedGrammarRule
    (solo-rule [exprs : RawGrammarExprs])
    (multi-rule
      [parts : (Dict Bytes RawGrammarExprs)]
      [default : (Maybe RawGrammarExprs)])))

(define (parse-grammar [input : Bytes]) : (Either Bytes ParsedGrammar)
  (match-define lines (bytes-split input #"\n"))
  (match-define rule-lines (filter (lambda ([line : Bytes]) (> (bytes-length line) 0)) lines))
  (case (extract-rights (map parse-raw-grammar-rule rule-lines))
    [(left v) (left v)]
    [(right rules)
     (right (parsed-grammar (empty)))]))


(define (parse-raw-grammar-rule [input : Bytes]) : (Either Bytes RawGrammarRule)
  (case (parse-sexps input)
    [(left v) (left v)]
    [(right (cons (symbol-sexp rule-name) (cons (symbol-sexp #"=") (cons expr (empty)))))
     (case (parse-raw-grammar-expr expr)
       [(left v) (left v)]
       [(right exprs)
        (right (raw-grammar-full-rule rule-name exprs))])]
    [(right (cons (symbol-sexp rule-name)
                  (cons (symbol-sexp sub-name)
                        (cons (keyword-sexp #"default")
                              (cons (symbol-sexp #"=")
                                    (cons expr (empty)))))))
     (case (parse-raw-grammar-expr expr)
       [(left v) (left v)]
       [(right exprs)
        (right (raw-grammar-sub-rule rule-name sub-name #t exprs))])]
    [(right (cons (symbol-sexp rule-name)
                  (cons (symbol-sexp sub-name)
                        (cons (symbol-sexp #"=")
                              (cons expr empty)))))
     (case (parse-raw-grammar-expr expr)
       [(left v) (left v)]
       [(right exprs)
        (right (raw-grammar-sub-rule rule-name sub-name #f exprs))])]
    [(right _)
     (left (bytes-append (varargs list #"Unparsable rule: " input)))]))

(define (parse-raw-grammar-exprs [input : (List Sexp)]) : (Either Bytes RawGrammarExprs)
  (case input
    [(empty)
     (right (empty-end-rgexpr))]
    [(cons (symbol-sexp sym) (cons (symbol-sexp #"...") (empty)))
     (right (repeating-end-rgexpr sym))]
    [(cons (symbol-sexp sym-rep) (cons (symbol-sexp #"...") (cons (symbol-sexp sym-end) (empty))))
     (right (repeating-all-but-end-rgexpr sym-rep sym-end))]
    [(cons expr exprs)
     (case (parse-raw-grammar-expr expr)
       [(left v) (left v)]
       [(right expr)
        (case (parse-raw-grammar-exprs exprs)
          [(left v) (left v)]
          [(right exprs)
           (right (cons-rgexpr expr exprs))])])]))

(define (parse-raw-grammar-expr [input : Sexp]) : (Either Bytes RawGrammarExpr)
  (case input
    [(symbol-sexp #"...") (left #"Stray ...")]
    [(symbol-sexp #"SYMBOL") (right (symbol-rgexpr))]
    [(symbol-sexp #"SEXP") (right (sexp-rgexpr))]
    [(symbol-sexp #"BYTES") (right (bytes-rgexpr))]
    [(symbol-sexp #"NUMBER") (right (number-rgexpr))]
    [(symbol-sexp #"BOOLEAN") (right (boolean-rgexpr))]
    [(symbol-sexp sym)
     (if (all-caps-and-underscores? sym)
         (right (non-terminal-rgexpr sym))
         (right (specific-symbol-rgexpr sym)))]
    [(keyword-sexp kw) (right (specific-keyword-rgexpr kw))]
    [(node sexps)
     (case (parse-raw-grammar-exprs sexps)
       [(left v) (left v)]
       [(right exprs) (right (node-rgexpr exprs))])]
    [(bracket-node sexps)
     (case (parse-raw-grammar-exprs sexps)
       [(left v) (left v)]
       [(right exprs) (right (bracket-node-rgexpr exprs))])]
    [(brace-node sexps)
     (case (parse-raw-grammar-exprs sexps)
       [(left v) (left v)]
       [(right exprs) (right (brace-node-rgexpr exprs))])]
    [_
     (left #"Unknown form")]))

(define (all-caps-and-underscores? [sym : Bytes]) : Boolean
  (andmap
    (lambda ([char : Int]) : Boolean
      (or (= 95 char)
          (and (<= 65 char) (< char 91))))
    (build-list (bytes-length sym) (lambda ([index : Int]) (u8->s64 (bytes-ref sym index))))))

(define (join-rules [rules : (List RawGrammarRule)]) : (Either Bytes (Dict Bytes JoinedGrammarRule))
  (left #"Join-rules NYI"))

(define (R) (run-non-terminal [n : Bytes] [rules : (Dict Bytes JoinedGrammarRule)]
                              [action : (Bytes (List R) -> R)] [input : (List Sexp)])
  : (Either Bytes R)
  (case (dict-ref rules n)
    [(nothing) (left #"Error unbound nonterminal")]
    [(just (solo-rule exprs))
     (case (run-exprs exprs rules action input)
       [(left v) (left v)]
       [(right vals)
        (right (action n vals))])]
    [(just (multi-rule sub-rules default))
     (left #"Multi-rule NYI")]))


(define (R) (run-exprs [es : RawGrammarExprs] [rules : (Dict Bytes JoinedGrammarRule)]
                       [action : (Bytes (List R) -> R)] [input : (List Sexp)])
  : (Either Bytes (List R))
  (case es
    [(empty-end-rgexpr) (right (empty))]
    [_ (left #"Run-exprs NYI")]))


(define (R) (run-grammar [grammar : ParsedGrammar]
                         [root-rule : Bytes]
                         [action : (Bytes (List R) -> R)]
                         [input : (List Sexp)]) : (Either Bytes R)
  (match-define (parsed-grammar rules) grammar)
  (case (join-rules rules)
    [(left v) (left v)]
    [(right joined-rules)
     (left #"NYI")]))
