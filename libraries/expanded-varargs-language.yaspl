#:module (expanded-varargs-language)
#:import {
  (list)
  (maybe)
  (module-name)
  (prim)
  {(resolved-vars-language)
    {#:types
      [CaseClause rv:CaseClause]
      DatatypeDefinition
      Exports
      [Expression rv:Expression]
      FunctionArg
      [FunctionDefinition rv:FunctionDefinition]
      Imports
      [Module rv:Module]
      Pattern
      PatternExport
      TypeExport
      ValueExport
    }
    {#:values
      function-arg-name
      function-arg-type
    }
    {#:patterns
      abstraction-pattern
      [app-expr rv:app-expr]
      [begin-expr rv:begin-expr]
      [boolean-literal rv:boolean-literal]
      [bytes-literal rv:bytes-literal]
      bytes-pattern
      [case-clause rv:case-clause]
      [case-expr rv:case-expr]
      exports
      function-arg
      [function-definition rv:function-definition]
      [global-var-expr rv:global-var-expr]
      [if-expr rv:if-expr]
      imports
      [int-literal rv:int-literal]
      int-pattern
      [lambda-expr rv:lambda-expr]
      [let-expr rv:let-expr]
      [local-var-expr rv:local-var-expr]
      [module rv:module]
      pattern-export
      type-export
      value-export
      [varargs-app-expr rv:varargs-app-expr]
      variable-pattern
      variant-accessor
      variant-constructor
    }
  }
  (top-level-name)
  (types)
  (yaspl var)
}
(export
  (#:types DatatypeDefinition Exports Expression FunctionDefinition FunctionArg Imports Module
           PatternExport TypeExport ValueExport Pattern CaseClause)
  (#:values expand-varargs function-arg-type function-arg-name)
  (#:patterns app-expr begin-expr boolean-literal bytes-literal exports
              function-definition function-arg global-var-expr if-expr imports int-literal lambda-expr let-expr
              local-var-expr module pattern-export type-export value-export varargs-app-expr
              variant-constructor variant-accessor case-expr case-clause
              variable-pattern int-pattern bytes-pattern abstraction-pattern))
(types
  (define-type Module
    (module [name : ModName]
            [imports : Imports]
            [exports : Exports]
            [definitions : (List FunctionDefinition)]
            [datatype-definitions : (List DatatypeDefinition)]))

  (define-type FunctionDefinition
    (function-definition
      [function-name : TopLevelName]
      [closure-name : TopLevelName]
      [type-vars : (List Bytes)]
      [args : (List FunctionArg)]
      [return-type : Type]
      [next-var : VarNumber]
      [body : Expression]))

  (define-type Expression
    (int-literal [v : Int])
    (bytes-literal [v : Bytes])
    (boolean-literal [v : Boolean])
    (local-var-expr [v : Var])
    (global-var-expr [v : TopLevelName])
    (if-expr [cond : Expression] [true : Expression] [false : Expression])
    (begin-expr [exprs : (List Expression)] [last-expr : Expression])
    (app-expr [tail-position : Boolean] [op : Expression] [args : (List Expression)])
    (varargs-app-expr [tail-position : Boolean] [op : Expression] [args : (List Expression)])
    (let-expr [var : Var] [expr : Expression] [body : Expression])
    (lambda-expr [args : (List FunctionArg)] [type : (Maybe Type)] [body : Expression])
    (case-expr [expr : Expression] [clauses : (List CaseClause)]))

  (define-type CaseClause
    (case-clause [pattern : Pattern] [body : Expression])))

(define (expand-varargs [mod : rv:Module]) : Module
  (case mod
    [(rv:module name imports exports funcs datatype-defs)
     (module name imports exports (map expand-varargs/function-definition funcs) datatype-defs)]))

(define (expand-varargs/function-definition [fun : rv:FunctionDefinition]) : FunctionDefinition
  (case fun
    [(rv:function-definition function-name closure-name type-vars args return-type next-var body)
     (function-definition function-name closure-name type-vars args return-type next-var
                          (expand-varargs/expr body))]))

(define (expand-varargs/expr [expr : rv:Expression]) : Expression
  (case expr
    ;; Recur structurally
    [(rv:case-expr expr clauses)
     (case-expr (expand-varargs/expr expr) (map expand-varargs/clause clauses))]
    [(rv:int-literal v)
     (int-literal v)]
    [(rv:bytes-literal v)
     (bytes-literal v)]
    [(rv:boolean-literal v)
     (boolean-literal v)]
    [(rv:local-var-expr v)
     (local-var-expr v)]
    [(rv:global-var-expr v)
     (global-var-expr v)]
    [(rv:if-expr c t f )
     (if-expr (expand-varargs/expr c) (expand-varargs/expr t) (expand-varargs/expr f))]
    [(rv:begin-expr exprs last)
     (begin-expr (map expand-varargs/expr exprs) (expand-varargs/expr last))]
    [(rv:app-expr tail op args)
     (app-expr tail (expand-varargs/expr op) (map expand-varargs/expr args))]
    [(rv:varargs-app-expr tail op args)
     (varargs-app-expr tail (expand-varargs/expr op) (map expand-varargs/expr args))]
    [(rv:let-expr name expr body)
     (let-expr name (expand-varargs/expr expr) (expand-varargs/expr body))]
    [(rv:lambda-expr args type body)
     (lambda-expr args type (expand-varargs/expr body))]))


(define (expand-varargs/clause [clause : rv:CaseClause]) : CaseClause
  (case clause
    [(rv:case-clause pat body)
     (case-clause pat (expand-varargs/expr body))]))
