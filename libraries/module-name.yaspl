#:module (module-name)
#:import {
  (bytes) {
    #:values
      bytes<
      bytes=?
  }
  (maybe) {
    #:types
      Maybe
    #:values
      just
      nothing
  }
  (prim) {
    #:types
      Boolean
      Bytes
  }
  (sexp-parser) {
    #:types
      Sexp
    #:values
      bytes-sexp
    #:patterns
      bytes-sexp
  }
}
(export
  #:types (ModName)
  #:values (mod-name mod-name-v mod-name->bytes mod-name=? mod-name->sexp sexp->mod-name mod-name<)
  #:patterns (mod-name))
(types
  ;; TODO Come up with a better name to avoid the conflict of the accesor and constructor.
  (define-type ModName
    (mod-name [v : Bytes])))

(define (mod-name->bytes [m : ModName]) : Bytes
  (mod-name-v m))

(define (mod-name=? [m1 : ModName] [m2 : ModName]) : Boolean
  (bytes=? (mod-name-v m1) (mod-name-v m2)))

(define (mod-name< [m1 : ModName] [m2 : ModName]) : Boolean
  (bytes< (mod-name-v m1) (mod-name-v m2)))

(define (mod-name->sexp [m : ModName]) : Sexp
  (bytes-sexp (mod-name-v m)))

(define (sexp->mod-name [m : Sexp]) : (Maybe ModName)
  (case m
    [(bytes-sexp m)
     (just (mod-name m))]
    [_ (nothing)]))
