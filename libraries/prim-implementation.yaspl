#:module (prim-implementation)
#:import {
  (bytes) {
    #:values
      bytes-append
      bytes=?
      subbytes
  }
  (dict) {
    #:types
      Dict
    #:values
      dict-add-all
      dict-values
      make-dict
  }
  (list) {
    #:types
      List
    #:values
      append*
      cons
      empty
      list
      map
  }
  (module-signature) {
    #:types
      ModuleSignature
    #:values
      module-signature
  }
  (prim) {
    #:types
      Bytes
      Int
    #:values
      +
      -
      =
      >
      bytes-length
  }
  (set) {
    #:values
      make-set
      set->list
      set-add-all
  }
  (stack-machine) {
    #:types
      BinLogicMathOp
      BinMathOp
      StackCmd
      TopLevelObject
    #:values
      array-length-cmd
      array-ref-cmd
      array-set!-cmd
      bin-add-op
      bin-bitwise-and-op
      bin-bitwise-ior-op
      bin-logic-math-cmd
      bin-logical-shift-left-op
      bin-logical-shift-right-op
      bin-math-cmd
      bin-mult-op
      bin-quotient-op
      bin-remainder-op
      bin-sub-op
      dup-cmd
      equal-op
      function-tlo
      greater-than-op
      greater-than-or-equal-op
      less-than-op
      less-than-or-equal-op
      make-array-cmd
      return
      stack-basic-block
      stack-function
      trivial-closure-tlo
  }
  (tuples) {
    #:values
      tuple2
  }
  (types) {
    #:types
      Type
    #:values
      abstract-type
      fun-type
      star-kind
      type-constructor
      var-type
  }
}
(export
  #:types ()
  #:values (prim-signature prim-implementation prim-known-functions
            int-type boolean-type bytes-type void-type)
  #:patterns ())
(types)

(define (prim-values) : (Dict Bytes Bytes)
  (dict-add-all
    (make-dict bytes=?)
    (varargs list
      (tuple2 #"u8" #"prim_u8_closure")
      (tuple2 #"s32" #"prim_s32_closure")
      (tuple2 #"u32" #"prim_u32_closure")
      (tuple2 #"u8->s64" #"prim_u8_s64_closure")
      (tuple2 #"s32->s64" #"prim_s32_s64_closure")
      (tuple2 #"u32->s64" #"prim_u32_s64_closure")
      (tuple2 #"+" #"prim_add_closure")
      (tuple2 #"-" #"prim_sub_closure")
      (tuple2 #"*" #"prim_mult_closure")
      (tuple2 #"=" #"prim_equal_closure")
      (tuple2 #"<" #"prim_less_than_closure")
      (tuple2 #"<=" #"prim_less_than_or_equal_closure")
      (tuple2 #">" #"prim_greater_than_closure")
      (tuple2 #">=" #"prim_greater_than_or_equal_closure")
      (tuple2 #"bitwise-and" #"prim_bitwise_and_closure")
      (tuple2 #"bitwise-ior" #"prim_bitwise_ior_closure")
      (tuple2 #"logical-shift-left" #"prim_logical_shift_left_closure")
      (tuple2 #"logical-shift-right" #"prim_logical_shift_right_closure")
      (tuple2 #"bytes-ref" #"prim_bytes_ref_closure")
      (tuple2 #"make-bytes" #"prim_make_bytes_closure")
      (tuple2 #"bytes-set!" #"prim_bytes_set_closure")
      (tuple2 #"bytes-length" #"prim_bytes_length_closure")
      (tuple2 #"write-bytes" #"prim_write_bytes_closure")
      (tuple2 #"read-bytes" #"prim_read_bytes_closure")
      (tuple2 #"open-input-file" #"prim_open_input_file_closure")
      (tuple2 #"open-output-file" #"prim_open_output_file_closure")
      (tuple2 #"close-input-port" #"prim_close_port_closure")
      (tuple2 #"close-output-port" #"prim_close_port_closure")
      (tuple2 #"delete-file" #"prim_delete_file_closure")
      (tuple2 #"set-file-or-directory-permissions" #"prim_set_file_or_directory_permissions_closure")
      (tuple2 #"socket" #"prim_socket_closure")
      (tuple2 #"bind" #"prim_bind_closure")
      (tuple2 #"sendto" #"prim_sendto_closure")
      (tuple2 #"recvfrom" #"prim_recvfrom_closure")
      (tuple2 #"connect" #"prim_connect_closure")
      (tuple2 #"shutdown" #"prim_shutdown_closure")
      (tuple2 #"listen" #"prim_listen_closure")
      (tuple2 #"accept" #"prim_accept_closure")
      (tuple2 #"setsockopt" #"prim_setsockopt_closure")
      (tuple2 #"mach-port->u32" #"prim_u32_closure")
      (tuple2 #"u32->mach-port" #"prim_u32_closure")
      (tuple2 #"mach-task-self" #"prim_mach_task_self_closure")
      (tuple2 #"mach-thread-self" #"prim_mach_thread_self_closure")
      (tuple2 #"mach-reply-port" #"prim_mach_reply_port_closure")
      (tuple2 #"mach-msg" #"prim_mach_msg_closure")
      (tuple2 #"mach-port-mod-refs" #"prim_mach_port_mod_refs_closure")
      (tuple2 #"mach-start-thread" #"prim_mach_start_thread_closure")
      (tuple2 #"void" #"prim_void_closure")
      (tuple2 #"and" #"prim_and_closure")
      (tuple2 #"or" #"prim_or_closure")
      (tuple2 #"quotient" #"prim_quotient_closure")
      (tuple2 #"remainder" #"prim_remainder_closure")
      (tuple2 #"panic" #"prim_panic_closure")
      (tuple2 #"make-array" #"prim_make_array_closure")
      (tuple2 #"array-length" #"prim_array_length_closure")
      (tuple2 #"array-ref" #"prim_array_ref_closure")
      (tuple2 #"array-set!" #"prim_array_set_closure")
      (tuple2 #"u32/le-byte0" #"prim_quad_le_byte0_closure")
      (tuple2 #"u32/le-byte1" #"prim_quad_le_byte1_closure")
      (tuple2 #"u32/le-byte2" #"prim_quad_le_byte2_closure")
      (tuple2 #"u32/le-byte3" #"prim_quad_le_byte3_closure")
      (tuple2 #"s32/le-byte0" #"prim_quad_le_byte0_closure")
      (tuple2 #"s32/le-byte1" #"prim_quad_le_byte1_closure")
      (tuple2 #"s32/le-byte2" #"prim_quad_le_byte2_closure")
      (tuple2 #"s32/le-byte3" #"prim_quad_le_byte3_closure"))))

(define (prim-type [name : Bytes]) : Type
  (abstract-type #"prim" name (empty)))

(define (int-type) : Type
  (prim-type #"Int"))
(define (bytes-type) : Type
  (prim-type #"Bytes"))
(define (boolean-type) : Type
  (prim-type #"Boolean"))
(define (void-type) : Type
  (prim-type #"Void"))
(define (u8-type) : Type
  (prim-type #"U8"))
(define (u32-type) : Type
  (prim-type #"U32"))
(define (s32-type) : Type
  (prim-type #"S32"))
(define (file-descriptor-type) : Type
  (prim-type #"FileDescriptor"))
(define (mach-port-type) : Type
  (prim-type #"MachPort"))
(define (array-type [e : Type]) : Type
  (abstract-type #"prim" #"Array" (varargs list e)))

(define (fun0-type [result : Type]) : Type
  (fun-type (empty) (empty) result))
(define (fun1-type [arg : Type] [result : Type]) : Type
  (fun-type (empty) (varargs list arg) result))
(define (fun2-type [arg1 : Type] [arg2 : Type] [result : Type]) : Type
  (fun-type (empty) (varargs list arg1 arg2) result))
(define (fun3-type [arg1 : Type] [arg2 : Type] [arg3 : Type] [result : Type]) : Type
  (fun-type (empty) (varargs list arg1 arg2 arg3) result))
(define (fun4-type [arg1 : Type] [arg2 : Type] [arg3 : Type] [arg4 : Type] [result : Type]) : Type
  (fun-type (empty) (varargs list arg1 arg2 arg3 arg4) result))
(define (fun5-type [arg1 : Type] [arg2 : Type] [arg3 : Type]
                   [arg4 : Type] [arg5 : Type] [result : Type]) : Type
  (fun-type (empty) (varargs list arg1 arg2 arg3 arg4 arg5) result))
(define (fun6-type [arg1 : Type] [arg2 : Type] [arg3 : Type]
                   [arg4 : Type] [arg5 : Type] [arg6 : Type] [result : Type]) : Type
  (fun-type (empty) (varargs list arg1 arg2 arg3 arg4 arg5 arg6) result))
(define (fun7-type [arg1 : Type] [arg2 : Type] [arg3 : Type] [arg4 : Type]
                   [arg5 : Type] [arg6 : Type] [arg7 : Type] [result : Type]) : Type
  (fun-type (empty) (varargs list arg1 arg2 arg3 arg4 arg5 arg6 arg7) result))

(define (math-2arg) : Type
  (fun2-type (int-type) (int-type) (int-type)))
(define (logic-2arg) : Type
  (fun2-type (int-type) (int-type) (boolean-type)))

;; TODO add mechanism to ensure that all bindings have types
(define (prim-value-types) : (Dict Bytes Type)
  (dict-add-all
    (make-dict bytes=?)
    (varargs list
      (tuple2 #"u8" (fun1-type (int-type) (u8-type)))
      (tuple2 #"s32" (fun1-type (int-type) (s32-type)))
      (tuple2 #"u32" (fun1-type (int-type) (u32-type)))
      (tuple2 #"u8->s64" (fun1-type (u8-type) (int-type)))
      (tuple2 #"s32->s64" (fun1-type (s32-type) (int-type)))
      (tuple2 #"u32->s64" (fun1-type (u32-type) (int-type)))
      (tuple2 #"+" (math-2arg))
      (tuple2 #"-" (math-2arg))
      (tuple2 #"*" (math-2arg))
      (tuple2 #"=" (logic-2arg))
      (tuple2 #"<" (logic-2arg))
      (tuple2 #"<=" (logic-2arg))
      (tuple2 #">" (logic-2arg))
      (tuple2 #">=" (logic-2arg))
      (tuple2 #"bitwise-and" (math-2arg))
      (tuple2 #"bitwise-ior" (math-2arg))
      (tuple2 #"logical-shift-left" (math-2arg))
      (tuple2 #"logical-shift-right" (math-2arg))
      (tuple2 #"bytes-ref" (fun2-type (bytes-type) (int-type) (int-type)))
      (tuple2 #"make-bytes" (fun1-type (int-type) (bytes-type)))
      (tuple2 #"bytes-set!" (fun3-type (bytes-type) (int-type) (u8-type) (void-type)))
      (tuple2 #"bytes-length" (fun1-type (bytes-type) (int-type)))
      (tuple2 #"write-bytes"
              (fun4-type (bytes-type) (file-descriptor-type) (int-type) (int-type) (int-type)))
      (tuple2 #"read-bytes"
              (fun4-type (bytes-type) (file-descriptor-type) (int-type) (int-type) (int-type)))
      (tuple2 #"open-input-file" (fun1-type (bytes-type) (file-descriptor-type)))
      (tuple2 #"open-output-file" (fun1-type (bytes-type) (file-descriptor-type)))
      (tuple2 #"close-input-port" (fun1-type (file-descriptor-type) (void-type)))
      (tuple2 #"close-output-port" (fun1-type (file-descriptor-type) (void-type)))
      (tuple2 #"delete-file" (fun1-type (bytes-type) (void-type)))
      (tuple2 #"set-file-or-directory-permissions" (fun2-type (bytes-type) (int-type) (void-type)))
      (tuple2 #"socket" (fun3-type (int-type) (int-type) (int-type) (file-descriptor-type)))
      (tuple2 #"bind" (fun3-type (file-descriptor-type) (bytes-type) (int-type) (void-type)))
      (tuple2 #"sendto"
              (fun6-type
                (file-descriptor-type) (bytes-type) (int-type) (int-type) (bytes-type) (int-type)
                (void-type)))
      (tuple2 #"recvfrom"
              (fun6-type
                (file-descriptor-type) (bytes-type) (int-type) (int-type) (bytes-type) (bytes-type)
                (int-type)))
      (tuple2 #"connect" (fun3-type (file-descriptor-type) (bytes-type) (int-type) (void-type)))
      (tuple2 #"shutdown" (fun2-type (file-descriptor-type) (int-type) (void-type)))
      (tuple2 #"listen" (fun2-type (file-descriptor-type) (int-type) (void-type)))
      (tuple2 #"accept"
              (fun3-type (file-descriptor-type) (bytes-type) (bytes-type) (file-descriptor-type)))
      (tuple2 #"setsockopt"
              (fun5-type (file-descriptor-type) (int-type) (int-type) (bytes-type) (int-type)
                         (void-type)))
      (tuple2 #"mach-port->u32" (fun1-type (mach-port-type) (u32-type)))
      (tuple2 #"u32->mach-port" (fun1-type (u32-type) (mach-port-type)))
      (tuple2 #"mach-task-self" (fun0-type (mach-port-type)))
      (tuple2 #"mach-thread-self" (fun0-type (mach-port-type)))
      (tuple2 #"mach-reply-port" (fun0-type (mach-port-type)))
      (tuple2 #"mach-msg" (fun7-type (bytes-type) (int-type) (int-type) (int-type)
                                     (mach-port-type) (int-type) (int-type)
                                     (void-type)))
      (tuple2 #"mach-port-mod-refs"
              (fun4-type (mach-port-type) (mach-port-type) (int-type) (int-type) (void-type)))
      (tuple2 #"mach-start-thread"
              (fun3-type (bytes-type) (fun0-type (void-type)) (mach-port-type) (void-type)))
      (tuple2 #"void" (fun0-type (void-type)))
      (tuple2 #"and" (fun2-type (boolean-type) (boolean-type) (boolean-type)))
      (tuple2 #"or" (fun2-type (boolean-type) (boolean-type) (boolean-type)))
      (tuple2 #"quotient" (math-2arg))
      (tuple2 #"remainder" (math-2arg))
      (tuple2 #"panic" (fun-type (varargs list #"a") (varargs list (bytes-type)) (var-type #"a")))
      (tuple2 #"make-array"
              (fun-type
                (varargs list #"a")
                (varargs list (int-type) (var-type #"a"))
                (array-type (var-type #"a"))))
      (tuple2 #"array-length"
              (fun-type
                (varargs list #"a")
                (varargs list (array-type (var-type #"a")))
                (int-type)))
      (tuple2 #"array-ref"
              (fun-type
                (varargs list #"a")
                (varargs list (array-type (var-type #"a")) (int-type))
                (var-type #"a")))
      (tuple2 #"array-set!"
              (fun-type
                (varargs list #"a")
                (varargs list (array-type (var-type #"a")) (int-type) (var-type #"a"))
                (void-type)))
      (tuple2 #"u32/le-byte0" (fun1-type (u32-type) (u8-type)))
      (tuple2 #"u32/le-byte1" (fun1-type (u32-type) (u8-type)))
      (tuple2 #"u32/le-byte2" (fun1-type (u32-type) (u8-type)))
      (tuple2 #"u32/le-byte3" (fun1-type (u32-type) (u8-type)))
      (tuple2 #"s32/le-byte0" (fun1-type (s32-type) (u8-type)))
      (tuple2 #"s32/le-byte1" (fun1-type (s32-type) (u8-type)))
      (tuple2 #"s32/le-byte2" (fun1-type (s32-type) (u8-type)))
      (tuple2 #"s32/le-byte3" (fun1-type (s32-type) (u8-type))))))

(define (prim-signature) : ModuleSignature
  (let ([prim-closures (prim-values)])
    (module-signature #"prim"
      prim-closures
      (make-dict bytes=?)
      (dict-add-all
        (make-dict bytes=?)
        (varargs list
          (tuple2 #"U8" (u8-type))
          (tuple2 #"S32" (s32-type))
          (tuple2 #"U32" (u32-type))
          (tuple2 #"Bytes" (bytes-type))
          (tuple2 #"Byte" (int-type))
          (tuple2 #"Int" (int-type))
          (tuple2 #"Void" (void-type))
          (tuple2 #"Boolean" (boolean-type))
          (tuple2 #"Array" (type-constructor #"prim" #"Array" (cons (star-kind) (empty))))
          (tuple2 #"InputPort" (file-descriptor-type))
          (tuple2 #"OutputPort" (file-descriptor-type))
          (tuple2 #"Socket" (file-descriptor-type))
          (tuple2 #"MachPort" (mach-port-type))))
      (prim-value-types)
      (prim-known-functions (dict-values prim-closures)))))

(define (prim-implementation) : (List TopLevelObject)
  (append*
    (varargs list
      (bin-math-implementation #"prim_add" (bin-add-op))
      (bin-math-implementation #"prim_sub" (bin-sub-op))
      (bin-math-implementation #"prim_mult" (bin-mult-op))
      (bin-math-implementation #"prim_quotient" (bin-quotient-op))
      (bin-math-implementation #"prim_remainder" (bin-remainder-op))
      (bin-math-implementation #"prim_bitwise_and" (bin-bitwise-and-op))
      (bin-math-implementation #"prim_bitwise_ior" (bin-bitwise-ior-op))
      (bin-math-implementation #"prim_logical_shift_left" (bin-logical-shift-left-op))
      (bin-math-implementation #"prim_logical_shift_right" (bin-logical-shift-right-op))
      (bin-logic-math-implementation #"prim_less_than" (less-than-op))
      (bin-logic-math-implementation #"prim_less_than_or_equal" (less-than-or-equal-op))
      (bin-logic-math-implementation #"prim_equal" (equal-op))
      (bin-logic-math-implementation #"prim_greater_than_or_equal" (greater-than-or-equal-op))
      (bin-logic-math-implementation #"prim_greater_than" (greater-than-op))
      (make-implementation #"prim_make_array" 2 (make-array-cmd))
      (make-implementation #"prim_array_length" 1 (array-length-cmd))
      (make-implementation #"prim_array_ref" 2 (array-ref-cmd))
      (make-implementation #"prim_array_set" 3 (array-set!-cmd)))))

(define (prim-known-functions [closure-names : (List Bytes)]) : (Dict Bytes Bytes)
  (dict-add-all
    (make-dict bytes=?)
    (map (lambda ([closure-name : Bytes])
           (tuple2
             closure-name
             (subbytes closure-name 0 (- (bytes-length closure-name) 8))))
         (set->list
           (set-add-all
             (make-set bytes=?)
             closure-names)))))

(define (duplicate-args [offset : Int] [amount : Int] [cmds : (List StackCmd)]) : (List StackCmd)
  (if (= 0 amount)
      cmds
      (duplicate-args offset (- amount 1) (cons (dup-cmd offset) cmds))))

(define (make-implementation [name : Bytes] [num-args : Int] [cmd : StackCmd])
  : (List TopLevelObject)
  (varargs list
    (function-tlo
      (stack-function
        name
        num-args
        (cons
          (stack-basic-block
            (duplicate-args (if (> num-args 6) (+ num-args 7) (- num-args 1)) num-args (cons cmd (empty)))
            (return num-args))
          (empty))))
    (trivial-closure-tlo
      (bytes-append (varargs list name #"_closure"))
      name)))

(define (bin-math-implementation [name : Bytes] [op : BinMathOp]) : (List TopLevelObject)
  (make-implementation name 2 (bin-math-cmd op)))


(define (bin-logic-math-implementation [name : Bytes] [op : BinLogicMathOp]) : (List TopLevelObject)
  (make-implementation name 2 (bin-logic-math-cmd op)))
