#:module (prim-implementation)
#:import {
  (bytes)
  (dict)
  (intermediate-expression)
  (intermediate-language)
  (list)
  (maybe)
  (module-name)
  (module-signature)
  (prim)
  (resolved-imports-language) {
    #:values
      empty-imports
  }
  (top-level-name)
  (tuples)
  (types)
  (yaspl intermediate-to-register) {
    #:values
      [module-to-top-level-objects r:module-to-top-level-objects]
  }
  (yaspl math-operations)
  (yaspl module-environment)
  (yaspl top-level-objects)
  (yaspl var)
}
(export
  #:types ()
  #:values (prim-signature prim-implementation int-type boolean-type bytes-type void-type)
  #:patterns ())
(types
  (define-type PrimOp
    (prim-op [binding : Bytes] [name : Bytes] [type : Type]
             [impl : ((List Expression) -> Expression)])))

(define (value-signature* [t : Type] [base-name : Bytes]) : ValueSignature
  (match-define closure-name
    (prim-name (bytes-append (varargs list base-name #"_closure"))))
  (value-signature t closure-name (nothing)))

(define (value-signature/inline* [t : Type] [base-name : Bytes] [inline : (Maybe InlineableFunction)])
  : ValueSignature
  (match-define closure-name
    (prim-name (bytes-append (varargs list base-name #"_closure"))))
  (value-signature t closure-name inline))


(define (inline-logical-op [op : LogicalBinOp]) : (Maybe InlineableFunction)
  (just (hoas-linear-inlineable-function
          (lambda ([args : (List Expression)])
            (case args
              [(cons x (cons y (empty)))
               (prim-logical-bin-op op x y)]
              [_ (panic #"logical op inlined with not 2 arguments")])))))

(define (inline-unary-logical-op [op : LogicalUnaryOp]) : (Maybe InlineableFunction)
  (just (hoas-linear-inlineable-function
          (lambda ([args : (List Expression)])
            (case args
              [(cons e (empty))
               (prim-logical-unary-op op e)]
              [_ (panic #"logical op inlined with not 2 arguments")])))))


(define (inline-no-op-cast-op [src-type : Type] [dest-type : Type]) : (Maybe InlineableFunction)
  (just (hoas-linear-inlineable-function
          (lambda ([args : (List Expression)])
            (case args
              [(cons e (empty))
               (no-op-cast-op src-type dest-type e)]
              [_ (panic #"no-op cast op inlined with not 1 argument")])))))

(define (inline-bytes-ref) : (Maybe InlineableFunction)
  (just (hoas-linear-inlineable-function
          (lambda ([args : (List Expression)])
            (case args
              [(cons b (cons off (empty)))
               (bytes-ref-expr b off)]
              [_ (panic #"bytes-ref inlined with not 2 arguments")])))))

(define (inline-bytes-set!) : (Maybe InlineableFunction)
  (just (hoas-linear-inlineable-function
          (lambda ([args : (List Expression)])
            (case args
              [(cons b (cons off (cons v (empty))))
               (bytes-set!-expr b off v)]
              [_ (panic #"bytes-set! inlined with not 3 arguments")])))))

(define (inline-bytes-length) : (Maybe InlineableFunction)
  (just (hoas-linear-inlineable-function
          (lambda ([args : (List Expression)])
            (case args
              [(cons b (empty))
               (bytes-length-expr b)]
              [_ (panic #"bytes-length inlined with not 1 argument")])))))

(define (prim-name [name : Bytes]) : TopLevelName
  (top-level-name (prim-mod) name))


(define (prim-values) : (Dict Bytes ValueSignature)
  (match-define runtime-sigs
    (varargs list
      (tuple2 #"u8" (value-signature* (fun1-type (int-type) (u8-type)) #"u8"))
      (tuple2 #"s32" (value-signature* (fun1-type (int-type) (s32-type)) #"s32"))
      (tuple2 #"u32" (value-signature* (fun1-type (int-type) (u32-type)) #"u32"))
      (tuple2 #"u8->s64" (value-signature/inline* (fun1-type (u8-type) (int-type)) #"u8_s64"
                                                  (inline-no-op-cast-op (u8-type) (int-type))))
      (tuple2 #"s32->s64" (value-signature/inline* (fun1-type (s32-type) (int-type)) #"s32_s64"
                                                   (inline-no-op-cast-op (s32-type) (int-type))))
      (tuple2 #"u32->s64" (value-signature/inline* (fun1-type (u32-type) (int-type)) #"u32_s64"
                                                   (inline-no-op-cast-op (u32-type) (int-type))))
      (tuple2 #"and" (value-signature/inline* (fun2-type (boolean-type) (boolean-type) (boolean-type))
                                              #"and" (inline-logical-op (and-op))))
      (tuple2 #"or" (value-signature/inline* (fun2-type (boolean-type) (boolean-type) (boolean-type))
                                             #"or" (inline-logical-op (ior-op))))
      (tuple2 #"not" (value-signature/inline* (fun1-type (boolean-type) (boolean-type))
                                              #"not" (inline-unary-logical-op (not-op))))

      (tuple2 #"make-bytes" (value-signature* (fun1-type (int-type) (bytes-type))
                                              #"make_bytes"))
      (tuple2 #"bytes-ref" (value-signature/inline* (fun2-type (bytes-type) (int-type) (u8-type))
                                                    #"bytes_ref"
                                                    (inline-bytes-ref)))
      (tuple2 #"bytes-set!" (value-signature/inline* (fun3-type (bytes-type) (int-type) (u8-type) (void-type))
                                                     #"bytes_set"
                                                     (inline-bytes-set!)))
      (tuple2 #"bytes-length" (value-signature/inline*
                                (fun1-type (bytes-type) (int-type)) #"bytes_length"
                                (inline-bytes-length)))
      (tuple2 #"write-bytes" (value-signature* (fun4-type (bytes-type) (file-descriptor-type)
                                                          (int-type) (int-type) (int-type))
                                               #"write_bytes"))
      (tuple2 #"read-bytes" (value-signature* (fun4-type (bytes-type) (file-descriptor-type)
                                                         (int-type) (int-type) (int-type))
                                              #"read_bytes"))
      (tuple2 #"open-input-file" (value-signature* (fun1-type (bytes-type) (file-descriptor-type))
                                                   #"open_input_file"))
      (tuple2 #"open-output-file" (value-signature* (fun1-type (bytes-type) (file-descriptor-type))
                                                    #"open_output_file"))
      (tuple2 #"close-input-port" (value-signature* (fun1-type (file-descriptor-type) (void-type))
                                                    #"close_port"))
      (tuple2 #"close-output-port" (value-signature* (fun1-type (file-descriptor-type) (void-type))
                                                     #"close_port"))
      (tuple2 #"prim-delete-file" (value-signature* (fun1-type (bytes-type) (void-type))
                                                    #"delete_file"))
      (tuple2 #"prim-make-directory" (value-signature* (fun1-type (bytes-type) (void-type))
                                                       #"make_directory"))
      (tuple2 #"set-file-or-directory-permissions"
              (value-signature* (fun2-type (bytes-type) (int-type) (void-type))
                                #"set_file_or_directory_permissions"))
      (tuple2 #"socket" (value-signature* (fun3-type (int-type) (int-type) (int-type) (file-descriptor-type))
                                          #"socket"))
      (tuple2 #"bind" (value-signature* (fun3-type (file-descriptor-type) (bytes-type) (int-type)
                                                   (void-type))#"bind"))

      (tuple2 #"sendto"
              (value-signature* (fun6-type (file-descriptor-type) (bytes-type) (int-type) (int-type)
                                          (bytes-type) (int-type) (void-type))
                                #"sendto"))
      (tuple2 #"recvfrom"
              (value-signature* (fun6-type (file-descriptor-type) (bytes-type) (int-type) (int-type)
                                          (bytes-type) (bytes-type) (int-type))
                                #"recvfrom"))
      (tuple2 #"connect"
              (value-signature* (fun3-type (file-descriptor-type) (bytes-type) (int-type) (void-type))
                                #"connect"))
      (tuple2 #"shutdown"
              (value-signature* (fun2-type (file-descriptor-type) (int-type) (void-type))
                                #"shutdown"))
      (tuple2 #"listen"
              (value-signature* (fun2-type (file-descriptor-type) (int-type) (void-type))
                                #"listen"))
      (tuple2 #"accept"
              (value-signature* (fun3-type (file-descriptor-type) (bytes-type) (bytes-type)
                                          (file-descriptor-type))
                                #"accept"))
      (tuple2 #"setsockopt"
              (value-signature* (fun5-type (file-descriptor-type) (int-type) (int-type) (bytes-type) (int-type)
                                          (void-type))
                                #"setsockopt"))
      (tuple2 #"mach-port->u32" (value-signature* (fun1-type (mach-port-type) (u32-type))
                                                  #"u32"))
      (tuple2 #"u32->mach-port" (value-signature* (fun1-type (u32-type) (mach-port-type)) #"u32"))
      (tuple2 #"mach-task-self" (value-signature* (fun0-type (mach-port-type)) #"mach_task_self"))
      (tuple2 #"mach-thread-self" (value-signature* (fun0-type (mach-port-type)) #"mach_thread_self"))
      (tuple2 #"mach-reply-port" (value-signature* (fun0-type (mach-port-type)) #"mach_reply_port"))
      (tuple2 #"mach-msg"
              (value-signature* (fun7-type (bytes-type) (int-type) (int-type) (int-type)
                                          (mach-port-type) (int-type) (int-type) (void-type))
                                #"mach_msg"))
      (tuple2 #"mach-port-mod-refs"
              (value-signature* (fun4-type (mach-port-type) (mach-port-type) (int-type) (int-type) (void-type))
                                #"mach_port_mod_refs"))
      (tuple2 #"mach-start-thread"
              (value-signature*
                (fun3-type (bytes-type) (fun0-type (void-type)) (mach-port-type) (void-type))
                #"mach_start_thread"))
      (tuple2 #"void" (value-signature* (fun0-type (void-type)) #"void"))
      (tuple2 #"panic" (value-signature* (fun-type (varargs list #"a") (varargs list (bytes-type)) (var-type #"a"))
                                         #"panic"))
      (tuple2 #"u32/le-byte0" (value-signature* (fun1-type (u32-type) (u8-type))
                                                #"quad_le_byte0"))
      (tuple2 #"u32/le-byte1" (value-signature* (fun1-type (u32-type) (u8-type))
                                                #"quad_le_byte1"))
      (tuple2 #"u32/le-byte2" (value-signature* (fun1-type (u32-type) (u8-type))
                                                #"quad_le_byte2"))
      (tuple2 #"u32/le-byte3" (value-signature* (fun1-type (u32-type) (u8-type))
                                                #"quad_le_byte3"))
      (tuple2 #"s32/le-byte0" (value-signature* (fun1-type (s32-type) (u8-type))
                                                #"quad_le_byte0"))
      (tuple2 #"s32/le-byte1" (value-signature* (fun1-type (s32-type) (u8-type))
                                                #"quad_le_byte1"))
      (tuple2 #"s32/le-byte2" (value-signature* (fun1-type (s32-type) (u8-type))
                                                #"quad_le_byte2"))
      (tuple2 #"s32/le-byte3" (value-signature* (fun1-type (s32-type) (u8-type))
                                                #"quad_le_byte3"))
      ;; TODO make this actually safe
      (tuple2 #"ioctl"
              (value-signature* (fun3-type (file-descriptor-type) (int-type) (bytes-type) (void-type))
                                #"ioctl"))))
  (match-define prim-sigs
    (map prim-op->signature (prim-ops)))
  (dict-add-all
    (dict-add-all
      (make-dict bytes-cmp)
      prim-sigs)
    runtime-sigs))

(define (prim-mod) : ModName
  (mod-name (varargs list #"prim")))

(define (prim-type [name : Bytes]) : Type
  (abstract-type (prim-mod) name (empty)))

(define (int-type) : Type
  (prim-type #"Int"))
(define (bytes-type) : Type
  (prim-type #"Bytes"))
(define (boolean-type) : Type
  (prim-type #"Boolean"))
(define (void-type) : Type
  (prim-type #"Void"))
(define (u8-type) : Type
  (prim-type #"U8"))
(define (u32-type) : Type
  (prim-type #"U32"))
(define (s32-type) : Type
  (prim-type #"S32"))
(define (file-descriptor-type) : Type
  (prim-type #"FileDescriptor"))
(define (mach-port-type) : Type
  (prim-type #"MachPort"))
(define (array-type [e : Type]) : Type
  (abstract-type (prim-mod) #"Array" (varargs list e)))

(define (fun0-type [result : Type]) : Type
  (fun-type (empty) (empty) result))
(define (fun1-type [arg : Type] [result : Type]) : Type
  (fun-type (empty) (varargs list arg) result))
(define (fun2-type [arg1 : Type] [arg2 : Type] [result : Type]) : Type
  (fun-type (empty) (varargs list arg1 arg2) result))
(define (fun3-type [arg1 : Type] [arg2 : Type] [arg3 : Type] [result : Type]) : Type
  (fun-type (empty) (varargs list arg1 arg2 arg3) result))
(define (fun4-type [arg1 : Type] [arg2 : Type] [arg3 : Type] [arg4 : Type] [result : Type]) : Type
  (fun-type (empty) (varargs list arg1 arg2 arg3 arg4) result))
(define (fun5-type [arg1 : Type] [arg2 : Type] [arg3 : Type]
                   [arg4 : Type] [arg5 : Type] [result : Type]) : Type
  (fun-type (empty) (varargs list arg1 arg2 arg3 arg4 arg5) result))
(define (fun6-type [arg1 : Type] [arg2 : Type] [arg3 : Type]
                   [arg4 : Type] [arg5 : Type] [arg6 : Type] [result : Type]) : Type
  (fun-type (empty) (varargs list arg1 arg2 arg3 arg4 arg5 arg6) result))
(define (fun7-type [arg1 : Type] [arg2 : Type] [arg3 : Type] [arg4 : Type]
                   [arg5 : Type] [arg6 : Type] [arg7 : Type] [result : Type]) : Type
  (fun-type (empty) (varargs list arg1 arg2 arg3 arg4 arg5 arg6 arg7) result))

(define (math-2arg) : Type
  (fun2-type (int-type) (int-type) (int-type)))
(define (logic-2arg) : Type
  (fun2-type (int-type) (int-type) (boolean-type)))

(define (prim-signature) : ModuleSignature
  (let ([prim-closures (prim-values)])
    (module-signature (prim-mod)
      prim-closures
      (make-dict bytes-cmp)
      (dict-add-all
        (make-dict bytes-cmp)
        (varargs list
          (tuple2 #"U8" (u8-type))
          (tuple2 #"S32" (s32-type))
          (tuple2 #"U32" (u32-type))
          (tuple2 #"Bytes" (bytes-type))
          (tuple2 #"Byte" (int-type))
          (tuple2 #"Int" (int-type))
          (tuple2 #"Void" (void-type))
          (tuple2 #"Boolean" (boolean-type))
          (tuple2 #"Array" (type-constructor (prim-mod) #"Array" (cons (star-kind) (empty))))
          (tuple2 #"InputPort" (file-descriptor-type))
          (tuple2 #"OutputPort" (file-descriptor-type))
          (tuple2 #"Socket" (file-descriptor-type))
          (tuple2 #"MachPort" (mach-port-type))))
      (dict-fold
        prim-closures
        (lambda ([binding : Bytes] [sig : ValueSignature] [acc : (Dict TopLevelName TopLevelSignature)])
          : (Dict TopLevelName TopLevelSignature)
          (case sig
            [(value-signature _ name _)
             (match-define (top-level-name mod closure-base) name)
             (match-define fun-base (subbytes closure-base 0 (- (bytes-length closure-base) 8)))
             (dict-set acc name (top-level-signature (just (top-level-name mod fun-base))))]))
        ((lambda () : (Dict TopLevelName TopLevelSignature) (make-dict top-level-name-cmp)))))))

(define (prim-implementation) : (List TopLevelObject)
  (match-define (tuple2 functions closures)
    (unzip (map implement-prim-op (prim-ops))))

  (match-define mod
    (module
      (prim-mod)
      (empty-imports)
      (exports (empty) (empty) (empty))
      (empty)
      functions
      closures
      (empty)))
  (match-define env (make-module-environment mod))
  (r:module-to-top-level-objects mod env))

(define (numeric-op-impl [op : NumericBinOp]) : ((List Expression) -> Expression)
  (lambda ([args : (List Expression)])
    (case args
      [(cons x (cons y (empty)))
       (prim-numeric-bin-op op x y)]
      [_ (panic #"numeric op inlined with not 2 arguments")])))

(define (comparison-op-impl [op : ComparisonBinOp]) : ((List Expression) -> Expression)
  (lambda ([args : (List Expression)])
    (case args
      [(cons x (cons y (empty)))
       (prim-comparison-bin-op op x y)]
      [_ (panic #"comparison op inlined with not 2 arguments")])))

(define (array-ref-impl) : ((List Expression) -> Expression)
  (lambda ([args : (List Expression)])
    (case args
      [(cons a (cons off (empty)))
       (array-ref-expr a off)]
      [_ (panic #"array-ref inlined with not 2 arguments")])))

(define (array-set!-impl) : ((List Expression) -> Expression)
  (lambda ([args : (List Expression)])
    (case args
      [(cons a (cons off (cons v (empty))))
       (array-set!-expr a off v)]
      [_ (panic #"array-set! inlined with not 3 arguments")])))

(define (array-length-impl) : ((List Expression) -> Expression)
  (lambda ([args : (List Expression)])
    (case args
      [(cons a (empty))
       (array-length-expr a)]
      [_ (panic #"array-length inlined with not 1 argument")])))

(define (make-array-impl) : ((List Expression) -> Expression)
  (lambda ([args : (List Expression)])
    (case args
      [(cons size (cons v (empty)))
       (make-array-expr size v)]
      [_ (panic #"make-array inlined with not 2 argument")])))


(define (fun-type->args [type : Type]) : (Tuple2 (List Bytes) (List Type))
  (case type
    [(fun-type tvars args result)
     (tuple2 tvars args)]
    [_ (panic #"Couldn't extract argument types")]))


(define (prim-op->signature [p : PrimOp]) : (Tuple2 Bytes ValueSignature)
  (match-define (prim-op binding name type impl) p)
  (tuple2
    binding
    (value-signature/inline* type name (just (hoas-linear-inlineable-function impl)))))


(define (implement-prim-op [op : PrimOp])
  : (Tuple2 FunctionDefinition ClosureConstant)
  (match-define (prim-op _ name type impl) op)
  ;; TODO use the tvars somewhere
  (match-define (tuple2 tvars arg-types) (fun-type->args type))
  (match-define vars
    (build-list (length arg-types) (lambda ([i : Int]) (var #"v" i))))

  (tuple2
    (function-definition
      name
      type
      (case (zip vars arg-types)
        [(nothing) (panic #"Args not the same length as vars")]
        [(just typed-vars) typed-vars])
      (empty)
      (impl (map local-var-expr vars)))
    (closure-constant (bytes-append (varargs list name #"_closure")) name)))


(define (prim-op* [name : Bytes] [type : Type] [impl : ((List Expression) -> Expression)]) : PrimOp
  (prim-op name name type impl))

(define (prim-ops) : (List PrimOp)
  (varargs list
    (prim-op
      #"+" #"add"
      (math-2arg)
      (numeric-op-impl (add-op)))
    (prim-op
      #"-" #"sub"
      (math-2arg)
      (numeric-op-impl (sub-op)))
    (prim-op
      #"*" #"mult"
      (math-2arg)
      (numeric-op-impl (mult-op)))
    (prim-op*
      #"quotient"
      (math-2arg)
      (numeric-op-impl (quotient-op)))
    (prim-op*
      #"remainder"
      (math-2arg)
      (numeric-op-impl (remainder-op)))
    (prim-op
      #"bitwise-and" #"bitwise_and"
      (math-2arg)
      (numeric-op-impl (bitwise-and-op)))
    (prim-op
      #"bitwise-ior" #"bitwise_ior"
      (math-2arg)
      (numeric-op-impl (bitwise-ior-op)))
    (prim-op
      #"logical-shift-left" #"logical_shift_left"
      (math-2arg)
      (numeric-op-impl (logical-shift-left-op)))
    (prim-op
      #"logical-shift-right" #"logical_shift_right"
      (math-2arg)
      (numeric-op-impl (logical-shift-right-op)))
    (prim-op
      #"<" #"less_than"
      (logic-2arg)
      (comparison-op-impl (less-than-op)))
    (prim-op
      #"<=" #"less_than_or_equal"
      (logic-2arg)
      (comparison-op-impl (less-than-or-equal-op)))
    (prim-op
      #"=" #"equal"
      (logic-2arg)
      (comparison-op-impl (equal-op)))
    (prim-op
      #">=" #"greater_than_or_equal"
      (logic-2arg)
      (comparison-op-impl (greater-than-or-equal-op)))
    (prim-op
      #">" #"greater_than"
      (logic-2arg)
      (comparison-op-impl (greater-than-op)))
    (prim-op
      #"make-array" #"make_array"
      (fun-type (varargs list #"a") (varargs list (int-type) (var-type #"a"))
                (array-type (var-type #"a")))
      (make-array-impl))
    (prim-op
      #"array-length" #"array_length"
      (fun-type (varargs list #"a") (varargs list (array-type (var-type #"a"))) (int-type))
      (array-length-impl))
    (prim-op
      #"array-ref" #"array_ref"
      (fun-type (varargs list #"a") (varargs list (array-type (var-type #"a")) (int-type))
                (var-type #"a"))
      (array-ref-impl))
    (prim-op
      #"array-set!" #"array_set"
      (fun-type (varargs list #"a")
                (varargs list (array-type (var-type #"a")) (int-type)
                              (var-type #"a"))
                (void-type))
      (array-set!-impl))))
