#:module (prim-implementation)
#:import {
  (bytes)
  (dict)
  (intermediate-expression)
  (intermediate-language)
  (list)
  (maybe)
  (module-signature)
  (prim)
  (prim-types)
  (top-level-name)
  (tuples)
  (types)
  (yaspl intermediate-to-register) {
    #:values
      [module-to-top-level-objects r:module-to-top-level-objects]
  }
  (yaspl math-operations)
  (yaspl top-level-objects)
  (yaspl var)
}
(export
  #:types ()
  #:values (prim-signature prim-implementation)
  #:patterns ())
(types
  (define-type PrimOp
    (prim-op [binding : Bytes] [name : Bytes] [type : Type]
             [impl : ((List Expression) -> Expression)]))
  (define-type PrimOpSig
    (prim-op-sig
      [binding : Bytes] [name : Bytes] [type : Type]
      [inline : (Maybe InlineableFunction)])))

(define (prim-op-sig* [binding : Bytes] [name : Bytes] [t : Type]) : PrimOpSig
  (prim-op-sig binding name t (nothing)))


(define (inline-logical-op [op : LogicalBinOp]) : (Maybe InlineableFunction)
  (just (hoas-linear-inlineable-function
          (lambda ([args : (List Expression)])
            (case args
              [(cons x (cons y (empty)))
               (prim-logical-bin-op op x y)]
              [_ (panic #"logical op inlined with not 2 arguments")])))))

(define (inline-unary-logical-op [op : LogicalUnaryOp]) : (Maybe InlineableFunction)
  (just (hoas-linear-inlineable-function
          (lambda ([args : (List Expression)])
            (case args
              [(cons e (empty))
               (prim-logical-unary-op op e)]
              [_ (panic #"logical op inlined with not 2 arguments")])))))


(define (inline-no-op-cast-op [src-type : Type] [dest-type : Type]) : (Maybe InlineableFunction)
  (just (hoas-linear-inlineable-function
          (lambda ([args : (List Expression)])
            (case args
              [(cons e (empty))
               (no-op-cast-op src-type dest-type e)]
              [_ (panic #"no-op cast op inlined with not 1 argument")])))))

(define (inline-bytes-ref) : (Maybe InlineableFunction)
  (just (hoas-linear-inlineable-function
          (lambda ([args : (List Expression)])
            (case args
              [(cons b (cons off (empty)))
               (bytes-ref-expr b off)]
              [_ (panic #"bytes-ref inlined with not 2 arguments")])))))

(define (inline-bytes-set!) : (Maybe InlineableFunction)
  (just (hoas-linear-inlineable-function
          (lambda ([args : (List Expression)])
            (case args
              [(cons b (cons off (cons v (empty))))
               (bytes-set!-expr b off v)]
              [_ (panic #"bytes-set! inlined with not 3 arguments")])))))

(define (inline-bytes-length) : (Maybe InlineableFunction)
  (just (hoas-linear-inlineable-function
          (lambda ([args : (List Expression)])
            (case args
              [(cons b (empty))
               (bytes-length-expr b)]
              [_ (panic #"bytes-length inlined with not 1 argument")])))))

(define (prim-name [name : Bytes]) : TopLevelName
  (top-level-name (prim-mod) name))

(define (runtime-prim-sigs) : (List PrimOpSig)
  (varargs list
    (prim-op-sig* #"u8" #"u8" (fun1-type (int-type) (u8-type)))
    (prim-op-sig* #"s32" #"s32" (fun1-type (int-type) (s32-type)))
    (prim-op-sig* #"u32" #"u32" (fun1-type (int-type) (u32-type)))
    (prim-op-sig #"u8->s64" #"u8_s64"
                 (fun1-type (u8-type) (int-type))
                 (inline-no-op-cast-op (u8-type) (int-type)))
    (prim-op-sig #"s32->s64" #"s32_s64"
                 (fun1-type (s32-type) (int-type))
                 (inline-no-op-cast-op (s32-type) (int-type)))
    (prim-op-sig #"u32->s64" #"u32_s64"
                 (fun1-type (u32-type) (int-type))
                 (inline-no-op-cast-op (u32-type) (int-type)))
    (prim-op-sig #"and" #"and"
                 (fun2-type (boolean-type) (boolean-type) (boolean-type))
                 (inline-logical-op (and-op)))
    (prim-op-sig #"or" #"or"
                 (fun2-type (boolean-type) (boolean-type) (boolean-type))
                 (inline-logical-op (ior-op)))
    (prim-op-sig #"not" #"not"
                 (fun1-type (boolean-type) (boolean-type))
                 (inline-unary-logical-op (not-op)))
    (prim-op-sig* #"make-array" #"make_array"
                  (fun-type (varargs list #"a") (varargs list (int-type) (var-type #"a"))
                            (array-type (var-type #"a"))))
    (prim-op-sig* #"make-bytes" #"make_bytes" (fun1-type (int-type) (bytes-type)))
    (prim-op-sig #"bytes-ref" #"bytes_ref"
                 (fun2-type (bytes-type) (int-type) (u8-type))
                 (inline-bytes-ref))
    (prim-op-sig #"bytes-set!" #"bytes_set"
                 (fun3-type (bytes-type) (int-type) (u8-type) (void-type))
                 (inline-bytes-set!))
    (prim-op-sig #"bytes-length" #"bytes_length"
                 (fun1-type (bytes-type) (int-type))
                 (inline-bytes-length))
    (prim-op-sig* #"write-bytes" #"write_bytes"
                  (fun4-type (bytes-type) (file-descriptor-type)
                             (int-type) (int-type) (int-type)))
    (prim-op-sig* #"read-bytes" #"read_bytes"
                  (fun4-type (bytes-type) (file-descriptor-type)
                             (int-type) (int-type) (int-type)))
    (prim-op-sig* #"open-input-file" #"open_input_file"
                  (fun1-type (bytes-type) (file-descriptor-type)))
    (prim-op-sig* #"open-output-file" #"open_output_file"
                  (fun1-type (bytes-type) (file-descriptor-type)))
    (prim-op-sig* #"close-input-port" #"close_port"
                  (fun1-type (file-descriptor-type) (void-type)))
    (prim-op-sig* #"close-output-port" #"close_port"
                  (fun1-type (file-descriptor-type) (void-type)))
    (prim-op-sig* #"prim-delete-file" #"delete_file"
                  (fun1-type (bytes-type) (void-type)))
    (prim-op-sig* #"prim-make-directory" #"make_directory"
                  (fun1-type (bytes-type) (void-type)))
    (prim-op-sig* #"set-file-or-directory-permissions" #"set_file_or_directory_permissions"
                  (fun2-type (bytes-type) (int-type) (void-type)))
    (prim-op-sig* #"socket" #"socket"
                  (fun3-type (int-type) (int-type) (int-type) (file-descriptor-type)))
    (prim-op-sig* #"bind" #"bind"
                  (fun3-type (file-descriptor-type) (bytes-type) (int-type) (void-type)))

    (prim-op-sig* #"sendto" #"sendto"
                  (fun6-type (file-descriptor-type) (bytes-type) (int-type) (int-type)
                             (bytes-type) (int-type) (void-type)))
    (prim-op-sig* #"recvfrom" #"recvfrom"
                  (fun6-type (file-descriptor-type) (bytes-type) (int-type) (int-type)
                             (bytes-type) (bytes-type) (int-type)))
    (prim-op-sig* #"connect" #"connect"
                  (fun3-type (file-descriptor-type) (bytes-type) (int-type) (void-type)))
    (prim-op-sig* #"shutdown" #"shutdown"
                  (fun2-type (file-descriptor-type) (int-type) (void-type)))
    (prim-op-sig* #"listen" #"listen"
                  (fun2-type (file-descriptor-type) (int-type) (void-type)))
    (prim-op-sig* #"accept" #"accept"
                  (fun3-type (file-descriptor-type) (bytes-type) (bytes-type) (file-descriptor-type)))
    (prim-op-sig* #"setsockopt" #"setsockopt"
                  (fun5-type (file-descriptor-type) (int-type) (int-type) (bytes-type) (int-type)
                             (void-type)))
    (prim-op-sig* #"mach-port->u32" #"u32"
                  (fun1-type (mach-port-type) (u32-type)))
    (prim-op-sig* #"u32->mach-port" #"u32"
                  (fun1-type (u32-type) (mach-port-type)))
    (prim-op-sig* #"mach-task-self" #"mach_task_self"
                  (fun0-type (mach-port-type)))
    (prim-op-sig* #"mach-thread-self" #"mach_thread_self"
                  (fun0-type (mach-port-type)))
    (prim-op-sig* #"mach-reply-port" #"mach_reply_port"
                  (fun0-type (mach-port-type)))
    (prim-op-sig* #"mach-msg" #"mach_msg"
                  (fun7-type (bytes-type) (int-type) (int-type) (int-type)
                             (mach-port-type) (int-type) (int-type) (void-type)))
    (prim-op-sig* #"mach-port-mod-refs" #"mach_port_mod_refs"
                  (fun4-type (mach-port-type) (mach-port-type) (int-type) (int-type) (void-type)))
    (prim-op-sig* #"void" #"void"
                  (fun0-type (void-type)))
    (prim-op-sig* #"panic" #"panic"
                  (fun-type (varargs list #"a") (varargs list (bytes-type)) (var-type #"a")))
    (prim-op-sig* #"u32/le-byte0" #"quad_le_byte0"
                  (fun1-type (u32-type) (u8-type)))
    (prim-op-sig* #"u32/le-byte1" #"quad_le_byte1"
                  (fun1-type (u32-type) (u8-type)))
    (prim-op-sig* #"u32/le-byte2" #"quad_le_byte2"
                  (fun1-type (u32-type) (u8-type)))
    (prim-op-sig* #"u32/le-byte3" #"quad_le_byte3"
                  (fun1-type (u32-type) (u8-type)))
    (prim-op-sig* #"s32/le-byte0" #"quad_le_byte0"
                  (fun1-type (s32-type) (u8-type)))
    (prim-op-sig* #"s32/le-byte1" #"quad_le_byte1"
                  (fun1-type (s32-type) (u8-type)))
    (prim-op-sig* #"s32/le-byte2" #"quad_le_byte2"
                  (fun1-type (s32-type) (u8-type)))
    (prim-op-sig* #"s32/le-byte3" #"quad_le_byte3"
                  (fun1-type (s32-type) (u8-type)))
    ;; TODO make this actually safe
    (prim-op-sig* #"ioctl" #"ioctl"
                  (fun3-type (file-descriptor-type) (int-type) (bytes-type) (void-type)))
    (prim-op-sig* #"fill-stack" #"fill_stack"
                  (fun1-type (array-type (int-type)) (int-type)))))

(define (prim-values [sigs : (List PrimOpSig)]) : (Dict Bytes ValueSignature)
  (foldl
    (lambda ([sig : PrimOpSig] [acc : (Dict Bytes ValueSignature)])
      (case sig
        [(prim-op-sig binding name type _)
         (match-define closure-name
           (prim-name (bytes-append (varargs list name #"_closure"))))
         (dict-add acc binding (value-signature type closure-name))]))
    sigs
    ((lambda () : (Dict Bytes ValueSignature) (make-dict bytes-cmp)))))

(define (u8-type) : Type
  (prim-type #"U8"))
(define (u32-type) : Type
  (prim-type #"U32"))
(define (s32-type) : Type
  (prim-type #"S32"))
(define (file-descriptor-type) : Type
  (prim-type #"FileDescriptor"))
(define (mach-port-type) : Type
  (prim-type #"MachPort"))
(define (array-type [e : Type]) : Type
  (abstract-type (prim-mod) #"Array" (varargs list e)))

(define (fun0-type [result : Type]) : Type
  (fun-type (empty) (empty) result))
(define (fun1-type [arg : Type] [result : Type]) : Type
  (fun-type (empty) (varargs list arg) result))
(define (fun2-type [arg1 : Type] [arg2 : Type] [result : Type]) : Type
  (fun-type (empty) (varargs list arg1 arg2) result))
(define (fun3-type [arg1 : Type] [arg2 : Type] [arg3 : Type] [result : Type]) : Type
  (fun-type (empty) (varargs list arg1 arg2 arg3) result))
(define (fun4-type [arg1 : Type] [arg2 : Type] [arg3 : Type] [arg4 : Type] [result : Type]) : Type
  (fun-type (empty) (varargs list arg1 arg2 arg3 arg4) result))
(define (fun5-type [arg1 : Type] [arg2 : Type] [arg3 : Type]
                   [arg4 : Type] [arg5 : Type] [result : Type]) : Type
  (fun-type (empty) (varargs list arg1 arg2 arg3 arg4 arg5) result))
(define (fun6-type [arg1 : Type] [arg2 : Type] [arg3 : Type]
                   [arg4 : Type] [arg5 : Type] [arg6 : Type] [result : Type]) : Type
  (fun-type (empty) (varargs list arg1 arg2 arg3 arg4 arg5 arg6) result))
(define (fun7-type [arg1 : Type] [arg2 : Type] [arg3 : Type] [arg4 : Type]
                   [arg5 : Type] [arg6 : Type] [arg7 : Type] [result : Type]) : Type
  (fun-type (empty) (varargs list arg1 arg2 arg3 arg4 arg5 arg6 arg7) result))

(define (math-2arg) : Type
  (fun2-type (int-type) (int-type) (int-type)))
(define (logic-2arg) : Type
  (fun2-type (int-type) (int-type) (boolean-type)))

(define (prim-signature) : ModuleSignature
  (match-define sigs
    (append (runtime-prim-sigs)
            (map prim-op->prim-op-sig (prim-ops))))
  (module-signature (prim-mod)
    (prim-values sigs)
    (make-dict bytes-cmp)
    (dict-add-all
      (make-dict bytes-cmp)
      (varargs list
        (tuple2 #"U8" (u8-type))
        (tuple2 #"S32" (s32-type))
        (tuple2 #"U32" (u32-type))
        (tuple2 #"Bytes" (bytes-type))
        (tuple2 #"Byte" (int-type))
        (tuple2 #"Int" (int-type))
        (tuple2 #"Void" (void-type))
        (tuple2 #"Boolean" (boolean-type))
        (tuple2 #"Array" (type-constructor (prim-mod) #"Array" (cons (star-kind) (empty))))
        (tuple2 #"InputPort" (file-descriptor-type))
        (tuple2 #"OutputPort" (file-descriptor-type))
        (tuple2 #"Socket" (file-descriptor-type))
        (tuple2 #"MachPort" (mach-port-type))))
    (foldl
      (lambda ([sig : PrimOpSig] [acc : (Dict TopLevelName TopLevelSignature)])
        : (Dict TopLevelName TopLevelSignature)
        (case sig
          [(prim-op-sig binding name _ inlineable)
           (match-define closure-name (bytes-append (varargs list name #"_closure")))
           (match-define top-fun-name (prim-name name))
           (match-define top-closure-name (prim-name closure-name))
           (dict-set
             (dict-set acc top-closure-name (top-level-signature (just top-fun-name) (nothing)))
             top-fun-name (top-level-signature (nothing) inlineable))]))
      sigs
      ((lambda () : (Dict TopLevelName TopLevelSignature) (make-dict top-level-name-cmp))))))

(define (prim-implementation) : (List TopLevelObject)
  (match-define (tuple2 functions closures)
    (unzip (map implement-prim-op (prim-ops))))

  (match-define mod
    (module
      (prim-mod)
      (empty-imports)
      (exports (empty) (empty) (empty))
      functions
      closures
      (make-dict top-level-name-cmp)))
  (r:module-to-top-level-objects mod))

(define (numeric-op-impl [op : NumericBinOp]) : ((List Expression) -> Expression)
  (lambda ([args : (List Expression)])
    (case args
      [(cons x (cons y (empty)))
       (prim-numeric-bin-op op x y)]
      [_ (panic #"numeric op inlined with not 2 arguments")])))

(define (comparison-op-impl [op : ComparisonBinOp]) : ((List Expression) -> Expression)
  (lambda ([args : (List Expression)])
    (case args
      [(cons x (cons y (empty)))
       (prim-comparison-bin-op op x y)]
      [_ (panic #"comparison op inlined with not 2 arguments")])))

(define (array-ref-impl) : ((List Expression) -> Expression)
  (lambda ([args : (List Expression)])
    (case args
      [(cons a (cons off (empty)))
       (array-ref-expr a off)]
      [_ (panic #"array-ref inlined with not 2 arguments")])))

(define (array-set!-impl) : ((List Expression) -> Expression)
  (lambda ([args : (List Expression)])
    (case args
      [(cons a (cons off (cons v (empty))))
       (array-set!-expr a off v)]
      [_ (panic #"array-set! inlined with not 3 arguments")])))

(define (array-length-impl) : ((List Expression) -> Expression)
  (lambda ([args : (List Expression)])
    (case args
      [(cons a (empty))
       (array-length-expr a)]
      [_ (panic #"array-length inlined with not 1 argument")])))

(define (fun-type->args [type : Type]) : (Tuple2 (List Bytes) (List Type))
  (case type
    [(fun-type tvars args result)
     (tuple2 tvars args)]
    [_ (panic #"Couldn't extract argument types")]))


(define (prim-op->prim-op-sig [p : PrimOp]) : PrimOpSig
  (match-define (prim-op binding name type impl) p)
  (prim-op-sig binding name type (just (hoas-linear-inlineable-function impl))))


(define (implement-prim-op [op : PrimOp])
  : (Tuple2 FunctionDefinition ConstantDefinition)
  (match-define (prim-op _ name type impl) op)
  ;; TODO use the tvars and args somewhere
  (match-define (tuple2 tvars arg-types) (fun-type->args type))
  (match-define vars
    (build-list (length arg-types) (lambda ([i : Int]) (var #"v" i))))

  (tuple2
    (function-definition
      name
      type
      vars
      (empty)
      (impl (map local-var-expr vars)))
    (closure-constant (bytes-append (varargs list name #"_closure")) name)))


(define (prim-op* [name : Bytes] [type : Type] [impl : ((List Expression) -> Expression)]) : PrimOp
  (prim-op name name type impl))

(define (prim-ops) : (List PrimOp)
  (varargs list
    (prim-op
      #"+" #"add"
      (math-2arg)
      (numeric-op-impl (add-op)))
    (prim-op
      #"-" #"sub"
      (math-2arg)
      (numeric-op-impl (sub-op)))
    (prim-op
      #"*" #"mult"
      (math-2arg)
      (numeric-op-impl (mult-op)))
    (prim-op*
      #"quotient"
      (math-2arg)
      (numeric-op-impl (quotient-op)))
    (prim-op*
      #"remainder"
      (math-2arg)
      (numeric-op-impl (remainder-op)))
    (prim-op
      #"bitwise-and" #"bitwise_and"
      (math-2arg)
      (numeric-op-impl (bitwise-and-op)))
    (prim-op
      #"bitwise-ior" #"bitwise_ior"
      (math-2arg)
      (numeric-op-impl (bitwise-ior-op)))
    (prim-op
      #"logical-shift-left" #"logical_shift_left"
      (math-2arg)
      (numeric-op-impl (logical-shift-left-op)))
    (prim-op
      #"logical-shift-right" #"logical_shift_right"
      (math-2arg)
      (numeric-op-impl (logical-shift-right-op)))
    (prim-op
      #"<" #"less_than"
      (logic-2arg)
      (comparison-op-impl (less-than-op)))
    (prim-op
      #"<=" #"less_than_or_equal"
      (logic-2arg)
      (comparison-op-impl (less-than-or-equal-op)))
    (prim-op
      #"=" #"equal"
      (logic-2arg)
      (comparison-op-impl (equal-op)))
    (prim-op
      #">=" #"greater_than_or_equal"
      (logic-2arg)
      (comparison-op-impl (greater-than-or-equal-op)))
    (prim-op
      #">" #"greater_than"
      (logic-2arg)
      (comparison-op-impl (greater-than-op)))
    (prim-op
      #"array-length" #"array_length"
      (fun-type (varargs list #"a") (varargs list (array-type (var-type #"a"))) (int-type))
      (array-length-impl))
    (prim-op
      #"array-ref" #"array_ref"
      (fun-type (varargs list #"a") (varargs list (array-type (var-type #"a")) (int-type))
                (var-type #"a"))
      (array-ref-impl))
    (prim-op
      #"array-set!" #"array_set"
      (fun-type (varargs list #"a")
                (varargs list (array-type (var-type #"a")) (int-type)
                              (var-type #"a"))
                (void-type))
      (array-set!-impl))))
