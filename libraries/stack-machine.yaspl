(module stack-machine
  (import
    (prim
      #:types (Bytes Byte InputPort OutputPort Void Boolean)
      #:values (void - + panic =)
      #:patterns ())
    (bytes bytes-append)
    (list
      #:types (List)
      #:values (map cons empty length list)
      #:patterns (cons empty))
    (tuples
      #:types ()
      #:values (tuple2)
      #:patterns (tuple2))
    (join-list
      #:types (JoinList)
      #:values (empty-jl jl->list snoc-jl cons-jl append-jl)
      #:patterns ())
    (bytes bytes=? bytes-append)
    (sexp-parser parse-sexp)
    (io read-all-bytes write-all-bytes)
    (numbers integer->decimal-bytes))
  (export StackFunction StackBasicBlock StackCmd StackTerminal TopLevelObject
          stack-function-blocks stack-basic-block-cmds
          stack-function stack-basic-block gen-state-cmds gen-state
          initial-variables return add-byte-literal add-boolean-literal add-bytes-literal
          name-temporary unscope-variable variable-ref
          call-function create-closure remove-temporaries boolean-jmp uncond-jmp
          tmp-slot ignore-value alloc-variant-cmd dup-cmd
          variant-ref-cmd variant-switch no-catch-all-case
          dup-temporary pop-cmd boolean-lit-cmd catch-all-case variant-case
          variant-ref var-slot swap-cmd assert-stack-equal? add-bytes-cmp add-byte-cmp
          bin-math-cmd bin-add-op bin-sub-op bin-mult-op bin-quotient-op bin-remainder-op
          bin-logic-math-cmd less-than-op less-than-or-equal-op equal-op greater-than-or-equal-op
          greater-than-op make-array-cmd array-length-cmd array-ref-cmd array-set!-cmd
          make-array-from-stack-cmd make-varargs-array known-fun-call-cmd
          function-tlo)
  (types
    (define-type StackCmd
      (num-lit-cmd [v Byte])
      (boolean-lit-cmd [v Boolean])
      (bytes-lit-cmd [v Bytes])
      (bytes-cmp-cmd)
      (create-closure-cmd [name Bytes] [num-free-vars Byte])
      (dup-cmd [offset Byte])
      (dup-free-var-cmd [offset Byte] [index Byte])
      (alloc-variant-cmd [tag Byte] [fields Byte])
      (variant-ref-cmd [tag Byte] [field Byte])
      (bin-math-cmd [op BinMathOp])
      (bin-logic-math-cmd [op BinLogicMathOp])
      (make-array-from-stack-cmd [num-args Byte])
      (make-array-cmd)
      (array-length-cmd)
      (array-ref-cmd)
      (array-set!-cmd)
      (pop-cmd)
      (swap-cmd)
      (fun-call-cmd [num-args Byte])
      (known-fun-call-cmd [name Bytes] [num-args Byte]))
    (define-type BinMathOp
      (bin-add-op)
      (bin-sub-op)
      (bin-mult-op)
      (bin-quotient-op)
      (bin-remainder-op))
    (define-type BinLogicMathOp
      (less-than-op)
      (less-than-or-equal-op)
      (equal-op)
      (greater-than-or-equal-op)
      (greater-than-op))

    (define-type AbstractStack
      (tmp-slot [stack AbstractStack])
      (return-address-slot [stack AbstractStack])
      (closure-slot [stack AbstractStack])
      (var-slot [var-name Bytes] [stack AbstractStack])
      (empty-abstract-stack))
    (define-type StackTerminal
      (boolean-jmp [true-index Byte] [false-index Byte])
      (uncond-jmp [index Byte])
      (variant-switch [cases VariantCases])
      (return [num-args Byte]))
    (define-type VariantCases
      (no-catch-all-case)
      (catch-all-case [index Byte])
      (variant-case [tag Byte] [index Byte] [cases VariantCases]))
    (define-type StackBasicBlock
      (stack-basic-block [cmds (List StackCmd)] [terminal StackTerminal]))
    (define-type StackFunction
      (stack-function [name Bytes] [closure-name Bytes] [blocks (List StackBasicBlock)]))
    (define-type TopLevelObject
      (function-tlo [v StackFunction]))

    (define-type GenState
      (gen-state [stack AbstractStack]
                 [cmds (JoinList StackCmd)]
                 [label-counter Byte]
                 [blocks (JoinList StackBasicBlock)])))


  (define (unscope-variable [var : Bytes] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot (remove-variable var (remove-temporaries 1 stack)))
         (snoc-jl (snoc-jl cmds (swap-cmd)) (pop-cmd))
         label
         blocks)]))
  (define (name-temporary [var : Bytes] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (var-slot var (remove-temporaries 1 stack))
         cmds
         label
         blocks)]))
  (define (variable-ref [var : Bytes] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot stack)
         (snoc-jl cmds (dup-cmd (stack-index var stack)))
         label
         blocks)]))

  (define (dup-temporary [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot stack)
         (snoc-jl cmds (dup-cmd 0))
         label
         blocks)]))

  (define (variant-ref [tag : Byte] [field : Byte] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot (remove-temporaries 1 stack))
         (snoc-jl cmds (variant-ref-cmd tag field))
         label
         blocks)]))

  (define (add-bytes-cmp [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot (remove-temporaries 2 stack))
         (snoc-jl cmds (bytes-cmp-cmd))
         label
         blocks)]))

  (define (add-byte-cmp [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot (remove-temporaries 2 stack))
         (snoc-jl cmds (bin-logic-math-cmd (equal-op)))
         label
         blocks)]))

  (define (create-closure [name : Bytes] [num-free-vars : Byte] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot (remove-temporaries num-free-vars stack))
         (snoc-jl cmds (create-closure-cmd name num-free-vars))
         label
         blocks)]))

  (define (call-function [num-args : Byte] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot (remove-temporaries (+ 1 num-args) stack))
         (snoc-jl cmds (fun-call-cmd num-args))
         label
         blocks)]))

  (define (ignore-value [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (remove-temporaries 1 stack)
         (snoc-jl cmds (pop-cmd))
         label
         blocks)]))

  (define (add-byte-literal [v : Byte] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot stack)
         (snoc-jl cmds (num-lit-cmd v))
         label
         blocks)]))

  (define (add-boolean-literal [v : Boolean] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot stack)
         (snoc-jl cmds (boolean-lit-cmd v))
         label
         blocks)]))

  (define (add-bytes-literal [v : Bytes] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot stack)
         (snoc-jl cmds (bytes-lit-cmd v))
         label
         blocks)]))


  (define (remove-variable [var : Bytes] [stack : AbstractStack]) : AbstractStack
    (case stack
      [(var-slot v stack)
       (if (bytes=? v var)
           stack
           (panic (bytes-append (cons #"Unexpected variable on stack when removing: "
                                      (cons var (empty))))))]
      [(tmp-slot stack)
       (panic (bytes-append (cons #"Unexpected temporary on stack when removing: "
                                      (cons var (empty)))))]
      [(return-address-slot stack) (panic #"Unexpected return address on stack")]
      [(closure-slot stack) (panic #"Unexpected closure on stack")]
      [(empty-abstract-stack) (panic #"Unexpected end of stack")]))

  (define (remove-temporaries [n : Byte] [stack : AbstractStack]) : AbstractStack
    (if (= 0 n)
        stack
        (case stack
          [(var-slot v stack) (panic #"Unexpected variable on stack")]
          [(tmp-slot stack) (remove-temporaries (- n 1) stack)]
          [(return-address-slot stack) (panic #"Unexpected return address on stack")]
          [(closure-slot stack) (panic #"Unexpected closure on stack")]
          [(empty-abstract-stack) (panic #"Unexpected end of stack")])))

  (define (initial-variables [vars : (List Bytes)]) : AbstractStack
    (initial-variables-helper vars (empty-abstract-stack)))

  (define (initial-variables-helper [vars : (List Bytes)] [stack : AbstractStack]) : AbstractStack
    (case vars
      [(empty) (return-address-slot (closure-slot stack))]
      [(cons var vars) (initial-variables-helper vars (var-slot var stack))]))


  (define (stack-index [var : Bytes] [stack : AbstractStack]) : Byte
    (stack-index-helper var stack 0))

  (define (stack-index-helper [var : Bytes] [stack : AbstractStack] [offset : Byte]) : Byte
    (case stack
      [(empty-abstract-stack) (panic #"Unbound variable")]
      [(return-address-slot stack) (stack-index-helper var stack (+ 1 offset))]
      [(closure-slot stack) (stack-index-helper var stack (+ 1 offset))]
      [(tmp-slot stack) (stack-index-helper var stack (+ 1 offset))]
      [(var-slot slot-var stack)
       (if (bytes=? var slot-var)
           offset
           (stack-index-helper var stack (+ 1 offset)))]))

  (define (assert-stack-equal? [stack1 : AbstractStack] [stack2 : AbstractStack]) : Void
    (if (stack-equal? stack1 stack2)
        (void)
        (panic
          (bytes-append
            (jl->list
              (append-jl
                (cons-jl #"Unmatched stacks:\n" (stack->bytes-jl stack1))
                (cons-jl #"\n" (stack->bytes-jl stack2))))))))

  (define (stack-equal? [stack1 : AbstractStack] [stack2 : AbstractStack]) : Boolean
    (case (tuple2 stack1 stack2)
      [(tuple2 (tmp-slot stack1) (tmp-slot stack2)) (stack-equal? stack1 stack2)]
      [(tuple2 (return-address-slot stack1) (return-address-slot stack2)) (stack-equal? stack1 stack2)]
      [(tuple2 (closure-slot stack1) (closure-slot stack2)) (stack-equal? stack1 stack2)]
      [(tuple2 (var-slot v1 stack1) (var-slot v2 stack2))
       (if (bytes=? v1 v2)
           (stack-equal? stack1 stack2)
           #f)]
      [(tuple2 (empty-abstract-stack) (empty-abstract-stack)) #t]
      [(tuple2 stack1 stack2) #f]))


  (define (stack->bytes-jl [stack : AbstractStack]) : (JoinList Bytes)
    (case stack
      [(tmp-slot stack)
       (cons-jl #"_ " (stack->bytes-jl stack))]
      [(return-address-slot stack) (cons-jl #"<ret> " (stack->bytes-jl stack))]
      [(closure-slot stack) (cons-jl #"<closure> " (stack->bytes-jl stack))]
      [(var-slot v stack)
       (cons-jl v (cons-jl #" " (stack->bytes-jl stack)))]
      [(empty-abstract-stack) (empty-jl)]))

  (define (make-varargs-array [num-args : Byte] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot (remove-temporaries num-args stack))
         (snoc-jl cmds (make-array-from-stack-cmd num-args))
         label
         blocks)])))
