(module stack-machine
  (import
    (prim
      #:types (Bytes Byte InputPort OutputPort Void Boolean)
      #:values (void - + panic =)
      #:patterns ())
    (arithmetic-expr
      #:types (ArithExpr NumOp Module Function)
      #:values (parse-arith-expr)
      #:patterns (module function
                  var-expr num-op-expr fun-call-expr num-lit
                  plus-op minus-op times-op let-expr))
    (list
      #:types (List)
      #:values (map cons empty length)
      #:patterns (cons empty))
    (join-list
      #:types (JoinList)
      #:values (empty-jl jl->list snoc-jl)
      #:patterns ())
    (bytes bytes=?)
    (sexp-parser parse-sexp)
    (io read-all-bytes write-all-bytes write-newline)
    (numbers integer->decimal-bytes))
  (export StackFunction StackBasicBlock StackCmd StackTerminal
          compile-module stack-function-blocks stack-basic-block-cmds
          stack-function stack-basic-block gen-state-cmds gen-state
          initial-variables return add-byte-literal add-boolean-literal add-bytes-literal
          name-temporary unscope-variable variable-ref
          call-function function-ref remove-temporaries boolean-jmp uncond-jmp
          tmp-slot)
  (types
    (define-type StackCmd
      (num-lit-cmd [v Byte])
      (boolean-lit-cmd [v Boolean])
      (bytes-lit-cmd [v Bytes])
      (fun-ref-cmd [name Bytes])
      (dup-cmd [offset Byte])
      (pop-cmd)
      (swap-cmd)
      (fun-call-cmd [num-args Byte]))
    (define-type AbstractStack
      (tmp-slot [stack AbstractStack])
      (return-address-slot [stack AbstractStack])
      (var-slot [var-name Bytes] [stack AbstractStack])
      (empty-abstract-stack))
    (define-type StackTerminal
      (boolean-jmp [true-index Byte] [false-index Byte])
      (uncond-jmp [index Byte])
      (return [num-args Byte]))
    (define-type StackBasicBlock
      (stack-basic-block [cmds (List StackCmd)] [terminal StackTerminal]))
    (define-type StackFunction
      (stack-function [name Bytes] [blocks (List StackBasicBlock)]))

    (define-type GenState
      (gen-state [stack AbstractStack]
                 [cmds (JoinList StackCmd)]
                 [label-counter Byte]
                 [blocks (JoinList StackBasicBlock)])))

  (define (compile-module [mod : Module]) : (List StackFunction)
    (case mod
      [(module functions)
       (map compile-function functions)]))

  (define (compile-function [function : Function]) : StackFunction
    (case function
      [(function name arg-names body)
       (stack-function
         name
         ;; TODO validate the genstate has one temporary left in it, the return addr, and then the
         ;; variables.
         (case (compile-arith-expr body
                 (gen-state (initial-variables arg-names) (empty-jl) 1 (empty-jl)))
           [(gen-state _ cmds _ blocks)
            (cons
              (stack-basic-block (jl->list cmds) (return (length arg-names)))
              (jl->list blocks))]))]))

  (define (compile-arith-expr [expr : ArithExpr] [state : GenState]) : GenState
    (case expr
      [(let-expr var expr body)
       (unscope-variable var
         (compile-arith-expr body
           (name-temporary var
             (compile-arith-expr expr state))))]
      [(var-expr var)
       (variable-ref var state) ]
      [(num-op-expr op left right)
       (add-op op
         (compile-arith-expr right
           (compile-arith-expr left state)))]
      [(fun-call-expr name args)
       (call-function (length args)
         (function-ref name
           (compile-arith-exprs args state)))]
      [(num-lit v)
       (add-byte-literal v state)]))


  (define (compile-arith-exprs [exprs : (List ArithExpr)] [state : GenState]) : GenState
    (case exprs
      [(empty) state]
      [(cons expr exprs)
       (compile-arith-exprs exprs
         (compile-arith-expr expr state))]))

  (define (unscope-variable [var : Bytes] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot (remove-variable var (remove-temporaries 1 stack)))
         (snoc-jl (snoc-jl cmds (swap-cmd)) (pop-cmd))
         label
         blocks)]))
  (define (name-temporary [var : Bytes] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (var-slot var (remove-temporaries 1 stack))
         cmds
         label
         blocks)]))
  (define (variable-ref [var : Bytes] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot stack)
         (snoc-jl cmds (dup-cmd (stack-index var stack)))
         label
         blocks)]))

  (define (add-op [v : NumOp] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot (remove-temporaries 2 stack))
         (snoc-jl
           (snoc-jl
             cmds
             (case v
               [(plus-op) (fun-ref-cmd #"prim_add")]
               [(times-op) (fun-ref-cmd #"prim_mult")]
               [(minus-op) (fun-ref-cmd #"prim_sub")]))
           (fun-call-cmd 2))
         label
         blocks)]))

  (define (function-ref [name : Bytes] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot stack)
         (snoc-jl cmds (fun-ref-cmd name))
         label
         blocks)]))

  (define (call-function [num-args : Byte] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot (remove-temporaries (+ 1 num-args) stack))
         (snoc-jl cmds (fun-call-cmd num-args))
         label
         blocks)]))


  (define (add-byte-literal [v : Byte] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot stack)
         (snoc-jl cmds (num-lit-cmd v))
         label
         blocks)]))

  (define (add-boolean-literal [v : Boolean] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot stack)
         (snoc-jl cmds (boolean-lit-cmd v))
         label
         blocks)]))

  (define (add-bytes-literal [v : Bytes] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot stack)
         (snoc-jl cmds (bytes-lit-cmd v))
         label
         blocks)]))


  (define (remove-variable [var : Bytes] [stack : AbstractStack]) : AbstractStack
    (case stack
      [(var-slot v stack)
       (if (bytes=? v var)
           stack
           (panic #"Unexpected variable on stack"))]
      [(tmp-slot stack) (panic #"Unexpected temporary on stack")]
      [(return-address-slot stack) (panic #"Unexpected return address on stack")]
      [(empty-abstract-stack) (panic #"Unexpected end of stack")]))

  (define (remove-temporaries [n : Byte] [stack : AbstractStack]) : AbstractStack
    (if (= 0 n)
        stack
        (case stack
          [(var-slot v stack) (panic #"Unexpected variable on stack")]
          [(tmp-slot stack) (remove-temporaries (- n 1) stack)]
          [(return-address-slot stack) (panic #"Unexpected return address on stack")]
          [(empty-abstract-stack) (panic #"Unexpected end of stack")])))

  (define (initial-variables [vars : (List Bytes)]) : AbstractStack
    (initial-variables-helper vars (empty-abstract-stack)))

  (define (initial-variables-helper [vars : (List Bytes)] [stack : AbstractStack]) : AbstractStack
    (case vars
      [(empty) (return-address-slot stack)]
      [(cons var vars) (initial-variables-helper vars (var-slot var stack))]))


  (define (stack-index [var : Bytes] [stack : AbstractStack]) : Byte
    (stack-index-helper var stack 0))

  (define (stack-index-helper [var : Bytes] [stack : AbstractStack] [offset : Byte]) : Byte
    (case stack
      [(empty-abstract-stack) (panic #"Unbound variable")]
      [(return-address-slot stack) (stack-index-helper var stack (+ 1 offset))]
      [(tmp-slot stack) (stack-index-helper var stack (+ 1 offset))]
      [(var-slot slot-var stack)
       (if (bytes=? var slot-var)
           offset
           (stack-index-helper var stack (+ 1 offset)))]))

  (define (num-op->bytes [op : NumOp]) : Bytes
    (case op
      [(plus-op) #"+"]
      [(minus-op) #"-"]
      [(times-op) #"*"])))
