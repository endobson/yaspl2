(module stack-machine
  (import
    (prim
      #:types (Bytes Byte InputPort OutputPort Void)
      #:values (void +)
      #:patterns ())
    (arithmetic-expr
      #:types (ArithExpr NumOp Module Function)
      #:values (parse-arith-expr)
      #:patterns (module function num-op-expr fun-call-expr num-lit plus-op minus-op times-op let-expr))
    (list
      #:types (List)
      #:values (cons empty cons-head)
      #:patterns (cons empty))
    (sexp-parser parse-sexp)
    (io read-all-bytes write-all-bytes write-newline)
    (numbers integer->decimal-bytes))
  (export StackFunction StackBasicBlock StackCmd StackTerminal
          compile-module stack-function-blocks stack-basic-block-cmds)
  (types
    (define-type StackCmd
      (num-lit-cmd [v Byte])
      ;; TODO use this when variables are supported in ArithExpr
      (dup-cmd [offset Byte])
      (pop-cmd)
      (swap-cmd)
      (fun-call-cmd [name Bytes] [num-args Byte])
      (eval-op-cmd [v NumOp]))
    (define-type Env
      (env-entry [var-name Bytes] [env Env])
      (empty-env))
    (define-type StackTerminal
      (return))
    (define-type StackBasicBlock
      (stack-basic-block [cmds (List StackCmd)] [terminal StackTerminal]))
    (define-type StackFunction
      (stack-function [name Bytes] [blocks (List StackBasicBlock)])))

  (define (compile-module [mod : Module]) : (List StackFunction)
    (case mod
      [(module functions)
       (compile-functions functions)]))


  (define (compile-functions [functions : (List Function)]) : (List StackFunction)
    (case functions
      [(empty) (empty)]
      [(cons function functions)
       (cons (compile-function function) (compile-functions functions))]))

  (define (compile-function [function : Function]) : StackFunction
    (case function
      [(function name arg-names body)
       ;; TODO Make environment wth argument names
       (stack-function
         name
         (cons (stack-basic-block (compile-arith-expr body (empty-env) (empty)) (return))
               (empty)))]))

  (define (compile-arith-expr [expr : ArithExpr] [env : Env] [cmds : (List StackCmd)]) : (List StackCmd)
    (case expr
      [(let-expr var expr body)
       (compile-arith-expr expr env
         (compile-arith-expr body (env-entry var env)
           (cons (swap-cmd) (cons (pop-cmd) cmds))))]
      [(num-op-expr op left right)
       (compile-arith-expr left env (compile-arith-expr right env (cons (eval-op-cmd op) cmds)))]
      [(fun-call-expr bytes args)
       (compile-arith-exprs args env (cons (fun-call-cmd bytes (length args)) cmds))]
      [(num-lit v)
       (cons (num-lit-cmd v) cmds)]))

  (define (compile-arith-exprs [exprs : (List ArithExpr)] [env : Env] [cmds : (List StackCmd)]) : (List StackCmd)
    (case exprs
      [(empty) cmds]
      [(cons expr exprs)
       (compile-arith-exprs exprs env (compile-arith-expr expr env cmds))]))


  (define (print-function [sfun : StackFunction] [output : OutputPort]) : Void
    (print-cmds (stack-basic-block-cmds (cons-head (stack-function-blocks sfun))) output))

  (define (print-cmds [cmds : (List StackCmd)] [output : OutputPort]) : Void
    (case cmds
      [(empty) (void)]
      [(cons cmd cmds)
       (case cmd
         [(num-lit-cmd v)
          (begin
            (write-all-bytes (integer->decimal-bytes v) output)
            (write-newline output)
            (print-cmds cmds output))]
         [(eval-op-cmd op)
          (begin
            (write-all-bytes (num-op->bytes op) output)
            (write-newline output)
            (print-cmds cmds output))])]))

  (define (num-op->bytes [op : NumOp]) : Bytes
    (case op
      [(plus-op) #"+"]
      [(minus-op) #"-"]
      [(times-op) #"*"]))

  (define (length [l : (List ArithExpr)]) : Byte
    (case l
      [(empty) 0]
      [(cons e l) (+ 1 (length l))])))
