(module stack-machine
  (import
    (prim
      #:types (Bytes Byte InputPort OutputPort Void Boolean)
      #:values (void - + panic =)
      #:patterns ())
    (arithmetic-expr
      #:types (ArithExpr NumOp Module Function)
      #:values (parse-arith-expr)
      #:patterns (module function
                  var-expr num-op-expr fun-call-expr num-lit
                  plus-op minus-op times-op let-expr))
    (list
      #:types (List)
      #:values (map cons empty length)
      #:patterns (cons empty))
    (tuples
      #:types ()
      #:values (tuple2)
      #:patterns (tuple2))
    (join-list
      #:types (JoinList)
      #:values (empty-jl jl->list snoc-jl cons-jl append-jl)
      #:patterns ())
    (bytes bytes=? bytes-append)
    (sexp-parser parse-sexp)
    (io read-all-bytes write-all-bytes)
    (numbers integer->decimal-bytes))
  (export StackFunction StackBasicBlock StackCmd StackTerminal
          compile-module stack-function-blocks stack-basic-block-cmds
          stack-function stack-basic-block gen-state-cmds gen-state
          initial-variables return add-byte-literal add-boolean-literal add-bytes-literal
          name-temporary unscope-variable variable-ref
          call-function function-ref remove-temporaries boolean-jmp uncond-jmp
          tmp-slot ignore-value alloc-variant-cmd dup-cmd
          variant-ref-cmd variant-switch no-catch-all-case
          dup-temporary pop-cmd boolean-lit-cmd catch-all-case variant-case
          variant-ref var-slot swap-cmd assert-stack-equal? add-bytes-cmp
          bin-math-cmd bin-add-op bin-sub-op bin-mult-op bin-quotient-op bin-remainder-op
          bin-logic-math-cmd less-than-op less-than-or-equal-op equal-op greater-than-or-equal-op
          greater-than-op make-array-cmd array-length-cmd array-ref-cmd array-set!-cmd)
  (types
    (define-type StackCmd
      (num-lit-cmd [v Byte])
      (boolean-lit-cmd [v Boolean])
      (bytes-lit-cmd [v Bytes])
      (bytes-cmp-cmd)
      (fun-ref-cmd [name Bytes])
      (dup-cmd [offset Byte])
      (alloc-variant-cmd [tag Byte] [fields Byte])
      (variant-ref-cmd [tag Byte] [field Byte])
      (bin-math-cmd [op BinMathOp])
      (bin-logic-math-cmd [op BinLogicMathOp])
      (make-array-cmd)
      (array-length-cmd)
      (array-ref-cmd)
      (array-set!-cmd)
      (pop-cmd)
      (swap-cmd)
      (fun-call-cmd [num-args Byte]))
    (define-type BinMathOp
      (bin-add-op)
      (bin-sub-op)
      (bin-mult-op)
      (bin-quotient-op)
      (bin-remainder-op))
    (define-type BinLogicMathOp
      (less-than-op)
      (less-than-or-equal-op)
      (equal-op)
      (greater-than-or-equal-op)
      (greater-than-op))

    (define-type AbstractStack
      (tmp-slot [stack AbstractStack])
      (return-address-slot [stack AbstractStack])
      (var-slot [var-name Bytes] [stack AbstractStack])
      (empty-abstract-stack))
    (define-type StackTerminal
      (boolean-jmp [true-index Byte] [false-index Byte])
      (uncond-jmp [index Byte])
      (variant-switch [cases VariantCases])
      (return [num-args Byte]))
    (define-type VariantCases
      (no-catch-all-case)
      (catch-all-case [index Byte])
      (variant-case [tag Byte] [index Byte] [cases VariantCases]))
    (define-type StackBasicBlock
      (stack-basic-block [cmds (List StackCmd)] [terminal StackTerminal]))
    (define-type StackFunction
      (stack-function [name Bytes] [blocks (List StackBasicBlock)]))

    (define-type GenState
      (gen-state [stack AbstractStack]
                 [cmds (JoinList StackCmd)]
                 [label-counter Byte]
                 [blocks (JoinList StackBasicBlock)])))

  (define (compile-module [mod : Module]) : (List StackFunction)
    (case mod
      [(module functions)
       (map compile-function functions)]))

  (define (compile-function [function : Function]) : StackFunction
    (case function
      [(function name arg-names body)
       (stack-function
         name
         ;; TODO validate the genstate has one temporary left in it, the return addr, and then the
         ;; variables.
         (case (compile-arith-expr body
                 (gen-state (initial-variables arg-names) (empty-jl) 1 (empty-jl)))
           [(gen-state _ cmds _ blocks)
            (cons
              (stack-basic-block (jl->list cmds) (return (length arg-names)))
              (jl->list blocks))]))]))

  (define (compile-arith-expr [expr : ArithExpr] [state : GenState]) : GenState
    (case expr
      [(let-expr var expr body)
       (unscope-variable var
         (compile-arith-expr body
           (name-temporary var
             (compile-arith-expr expr state))))]
      [(var-expr var)
       (variable-ref var state) ]
      [(num-op-expr op left right)
       (add-op op
         (compile-arith-expr right
           (compile-arith-expr left state)))]
      [(fun-call-expr name args)
       (call-function (length args)
         (function-ref name
           (compile-arith-exprs args state)))]
      [(num-lit v)
       (add-byte-literal v state)]))


  (define (compile-arith-exprs [exprs : (List ArithExpr)] [state : GenState]) : GenState
    (case exprs
      [(empty) state]
      [(cons expr exprs)
       (compile-arith-exprs exprs
         (compile-arith-expr expr state))]))

  (define (unscope-variable [var : Bytes] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot (remove-variable var (remove-temporaries 1 stack)))
         (snoc-jl (snoc-jl cmds (swap-cmd)) (pop-cmd))
         label
         blocks)]))
  (define (name-temporary [var : Bytes] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (var-slot var (remove-temporaries 1 stack))
         cmds
         label
         blocks)]))
  (define (variable-ref [var : Bytes] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot stack)
         (snoc-jl cmds (dup-cmd (stack-index var stack)))
         label
         blocks)]))

  (define (dup-temporary [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot stack)
         (snoc-jl cmds (dup-cmd 0))
         label
         blocks)]))

  (define (variant-ref [tag : Byte] [field : Byte] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot (remove-temporaries 1 stack))
         (snoc-jl cmds (variant-ref-cmd tag field))
         label
         blocks)]))

  (define (add-bytes-cmp [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot (remove-temporaries 2 stack))
         (snoc-jl cmds (bytes-cmp-cmd))
         label
         blocks)]))

  (define (add-op [v : NumOp] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot (remove-temporaries 2 stack))
         (snoc-jl
           (snoc-jl
             cmds
             (case v
               [(plus-op) (fun-ref-cmd #"prim_add")]
               [(times-op) (fun-ref-cmd #"prim_mult")]
               [(minus-op) (fun-ref-cmd #"prim_sub")]))
           (fun-call-cmd 2))
         label
         blocks)]))

  (define (function-ref [name : Bytes] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot stack)
         (snoc-jl cmds (fun-ref-cmd name))
         label
         blocks)]))

  (define (call-function [num-args : Byte] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot (remove-temporaries (+ 1 num-args) stack))
         (snoc-jl cmds (fun-call-cmd num-args))
         label
         blocks)]))

  (define (ignore-value [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (remove-temporaries 1 stack)
         (snoc-jl cmds (pop-cmd))
         label
         blocks)]))

  (define (add-byte-literal [v : Byte] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot stack)
         (snoc-jl cmds (num-lit-cmd v))
         label
         blocks)]))

  (define (add-boolean-literal [v : Boolean] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot stack)
         (snoc-jl cmds (boolean-lit-cmd v))
         label
         blocks)]))

  (define (add-bytes-literal [v : Bytes] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (gen-state
         (tmp-slot stack)
         (snoc-jl cmds (bytes-lit-cmd v))
         label
         blocks)]))


  (define (remove-variable [var : Bytes] [stack : AbstractStack]) : AbstractStack
    (case stack
      [(var-slot v stack)
       (if (bytes=? v var)
           stack
           (panic (bytes-append (cons #"Unexpected variable on stack when removing: "
                                      (cons var (empty))))))]
      [(tmp-slot stack)
       (panic (bytes-append (cons #"Unexpected temporary on stack when removing: "
                                      (cons var (empty)))))]
      [(return-address-slot stack) (panic #"Unexpected return address on stack")]
      [(empty-abstract-stack) (panic #"Unexpected end of stack")]))

  (define (remove-temporaries [n : Byte] [stack : AbstractStack]) : AbstractStack
    (if (= 0 n)
        stack
        (case stack
          [(var-slot v stack) (panic #"Unexpected variable on stack")]
          [(tmp-slot stack) (remove-temporaries (- n 1) stack)]
          [(return-address-slot stack) (panic #"Unexpected return address on stack")]
          [(empty-abstract-stack) (panic #"Unexpected end of stack")])))

  (define (initial-variables [vars : (List Bytes)]) : AbstractStack
    (initial-variables-helper vars (empty-abstract-stack)))

  (define (initial-variables-helper [vars : (List Bytes)] [stack : AbstractStack]) : AbstractStack
    (case vars
      [(empty) (return-address-slot stack)]
      [(cons var vars) (initial-variables-helper vars (var-slot var stack))]))


  (define (stack-index [var : Bytes] [stack : AbstractStack]) : Byte
    (stack-index-helper var stack 0))

  (define (stack-index-helper [var : Bytes] [stack : AbstractStack] [offset : Byte]) : Byte
    (case stack
      [(empty-abstract-stack) (panic #"Unbound variable")]
      [(return-address-slot stack) (stack-index-helper var stack (+ 1 offset))]
      [(tmp-slot stack) (stack-index-helper var stack (+ 1 offset))]
      [(var-slot slot-var stack)
       (if (bytes=? var slot-var)
           offset
           (stack-index-helper var stack (+ 1 offset)))]))

  (define (assert-stack-equal? [stack1 : AbstractStack] [stack2 : AbstractStack]) : Void
    (if (stack-equal? stack1 stack2)
        (void)
        (panic
          (bytes-append
            (jl->list
              (append-jl
                (cons-jl #"Unmatched stacks:\n" (stack->bytes-jl stack1))
                (cons-jl #"\n" (stack->bytes-jl stack2))))))))

  (define (stack-equal? [stack1 : AbstractStack] [stack2 : AbstractStack]) : Boolean
    (case (tuple2 stack1 stack2)
      [(tuple2 (tmp-slot stack1) (tmp-slot stack2)) (stack-equal? stack1 stack2)]
      [(tuple2 (return-address-slot stack1) (return-address-slot stack2)) (stack-equal? stack1 stack2)]
      [(tuple2 (var-slot v1 stack1) (var-slot v2 stack2))
       (if (bytes=? v1 v2)
           (stack-equal? stack1 stack2)
           #f)]
      [(tuple2 (empty-abstract-stack) (empty-abstract-stack)) #t]
      [(tuple2 stack1 stack2) #f]))


  (define (stack->bytes-jl [stack : AbstractStack]) : (JoinList Bytes)
    (case stack
      [(tmp-slot stack)
       (cons-jl #"_ " (stack->bytes-jl stack))]
      [(return-address-slot stack) (cons-jl #"<ret> " (stack->bytes-jl stack))]
      [(var-slot v stack)
       (cons-jl v (cons-jl #" " (stack->bytes-jl stack)))]
      [(empty-abstract-stack) (empty-jl)])))
