(module stack-machine
  (import
    (prim
      #:types (Bytes Byte InputPort OutputPort Void)
      #:values (void - + panic =)
      #:patterns ())
    (arithmetic-expr
      #:types (ArithExpr NumOp Module Function)
      #:values (parse-arith-expr)
      #:patterns (module function
                  var-expr num-op-expr fun-call-expr num-lit
                  plus-op minus-op times-op let-expr))
    (list
      #:types (List)
      #:values (map cons empty length)
      #:patterns (cons empty))
    (join-list
      #:types (JoinList)
      #:values (empty-jl jl->list snoc-jl)
      #:patterns ())
    (bytes bytes=?)
    (sexp-parser parse-sexp)
    (io read-all-bytes write-all-bytes write-newline)
    (numbers integer->decimal-bytes))
  (export StackFunction StackBasicBlock StackCmd StackTerminal
          compile-module stack-function-blocks stack-basic-block-cmds)
  (types
    (define-type StackCmd
      (num-lit-cmd [v Byte])
      (dup-cmd [offset Byte])
      (pop-cmd)
      (swap-cmd)
      (fun-call-cmd [name Bytes] [num-args Byte])
      (eval-op-cmd [v NumOp]))
    (define-type AbstractStack
      (tmp-slot [stack AbstractStack])
      (return-address-slot [stack AbstractStack])
      (var-slot [var-name Bytes] [stack AbstractStack])
      (empty-abstract-stack))
    (define-type StackTerminal
      (return [num-args Byte]))
    (define-type StackBasicBlock
      (stack-basic-block [cmds (List StackCmd)] [terminal StackTerminal]))
    (define-type StackFunction
      (stack-function [name Bytes] [blocks (List StackBasicBlock)]))

    (define-type GenState
      (gen-state [stack AbstractStack] [cmds (JoinList StackCmd)])))

  (define (compile-module [mod : Module]) : (List StackFunction)
    (case mod
      [(module functions)
       (map compile-function functions)]))

  (define (compile-function [function : Function]) : StackFunction
    (case function
      [(function name arg-names body)
       (stack-function
         name
         (cons
           (stack-basic-block
             ;; TODO validate this has one temporary left in it, the return addr, and then the variables.
             (jl->list
               (gen-state-cmds
                 (compile-arith-expr body (gen-state (initial-variables arg-names) (empty-jl)))))
             (return (length arg-names)))
           (empty)))]))

  (define (compile-arith-expr [expr : ArithExpr] [state : GenState]) : GenState
    (case expr
      [(let-expr var expr body)
       (unscope-variable var
         (compile-arith-expr body
           (name-temporary var
             (compile-arith-expr expr state))))]
      [(var-expr var)
       (variable-ref var state) ]
      [(num-op-expr op left right)
       (add-op op
         (compile-arith-expr right
           (compile-arith-expr left state)))]
      [(fun-call-expr bytes args)
       (call-function bytes (length args)
         (compile-arith-exprs args state))]
      [(num-lit v)
       (add-literal v state)]))


  (define (compile-arith-exprs [exprs : (List ArithExpr)] [state : GenState]) : GenState
    (case exprs
      [(empty) state]
      [(cons expr exprs)
       (compile-arith-exprs exprs
         (compile-arith-expr expr state))]))

  (define (unscope-variable [var : Bytes] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds)
       (gen-state
         (tmp-slot (remove-variable var (remove-temporaries 1 stack)))
         (snoc-jl (snoc-jl cmds (swap-cmd)) (pop-cmd)))]))
  (define (name-temporary [var : Bytes] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds)
       (gen-state
         (var-slot var (remove-temporaries 1 stack))
         cmds)]))
  (define (variable-ref [var : Bytes] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds)
       (gen-state
         (tmp-slot stack)
         (snoc-jl cmds (dup-cmd (stack-index var stack))))]))

  (define (add-op [v : NumOp] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds)
       (gen-state
         (tmp-slot (remove-temporaries 2 stack))
         (snoc-jl cmds (eval-op-cmd v)))]))
  (define (call-function [name : Bytes] [num-args : Byte] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds)
       (gen-state
         (tmp-slot (remove-temporaries num-args stack))
         (snoc-jl cmds (fun-call-cmd name num-args)))]))
  (define (add-literal [v : Byte] [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds)
       (gen-state
         (tmp-slot stack)
         (snoc-jl cmds (num-lit-cmd v)))]))

  (define (remove-variable [var : Bytes] [stack : AbstractStack]) : AbstractStack
    (case stack
      [(var-slot v stack)
       (if (bytes=? v var)
           stack
           (panic #"Unexpected variable on stack"))]
      [(tmp-slot stack) (panic #"Unexpected temporary on stack")]
      [(return-address-slot stack) (panic #"Unexpected return address on stack")]
      [(empty-abstract-stack) (panic #"Unexpected end of stack")]))

  (define (remove-temporaries [n : Byte] [stack : AbstractStack]) : AbstractStack
    (if (= 0 n)
        stack
        (case stack
          [(var-slot v stack) (panic #"Unexpected variable on stack")]
          [(tmp-slot stack) (remove-temporaries (- n 1) stack)]
          [(return-address-slot stack) (panic #"Unexpected return address on stack")]
          [(empty-abstract-stack) (panic #"Unexpected end of stack")])))

  (define (initial-variables [vars : (List Bytes)]) : AbstractStack
    (initial-variables-helper vars (empty-abstract-stack)))

  (define (initial-variables-helper [vars : (List Bytes)] [stack : AbstractStack]) : AbstractStack
    (case vars
      [(empty) (return-address-slot stack)]
      [(cons var vars) (initial-variables-helper vars (var-slot var stack))]))


  (define (stack-index [var : Bytes] [stack : AbstractStack]) : Byte
    (stack-index-helper var stack 0))

  (define (stack-index-helper [var : Bytes] [stack : AbstractStack] [offset : Byte]) : Byte
    (case stack
      [(empty-abstract-stack) (panic #"Unbound variable")]
      [(return-address-slot stack) (stack-index-helper var stack (+ 1 offset))]
      [(tmp-slot stack) (stack-index-helper var stack (+ 1 offset))]
      [(var-slot slot-var stack)
       (if (bytes=? var slot-var)
           offset
           (stack-index-helper var stack (+ 1 offset)))]))

  (define (num-op->bytes [op : NumOp]) : Bytes
    (case op
      [(plus-op) #"+"]
      [(minus-op) #"-"]
      [(times-op) #"*"])))
