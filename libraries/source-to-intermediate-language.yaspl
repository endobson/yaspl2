(module source-to-intermediate-language
  (import
    (prim
      #:types (Bytes)
      #:values (panic)
      #:patterns ())
    (bytes bytes-append bytes=?)
    (list
      #:types (List)
      #:values (empty cons list map)
      #:patterns (empty cons))
    (dict
      #:types (Dict)
      #:values (dict-set make-dict dict-ref)
      #:patterns ())
    (maybe
      #:types (Maybe)
      #:values ()
      #:patterns (just nothing))
    (set
      #:types (Set)
      #:values (set->list)
      #:patterns ())
    (tuples
      #:types (Tuple2)
      #:values (tuple2)
      #:patterns (tuple2))
    (free-variables free-variables)
    (intermediate-language
      #:types
        ((Module i:Module)
         (FunctionDefinition i:FunctionDefinition)
         (Expression i:Expression)
         (CaseClause i:CaseClause)
         ClosureConstant)
      #:values
        ((module i:module)
         (function-definition i:function-definition)
         (byte-literal i:byte-literal)
         (bytes-literal i:bytes-literal)
         (boolean-literal i:boolean-literal)
         (local-var-expr i:local-var-expr)
         (if-expr i:if-expr)
         (begin-expr i:begin-expr)
         (create-closure-expr i:create-closure-expr)
         (call-closure-expr i:call-closure-expr)
         (varargs-call-closure-expr i:varargs-call-closure-expr)
         (let-expr i:let-expr)
         (case-expr i:case-expr)
         (case-clause i:case-clause)
         closure-constant)
      #:patterns (closure-constant))
    (source-language
      #:types (Module FunctionDefinition Expression CaseClause PreType)
      #:values (var-pre-type)
      #:patterns (module function-definition byte-literal bytes-literal
                  boolean-literal var-expr if-expr begin-expr lambda-expr
                  let-expr case-expr case-clause app-expr varargs-app-expr)))
  (export source->intermediate)
  (types
    (define-type Environment
      (environment)))

  (define (source->intermediate [mod : Module]) : i:Module
    (case mod
      [(module name imports _ types definitions)
       (i:module
         name
         imports
         types
         (convert-function-definitions
           definitions
           (environment)
           (empty))
         (create-closures definitions (empty)))]))

  (define (create-closures
            [funs : (List FunctionDefinition)]
            [acc : (List ClosureConstant)]) : (List ClosureConstant)
    (case funs
      [(empty) acc]
      [(cons (function-definition name type args body) funs)
       (create-closures
         funs
         (cons (closure-constant name (bytes-append (varargs list name #"-code"))) acc))]))

  (define (convert-function-definitions
            [funs : (List FunctionDefinition)]
            [env : Environment]
            [acc : (List i:FunctionDefinition)]) : (List i:FunctionDefinition)
    (case funs
      [(empty) acc]
      [(cons fun funs)
       (convert-function-definitions funs env (convert-function-definition fun env acc))]))

  (define (convert-function-definition
            [fun : FunctionDefinition]
            [env : Environment]
            [acc : (List i:FunctionDefinition)])
    : (List i:FunctionDefinition)
    (case fun
      [(function-definition name type args body)
       (case (convert-expression body env acc)
         [(tuple2 i:body acc)
          (cons
            (i:function-definition
              (bytes-append (varargs list name #"-code"))
              type args (empty) i:body)
            acc)])]))

  (define (parse-arg [arg+ty : (Tuple2 Bytes PreType)]) : Bytes
    (case arg+ty
      [(tuple2 arg ty) arg]))

  (define (convert-expression [expr : Expression] [env : Environment] [acc : (List i:FunctionDefinition)])
    : (Tuple2 i:Expression (List i:FunctionDefinition))
    (case expr
      [(byte-literal v) (tuple2 (i:byte-literal v) acc)]
      [(bytes-literal v) (tuple2 (i:bytes-literal v) acc)]
      [(boolean-literal v) (tuple2 (i:boolean-literal v) acc)]
      ;; TODO handle this correctly
      [(var-expr v) (tuple2 (i:local-var-expr v) acc)]
      [(if-expr c t f)
       (case (convert-expression c env acc)
         [(tuple2 ic acc)
          (case (convert-expression t env acc)
            [(tuple2 it acc)
             (case (convert-expression f env acc)
               [(tuple2 if acc)
                (tuple2 (i:if-expr ic it if) acc)])])])]
      [(begin-expr e es)
       (case (convert-expression e env acc)
         [(tuple2 ie acc)
          (case (convert-expressions es env acc)
            [(tuple2 ies acc)
             (tuple2 (i:begin-expr ie ies) acc)])])]
      [(let-expr name expr body)
       (case (convert-expression expr env acc)
         [(tuple2 iexpr acc)
          (case (convert-expression body env acc)
            [(tuple2 ibody acc)
             (tuple2 (i:let-expr name iexpr ibody) acc)])])]
      [(case-expr expr clauses)
       (case (convert-expression expr env acc)
         [(tuple2 iexpr acc)
          (case (convert-clauses clauses env acc)
            [(tuple2 iclauses acc)
             (tuple2 (i:case-expr iexpr iclauses) acc)])])]
      [(lambda-expr args+tys body)
       (let ([fv (free-variables body)])
         (case (convert-expression body env acc)
           [(tuple2 ibody acc)
            ;; TODO use a real type
            (tuple2
              (i:create-closure-expr (i:local-var-expr #"closure-name") (empty))
              (cons
                (i:function-definition
                  #"closure-name" (var-pre-type #"bogus")
                  (map parse-arg args+tys) (set->list fv) ibody)
                acc))]))]
      [(app-expr op args)
       (case (convert-expression op env acc)
         [(tuple2 iop acc)
          (case (convert-expressions args env acc)
            [(tuple2 iargs acc)
             (tuple2 (i:call-closure-expr iop iargs) acc)])])]
      [(varargs-app-expr op args)
       (case (convert-expression op env acc)
         [(tuple2 iop acc)
          (case (convert-expressions args env acc)
            [(tuple2 iargs acc)
             (tuple2 (i:varargs-call-closure-expr iop iargs) acc)])])]))

  (define (convert-clause [clause : CaseClause] [env : Environment] [acc : (List i:FunctionDefinition)])
    : (Tuple2 i:CaseClause (List i:FunctionDefinition))
    (case clause
      [(case-clause pat expr)
       (case (convert-expression expr env acc)
         [(tuple2 iexpr acc)
          (tuple2 (i:case-clause pat iexpr) acc)])]))

  (define (convert-expressions
            [exprs : (List Expression)]
            [env : Environment]
            [acc : (List i:FunctionDefinition)])
    : (Tuple2 (List i:Expression) (List i:FunctionDefinition))
    (case exprs
      [(empty) (tuple2 (empty) acc)]
      [(cons e es)
       (case (convert-expression e env acc)
         [(tuple2 ie acc)
          (case (convert-expressions es env acc)
            [(tuple2 ies acc)
             (tuple2 (cons ie ies) acc)])])]))

  (define (convert-clauses
            [clauses : (List CaseClause)]
            [env : Environment]
            [acc : (List i:FunctionDefinition)])
    : (Tuple2 (List i:CaseClause) (List i:FunctionDefinition))
    (case clauses
      [(empty) (tuple2 (empty) acc)]
      [(cons c cs)
       (case (convert-clause c env acc)
         [(tuple2 ic acc)
          (case (convert-clauses cs env acc)
            [(tuple2 ics acc)
             (tuple2 (cons ic ics) acc)])])])))
