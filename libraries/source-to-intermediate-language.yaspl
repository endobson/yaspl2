(module source-to-intermediate-language
  (import
    (prim
      #:types (Byte Bytes)
      #:values (+)
      #:patterns ())
    (bytes bytes-append bytes=?)
    (list
      #:types (List)
      #:values (empty cons list map)
      #:patterns (empty cons))
    (maybe
      #:types (Maybe)
      #:values ()
      #:patterns (just nothing))
    (set
      #:types (Set)
      #:values (set->list set-remove-all)
      #:patterns ())
    (numbers integer->decimal-bytes)
    (tuples
      #:types (Tuple2)
      #:values (tuple2)
      #:patterns (tuple2))
    (free-variables free-variables)
    (intermediate-language
      #:types
        ((Module i:Module)
         (FunctionDefinition i:FunctionDefinition)
         (BytesConstant i:BytesConstant)
         (Expression i:Expression)
         (CaseClause i:CaseClause)
         (Pattern i:Pattern)
         ClosureConstant)
      #:values
        ((module i:module)
         (function-definition i:function-definition)
         (byte-literal i:byte-literal)
         (boolean-literal i:boolean-literal)
         (local-var-expr i:local-var-expr)
         (if-expr i:if-expr)
         (begin-expr i:begin-expr)
         (create-closure-expr i:create-closure-expr)
         (call-closure-expr i:call-closure-expr)
         (varargs-call-closure-expr i:varargs-call-closure-expr)
         (let-expr i:let-expr)
         (case-expr i:case-expr)
         (case-clause i:case-clause)
         (ignore-pattern i:ignore-pattern)
         (variable-pattern i:variable-pattern)
         (abstraction-pattern i:abstraction-pattern)
         (bytes-pattern i:bytes-pattern)
         (byte-pattern i:byte-pattern)
         closure-constant
         bytes-constant)
      #:patterns (closure-constant))
    (source-language
      #:types (Module FunctionDefinition Expression CaseClause Pattern PreType)
      #:values (var-pre-type)
      #:patterns (module function-definition byte-literal bytes-literal
                  boolean-literal var-expr if-expr begin-expr lambda-expr
                  let-expr case-expr case-clause app-expr varargs-app-expr
                  bytes-pattern byte-pattern variable-pattern ignore-pattern abstraction-pattern)))
  (export source->intermediate)
  (types
    (define-type Environment
      (environment))
    (define-type State
      (state [funcs (List i:FunctionDefinition)] [bytes (List i:BytesConstant)] [counter Byte])))

  (define (source->intermediate [mod : Module]) : i:Module
    (case mod
      [(module name imports exports types definitions)
       (case (convert-function-definitions definitions (environment) (state (empty) (empty) 0))
         [(state funcs byte-constants _)
          (i:module
            name
            imports
            exports
            types
            funcs
            (create-closures definitions (empty))
            byte-constants)])]))

  (define (create-closures
            [funs : (List FunctionDefinition)]
            [acc : (List ClosureConstant)]) : (List ClosureConstant)
    (case funs
      [(empty) acc]
      [(cons (function-definition name type args body) funs)
       (create-closures
         funs
         (cons (closure-constant name (bytes-append (varargs list name #"-code"))) acc))]))

  (define (convert-function-definitions
            [funs : (List FunctionDefinition)]
            [env : Environment]
            [acc : State]) : State
    (case funs
      [(empty) acc]
      [(cons fun funs)
       (convert-function-definitions funs env (convert-function-definition fun env acc))]))

  (define (convert-function-definition
            [fun : FunctionDefinition]
            [env : Environment]
            [acc : State])
    : State
    (case fun
      [(function-definition name type args body)
       (case (convert-expression body env acc)
         [(tuple2 i:body acc)
          (add-function
            (i:function-definition
              (bytes-append (varargs list name #"-code"))
              type args (empty) i:body)
            acc)])]))

  (define (parse-arg [arg+ty : (Tuple2 Bytes PreType)]) : Bytes
    (case arg+ty
      [(tuple2 arg ty) arg]))

  (define (convert-expression [expr : Expression] [env : Environment] [acc : State])
    : (Tuple2 i:Expression State)
    (case expr
      [(byte-literal v) (tuple2 (i:byte-literal v) acc)]
      [(bytes-literal v)
       (case (get-next-index acc)
         [(tuple2 index acc)
          (let ([constant-name
                  (bytes-append (cons #"bytes-" (cons (integer->decimal-bytes index) (empty))))])
            (tuple2 (i:local-var-expr constant-name)
                    (add-bytes-constant constant-name v acc)))])]
      [(boolean-literal v) (tuple2 (i:boolean-literal v) acc)]
      ;; TODO handle this correctly
      [(var-expr v) (tuple2 (i:local-var-expr v) acc)]
      [(if-expr c t f)
       (case (convert-expression c env acc)
         [(tuple2 ic acc)
          (case (convert-expression t env acc)
            [(tuple2 it acc)
             (case (convert-expression f env acc)
               [(tuple2 if acc)
                (tuple2 (i:if-expr ic it if) acc)])])])]
      [(begin-expr e es)
       (case (convert-expression e env acc)
         [(tuple2 ie acc)
          (case (convert-expressions es env acc)
            [(tuple2 ies acc)
             (tuple2 (i:begin-expr ie ies) acc)])])]
      [(let-expr name expr body)
       (case (convert-expression expr env acc)
         [(tuple2 iexpr acc)
          (case (convert-expression body env acc)
            [(tuple2 ibody acc)
             (tuple2 (i:let-expr name iexpr ibody) acc)])])]
      [(case-expr expr clauses)
       (case (convert-expression expr env acc)
         [(tuple2 iexpr acc)
          (case (convert-clauses clauses env acc)
            [(tuple2 iclauses acc)
             (tuple2 (i:case-expr iexpr iclauses) acc)])])]
      [(lambda-expr args+tys body)
       (let ([args (map parse-arg args+tys)])
         (let ([fv (set-remove-all (free-variables body) args)])
           (case (convert-expression body env acc)
             [(tuple2 ibody acc)
              (case (get-next-index acc)
                [(tuple2 index acc)
                 (let ([closure-name
                         (bytes-append (cons #"lambda-" (cons (integer->decimal-bytes index) (empty))))])
                   ;; TODO use a real type
                   (tuple2
                     (i:create-closure-expr (i:local-var-expr closure-name)
                                            (map i:local-var-expr (set->list fv)))
                     (add-function
                       (i:function-definition
                         closure-name (var-pre-type #"bogus") args (set->list fv) ibody)
                       acc)))])])))]
      [(app-expr op args)
       (case (convert-expression op env acc)
         [(tuple2 iop acc)
          (case (convert-expressions args env acc)
            [(tuple2 iargs acc)
             (tuple2 (i:call-closure-expr iop iargs) acc)])])]
      [(varargs-app-expr op args)
       (case (convert-expression op env acc)
         [(tuple2 iop acc)
          (case (convert-expressions args env acc)
            [(tuple2 iargs acc)
             (tuple2 (i:varargs-call-closure-expr iop iargs) acc)])])]))

  (define (convert-clause [clause : CaseClause] [env : Environment] [acc : State])
    : (Tuple2 i:CaseClause State)
    (case clause
      [(case-clause pat expr)
       (case (convert-expression expr env acc)
         [(tuple2 iexpr acc)
          (case (convert-pattern pat acc)
            [(tuple2 ipat acc)
             (tuple2 (i:case-clause ipat iexpr) acc)])])]))

  (define (convert-pattern [pat : Pattern] [acc : State]) : (Tuple2 i:Pattern State)
    (case pat
      [(bytes-pattern v)
       (case (get-next-index acc)
         [(tuple2 index acc)
          (let ([constant-name
                  (bytes-append (cons #"bytes-" (cons (integer->decimal-bytes index) (empty))))])
            (tuple2 (i:bytes-pattern constant-name)
                    (add-bytes-constant constant-name v acc)))])]
      [(byte-pattern v)
       (tuple2 (i:byte-pattern v) acc)]
      [(variable-pattern v)
       (tuple2 (i:variable-pattern v) acc)]
      [(ignore-pattern)
       (tuple2 (i:ignore-pattern) acc)]
      [(abstraction-pattern name pats)
       (case (convert-patterns pats acc)
         [(tuple2 ipats acc)
          (tuple2 (i:abstraction-pattern name ipats) acc)])]))

  (define (convert-patterns [pats : (List Pattern)] [acc : State]) : (Tuple2 (List i:Pattern) State)
    (case pats
      [(empty) (tuple2 (empty) acc)]
      [(cons pat pats)
       (case (convert-pattern pat acc)
         [(tuple2 ipat acc)
          (case (convert-patterns pats acc)
            [(tuple2 ipats acc)
             (tuple2 (cons ipat ipats) acc)])])]))


  (define (convert-expressions
            [exprs : (List Expression)]
            [env : Environment]
            [acc : State])
    : (Tuple2 (List i:Expression) State)
    (case exprs
      [(empty) (tuple2 (empty) acc)]
      [(cons e es)
       (case (convert-expression e env acc)
         [(tuple2 ie acc)
          (case (convert-expressions es env acc)
            [(tuple2 ies acc)
             (tuple2 (cons ie ies) acc)])])]))

  (define (convert-clauses
            [clauses : (List CaseClause)]
            [env : Environment]
            [acc : State])
    : (Tuple2 (List i:CaseClause) State)
    (case clauses
      [(empty) (tuple2 (empty) acc)]
      [(cons c cs)
       (case (convert-clause c env acc)
         [(tuple2 ic acc)
          (case (convert-clauses cs env acc)
            [(tuple2 ics acc)
             (tuple2 (cons ic ics) acc)])])]))

  (define (add-function [func : i:FunctionDefinition] [acc : State]) : State
    (case acc
      [(state funcs bytes counter)
       (state (cons func funcs) bytes counter)]))

  (define (add-bytes-constant [name : Bytes] [value : Bytes] [acc : State]) : State
    (case acc
      [(state funcs bytes counter)
       (state funcs (cons (bytes-constant name value) bytes) counter)]))

  (define (get-next-index [acc : State]) : (Tuple2 Byte State)
    (case acc
      [(state funcs bytes counter)
       (tuple2 counter (state funcs bytes (+ 1 counter)))])))
