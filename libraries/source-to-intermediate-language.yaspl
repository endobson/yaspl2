#:module (source-to-intermediate-language)
#:import {
  (bytes)
  (dict)
  (either)
  (free-variables)
  (intermediate-language) {
    #:types
      [BytesConstant i:BytesConstant]
      [CaseClause i:CaseClause]
      ClosureConstant
      [Export i:Export]
      [Exports i:Exports]
      [Expression i:Expression]
      [FunctionDefinition i:FunctionDefinition]
      [Module i:Module]
      [Pattern i:Pattern]
      [TypeDefinition i:TypeDefinition]
      [TypedExport i:TypedExport]
      [VariantDefinition i:VariantDefinition]
      [VariantField i:VariantField]
    #:values
      [abstraction-pattern i:abstraction-pattern]
      [array-expr i:array-expr]
      [begin-expr i:begin-expr]
      [boolean-literal i:boolean-literal]
      bytes-constant
      [bytes-pattern i:bytes-pattern]
      [call-closure-expr i:call-closure-expr]
      [case-clause i:case-clause]
      [case-expr i:case-expr]
      closure-constant
      [create-closure-expr i:create-closure-expr]
      [export i:export]
      [exports i:exports]
      [function-definition i:function-definition]
      [if-expr i:if-expr]
      [ignore-pattern i:ignore-pattern]
      [int-literal i:int-literal]
      [int-pattern i:int-pattern]
      [let-expr i:let-expr]
      [module i:module]
      [type-definition i:type-definition]
      [typed-export i:typed-export]
      [var-expr i:var-expr]
      [variable-pattern i:variable-pattern]
      [variant-definition i:variant-definition]
      [variant-field i:variant-field]
  }
  (list)
  (maybe)
  (module-name)
  (numbers)
  (prim)
  (resolved-imports-language) {
    #:types
      Module
    #:patterns
      module
  }
  (set)
  (source-language) {
    #:types
      BlockDefinition
      CaseClause
      Export
      Exports
      Expression
      FunctionDefinition
      Pattern
      PreType
      TypeDefinition
      VariantDefinition
      VariantField
    #:patterns
      abstraction-pattern
      app-expr
      begin-expr
      block
      boolean-literal
      bytes-literal
      bytes-pattern
      case-clause
      case-expr
      export
      exports
      fun-pre-type
      function-definition
      if-expr
      ignore-pattern
      int-literal
      int-pattern
      lambda-expr
      let-expr
      match-def
      type-app-pre-type
      type-definition
      var-expr
      var-pre-type
      varargs-app-expr
      variable-pattern
      variant-definition
      variant-field
  }
  (tuples)
  (type-checker)
  (type-checker-context)
  (types)
}
(export
  #:types ()
  #:values (source->intermediate)
  #:patterns ())
(types
  (define-type Environment
    (environment
      [type-bindings : (Dict Bytes Type)]))
  (define-type State
    (state [funcs : (List i:FunctionDefinition)] [bytes : (List i:BytesConstant)] [counter : Int])))

(define (source->intermediate [mod : Module])
  : (Either Bytes i:Module)
  (case (type-check mod)
    [(left v) (left (type-check-error->bytes v))]
    [(right context)
     (case mod
       [(module name imports exports types definitions)
        (let ([type-env (context-types context)])
          (case (convert-function-definitions
                  definitions
                  (environment type-env)
                  (state (empty) (empty) 0))
            [(state funcs byte-constants _)
             (right
               (i:module
                 name
                 imports
                 (convert-exports exports type-env (context-values context))
                 (convert-type-definitions name types type-env)
                 funcs
                 (create-closures definitions (empty))
                 byte-constants))]))])]))

(define (convert-exports
          [exports : Exports]
          [type-env : (Dict Bytes Type)]
          [value-env : (Dict Bytes Type)]) : i:Exports
  (case exports
    [(exports types values patterns)
     (i:exports
       (map (lambda ([e : Export]) (convert-typed-export e type-env)) types)
       (map (lambda ([e : Export]) (convert-typed-export e value-env)) values)
       (map convert-export patterns))]))

(define (convert-typed-export [export : Export] [env : (Dict Bytes Type)]) : i:TypedExport
  (case export
    [(export local exported)
     (case (dict-ref env local)
       [(nothing) (panic #"Export not in environment")]
       [(just t) (i:typed-export local exported t)])]))


(define (convert-export [export : Export]) : i:Export
  (case export
    [(export local exported)
     (i:export local exported)]))

(define (create-closures
          [funs : (List FunctionDefinition)]
          [acc : (List ClosureConstant)]) : (List ClosureConstant)
  (case funs
    [(empty) acc]
    [(cons (function-definition name type args body) funs)
     (create-closures
       funs
       (cons (closure-constant name (bytes-append (varargs list name #"-code"))) acc))]))

(define (convert-type-definitions
          [mod-name : ModName]
          [types : (List TypeDefinition)]
          [env : (Dict Bytes Type)])
  : (List i:TypeDefinition)
  (map
    (lambda ([def : TypeDefinition]) (convert-type-definition mod-name def env))
    types))

(define (simplify-type-vars [tvs : (Maybe (List Bytes))]) : (List Bytes)
  (case tvs
    [(nothing) (empty)]
    [(just tvs) tvs]))

(define (lookup-type [env : (Dict Bytes Type)] [name : Bytes]) : Type
  (case (dict-ref env name)
    [(nothing) (panic #"No type bound")]
    [(just v) v]))

(define (convert-type-definition
          [mod-name : ModName]
          [type : TypeDefinition]
          [env : (Dict Bytes Type)])
  : i:TypeDefinition
  (case type
    [(type-definition name type-vars variants)
     (let ([type-vars (simplify-type-vars type-vars)])
       (i:type-definition
         name
         (lookup-type env name)
         type-vars
         (abstract-type mod-name name (map var-type type-vars))
         (convert-variant-definitions
           variants 0
           (add-type-vars type-vars env))))]))

(define (convert-variant-definitions
          [variants : (List VariantDefinition)]
          [index : Int]
          [env : (Dict Bytes Type)])
  : (List i:VariantDefinition)
  (case variants
    [(empty) (empty)]
    [(cons v vs)
     (cons
       (convert-variant-definition v index env)
       (convert-variant-definitions vs (+ index 1) env))]))

(define (convert-variant-definition
          [variant : VariantDefinition]
          [index : Int]
          [env : (Dict Bytes Type)])
  : i:VariantDefinition
  (case variant
    [(variant-definition name fields)
     (i:variant-definition
       name
       index
       (map (lambda ([f : VariantField]) (convert-variant-field f env)) fields))]))

(define (convert-variant-field
          [field : VariantField]
          [env : (Dict Bytes Type)])
  : i:VariantField
  (case field
    [(variant-field name pre-type)
     (i:variant-field name (convert-type env pre-type))]))

(define (convert-function-definitions
          [funs : (List FunctionDefinition)]
          [env : Environment]
          [acc : State]) : State
  (case funs
    [(empty) acc]
    [(cons fun funs)
     (convert-function-definitions funs env (convert-function-definition fun env acc))]))

(define (convert-function-definition
          [fun : FunctionDefinition]
          [env : Environment]
          [acc : State])
  : State
  (case fun
    [(function-definition name type args (block defs body))
     (case (convert-block defs body env acc)
       [(tuple2 i:body acc)
        (add-function
          (i:function-definition
            (bytes-append (varargs list name #"-code"))
            (convert-type (environment-type-bindings env) type)
            args (empty) i:body)
          acc)])]))

(define (parse-arg [arg+ty : (Tuple2 Bytes PreType)]) : Bytes
  (case arg+ty
    [(tuple2 arg ty) arg]))

(define (convert-expression [expr : Expression] [env : Environment] [acc : State])
  : (Tuple2 i:Expression State)
  (case expr
    [(int-literal v) (tuple2 (i:int-literal v) acc)]
    [(bytes-literal v)
     (case (get-next-index acc)
       [(tuple2 index acc)
        (let ([constant-name
                (bytes-append (cons #"bytes-" (cons (integer->decimal-bytes index) (empty))))])
          (tuple2 (i:var-expr constant-name)
                  (add-bytes-constant constant-name v acc)))])]
    [(boolean-literal v) (tuple2 (i:boolean-literal v) acc)]
    ;; TODO handle this correctly
    [(var-expr v) (tuple2 (i:var-expr v) acc)]
    [(if-expr c t f)
     (case (convert-expression c env acc)
       [(tuple2 ic acc)
        (case (convert-expression t env acc)
          [(tuple2 it acc)
           (case (convert-expression f env acc)
             [(tuple2 if acc)
              (tuple2 (i:if-expr ic it if) acc)])])])]
    [(begin-expr es e)
     (case (convert-expressions es env acc)
       [(tuple2 ies acc)
        (case (convert-expression e env acc)
          [(tuple2 ie acc)
           (tuple2 (i:begin-expr ies ie) acc)])])]
    [(let-expr name expr body)
     (case (convert-expression expr env acc)
       [(tuple2 iexpr acc)
        (case (convert-expression body env acc)
          [(tuple2 ibody acc)
           (tuple2 (i:let-expr name iexpr ibody) acc)])])]
    [(case-expr expr clauses)
     (case (convert-expression expr env acc)
       [(tuple2 iexpr acc)
        (case (convert-clauses clauses env acc)
          [(tuple2 iclauses acc)
           (tuple2 (i:case-expr iexpr iclauses) acc)])])]
    [(lambda-expr args+tys _ body)
     (let ([args (map parse-arg args+tys)])
       (let ([fv (free-variables/expr body (set-add-all (make-set bytes-cmp) args) (make-set bytes-cmp))])
         (case (convert-expression body env acc)
           [(tuple2 ibody acc)
            (case (get-next-index acc)
              [(tuple2 index acc)
               (let ([closure-name
                       (bytes-append (cons #"lambda_" (cons (integer->decimal-bytes index) (empty))))])
                 ;; TODO use a real type
                 (tuple2
                   (i:create-closure-expr closure-name (map i:var-expr (set->list fv)))
                   (add-function
                     (i:function-definition
                       closure-name (var-type #"bogus") args (set->list fv) ibody)
                     acc)))])])))]
    [(app-expr tail-position op args)
     (case (convert-expression op env acc)
       [(tuple2 iop acc)
        (case (convert-expressions args env acc)
          [(tuple2 iargs acc)
           (tuple2 (i:call-closure-expr tail-position iop iargs) acc)])])]
    [(varargs-app-expr tail-position op args)
     (case (convert-expression op env acc)
       [(tuple2 iop acc)
        (case (convert-expressions args env acc)
          [(tuple2 iargs acc)
           (tuple2 (i:call-closure-expr tail-position iop (varargs list (i:array-expr iargs))) acc)])])]))

(define (convert-clause [clause : CaseClause] [env : Environment] [acc : State])
  : (Tuple2 i:CaseClause State)
  (case clause
    [(case-clause pat (block defs expr))
     (case (convert-block defs expr env acc)
       [(tuple2 iexpr acc)
        (case (convert-pattern pat acc)
          [(tuple2 ipat acc)
           (tuple2 (i:case-clause ipat iexpr) acc)])])]))

(define (convert-pattern [pat : Pattern] [acc : State]) : (Tuple2 i:Pattern State)
  (case pat
    [(bytes-pattern v)
     (case (get-next-index acc)
       [(tuple2 index acc)
        (let ([constant-name
                (bytes-append (cons #"bytes-" (cons (integer->decimal-bytes index) (empty))))])
          (tuple2 (i:bytes-pattern constant-name)
                  (add-bytes-constant constant-name v acc)))])]
    [(int-pattern v)
     (tuple2 (i:int-pattern v) acc)]
    [(variable-pattern v)
     (tuple2 (i:variable-pattern v) acc)]
    [(ignore-pattern)
     (tuple2 (i:ignore-pattern) acc)]
    [(abstraction-pattern name pats)
     (case (convert-patterns pats acc)
       [(tuple2 ipats acc)
        (tuple2 (i:abstraction-pattern name ipats) acc)])]))

(define (convert-patterns [pats : (List Pattern)] [acc : State]) : (Tuple2 (List i:Pattern) State)
  (case pats
    [(empty) (tuple2 (empty) acc)]
    [(cons pat pats)
     (case (convert-pattern pat acc)
       [(tuple2 ipat acc)
        (case (convert-patterns pats acc)
          [(tuple2 ipats acc)
           (tuple2 (cons ipat ipats) acc)])])]))


(define (convert-expressions
          [exprs : (List Expression)]
          [env : Environment]
          [acc : State])
  : (Tuple2 (List i:Expression) State)
  (case exprs
    [(empty) (tuple2 (empty) acc)]
    [(cons e es)
     (case (convert-expression e env acc)
       [(tuple2 ie acc)
        (case (convert-expressions es env acc)
          [(tuple2 ies acc)
           (tuple2 (cons ie ies) acc)])])]))

(define (convert-clauses
          [clauses : (List CaseClause)]
          [env : Environment]
          [acc : State])
  : (Tuple2 (List i:CaseClause) State)
  (case clauses
    [(empty) (tuple2 (empty) acc)]
    [(cons c cs)
     (case (convert-clause c env acc)
       [(tuple2 ic acc)
        (case (convert-clauses cs env acc)
          [(tuple2 ics acc)
           (tuple2 (cons ic ics) acc)])])]))

(define (convert-block [defs : (List BlockDefinition)] [body : Expression] [env : Environment] [acc : State])
  : (Tuple2 i:Expression State)
  (case defs
    [(empty) (convert-expression body env acc)]
    [(cons (match-def pat expr) defs)
     (case (convert-expression expr env acc)
       [(tuple2 iexpr acc)
        (case (convert-pattern pat acc)
          [(tuple2 ipat acc)
           (case (convert-block defs body env acc)
             [(tuple2 ibody acc)
              (tuple2 (i:case-expr iexpr (varargs list (i:case-clause ipat ibody))) acc)])])])]))

(define (add-function [func : i:FunctionDefinition] [acc : State]) : State
  (case acc
    [(state funcs bytes counter)
     (state (cons func funcs) bytes counter)]))

(define (add-bytes-constant [name : Bytes] [value : Bytes] [acc : State]) : State
  (case acc
    [(state funcs bytes counter)
     (state funcs (cons (bytes-constant name value) bytes) counter)]))

(define (get-next-index [acc : State]) : (Tuple2 Int State)
  (case acc
    [(state funcs bytes counter)
     (tuple2 counter (state funcs bytes (+ 1 counter)))]))

(define (convert-type [type-bindings : (Dict Bytes Type)] [type : PreType]) : Type
  (case type
    [(var-pre-type v)
     (case (dict-ref type-bindings v)
       [(just t)
        t]
       [_ (panic (bytes-append (varargs list #"No type is bound for " v)))])]
    [(fun-pre-type type-vars args result)
     (let ([type-bindings (add-type-vars type-vars type-bindings)])
       (fun-type
         type-vars
         (map (lambda ([t : PreType]) (convert-type type-bindings t)) args)
         (convert-type type-bindings result)))]
    [(type-app-pre-type constructor args)
     (case (dict-ref type-bindings constructor)
       [(just (type-constructor mod name kinds))
        (if (= (length kinds) (length args))
            (abstract-type
              mod name
              (map (lambda ([t : PreType]) (convert-type type-bindings t)) args))
            (panic #"Wrong number of type args."))]
       [(just _)
        (panic #"Type is not bound to a type constructor")]
       [_ (panic (bytes-append (varargs list #"No type is bound for " constructor)))])]))

(define (add-type-vars [type-vars : (List Bytes)] [type-bindings : (Dict Bytes Type)])
  : (Dict Bytes Type)
  (case type-vars
    [(empty) type-bindings]
    [(cons type-var type-vars)
     (add-type-vars type-vars (dict-add type-bindings type-var (var-type type-var)))]))
