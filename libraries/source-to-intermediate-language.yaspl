#:module (source-to-intermediate-language)
#:import {
  (bytes)
  (data lifted-primitives)
  (dict)
  (either)
  (expanded-datatypes-language)
  {(intermediate-expression)
    {#:types
      [CaseClause i:CaseClause]
      [Expression i:Expression]
      [Pattern i:Pattern]
    }
    {#:values
      [abstraction-pattern i:abstraction-pattern]
      [array-expr i:array-expr]
      [begin-expr i:begin-expr]
      [boolean-literal i:boolean-literal]
      [bytes-pattern i:bytes-pattern]
      [call-closure-expr i:call-closure-expr]
      [case-clause i:case-clause]
      [case-expr i:case-expr]
      [create-closure-expr i:create-closure-expr]
      [global-var-expr i:global-var-expr]
      [if-expr i:if-expr]
      [ignore-pattern i:ignore-pattern]
      [int-literal i:int-literal]
      [int-pattern i:int-pattern]
      [let-expr i:let-expr]
      [local-var-expr i:local-var-expr]
      [make-variant-expr i:make-variant-expr]
      [variable-pattern i:variable-pattern]
      [variant-field-ref-expr i:variant-field-ref-expr]
    }
  }
  {(intermediate-language)
    {#:types
      [ConstantDefinition i:ConstantDefinition]
      [Exports i:Exports]
      [FunctionDefinition i:FunctionDefinition]
      [Imports i:Imports]
      [Module i:Module]
      [PatternExport i:PatternExport]
      [TypeExport i:TypeExport]
      [ValueExport i:ValueExport]
    }
    {#:values
      bytes-constant
      closure-constant
      [exports i:exports]
      [function-definition i:function-definition]
      [imports i:imports]
      [module i:module]
      [pattern-export i:pattern-export]
      trivial-variant-constant
      [type-export i:type-export]
      [value-export i:value-export]
    }
    {#:patterns
      bytes-constant
      closure-constant
      trivial-variant-constant
    }
  }
  (list)
  (maybe)
  (module-name)
  (module-signature)
  (numbers)
  (prim)
  {(resolved-types-language)
    {#:types
      [Module rt:Module]
    }
  }
  (set)
  (top-level-name)
  (tuples)
  (type-checker)
  (types)
  (yaspl var)
}
(export
  (#:types)
  (#:values source->intermediate)
  (#:patterns))
(types
  (define-type Environment
    (environment
      [local-variables : (Dict Bytes Var)]
      [global-variables : (Dict Bytes TopLevelName)]
      [module-name : ModName]))
  (define-type State
    (state [funcs : (List i:FunctionDefinition)] [bytes : (List i:ConstantDefinition)]
           [counter : Int])))

(define (source->intermediate [mod : rt:Module])
  : (Either Bytes i:Module)
  (case (type-check mod)
    [(left v) (left (type-check-error->bytes v))]
    [(right mod)
     (match-define mod (expand-datatypes mod))
     (case mod
       [(module name imports exports definitions)
        (match-define global-env (setup-value-environment mod))
        (case (convert-function-definitions
                definitions
                (environment (make-dict bytes-cmp) global-env name)
                (state (empty) (empty) 0))
          [(state funcs byte-constants _)
           (match-define constants
             (append
               (create-closures definitions (empty))
               byte-constants))
           (right
             (i:module
               name
               (convert-imports imports)
               (convert-exports exports global-env)
               funcs
               constants
               (create-static-info
                 name
                 constants
                 definitions)))])])]))

(define (convert-imports [i : Imports]) : i:Imports
  (case i
    [(imports values static-info)
     (i:imports static-info)]))

(define (convert-exports
          [exports : Exports]
          [global-env : (Dict Bytes TopLevelName)]) : i:Exports
  (case exports
    [(exports types values patterns)
     (i:exports
       (map convert-type-export types)
       (map (lambda ([e : ValueExport]) (convert-value-export e global-env)) values)
       (map convert-pattern-export patterns))]))

(define (convert-type-export [export : TypeExport]) : i:TypeExport
  (case export
    [(type-export exported type)
     (i:type-export exported type)]))

(define (convert-pattern-export [export : PatternExport]) : i:PatternExport
  (case export
    [(pattern-export exported type)
     (i:pattern-export exported type)]))

(define (convert-value-export [export : ValueExport]
                              [global-env : (Dict Bytes TopLevelName)]) : i:ValueExport
  (case export
    [(value-export local exported type)
     (case (dict-ref global-env local)
       [(nothing) (panic #"Export not in environment")]
       [(just top-level)
        (i:value-export exported top-level type)])]))

(define (create-closures
          [funs : (List FunctionDefinition)]
          [acc : (List i:ConstantDefinition)]) : (List i:ConstantDefinition)
  (foldl
    (lambda ([f : FunctionDefinition] [acc : (List i:ConstantDefinition)])
      (case f
        [(function-definition name _ args _ body)
         (cons (closure-constant name (bytes-append (varargs list name #"-code"))) acc)]
        [(variant-constructor type-name variant-name (empty) tag)
         (cons
           (trivial-variant-constant
             (bytes-append (varargs list type-name #"_" variant-name #"_const"))
             tag)
           (cons
             (closure-constant
               (bytes-append
                 (varargs list type-name #"_" variant-name #"_closure"))
               (bytes-append
                 (varargs list type-name #"_" variant-name)))
             acc))]
        [(variant-constructor type-name variant-name _ _)
         (cons
           (closure-constant
             (bytes-append
               (varargs list type-name #"_" variant-name #"_closure"))
             (bytes-append
               (varargs list type-name #"_" variant-name)))
           acc)]
        [(variant-accessor type-name variant-name field-name _)
         (cons
           (closure-constant
             (bytes-append
               (varargs list type-name #"_" variant-name #"_" field-name #"_closure"))
             (bytes-append
               (varargs list type-name #"_" variant-name #"_" field-name)))
           acc)]))
    funs
    acc))

(define (environment-add-local [env : Environment] [local : Bytes] [state : State])
  : (Tuple3 Environment Var State)
  (match-define (environment locals globals name) env)
  (match-define (tuple2 (lifted-int index) state) (get-next-index state))
  (match-define v (var local (var-number index)))
  (tuple3
    (environment (dict-set locals local v) globals name)
    v
    state))

(define (environment-add-locals [env : Environment] [locals : (List Bytes)] [state : State])
  : (Tuple2 Environment State)
  (case locals
    [(empty) (tuple2 env state)]
    [(cons local locals)
     (case (environment-add-local env local state)
       [(tuple3 env _ state)
        (environment-add-locals env locals state)])]))

(define (pattern-bound-vars [p : Pattern]) : (List Bytes)
  (pattern-bound-vars* p (empty)))
(define (pattern-bound-vars* [p : Pattern] [acc : (List Bytes)]) : (List Bytes)
  (case p
    [(bytes-pattern v) acc]
    [(int-pattern v) acc]
    [(variable-pattern v)
     (cons v acc)]
    [(ignore-pattern) acc]
    [(abstraction-pattern _ pats)
     (foldl pattern-bound-vars* pats acc)]))

(define (convert-function-definitions
          [funs : (List FunctionDefinition)]
          [env : Environment]
          [acc : State]) : State
  (case funs
    [(empty) acc]
    [(cons fun funs)
     (convert-function-definitions funs env (convert-function-definition fun env acc))]))

(define (convert-function-definition
          [fun : FunctionDefinition]
          [env : Environment]
          [acc : State])
  : State
  (case fun
    [(function-definition name type-vars args result-type (block defs body))
     (match-define arg-names (map parse-arg-name args))
     (match-define arg-types (map parse-arg-type args))
     (match-define new-type
                     (fun-type type-vars arg-types result-type))
     (match-define (tuple2 env acc) (environment-add-locals env arg-names acc))
     (case (convert-block defs body env acc)
       [(tuple2 i:body acc)
        (add-function
          (i:function-definition
            (bytes-append (varargs list name #"-code"))
            new-type
            (map (lambda ([t : (Tuple2 Bytes Type)])
                   (convert-arg-type t env))
                 args)
            (empty) i:body)
          acc)])]
    [(variant-constructor type-name variant-name (empty) tag)
     (match-define const-name
       (bytes-append (varargs list type-name #"_" variant-name #"_const")))
     (add-function
       (i:function-definition
         (bytes-append (varargs list type-name #"_" variant-name))
         (var-type #"bogus")
         (empty)
         (empty)
         (i:global-var-expr (top-level-name (environment-module-name env) const-name)))
       acc)]
    [(variant-constructor type-name variant-name field-names tag)
     (match-define args
       (build-list (length field-names) (lambda ([index : Int]) (var #"arg" (var-number index)))))
     (add-function
       (i:function-definition
         (bytes-append (varargs list type-name #"_" variant-name))
         (var-type #"bogus")
         args
         (empty)
         (i:make-variant-expr tag (map i:local-var-expr args)))
       acc)]
    [(variant-accessor type-name variant-name field-name index)
     (match-define arg (var #"arg" (initial-var-number)))
     (add-function
       (i:function-definition
         (bytes-append (varargs list type-name #"_" variant-name #"_" field-name))
         (var-type #"bogus")
         (varargs list arg)
         (empty)
         (i:variant-field-ref-expr (i:local-var-expr arg) index))
       acc)]))

;; TODO actually send down the type
(define (convert-arg-type [arg+ty : (Tuple2 Bytes Type)] [env : Environment]) : Var
  (case arg+ty
    [(tuple2 arg ty)
     (case (dict-ref (environment-local-variables env) arg)
       [(nothing) (panic #"No value found for function arg")]
       [(just var) var])]))

(define (parse-arg-name [arg+ty : (Tuple2 Bytes Type)]) : Bytes
  (case arg+ty
    [(tuple2 arg ty) arg]))
(define (parse-arg-type [arg+ty : (Tuple2 Bytes Type)]) : Type
  (case arg+ty
    [(tuple2 arg ty) ty]))

(define (convert-expression [expr : Expression] [env : Environment] [acc : State])
  : (Tuple2 i:Expression State)
  (case expr
    [(int-literal v) (tuple2 (i:int-literal v) acc)]
    [(bytes-literal v)
     (case (get-next-index acc)
       [(tuple2 (lifted-int index) acc)
        (let ([constant-name
                (bytes-append (cons #"bytes-" (cons (integer->decimal-bytes index) (empty))))])
          (tuple2 (i:global-var-expr (top-level-name (environment-module-name env) constant-name))
                  (add-bytes-constant constant-name v acc)))])]
    [(boolean-literal v) (tuple2 (i:boolean-literal v) acc)]
    [(var-expr v)
     (case (dict-ref (environment-local-variables env) v)
       [(just v)
        (tuple2 (i:local-var-expr v) acc)]
       [(nothing)
        (case (dict-ref (environment-global-variables env) v)
          [(just v)
           (tuple2 (i:global-var-expr v) acc)]
          [(nothing)
           (panic #"Unbound variable")])])]
    [(if-expr c t f)
     (case (convert-expression c env acc)
       [(tuple2 ic acc)
        (case (convert-expression t env acc)
          [(tuple2 it acc)
           (case (convert-expression f env acc)
             [(tuple2 if acc)
              (tuple2 (i:if-expr ic it if) acc)])])])]
    [(begin-expr es e)
     (case (convert-expressions es env acc)
       [(tuple2 ies acc)
        (case (convert-expression e env acc)
          [(tuple2 ie acc)
           (tuple2 (i:begin-expr ies ie) acc)])])]
    [(let-expr name expr body)
     (case (convert-expression expr env acc)
       [(tuple2 iexpr acc)
        (case (environment-add-local env name acc)
          [(tuple3 env var acc)
           (case (convert-expression body env acc)
             [(tuple2 ibody acc)
              (tuple2 (i:let-expr var iexpr ibody) acc)])])])]
    [(case-expr expr clauses)
     (case (convert-expression expr env acc)
       [(tuple2 iexpr acc)
        (case (convert-clauses clauses env acc)
          [(tuple2 iclauses acc)
           (tuple2 (i:case-expr iexpr iclauses) acc)])])]
    [(annotated-expr _ expr)
     (convert-expression expr env acc)]
    [(lambda-expr args+tys _ body)
     (let ([outer-env env])
       (let ([args (map parse-arg-name args+tys)])
         (let ([fv (free-variables/expr body (set-add-all (make-set bytes-cmp) args) (make-set bytes-cmp))])
           (case (environment-add-locals env args acc)
             [(tuple2 env acc)
              (case (convert-expression body env acc)
                [(tuple2 ibody acc)
                 (case (get-next-index acc)
                   [(tuple2 (lifted-int index) acc)
                    (match-define closure-name
                      (bytes-append (cons #"lambda_" (cons (integer->decimal-bytes index) (empty)))))
                    (match-define free-local-variables
                      (map
                        (lambda ([v : Bytes]) : Var
                          (case (dict-ref (environment-local-variables outer-env) v)
                            [(nothing) (panic #"No value found for free variable")]
                            [(just var) var]))
                       (set->list (set-intersect (dict-keys (environment-local-variables env)) fv))))
                    ;; TODO use a real type
                    (tuple2
                      (i:create-closure-expr
                        (top-level-name (environment-module-name env) closure-name)
                        (map i:local-var-expr free-local-variables))
                      (add-function
                        (i:function-definition
                          closure-name (var-type #"bogus")
                          (map (lambda ([t : (Tuple2 Bytes Type)])
                                 (convert-arg-type t env))
                               args+tys)
                          free-local-variables ibody)
                        acc))])])]))))]
    [(app-expr tail-position op args)
     (case (convert-expression op env acc)
       [(tuple2 iop acc)
        (case (convert-expressions args env acc)
          [(tuple2 iargs acc)
           (tuple2 (i:call-closure-expr tail-position iop iargs) acc)])])]
    [(varargs-app-expr tail-position op args)
     (case (convert-expression op env acc)
       [(tuple2 iop acc)
        (case (convert-expressions args env acc)
          [(tuple2 iargs acc)
           (tuple2 (i:call-closure-expr tail-position iop (varargs list (i:array-expr iargs))) acc)])])]))

(define (convert-clause [clause : CaseClause] [env : Environment] [acc : State])
  : (Tuple2 i:CaseClause State)
  (case clause
    [(case-clause pat (block defs expr))
     (case (environment-add-locals env (pattern-bound-vars pat) acc)
       [(tuple2 env acc)
        (case (convert-block defs expr env acc)
          [(tuple2 iexpr acc)
           (case (convert-pattern pat env acc)
             [(tuple2 ipat acc)
              (tuple2 (i:case-clause ipat iexpr) acc)])])])]))

(define (convert-pattern [pat : Pattern] [env : Environment] [acc : State]) : (Tuple2 i:Pattern State)
  (case pat
    [(bytes-pattern v)
     (case (get-next-index acc)
       [(tuple2 (lifted-int index) acc)
        (let ([constant-name
                (bytes-append (cons #"bytes-" (cons (integer->decimal-bytes index) (empty))))])
          (tuple2 (i:bytes-pattern (top-level-name (environment-module-name env) constant-name))
                  (add-bytes-constant constant-name v acc)))])]
    [(int-pattern v)
     (tuple2 (i:int-pattern v) acc)]
    [(variable-pattern v)
     (case (dict-ref (environment-local-variables env) v)
       [(nothing) (panic #"Unbound pattern variable")]
       [(just var)
        (tuple2 (i:variable-pattern var) acc)])]
    [(ignore-pattern)
     (tuple2 (i:ignore-pattern) acc)]
    [(abstraction-pattern (pattern-signature variant-name tag  _ _ _ _ _) pats)
     (case (convert-patterns pats env acc)
       [(tuple2 ipats acc)
        (tuple2 (i:abstraction-pattern variant-name tag ipats) acc)])]))

(define (convert-patterns [pats : (List Pattern)] [env : Environment] [acc : State]) : (Tuple2 (List i:Pattern) State)
  (case pats
    [(empty) (tuple2 (empty) acc)]
    [(cons pat pats)
     (case (convert-pattern pat env acc)
       [(tuple2 ipat acc)
        (case (convert-patterns pats env acc)
          [(tuple2 ipats acc)
           (tuple2 (cons ipat ipats) acc)])])]))


(define (convert-expressions
          [exprs : (List Expression)]
          [env : Environment]
          [acc : State])
  : (Tuple2 (List i:Expression) State)
  (case exprs
    [(empty) (tuple2 (empty) acc)]
    [(cons e es)
     (case (convert-expression e env acc)
       [(tuple2 ie acc)
        (case (convert-expressions es env acc)
          [(tuple2 ies acc)
           (tuple2 (cons ie ies) acc)])])]))

(define (convert-clauses
          [clauses : (List CaseClause)]
          [env : Environment]
          [acc : State])
  : (Tuple2 (List i:CaseClause) State)
  (case clauses
    [(empty) (tuple2 (empty) acc)]
    [(cons c cs)
     (case (convert-clause c env acc)
       [(tuple2 ic acc)
        (case (convert-clauses cs env acc)
          [(tuple2 ics acc)
           (tuple2 (cons ic ics) acc)])])]))

(define (convert-block [defs : (List BlockDefinition)] [body : Expression] [env : Environment] [acc : State])
  : (Tuple2 i:Expression State)
  (case defs
    [(empty) (convert-expression body env acc)]
    [(cons (match-def pat type expr) defs)
     (case (convert-expression expr env acc)
       [(tuple2 iexpr acc)
        (case (environment-add-locals env (pattern-bound-vars pat) acc)
          [(tuple2 env acc)
           (case (convert-pattern pat env acc)
             [(tuple2 ipat acc)
              (case (convert-block defs body env acc)
                [(tuple2 ibody acc)
                 (tuple2 (i:case-expr iexpr (varargs list (i:case-clause ipat ibody))) acc)])])])])]))

(define (add-function [func : i:FunctionDefinition] [acc : State]) : State
  (case acc
    [(state funcs bytes counter)
     (state (cons func funcs) bytes counter)]))

(define (add-bytes-constant [name : Bytes] [value : Bytes] [acc : State]) : State
  (case acc
    [(state funcs bytes counter)
     (state funcs (cons (bytes-constant name value) bytes) counter)]))

(define (get-next-index [acc : State]) : (Tuple2 LiftedInt State)
  (case acc
    [(state funcs bytes counter)
     (tuple2 (lifted-int counter) (state funcs bytes (+ 1 counter)))]))

(define (setup-value-environment [mod : Module])
  : (Dict Bytes TopLevelName)
  (add-all-imported-functions
    (add-locally-defined-functions
      (make-dict bytes-cmp)
      mod)
    mod))

(define (add-all-imported-functions [env : (Dict Bytes TopLevelName)] [mod : Module])
  : (Dict Bytes TopLevelName)
  (match-define (imports values _) (module-imports mod))
  (merge-dicts
    (dict-value-map values
      (lambda ([v : ValueSignature])
        (value-signature-value v)))
    env))

(define (add-locally-defined-functions [env : (Dict Bytes TopLevelName)] [mod : Module])
  : (Dict Bytes TopLevelName)
  (match-define mod-name (module-name mod))
  (foldl
    (lambda ([f : FunctionDefinition] [env : (Dict Bytes TopLevelName)])
      (case f
        [(function-definition name _ _ _ _)
         (dict-add env name (top-level-name mod-name name))]
        [(variant-constructor type-name variant-name _ _)
         (dict-add
           env
           variant-name
           (top-level-name
             mod-name
             (bytes-append
               (varargs list type-name #"_" variant-name #"_closure"))))]
        [(variant-accessor type-name variant-name field-name _)
         (dict-add
           env
           (bytes-append (varargs list variant-name #"-" field-name))
           (top-level-name
             mod-name
             (bytes-append
               (varargs list type-name #"_" variant-name #"_" field-name #"_closure"))))]))
    (module-definitions mod)
    env))

(define (create-static-info
          [name : ModName]
          [constants : (List i:ConstantDefinition)]
          [funcs : (List FunctionDefinition)]) : (Dict TopLevelName TopLevelSignature)
  (add-function-static-info
    name
    funcs
    (add-constants-static-info
      name
      constants
      (make-dict top-level-name-cmp))))

(define (add-constants-static-info
          [mod-name : ModName]
          [constants : (List i:ConstantDefinition)]
          [acc : (Dict TopLevelName TopLevelSignature)])
  : (Dict TopLevelName TopLevelSignature)
  (foldl
    (lambda ([const : i:ConstantDefinition] [acc : (Dict TopLevelName TopLevelSignature)])
      (case const
        [(closure-constant name fun-name)
         (dict-add acc (top-level-name mod-name name)
                   (top-level-signature (just (top-level-name mod-name fun-name)) (nothing)))]
        [(bytes-constant _ _)
         acc]
        [(trivial-variant-constant name _)
         acc]))
    constants
    acc))

(define (add-function-static-info
          [mod-name : ModName]
          [funs : (List FunctionDefinition)]
          [acc : (Dict TopLevelName TopLevelSignature)]) : (Dict TopLevelName TopLevelSignature)
  (foldl
    (lambda ([f : FunctionDefinition] [acc : (Dict TopLevelName TopLevelSignature)])
      (case f
        [(function-definition _ _ _ _ _) acc]
        [(variant-constructor type-name variant-name (empty) tag)
         (dict-add
           acc
           (top-level-name mod-name (bytes-append (varargs list type-name #"_" variant-name)))
           (top-level-signature
             (nothing)
             (just
               (zero-arg-constant-inlineable-function
                 (top-level-name
                   mod-name
                   (bytes-append (varargs list type-name #"_" variant-name #"_const")))))))]
        [(variant-constructor type-name variant-name fields tag)
         (dict-add
           acc
           (top-level-name mod-name (bytes-append (varargs list type-name #"_" variant-name)))
           (top-level-signature
             (nothing)
             (just
               ;; TODO include the expected number of args
               (variant-constructor-inlineable-function tag)))) ]
        [(variant-accessor type-name variant-name field-name offset)
         (dict-add
           acc
           (top-level-name
             mod-name
             (bytes-append (varargs list type-name #"_" variant-name #"_" field-name)))
           (top-level-signature
             (nothing)
             (just
               (variant-accessor-inlineable-function offset))))]))
    funs
    acc))

(define (free-variables/block [block : Block] [env : (Set Bytes)] [acc : (Set Bytes)])
  : (Set Bytes)
  (match-define (block defs body) block)
  (free-variables/block* defs body env acc))

(define (free-variables/block*
          [defs : (List BlockDefinition)]
          [final-expr : Expression]
          [env : (Set Bytes)]
          [acc : (Set Bytes)]) : (Set Bytes)
  (case defs
    [(empty) (free-variables/expr final-expr env acc)]
    [(cons (match-def pattern type expr) defs)
     (free-variables/block*
       defs final-expr
       (set-add-all env (pattern-bound-vars pattern))
       (free-variables/expr expr env acc))]))

(define (free-variables/expr [expr : Expression] [env : (Set Bytes)] [acc : (Set Bytes)])
  : (Set Bytes)
  (case expr
    [(int-literal _) acc]
    [(bytes-literal _) acc]
    [(boolean-literal _) acc]
    [(annotated-expr _ expr)
     (free-variables/expr expr env acc)]
    [(if-expr c t f)
     (free-variables/list (cons c (cons t (cons f (empty)))) env acc)]
    [(begin-expr es e)
     (free-variables/list (cons e es) env acc)]
    [(app-expr _ op args)
     (free-variables/list (cons op args) env acc)]
    [(varargs-app-expr _ op args)
     (free-variables/list (cons op args) env acc)]
    [(let-expr name expr body)
     (free-variables/expr body (set-add env name) (free-variables/expr expr env acc))]
    [(case-expr expr clauses)
     (free-variables/clauses clauses env (free-variables/expr expr env acc))]
    [(lambda-expr args+tys _ body)
     (free-variables/expr body (set-add-all env (map (lambda ([arg+ty : (Tuple2 Bytes Type)])
                                                       (case arg+ty [(tuple2 arg _) arg]))
                                                     args+tys)) acc)]
    [(var-expr v)
     (if (set-member? env v)
         acc
         (set-add acc v))]))

(define (free-variables/list
          [exprs : (List Expression)]
          [env : (Set Bytes)]
          [acc : (Set Bytes)]) : (Set Bytes)
  (case exprs
    [(empty) acc]
    [(cons expr exprs)
     (free-variables/list exprs env (free-variables/expr expr env acc))]))

(define (free-variables/clauses
          [exprs : (List CaseClause)]
          [env : (Set Bytes)]
          [acc : (Set Bytes)]) : (Set Bytes)
  (case exprs
    [(empty) acc]
    [(cons (case-clause pattern body) clauses)
     (free-variables/clauses
       clauses env
       (free-variables/block
         body
         (set-add-all env (pattern-bound-vars pattern))
         acc))]))
