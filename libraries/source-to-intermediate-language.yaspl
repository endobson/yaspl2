#:module (source-to-intermediate-language)
#:import {
  (bytes)
  (dict)
  (either)
  (free-variables)
  (intermediate-expression) {
    #:types
      [CaseClause i:CaseClause]
      [Expression i:Expression]
      [Pattern i:Pattern]
    #:values
      [abstraction-pattern i:abstraction-pattern]
      [array-expr i:array-expr]
      [begin-expr i:begin-expr]
      [boolean-literal i:boolean-literal]
      [bytes-pattern i:bytes-pattern]
      [call-closure-expr i:call-closure-expr]
      [case-clause i:case-clause]
      [case-expr i:case-expr]
      [create-closure-expr i:create-closure-expr]
      [global-var-expr i:global-var-expr]
      [if-expr i:if-expr]
      [ignore-pattern i:ignore-pattern]
      [int-literal i:int-literal]
      [int-pattern i:int-pattern]
      [let-expr i:let-expr]
      [local-var-expr i:local-var-expr]
      [make-variant-expr i:make-variant-expr]
      [variable-pattern i:variable-pattern]
      [variant-field-ref-expr i:variant-field-ref-expr]
  }
  (intermediate-language) {
    #:types
      [ConstantDefinition i:ConstantDefinition]
      [Exports i:Exports]
      [FunctionDefinition i:FunctionDefinition]
      [Imports i:Imports]
      [Module i:Module]
      [PatternExport i:PatternExport]
      [TypeExport i:TypeExport]
      [ValueExport i:ValueExport]
    #:values
      bytes-constant
      closure-constant
      [exports i:exports]
      [function-definition i:function-definition]
      [imports i:imports]
      [module i:module]
      [pattern-export i:pattern-export]
      trivial-variant-constant
      [type-export i:type-export]
      [value-export i:value-export]
    #:patterns
      bytes-constant
      closure-constant
      trivial-variant-constant
  }
  (list)
  (maybe)
  (module-name)
  (module-signature)
  (numbers)
  (prim)
  (resolved-imports-language) {
    #:types
      Imports
      Module
    #:values
      module-definitions
      module-imports
      module-name
    #:patterns
      imports
      module
  }
  (set)
  (source-language) {
    #:types
      BlockDefinition
      CaseClause
      Export
      Exports
      Expression
      FunctionDefinition
      Pattern
      PreType
      TypeDefinition
      VariantDefinition
      VariantField
    #:values
      fun-pre-type
      function-definition-name
      variant-field-name
    #:patterns
      abstraction-pattern
      app-expr
      begin-expr
      block
      boolean-literal
      bytes-literal
      bytes-pattern
      case-clause
      case-expr
      export
      exports
      fun-pre-type
      function-definition
      if-expr
      ignore-pattern
      int-literal
      int-pattern
      lambda-expr
      let-expr
      match-def
      type-app-pre-type
      type-definition
      var-expr
      var-pre-type
      varargs-app-expr
      variable-pattern
      variant-definition
      variant-field
  }
  (top-level-name)
  (tuples)
  (type-checker)
  (type-checker-context)
  (types)
  (yaspl var)
}
(export
  #:types ()
  #:values (source->intermediate)
  #:patterns ())
(types
  (define-type Environment
    (environment
      [type-bindings : (Dict Bytes Type)]
      [variant-bindings : (Dict Bytes Int)]
      [local-variables : (Dict Bytes Var)]
      [global-variables : (Dict Bytes TopLevelName)]
      [module-name : ModName]))
  (define-type State
    (state [funcs : (List i:FunctionDefinition)] [bytes : (List i:ConstantDefinition)] [counter : Int]))
  (define-type DatatypeFunction
    (variant-constructor
      [type-name : Bytes]
      [variant-name : Bytes]
      ;; TODO include something more useful than field names here
      [fields : (List Bytes)]
      [tag : Int])
    (variant-accessor
      [type-name : Bytes]
      [variant-name : Bytes]
      [field-name : Bytes]
      [field-offset : Int]))

  ;; TODO remove these/make them not needed
  (define-type i-TypeDefinition
    (i-type-definition
      [name : Bytes]
      ;; This is what the name is bound to in the type environment
      [type-binding : Type]
      [type-vars : (List Bytes)]
      ;; This is what the variants return
      [constructed-type : Type]
      [variants : (List i-VariantDefinition)]))
  (define-type i-VariantDefinition
    (i-variant-definition
      [name : Bytes]
      [tag : Int]
      [fields : (List i-VariantField)]))
  (define-type i-VariantField
    (i-variant-field
      [name : Bytes]
      [type : Type])))

(define (source->intermediate [mod : Module])
  : (Either Bytes i:Module)
  (case (type-check mod)
    [(left v) (left (type-check-error->bytes v))]
    [(right context)
     (case mod
       [(module name imports exports types definitions)
        (match-define type-env (context-types context))
        (match-define type-functions
          (type-definitions->functions type-env types))
        (match-define global-env (setup-value-environment mod type-functions))
        (match-define variant-bindings (setup-variant-bindings imports type-functions))
        (match-define type-definitions (convert-type-definitions name types type-env))
        (case (convert-function-definitions
                definitions
                (environment type-env variant-bindings (make-dict bytes-cmp) global-env name)
                (state (empty) (empty) 0))
          [(state funcs byte-constants _)
           (match-define constants
             (append
               (create-closures definitions type-functions (empty))
               byte-constants))
           (right
             (i:module
               name
               (convert-imports imports)
               (convert-exports exports type-env (context-values context) global-env type-definitions)
               (append
                 funcs
                 (create-datatype-definitions name type-functions))
               constants
               (create-static-info
                 name
                 constants
                 funcs
                 type-functions)))])])]))

(define (convert-imports [i : Imports]) : i:Imports
  (case i
    [(imports types values patterns static-info)
     (i:imports static-info)]))

(define (convert-exports
          [exports : Exports]
          [type-env : (Dict Bytes Type)]
          [value-env : (Dict Bytes Type)]
          [global-env : (Dict Bytes TopLevelName)]
          [type-defs : (List i-TypeDefinition)]) : i:Exports
  (case exports
    [(exports types values patterns)
     (i:exports
       (map (lambda ([e : Export]) (convert-type-export e type-env)) types)
       (map (lambda ([e : Export]) (convert-value-export e value-env global-env)) values)
       (convert-pattern-exports patterns type-defs))]))

(define (convert-type-export [export : Export] [env : (Dict Bytes Type)]) : i:TypeExport
  (case export
    [(export local exported)
     (case (dict-ref env local)
       [(nothing) (panic #"Export not in environment")]
       [(just t) (i:type-export exported t)])]))

(define (convert-value-export [export : Export]
                              [env : (Dict Bytes Type)]
                              [global-env : (Dict Bytes TopLevelName)]) : i:ValueExport
  (case export
    [(export local exported)
     (case (dict-ref env local)
       [(nothing) (panic #"Export not in environment")]
       [(just type)
        (case (dict-ref global-env local)
          [(nothing) (panic #"Export not in environment")]
          [(just top-level)
           (i:value-export exported top-level type)])])]))

(define (convert-pattern-exports
          [exports : (List Export)]
          [type-defs : (List i-TypeDefinition)])
  : (List i:PatternExport)
  (let ([export-map (foldl
                      (lambda ([export : Export] [acc : (Dict Bytes Bytes)])
                        (case export
                          [(export local exported)
                           (dict-add acc local exported)]))
                      exports
                      ((lambda () : (Dict Bytes Bytes) (make-dict bytes-cmp))))])
    (foldl
      (lambda ([t : i-TypeDefinition] [acc : (List i:PatternExport)])
        (case t
          [(i-type-definition _ _ type-vars self-type variants)
           (match-define type-sig (type-signature (map i-variant-definition-name variants)))
           (foldl
             (lambda ([v : i-VariantDefinition] [acc : (List i:PatternExport)])
               (case v
                 [(i-variant-definition name tag fields)
                  (case (dict-ref export-map name)
                    [(nothing) acc]
                    [(just exported-name)
                     (cons
                       (i:pattern-export
                         exported-name
                         (pattern-signature name tag type-vars self-type
                                            (map i-variant-field-type fields)
                                            type-sig))
                       acc)])]))
             variants
             acc)]))
      type-defs
      ((lambda () : (List i:PatternExport) (empty))))))

(define (create-closures
          [funs : (List FunctionDefinition)]
          [types : (List DatatypeFunction)]
          [acc : (List i:ConstantDefinition)]) : (List i:ConstantDefinition)
  (create-closures/functions funs
    (create-closures/types types acc)))

(define (create-closures/functions
          [funs : (List FunctionDefinition)]
          [acc : (List i:ConstantDefinition)]) : (List i:ConstantDefinition)
  (foldl
    (lambda ([f : FunctionDefinition] [acc : (List i:ConstantDefinition)])
      (case f
        [(function-definition name _ args _ body)
         (cons (closure-constant name (bytes-append (varargs list name #"-code"))) acc)]))
    funs
    acc))


(define (create-closures/types
          [types : (List DatatypeFunction)]
          [acc : (List i:ConstantDefinition)]) : (List i:ConstantDefinition)
  (foldl
    (lambda ([f : DatatypeFunction] [acc : (List i:ConstantDefinition)])
      (case f
        [(variant-constructor type-name variant-name (empty) tag)
         (cons
           (trivial-variant-constant
             (bytes-append (varargs list type-name #"_" variant-name #"_const"))
             tag)
           (cons
             (closure-constant
               (bytes-append
                 (varargs list type-name #"_" variant-name #"_closure"))
               (bytes-append
                 (varargs list type-name #"_" variant-name)))
             acc))]
        [(variant-constructor type-name variant-name _ _)
         (cons
           (closure-constant
             (bytes-append
               (varargs list type-name #"_" variant-name #"_closure"))
             (bytes-append
               (varargs list type-name #"_" variant-name)))
           acc)]
        [(variant-accessor type-name variant-name field-name _)
         (cons
           (closure-constant
             (bytes-append
               (varargs list type-name #"_" variant-name #"_" field-name #"_closure"))
             (bytes-append
               (varargs list type-name #"_" variant-name #"_" field-name)))
           acc)]))
    types
    acc))

(define (create-datatype-definitions [mod-name : ModName] [funs : (List DatatypeFunction)])
  : (List i:FunctionDefinition)
  (filter-map
    (lambda ([fun : DatatypeFunction]) : (Maybe i:FunctionDefinition)
      (case fun
        [(variant-constructor type-name variant-name (empty) tag)
         (match-define const-name
           (bytes-append (varargs list type-name #"_" variant-name #"_const")))
         (just
           (i:function-definition
             (bytes-append (varargs list type-name #"_" variant-name))
             (var-type #"bogus")
             (empty)
             (empty)
             (i:global-var-expr (top-level-name mod-name const-name))))]
        [(variant-constructor type-name variant-name field-names tag)
         (match-define args
           (build-list (length field-names) (lambda ([index : Int]) (var #"arg" index))))
         (just
           (i:function-definition
             (bytes-append (varargs list type-name #"_" variant-name))
             (var-type #"bogus")
             args
             (empty)
             (i:make-variant-expr tag (map i:local-var-expr args))))]
        [(variant-accessor type-name variant-name field-name index)
         (match-define arg (var #"arg" 0))
         (just
           (i:function-definition
             (bytes-append (varargs list type-name #"_" variant-name #"_" field-name))
             (var-type #"bogus")
             (varargs list arg)
             (empty)
             (i:variant-field-ref-expr (i:local-var-expr arg) index)))]))
    funs))


(define (convert-type-definitions
          [mod-name : ModName]
          [types : (List TypeDefinition)]
          [env : (Dict Bytes Type)])
  : (List i-TypeDefinition)
  (map
    (lambda ([def : TypeDefinition]) (convert-type-definition mod-name def env))
    types))

(define (simplify-type-vars [tvs : (Maybe (List Bytes))]) : (List Bytes)
  (case tvs
    [(nothing) (empty)]
    [(just tvs) tvs]))

(define (lookup-type [env : (Dict Bytes Type)] [name : Bytes]) : Type
  (case (dict-ref env name)
    [(nothing) (panic #"No type bound")]
    [(just v) v]))

(define (convert-type-definition
          [mod-name : ModName]
          [type : TypeDefinition]
          [env : (Dict Bytes Type)])
  : i-TypeDefinition
  (case type
    [(type-definition name type-vars variants)
     (let ([type-vars (simplify-type-vars type-vars)])
       (i-type-definition
         name
         (lookup-type env name)
         type-vars
         (abstract-type mod-name name (map var-type type-vars))
         (convert-variant-definitions
           variants 0
           (add-type-vars type-vars env))))]))

(define (convert-variant-definitions
          [variants : (List VariantDefinition)]
          [index : Int]
          [env : (Dict Bytes Type)])
  : (List i-VariantDefinition)
  (case variants
    [(empty) (empty)]
    [(cons v vs)
     (cons
       (convert-variant-definition v index env)
       (convert-variant-definitions vs (+ index 1) env))]))

(define (convert-variant-definition
          [variant : VariantDefinition]
          [index : Int]
          [env : (Dict Bytes Type)])
  : i-VariantDefinition
  (case variant
    [(variant-definition name fields)
     (i-variant-definition
       name
       index
       (map (lambda ([f : VariantField]) (convert-variant-field f env)) fields))]))

(define (convert-variant-field
          [field : VariantField]
          [env : (Dict Bytes Type)])
  : i-VariantField
  (case field
    [(variant-field name pre-type)
     (i-variant-field name (convert-type env pre-type))]))

(define (environment-add-local [env : Environment] [local : Bytes] [state : State])
  : (Tuple3 Environment Var State)
  (match-define (environment types variants locals globals name) env)
  (match-define (tuple2 index state) (get-next-index state))
  (match-define v (var local index))
  (tuple3
    (environment types variants (dict-set locals local (var local index)) globals name)
    v
    state))

(define (environment-add-locals [env : Environment] [locals : (List Bytes)] [state : State])
  : (Tuple2 Environment State)
  (case locals
    [(empty) (tuple2 env state)]
    [(cons local locals)
     (case (environment-add-local env local state)
       [(tuple3 env _ state)
        (environment-add-locals env locals state)])]))

(define (environment-add-type-vars [env : Environment] [type-vars : (List Bytes)]) : Environment
  (match-define (environment types variants locals globals name) env)
  (environment (add-type-vars type-vars types) variants locals globals name))

(define (pattern-bound-vars [p : Pattern]) : (List Bytes)
  (pattern-bound-vars* p (empty)))
(define (pattern-bound-vars* [p : Pattern] [acc : (List Bytes)]) : (List Bytes)
  (case p
    [(bytes-pattern v) acc]
    [(int-pattern v) acc]
    [(variable-pattern v)
     (cons v acc)]
    [(ignore-pattern) acc]
    [(abstraction-pattern name pats)
     (foldl pattern-bound-vars* pats acc)]))

(define (convert-function-definitions
          [funs : (List FunctionDefinition)]
          [env : Environment]
          [acc : State]) : State
  (case funs
    [(empty) acc]
    [(cons fun funs)
     (convert-function-definitions funs env (convert-function-definition fun env acc))]))

(define (convert-function-definition
          [fun : FunctionDefinition]
          [env : Environment]
          [acc : State])
  : State
  (case fun
    [(function-definition name type-vars args result-type (block defs body))
     (match-define arg-names (map parse-arg-name args))
     (match-define arg-types (map parse-arg-type args))
     (match-define new-type
       (convert-type (environment-type-bindings env)
                     (fun-pre-type type-vars arg-types result-type)))
     (match-define env (environment-add-type-vars env type-vars))
     (match-define (tuple2 env acc) (environment-add-locals env arg-names acc))
     (case (convert-block defs body env acc)
       [(tuple2 i:body acc)
        (add-function
          (i:function-definition
            (bytes-append (varargs list name #"-code"))
            new-type
            (map (lambda ([t : (Tuple2 Bytes PreType)])
                   (convert-arg-type t env))
                 args)
            (empty) i:body)
          acc)])]))

;; TODO actually send down the type
(define (convert-arg-type [arg+ty : (Tuple2 Bytes PreType)] [env : Environment]) : Var
  (case arg+ty
    [(tuple2 arg ty)
     (case (dict-ref (environment-local-variables env) arg)
       [(nothing) (panic #"No value found for function arg")]
       [(just var) var])]))

(define (parse-arg-name [arg+ty : (Tuple2 Bytes PreType)]) : Bytes
  (case arg+ty
    [(tuple2 arg ty) arg]))
(define (parse-arg-type [arg+ty : (Tuple2 Bytes PreType)]) : PreType
  (case arg+ty
    [(tuple2 arg ty) ty]))

(define (convert-expression [expr : Expression] [env : Environment] [acc : State])
  : (Tuple2 i:Expression State)
  (case expr
    [(int-literal v) (tuple2 (i:int-literal v) acc)]
    [(bytes-literal v)
     (case (get-next-index acc)
       [(tuple2 index acc)
        (let ([constant-name
                (bytes-append (cons #"bytes-" (cons (integer->decimal-bytes index) (empty))))])
          (tuple2 (i:global-var-expr (top-level-name (environment-module-name env) constant-name))
                  (add-bytes-constant constant-name v acc)))])]
    [(boolean-literal v) (tuple2 (i:boolean-literal v) acc)]
    [(var-expr v)
     (case (dict-ref (environment-local-variables env) v)
       [(just v)
        (tuple2 (i:local-var-expr v) acc)]
       [(nothing)
        (case (dict-ref (environment-global-variables env) v)
          [(just v)
           (tuple2 (i:global-var-expr v) acc)]
          [(nothing)
           (panic #"Unbound variable")])])]
    [(if-expr c t f)
     (case (convert-expression c env acc)
       [(tuple2 ic acc)
        (case (convert-expression t env acc)
          [(tuple2 it acc)
           (case (convert-expression f env acc)
             [(tuple2 if acc)
              (tuple2 (i:if-expr ic it if) acc)])])])]
    [(begin-expr es e)
     (case (convert-expressions es env acc)
       [(tuple2 ies acc)
        (case (convert-expression e env acc)
          [(tuple2 ie acc)
           (tuple2 (i:begin-expr ies ie) acc)])])]
    [(let-expr name expr body)
     (case (convert-expression expr env acc)
       [(tuple2 iexpr acc)
        (case (environment-add-local env name acc)
          [(tuple3 env var acc)
           (case (convert-expression body env acc)
             [(tuple2 ibody acc)
              (tuple2 (i:let-expr var iexpr ibody) acc)])])])]
    [(case-expr expr clauses)
     (case (convert-expression expr env acc)
       [(tuple2 iexpr acc)
        (case (convert-clauses clauses env acc)
          [(tuple2 iclauses acc)
           (tuple2 (i:case-expr iexpr iclauses) acc)])])]
    [(lambda-expr args+tys _ body)
     (let ([outer-env env])
       (let ([args (map parse-arg-name args+tys)])
         (let ([fv (free-variables/expr body (set-add-all (make-set bytes-cmp) args) (make-set bytes-cmp))])
           (case (environment-add-locals env args acc)
             [(tuple2 env acc)
              (case (convert-expression body env acc)
                [(tuple2 ibody acc)
                 (case (get-next-index acc)
                   [(tuple2 index acc)
                    (match-define closure-name
                      (bytes-append (cons #"lambda_" (cons (integer->decimal-bytes index) (empty)))))
                    (match-define free-local-variables
                      (map
                        (lambda ([v : Bytes]) : Var
                          (case (dict-ref (environment-local-variables outer-env) v)
                            [(nothing) (panic #"No value found for free variable")]
                            [(just var) var]))
                       (set->list (set-intersect (dict-keys (environment-local-variables env)) fv))))
                    ;; TODO use a real type
                    (tuple2
                      (i:create-closure-expr
                        (top-level-name (environment-module-name env) closure-name)
                        (map i:local-var-expr free-local-variables))
                      (add-function
                        (i:function-definition
                          closure-name (var-type #"bogus")
                          (map (lambda ([t : (Tuple2 Bytes PreType)])
                                 (convert-arg-type t env))
                               args+tys)
                          free-local-variables ibody)
                        acc))])])]))))]
    [(app-expr tail-position op args)
     (case (convert-expression op env acc)
       [(tuple2 iop acc)
        (case (convert-expressions args env acc)
          [(tuple2 iargs acc)
           (tuple2 (i:call-closure-expr tail-position iop iargs) acc)])])]
    [(varargs-app-expr tail-position op args)
     (case (convert-expression op env acc)
       [(tuple2 iop acc)
        (case (convert-expressions args env acc)
          [(tuple2 iargs acc)
           (tuple2 (i:call-closure-expr tail-position iop (varargs list (i:array-expr iargs))) acc)])])]))

(define (convert-clause [clause : CaseClause] [env : Environment] [acc : State])
  : (Tuple2 i:CaseClause State)
  (case clause
    [(case-clause pat (block defs expr))
     (case (environment-add-locals env (pattern-bound-vars pat) acc)
       [(tuple2 env acc)
        (case (convert-block defs expr env acc)
          [(tuple2 iexpr acc)
           (case (convert-pattern pat env acc)
             [(tuple2 ipat acc)
              (tuple2 (i:case-clause ipat iexpr) acc)])])])]))

(define (convert-pattern [pat : Pattern] [env : Environment] [acc : State]) : (Tuple2 i:Pattern State)
  (case pat
    [(bytes-pattern v)
     (case (get-next-index acc)
       [(tuple2 index acc)
        (let ([constant-name
                (bytes-append (cons #"bytes-" (cons (integer->decimal-bytes index) (empty))))])
          (tuple2 (i:bytes-pattern (top-level-name (environment-module-name env) constant-name))
                  (add-bytes-constant constant-name v acc)))])]
    [(int-pattern v)
     (tuple2 (i:int-pattern v) acc)]
    [(variable-pattern v)
     (case (dict-ref (environment-local-variables env) v)
       [(nothing) (panic #"Unbound pattern variable")]
       [(just var)
        (tuple2 (i:variable-pattern var) acc)])]
    [(ignore-pattern)
     (tuple2 (i:ignore-pattern) acc)]
    [(abstraction-pattern name pats)
     (case (dict-ref (environment-variant-bindings env) name)
       [(nothing) (panic #"Unbound abstraction pattern")]
       [(just tag)
        (case (convert-patterns pats env acc)
          [(tuple2 ipats acc)
           (tuple2 (i:abstraction-pattern name tag ipats) acc)])])]))

(define (convert-patterns [pats : (List Pattern)] [env : Environment] [acc : State]) : (Tuple2 (List i:Pattern) State)
  (case pats
    [(empty) (tuple2 (empty) acc)]
    [(cons pat pats)
     (case (convert-pattern pat env acc)
       [(tuple2 ipat acc)
        (case (convert-patterns pats env acc)
          [(tuple2 ipats acc)
           (tuple2 (cons ipat ipats) acc)])])]))


(define (convert-expressions
          [exprs : (List Expression)]
          [env : Environment]
          [acc : State])
  : (Tuple2 (List i:Expression) State)
  (case exprs
    [(empty) (tuple2 (empty) acc)]
    [(cons e es)
     (case (convert-expression e env acc)
       [(tuple2 ie acc)
        (case (convert-expressions es env acc)
          [(tuple2 ies acc)
           (tuple2 (cons ie ies) acc)])])]))

(define (convert-clauses
          [clauses : (List CaseClause)]
          [env : Environment]
          [acc : State])
  : (Tuple2 (List i:CaseClause) State)
  (case clauses
    [(empty) (tuple2 (empty) acc)]
    [(cons c cs)
     (case (convert-clause c env acc)
       [(tuple2 ic acc)
        (case (convert-clauses cs env acc)
          [(tuple2 ics acc)
           (tuple2 (cons ic ics) acc)])])]))

(define (convert-block [defs : (List BlockDefinition)] [body : Expression] [env : Environment] [acc : State])
  : (Tuple2 i:Expression State)
  (case defs
    [(empty) (convert-expression body env acc)]
    [(cons (match-def pat expr) defs)
     (case (convert-expression expr env acc)
       [(tuple2 iexpr acc)
        (case (environment-add-locals env (pattern-bound-vars pat) acc)
          [(tuple2 env acc)
           (case (convert-pattern pat env acc)
             [(tuple2 ipat acc)
              (case (convert-block defs body env acc)
                [(tuple2 ibody acc)
                 (tuple2 (i:case-expr iexpr (varargs list (i:case-clause ipat ibody))) acc)])])])])]))

(define (add-function [func : i:FunctionDefinition] [acc : State]) : State
  (case acc
    [(state funcs bytes counter)
     (state (cons func funcs) bytes counter)]))

(define (add-bytes-constant [name : Bytes] [value : Bytes] [acc : State]) : State
  (case acc
    [(state funcs bytes counter)
     (state funcs (cons (bytes-constant name value) bytes) counter)]))

(define (get-next-index [acc : State]) : (Tuple2 Int State)
  (case acc
    [(state funcs bytes counter)
     (tuple2 counter (state funcs bytes (+ 1 counter)))]))

(define (convert-type [type-bindings : (Dict Bytes Type)] [type : PreType]) : Type
  (case type
    [(var-pre-type v)
     (case (dict-ref type-bindings v)
       [(just t)
        t]
       [_ (panic (bytes-append (varargs list #"No type is bound for " v)))])]
    [(fun-pre-type type-vars args result)
     (let ([type-bindings (add-type-vars type-vars type-bindings)])
       (fun-type
         type-vars
         (map (lambda ([t : PreType]) (convert-type type-bindings t)) args)
         (convert-type type-bindings result)))]
    [(type-app-pre-type constructor args)
     (case (dict-ref type-bindings constructor)
       [(just (type-constructor mod name kinds))
        (if (= (length kinds) (length args))
            (abstract-type
              mod name
              (map (lambda ([t : PreType]) (convert-type type-bindings t)) args))
            (panic #"Wrong number of type args."))]
       [(just _)
        (panic #"Type is not bound to a type constructor")]
       [_ (panic (bytes-append (varargs list #"No type is bound for " constructor)))])]))

(define (add-type-vars [type-vars : (List Bytes)] [type-bindings : (Dict Bytes Type)])
  : (Dict Bytes Type)
  (case type-vars
    [(empty) type-bindings]
    [(cons type-var type-vars)
     (add-type-vars type-vars (dict-add type-bindings type-var (var-type type-var)))]))


(define (setup-variant-bindings [imports : Imports] [datatype-funs : (List DatatypeFunction)])
  : (Dict Bytes Int)
  (add-all-imported-patterns
    (add-datatype-patterns
      (make-dict bytes-cmp)
      datatype-funs)
    imports))

(define (add-all-imported-patterns [env : (Dict Bytes Int)] [imports : Imports])
  : (Dict Bytes Int)
  (match-define (imports _ _ patterns _) imports)
  (merge-dicts
    (dict-value-map
      patterns
      (lambda ([p : PatternSignature])
        (case p
          [(pattern-signature _ tag _ _ _ _)
           tag])))
    env))

(define (add-datatype-patterns
          [env : (Dict Bytes Int)]
          [funs : (List DatatypeFunction)])
  : (Dict Bytes Int)
  (foldl
    (lambda ([f : DatatypeFunction] [env : (Dict Bytes Int)])
      (case f
        [(variant-constructor type-name variant-name _ tag)
         (dict-add env variant-name tag)]
        [(variant-accessor type-name variant-name field-name _)
         env]))
    funs
    env))

(define (setup-value-environment [mod : Module]
                                 [datatype-funs : (List DatatypeFunction)])
  : (Dict Bytes TopLevelName)
  (add-all-imported-functions
    (add-datatype-functions
      (add-locally-defined-functions
        (make-dict bytes-cmp)
        mod)
      (module-name mod)
      datatype-funs)
    mod))

(define (add-all-imported-functions [env : (Dict Bytes TopLevelName)] [mod : Module])
  : (Dict Bytes TopLevelName)
  (match-define (imports _ values _ _) (module-imports mod))
  (merge-dicts
    (dict-value-map values
      (lambda ([v : ValueSignature])
        (value-signature-value v)))
    env))

(define (add-locally-defined-functions [env : (Dict Bytes TopLevelName)] [mod : Module])
  : (Dict Bytes TopLevelName)
  (let ([var-names (map function-definition-name (module-definitions mod))])
    (let ([top-level-names (get-function-top-level-names (module-name mod) (module-definitions mod))])
      (add-all-globals env var-names top-level-names))))

(define (get-function-top-level-names [mod-name : ModName] [funs : (List FunctionDefinition)])
  : (List TopLevelName)
  (case funs
    [(empty) (empty)]
    [(cons (function-definition name _ _ _ _) funs)
     (cons
       (top-level-name mod-name name)
       (get-function-top-level-names mod-name funs))]))

(define (add-all-globals [env : (Dict Bytes TopLevelName)]
                         [var-names : (List Bytes)]
                         [top-level-names : (List TopLevelName)])
  : (Dict Bytes TopLevelName)
  (case var-names
    [(empty) env]
    [(cons var-name var-names)
     (case top-level-names
       [(empty) (panic #"var-names not the same length as mangled-names")]
       [(cons top-level-name top-level-names)
        (add-all-globals
          (dict-add env var-name top-level-name) var-names top-level-names)])]))

(define (add-datatype-functions
          [env : (Dict Bytes TopLevelName)]
          [mod-name : ModName]
          [funs : (List DatatypeFunction)])
  : (Dict Bytes TopLevelName)
  (foldl
    (lambda ([f : DatatypeFunction] [env : (Dict Bytes TopLevelName)])
      (case f
        [(variant-constructor type-name variant-name _ _)
         (dict-add
           env
           variant-name
           (top-level-name
             mod-name
             (bytes-append
               (varargs list type-name #"_" variant-name #"_closure"))))]
        [(variant-accessor type-name variant-name field-name _)
         (dict-add
           env
           (bytes-append (varargs list variant-name #"-" field-name))
           (top-level-name
             mod-name
             (bytes-append
               (varargs list type-name #"_" variant-name #"_" field-name #"_closure"))))]))
    funs
    env))

(define (type-definitions->functions
          [env : (Dict Bytes Type)]
          [defs : (List TypeDefinition)])
  : (List DatatypeFunction)
  (foldl
    (lambda ([def : TypeDefinition] [acc : (List DatatypeFunction)])
      (case def
        [(type-definition name _ (cons variant (empty)))
         (case variant
           [(variant-definition variant-name fields)
            (variant-definition->accessors
              (variant-definition->constructor acc env 0 name variant)
              env 0 name variant-name fields)])]
        [(type-definition name _ variants)
         (variant-definitions->constructors acc env 0 name variants)]))
    defs
    ((lambda () : (List DatatypeFunction) (empty)))))


(define (variant-definitions->constructors
          [acc : (List DatatypeFunction)]
          [env : (Dict Bytes Type)]
          [tag : Int]
          [type-name : Bytes]
          [defs : (List VariantDefinition)]) : (List DatatypeFunction)
  (case defs
    [(empty) acc]
    [(cons def defs)
     (variant-definitions->constructors
       (variant-definition->constructor acc env tag type-name def)
       env
       (+ 1 tag)
       type-name
       defs)]))

(define (variant-definition->constructor
          [acc : (List DatatypeFunction)]
          [env : (Dict Bytes Type)]
          [tag : Int]
          [type-name : Bytes]
          [def : VariantDefinition]) : (List DatatypeFunction)
  (case def
    [(variant-definition name fields)
     (cons
       (variant-constructor type-name name
                            (map variant-field-name fields)
                            tag)
       acc)]))

(define (variant-definition->accessors
          [acc : (List DatatypeFunction)]
          [env : (Dict Bytes Type)]
          [offset : Int]
          [type-name : Bytes]
          [variant-name : Bytes]
          [fields : (List VariantField)]) : (List DatatypeFunction)
  (case fields
    [(empty) acc]
    [(cons (variant-field name type) fields)
     (variant-definition->accessors
       (cons
         (variant-accessor type-name variant-name name offset)
         acc)
       env
       (+ offset 1)
       type-name
       variant-name
       fields)]))

(define (create-static-info
          [name : ModName]
          [constants : (List i:ConstantDefinition)]
          [funcs : (List i:FunctionDefinition)]
          [datatype-funs : (List DatatypeFunction)]) : (Dict TopLevelName TopLevelSignature)
  (add-datatype-function-static-info
    name
    datatype-funs
    (add-constants-static-info
      name
      constants
      (make-dict top-level-name-cmp))))

(define (add-constants-static-info
          [mod-name : ModName]
          [constants : (List i:ConstantDefinition)]
          [acc : (Dict TopLevelName TopLevelSignature)])
  : (Dict TopLevelName TopLevelSignature)
  (foldl
    (lambda ([const : i:ConstantDefinition] [acc : (Dict TopLevelName TopLevelSignature)])
      (case const
        [(closure-constant name fun-name)
         (dict-add acc (top-level-name mod-name name)
                   (top-level-signature (just (top-level-name mod-name fun-name)) (nothing)))]
        [(bytes-constant _ _)
         acc]
        [(trivial-variant-constant name _)
         acc]))
    constants
    acc))

(define (add-datatype-function-static-info
          [mod-name : ModName]
          [datatype-funs : (List DatatypeFunction)]
          [acc : (Dict TopLevelName TopLevelSignature)]) : (Dict TopLevelName TopLevelSignature)
  (foldl
    (lambda ([datatype : DatatypeFunction] [acc : (Dict TopLevelName TopLevelSignature)])
      (case datatype
        [(variant-constructor type-name variant-name (empty) tag)
         (dict-add
           acc
           (top-level-name mod-name (bytes-append (varargs list type-name #"_" variant-name)))
           (top-level-signature
             (nothing)
             (just
               (zero-arg-constant-inlineable-function
                 (top-level-name
                   mod-name
                   (bytes-append (varargs list type-name #"_" variant-name #"_const")))))))]
        [(variant-constructor type-name variant-name fields tag)
         (dict-add
           acc
           (top-level-name mod-name (bytes-append (varargs list type-name #"_" variant-name)))
           (top-level-signature
             (nothing)
             (just
               ;; TODO include the expected number of args
               (variant-constructor-inlineable-function tag)))) ]
        [(variant-accessor type-name variant-name field-name offset)
         (dict-add
           acc
           (top-level-name
             mod-name
             (bytes-append (varargs list type-name #"_" variant-name #"_" field-name)))
           (top-level-signature
             (nothing)
             (just
               (variant-accessor-inlineable-function offset))))]))
    datatype-funs
    acc))
