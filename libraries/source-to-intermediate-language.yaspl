(module source-to-intermediate-language
  (import
    (prim
      #:types (Bytes Int)
      #:values (+ = panic)
      #:patterns ())
    (bytes bytes-append bytes=?)
    (dict
      #:types (Dict)
      #:values (dict-ref dict-add make-dict)
      #:patterns ())
    (list
      #:types (List)
      #:values (empty cons list map length)
      #:patterns (empty cons))
    (maybe
      #:types (Maybe)
      #:values (just-v)
      #:patterns (nothing just))
    (types
      #:types (Type)
      #:values (var-type fun-type abstract-type star-kind type-constructor)
      #:patterns (type-constructor))
    (set
      #:types ()
      #:values (set->list set-remove-all)
      #:patterns ())
    (numbers integer->decimal-bytes)
    (tuples
      #:types (Tuple2)
      #:values (tuple2)
      #:patterns (tuple2))
    (free-variables free-variables)
    (module-signature
      #:types (ModuleSignature)
      #:values (module-signature-type-bindings module-signature-name)
      #:patterns ())
    (intermediate-language
      #:types
        ((Module i:Module)
         (TypeDefinition i:TypeDefinition)
         (VariantDefinition i:VariantDefinition)
         (VariantField i:VariantField)
         (FunctionDefinition i:FunctionDefinition)
         (BytesConstant i:BytesConstant)
         (Expression i:Expression)
         (CaseClause i:CaseClause)
         (Pattern i:Pattern)
         ClosureConstant)
      #:values
        ((module i:module)
         (type-definition i:type-definition)
         (variant-definition i:variant-definition)
         (variant-field i:variant-field)
         (function-definition i:function-definition)
         (int-literal i:int-literal)
         (boolean-literal i:boolean-literal)
         (local-var-expr i:local-var-expr)
         (if-expr i:if-expr)
         (begin-expr i:begin-expr)
         (create-closure-expr i:create-closure-expr)
         (call-closure-expr i:call-closure-expr)
         (varargs-call-closure-expr i:varargs-call-closure-expr)
         (let-expr i:let-expr)
         (case-expr i:case-expr)
         (case-clause i:case-clause)
         (ignore-pattern i:ignore-pattern)
         (variable-pattern i:variable-pattern)
         (abstraction-pattern i:abstraction-pattern)
         (bytes-pattern i:bytes-pattern)
         (int-pattern i:int-pattern)
         closure-constant
         bytes-constant)
      #:patterns ())
    (source-language
      #:types (Module FunctionDefinition Expression CaseClause Pattern PreType TypeDefinition
               VariantDefinition VariantField Import Imports)
      #:values ()
      #:patterns (module function-definition int-literal bytes-literal
                  boolean-literal var-expr if-expr begin-expr lambda-expr
                  let-expr case-expr case-clause app-expr varargs-app-expr
                  bytes-pattern int-pattern variable-pattern ignore-pattern abstraction-pattern
                  var-pre-type fun-pre-type type-app-pre-type
                  type-definition variant-definition variant-field import imports)))
  (export
    #:types ()
    #:values (source->intermediate)
    #:patterns ())
  (types
    (define-type Environment
      (environment
        (type-bindings (Dict Bytes Type))))
    (define-type State
      (state [funcs (List i:FunctionDefinition)] [bytes (List i:BytesConstant)] [counter Int])))

  (define (source->intermediate [mod : Module] [sigs : (List ModuleSignature)]) : i:Module
    (case mod
      [(module name imports exports types definitions)
       (let ([type-env (make-type-environment mod sigs)])
         (case (convert-function-definitions
                 definitions
                 (environment type-env)
                 (state (empty) (empty) 0))
           [(state funcs byte-constants _)
            (i:module
              name
              imports
              exports
              (convert-type-definitions name types type-env)
              funcs
              (create-closures definitions (empty))
              byte-constants)]))]))

  (define (make-type-environment [mod : Module] [sigs : (List ModuleSignature)])
    : (Dict Bytes Type)
    (case mod
      [(module name importss _ types _)
       (add-imported-types/importss importss sigs
         (add-type-definitions name types (make-dict bytes=?)))]))

  (define (add-imported-types/importss
            [importss : (List Imports)]
            [sigs : (List ModuleSignature)]
            [env : (Dict Bytes Type)])
    : (Dict Bytes Type)
    (case importss
      [(empty) env]
      [(cons (imports module-name types _ _) importss)
       (add-imported-types/importss
         importss
         sigs
         (add-imported-types module-name types
           (module-signature-type-bindings (lookup-signature module-name sigs)) env))]))

  (define (lookup-signature [name : Bytes] [sigs : (List ModuleSignature)])
    : ModuleSignature
    (case sigs
      [(empty) (panic #"No such signature")]
      [(cons sig sigs)
       (if (bytes=? (module-signature-name sig) name)
           sig
           (lookup-signature name sigs))]))


  (define (add-imported-types
            [module-name : Bytes]
            [types : (List Import)]
            [external-types : (Dict Bytes Type)]
            [env : (Dict Bytes Type)])
    : (Dict Bytes Type)
    (case types
      [(empty) env]
      [(cons (import external-name local-name) types)
       (add-imported-types
         module-name
         types
         external-types
         (dict-add env local-name
            (case (dict-ref external-types external-name)
              [(nothing) (panic (bytes-append (varargs list #"No type " external-name #" exported by "
                                                       module-name)))]
              [(just type) type])))]))


  (define (add-type-definitions [mod-name : Bytes] [types : (List TypeDefinition)] [env : (Dict Bytes Type)])
    : (Dict Bytes Type)
    (case types
      [(empty) env]
      [(cons (type-definition name (nothing) _) types)
       (add-type-definitions
         mod-name
         types
         (dict-add env name (abstract-type mod-name name (empty))))]
      [(cons (type-definition name (just syms) _) types)
       (add-type-definitions
         mod-name
         types
         (dict-add env name
            (type-constructor mod-name name (map (lambda ([v : Bytes]) (star-kind)) syms))))]))



  (define (create-closures
            [funs : (List FunctionDefinition)]
            [acc : (List ClosureConstant)]) : (List ClosureConstant)
    (case funs
      [(empty) acc]
      [(cons (function-definition name type args body) funs)
       (create-closures
         funs
         (cons (closure-constant name (bytes-append (varargs list name #"-code"))) acc))]))

  (define (convert-type-definitions
            [mod-name : Bytes]
            [types : (List TypeDefinition)]
            [env : (Dict Bytes Type)])
    : (List i:TypeDefinition)
    (map
      (lambda ([def : TypeDefinition]) (convert-type-definition mod-name def env))
      types))

  (define (simplify-type-vars [tvs : (Maybe (List Bytes))]) : (List Bytes)
    (case tvs
      [(nothing) (empty)]
      [(just tvs) tvs]))

  (define (convert-type-definition
            [mod-name : Bytes]
            [type : TypeDefinition]
            [env : (Dict Bytes Type)])
    : i:TypeDefinition
    (case type
      [(type-definition name type-vars variants)
       (let ([type-vars (simplify-type-vars type-vars)])
         (i:type-definition
           name
           (just-v (dict-ref env name))
           type-vars
           (abstract-type mod-name name (map var-type type-vars))
           (convert-variant-definitions
             variants 0
             (add-type-vars type-vars env))))]))

  (define (convert-variant-definitions
            [variants : (List VariantDefinition)]
            [index : Int]
            [env : (Dict Bytes Type)])
    : (List i:VariantDefinition)
    (case variants
      [(empty) (empty)]
      [(cons v vs)
       (cons
         (convert-variant-definition v index env)
         (convert-variant-definitions vs (+ index 1) env))]))

  (define (convert-variant-definition
            [variant : VariantDefinition]
            [index : Int]
            [env : (Dict Bytes Type)])
    : i:VariantDefinition
    (case variant
      [(variant-definition name fields)
       (i:variant-definition
         name
         index
         (map (lambda ([f : VariantField]) (convert-variant-field f env)) fields))]))

  (define (convert-variant-field
            [field : VariantField]
            [env : (Dict Bytes Type)])
    : i:VariantField
    (case field
      [(variant-field name pre-type)
       (i:variant-field name (convert-type env pre-type))]))

  (define (convert-function-definitions
            [funs : (List FunctionDefinition)]
            [env : Environment]
            [acc : State]) : State
    (case funs
      [(empty) acc]
      [(cons fun funs)
       (convert-function-definitions funs env (convert-function-definition fun env acc))]))

  (define (convert-function-definition
            [fun : FunctionDefinition]
            [env : Environment]
            [acc : State])
    : State
    (case fun
      [(function-definition name type args body)
       (case (convert-expression body env acc)
         [(tuple2 i:body acc)
          (add-function
            (i:function-definition
              (bytes-append (varargs list name #"-code"))
              (convert-type (environment-type-bindings env) type)
              args (empty) i:body)
            acc)])]))

  (define (parse-arg [arg+ty : (Tuple2 Bytes PreType)]) : Bytes
    (case arg+ty
      [(tuple2 arg ty) arg]))

  (define (convert-expression [expr : Expression] [env : Environment] [acc : State])
    : (Tuple2 i:Expression State)
    (case expr
      [(int-literal v) (tuple2 (i:int-literal v) acc)]
      [(bytes-literal v)
       (case (get-next-index acc)
         [(tuple2 index acc)
          (let ([constant-name
                  (bytes-append (cons #"bytes-" (cons (integer->decimal-bytes index) (empty))))])
            (tuple2 (i:local-var-expr constant-name)
                    (add-bytes-constant constant-name v acc)))])]
      [(boolean-literal v) (tuple2 (i:boolean-literal v) acc)]
      ;; TODO handle this correctly
      [(var-expr v) (tuple2 (i:local-var-expr v) acc)]
      [(if-expr c t f)
       (case (convert-expression c env acc)
         [(tuple2 ic acc)
          (case (convert-expression t env acc)
            [(tuple2 it acc)
             (case (convert-expression f env acc)
               [(tuple2 if acc)
                (tuple2 (i:if-expr ic it if) acc)])])])]
      [(begin-expr e es)
       (case (convert-expression e env acc)
         [(tuple2 ie acc)
          (case (convert-expressions es env acc)
            [(tuple2 ies acc)
             (tuple2 (i:begin-expr ie ies) acc)])])]
      [(let-expr name expr body)
       (case (convert-expression expr env acc)
         [(tuple2 iexpr acc)
          (case (convert-expression body env acc)
            [(tuple2 ibody acc)
             (tuple2 (i:let-expr name iexpr ibody) acc)])])]
      [(case-expr expr clauses)
       (case (convert-expression expr env acc)
         [(tuple2 iexpr acc)
          (case (convert-clauses clauses env acc)
            [(tuple2 iclauses acc)
             (tuple2 (i:case-expr iexpr iclauses) acc)])])]
      [(lambda-expr args+tys body)
       (let ([args (map parse-arg args+tys)])
         (let ([fv (set-remove-all (free-variables body) args)])
           (case (convert-expression body env acc)
             [(tuple2 ibody acc)
              (case (get-next-index acc)
                [(tuple2 index acc)
                 (let ([closure-name
                         (bytes-append (cons #"lambda-" (cons (integer->decimal-bytes index) (empty))))])
                   ;; TODO use a real type
                   (tuple2
                     (i:create-closure-expr (i:local-var-expr closure-name)
                                            (map i:local-var-expr (set->list fv)))
                     (add-function
                       (i:function-definition
                         closure-name (var-type #"bogus") args (set->list fv) ibody)
                       acc)))])])))]
      [(app-expr op args)
       (case (convert-expression op env acc)
         [(tuple2 iop acc)
          (case (convert-expressions args env acc)
            [(tuple2 iargs acc)
             (tuple2 (i:call-closure-expr iop iargs) acc)])])]
      [(varargs-app-expr op args)
       (case (convert-expression op env acc)
         [(tuple2 iop acc)
          (case (convert-expressions args env acc)
            [(tuple2 iargs acc)
             (tuple2 (i:varargs-call-closure-expr iop iargs) acc)])])]))

  (define (convert-clause [clause : CaseClause] [env : Environment] [acc : State])
    : (Tuple2 i:CaseClause State)
    (case clause
      [(case-clause pat expr)
       (case (convert-expression expr env acc)
         [(tuple2 iexpr acc)
          (case (convert-pattern pat acc)
            [(tuple2 ipat acc)
             (tuple2 (i:case-clause ipat iexpr) acc)])])]))

  (define (convert-pattern [pat : Pattern] [acc : State]) : (Tuple2 i:Pattern State)
    (case pat
      [(bytes-pattern v)
       (case (get-next-index acc)
         [(tuple2 index acc)
          (let ([constant-name
                  (bytes-append (cons #"bytes-" (cons (integer->decimal-bytes index) (empty))))])
            (tuple2 (i:bytes-pattern constant-name)
                    (add-bytes-constant constant-name v acc)))])]
      [(int-pattern v)
       (tuple2 (i:int-pattern v) acc)]
      [(variable-pattern v)
       (tuple2 (i:variable-pattern v) acc)]
      [(ignore-pattern)
       (tuple2 (i:ignore-pattern) acc)]
      [(abstraction-pattern name pats)
       (case (convert-patterns pats acc)
         [(tuple2 ipats acc)
          (tuple2 (i:abstraction-pattern name ipats) acc)])]))

  (define (convert-patterns [pats : (List Pattern)] [acc : State]) : (Tuple2 (List i:Pattern) State)
    (case pats
      [(empty) (tuple2 (empty) acc)]
      [(cons pat pats)
       (case (convert-pattern pat acc)
         [(tuple2 ipat acc)
          (case (convert-patterns pats acc)
            [(tuple2 ipats acc)
             (tuple2 (cons ipat ipats) acc)])])]))


  (define (convert-expressions
            [exprs : (List Expression)]
            [env : Environment]
            [acc : State])
    : (Tuple2 (List i:Expression) State)
    (case exprs
      [(empty) (tuple2 (empty) acc)]
      [(cons e es)
       (case (convert-expression e env acc)
         [(tuple2 ie acc)
          (case (convert-expressions es env acc)
            [(tuple2 ies acc)
             (tuple2 (cons ie ies) acc)])])]))

  (define (convert-clauses
            [clauses : (List CaseClause)]
            [env : Environment]
            [acc : State])
    : (Tuple2 (List i:CaseClause) State)
    (case clauses
      [(empty) (tuple2 (empty) acc)]
      [(cons c cs)
       (case (convert-clause c env acc)
         [(tuple2 ic acc)
          (case (convert-clauses cs env acc)
            [(tuple2 ics acc)
             (tuple2 (cons ic ics) acc)])])]))

  (define (add-function [func : i:FunctionDefinition] [acc : State]) : State
    (case acc
      [(state funcs bytes counter)
       (state (cons func funcs) bytes counter)]))

  (define (add-bytes-constant [name : Bytes] [value : Bytes] [acc : State]) : State
    (case acc
      [(state funcs bytes counter)
       (state funcs (cons (bytes-constant name value) bytes) counter)]))

  (define (get-next-index [acc : State]) : (Tuple2 Int State)
    (case acc
      [(state funcs bytes counter)
       (tuple2 counter (state funcs bytes (+ 1 counter)))]))

  (define (convert-type [type-bindings : (Dict Bytes Type)] [type : PreType]) : Type
    (case type
      [(var-pre-type v)
       (case (dict-ref type-bindings v)
         [(just t)
          t]
         [_ (panic (bytes-append (varargs list #"No type is bound for " v)))])]
      [(fun-pre-type type-vars args result)
       (let ([type-bindings (add-type-vars type-vars type-bindings)])
         (fun-type
           type-vars
           (map (lambda ([t : PreType]) (convert-type type-bindings t)) args)
           (convert-type type-bindings result)))]
      [(type-app-pre-type constructor args)
       (case (dict-ref type-bindings constructor)
         [(just (type-constructor mod name kinds))
          (if (= (length kinds) (length args))
              (abstract-type
                mod name
                (map (lambda ([t : PreType]) (convert-type type-bindings t)) args))
              (panic #"Wrong number of type args."))]
         [(just _)
          (panic #"Type is not bound to a type constructor")]
         [_ (panic (bytes-append (varargs list #"No type is bound for " constructor)))])]))

  (define (add-type-vars [type-vars : (List Bytes)] [type-bindings : (Dict Bytes Type)])
    : (Dict Bytes Type)
    (case type-vars
      [(empty) type-bindings]
      [(cons type-var type-vars)
       (add-type-vars type-vars (dict-add type-bindings type-var (var-type type-var)))])))
