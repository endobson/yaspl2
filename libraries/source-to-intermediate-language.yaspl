#:module (source-to-intermediate-language)
#:import {
  (bytes)
  (data lifted-primitives)
  (dict)
  (either)
  {(intermediate-expression)
    {#:types
      [CaseClause i:CaseClause]
      [Expression i:Expression]
      [Pattern i:Pattern]
    }
    {#:values
      [abstraction-pattern i:abstraction-pattern]
      [array-expr i:array-expr]
      [begin-expr i:begin-expr]
      [boolean-literal i:boolean-literal]
      [bytes-pattern i:bytes-pattern]
      [call-closure-expr i:call-closure-expr]
      [case-clause i:case-clause]
      [case-expr i:case-expr]
      [create-closure-expr i:create-closure-expr]
      [global-var-expr i:global-var-expr]
      [if-expr i:if-expr]
      [ignore-pattern i:ignore-pattern]
      [int-literal i:int-literal]
      [int-pattern i:int-pattern]
      [let-expr i:let-expr]
      [local-var-expr i:local-var-expr]
      [make-variant-expr i:make-variant-expr]
      [variable-pattern i:variable-pattern]
      [variant-field-ref-expr i:variant-field-ref-expr]
    }
  }
  {(intermediate-language)
    {#:types
      [ConstantDefinition i:ConstantDefinition]
      [Exports i:Exports]
      [FunctionDefinition i:FunctionDefinition]
      [Imports i:Imports]
      [Module i:Module]
      [PatternExport i:PatternExport]
      [TypeExport i:TypeExport]
      [ValueExport i:ValueExport]
    }
    {#:values
      bytes-constant
      closure-constant
      [exports i:exports]
      [function-definition i:function-definition]
      [imports i:imports]
      [module i:module]
      [pattern-export i:pattern-export]
      trivial-variant-constant
      [type-export i:type-export]
      [value-export i:value-export]
    }
    {#:patterns
      bytes-constant
      closure-constant
      trivial-variant-constant
    }
  }
  (list)
  (maybe)
  (module-name)
  (module-signature)
  (numbers)
  (prim)
  {(resolved-types-language)
    {#:types
      [Module rt:Module]
    }
  }
  (set)
  (top-level-name)
  (tuples)
  {(type-checked-language)
    {#:types
      Block
      BlockDefinition
      CaseClause
      Export
      Exports
      Expression
      FunctionDefinition
      Imports
      Module
      Pattern
      TypeDefinition
      TypeExport
      ValueExport
      VariantDefinition
      VariantField
    }
    {#:values
      function-definition-name
      imports-patterns
      module-definitions
      module-imports
      module-name
      variant-field-name
    }
    {#:patterns
      abstraction-pattern
      annotated-expr
      app-expr
      begin-expr
      block
      boolean-literal
      bytes-literal
      bytes-pattern
      case-clause
      case-expr
      export
      exports
      function-definition
      if-expr
      ignore-pattern
      imports
      int-literal
      int-pattern
      lambda-expr
      let-expr
      match-def
      module
      pattern-descriptor
      type-definition
      type-export
      value-export
      var-expr
      varargs-app-expr
      variable-pattern
      variant-definition
      variant-field
    }
  }
  (type-checker)
  (types)
  (yaspl var)
}
(export
  (#:types)
  (#:values source->intermediate)
  (#:patterns))
(types
  (define-type Environment
    (environment
      [local-variables : (Dict Bytes Var)]
      [global-variables : (Dict Bytes TopLevelName)]
      [module-name : ModName]))
  (define-type State
    (state [funcs : (List i:FunctionDefinition)] [bytes : (List i:ConstantDefinition)] [counter : Int]))
  (define-type DatatypeFunction
    (variant-constructor
      [type-name : Bytes]
      [variant-name : Bytes]
      ;; TODO include something more useful than field names here
      [fields : (List Bytes)]
      [tag : U8])
    (variant-accessor
      [type-name : Bytes]
      [variant-name : Bytes]
      [field-name : Bytes]
      [field-offset : Int]))

  ;; TODO remove these/make them not needed
  (define-type i-TypeDefinition
    (i-type-definition
      [name : Bytes]
      [type-vars : (List Bytes)]
      ;; This is what the variants return
      [constructed-type : Type]
      [variants : (List i-VariantDefinition)]))
  (define-type i-VariantDefinition
    (i-variant-definition
      [name : Bytes]
      [tag : U8]
      [fields : (List i-VariantField)]))
  (define-type i-VariantField
    (i-variant-field
      [name : Bytes]
      [type : Type])))

(define (source->intermediate [mod : rt:Module])
  : (Either Bytes i:Module)
  (case (type-check mod)
    [(left v) (left (type-check-error->bytes v))]
    [(right mod)
     (case mod
       [(module name imports exports types definitions)
        (match-define type-functions (type-definitions->functions types))
        (match-define global-env (setup-value-environment mod type-functions))
        (match-define type-definitions (convert-type-definitions name types))
        (case (convert-function-definitions
                definitions
                (environment (make-dict bytes-cmp) global-env name)
                (state (empty) (empty) 0))
          [(state funcs byte-constants _)
           (match-define constants
             (append
               (create-closures definitions type-functions (empty))
               byte-constants))
           (right
             (i:module
               name
               (convert-imports imports)
               (convert-exports name exports global-env (imports-patterns imports) type-definitions)
               (append
                 funcs
                 (create-datatype-definitions name type-functions))
               constants
               (create-static-info
                 name
                 constants
                 funcs
                 type-functions)))])])]))

(define (convert-imports [i : Imports]) : i:Imports
  (case i
    [(imports values patterns static-info)
     (i:imports static-info)]))

(define (convert-exports
          [mod-name : ModName]
          [exports : Exports]
          [global-env : (Dict Bytes TopLevelName)]
          [imported-patterns : (Dict Bytes PatternSignature)]
          [type-defs : (List i-TypeDefinition)]) : i:Exports
  (case exports
    [(exports types values patterns)
     (i:exports
       (map convert-type-export types)
       (map (lambda ([e : ValueExport]) (convert-value-export e global-env)) values)
       (convert-pattern-exports mod-name patterns imported-patterns type-defs))]))

(define (convert-type-export [export : TypeExport]) : i:TypeExport
  (case export
    [(type-export exported type)
     (i:type-export exported type)]))

(define (convert-value-export [export : ValueExport]
                              [global-env : (Dict Bytes TopLevelName)]) : i:ValueExport
  (case export
    [(value-export local exported type)
     (case (dict-ref global-env local)
       [(nothing) (panic #"Export not in environment")]
       [(just top-level)
        (i:value-export exported top-level type)])]))

(define (convert-pattern-exports
          [mod-name : ModName]
          [exports : (List Export)]
          [imported-patterns : (Dict Bytes PatternSignature)]
          [type-defs : (List i-TypeDefinition)])
  : (List i:PatternExport)
  (let ([export-map (foldl
                      (lambda ([export : Export] [acc : (Dict Bytes Bytes)])
                        (case export
                          [(export local exported)
                           (dict-add acc local exported)]))
                      exports
                      (ann (Dict Bytes Bytes) (make-dict bytes-cmp)))])
    (dict-fold
      imported-patterns
      (lambda ([name : Bytes] [sig : PatternSignature] [acc : (List i:PatternExport)])
        (case (dict-ref export-map name)
          [(nothing) acc]
          [(just exported-name)
           (cons (i:pattern-export exported-name sig) acc)]))
      (foldl
        (lambda ([t : i-TypeDefinition] [acc : (List i:PatternExport)])
          (case t
            [(i-type-definition type-name type-vars self-type variants)
             (match-define type-sig (type-signature (map i-variant-definition-name variants)))
             (foldl
               (lambda ([v : i-VariantDefinition] [acc : (List i:PatternExport)])
                 (case v
                   [(i-variant-definition name tag fields)
                    (case (dict-ref export-map name)
                      [(nothing) acc]
                      [(just exported-name)
                       (cons
                         (i:pattern-export
                           exported-name
                           (pattern-signature name tag mod-name type-name
                                              type-vars (map i-variant-field-type fields) type-sig))
                         acc)])]))
               variants
               acc)]))
        type-defs
        (ann (List i:PatternExport) (empty))))))

(define (create-closures
          [funs : (List FunctionDefinition)]
          [types : (List DatatypeFunction)]
          [acc : (List i:ConstantDefinition)]) : (List i:ConstantDefinition)
  (create-closures/functions funs
    (create-closures/types types acc)))

(define (create-closures/functions
          [funs : (List FunctionDefinition)]
          [acc : (List i:ConstantDefinition)]) : (List i:ConstantDefinition)
  (foldl
    (lambda ([f : FunctionDefinition] [acc : (List i:ConstantDefinition)])
      (case f
        [(function-definition name _ args _ body)
         (cons (closure-constant name (bytes-append (varargs list name #"-code"))) acc)]))
    funs
    acc))


(define (create-closures/types
          [types : (List DatatypeFunction)]
          [acc : (List i:ConstantDefinition)]) : (List i:ConstantDefinition)
  (foldl
    (lambda ([f : DatatypeFunction] [acc : (List i:ConstantDefinition)])
      (case f
        [(variant-constructor type-name variant-name (empty) tag)
         (cons
           (trivial-variant-constant
             (bytes-append (varargs list type-name #"_" variant-name #"_const"))
             tag)
           (cons
             (closure-constant
               (bytes-append
                 (varargs list type-name #"_" variant-name #"_closure"))
               (bytes-append
                 (varargs list type-name #"_" variant-name)))
             acc))]
        [(variant-constructor type-name variant-name _ _)
         (cons
           (closure-constant
             (bytes-append
               (varargs list type-name #"_" variant-name #"_closure"))
             (bytes-append
               (varargs list type-name #"_" variant-name)))
           acc)]
        [(variant-accessor type-name variant-name field-name _)
         (cons
           (closure-constant
             (bytes-append
               (varargs list type-name #"_" variant-name #"_" field-name #"_closure"))
             (bytes-append
               (varargs list type-name #"_" variant-name #"_" field-name)))
           acc)]))
    types
    acc))

(define (create-datatype-definitions [mod-name : ModName] [funs : (List DatatypeFunction)])
  : (List i:FunctionDefinition)
  (filter-map
    (lambda ([fun : DatatypeFunction]) : (Maybe i:FunctionDefinition)
      (case fun
        [(variant-constructor type-name variant-name (empty) tag)
         (match-define const-name
           (bytes-append (varargs list type-name #"_" variant-name #"_const")))
         (just
           (i:function-definition
             (bytes-append (varargs list type-name #"_" variant-name))
             (var-type #"bogus")
             (empty)
             (empty)
             (i:global-var-expr (top-level-name mod-name const-name))))]
        [(variant-constructor type-name variant-name field-names tag)
         (match-define args
           (build-list (length field-names) (lambda ([index : Int]) (var #"arg" (var-number index)))))
         (just
           (i:function-definition
             (bytes-append (varargs list type-name #"_" variant-name))
             (var-type #"bogus")
             args
             (empty)
             (i:make-variant-expr tag (map i:local-var-expr args))))]
        [(variant-accessor type-name variant-name field-name index)
         (match-define arg (var #"arg" (initial-var-number)))
         (just
           (i:function-definition
             (bytes-append (varargs list type-name #"_" variant-name #"_" field-name))
             (var-type #"bogus")
             (varargs list arg)
             (empty)
             (i:variant-field-ref-expr (i:local-var-expr arg) index)))]))
    funs))


(define (convert-type-definitions [mod-name : ModName] [types : (List TypeDefinition)])
  : (List i-TypeDefinition)
  (map
    (lambda ([def : TypeDefinition]) (convert-type-definition mod-name def))
    types))

(define (simplify-type-vars [tvs : (Maybe (List Bytes))]) : (List Bytes)
  (case tvs
    [(nothing) (empty)]
    [(just tvs) tvs]))

(define (convert-type-definition [mod-name : ModName] [type : TypeDefinition])
  : i-TypeDefinition
  (case type
    [(type-definition name type-vars variants)
     (let ([type-vars (simplify-type-vars type-vars)])
       (i-type-definition
         name
         type-vars
         (abstract-type mod-name name (map var-type type-vars) (star-kind))
         (convert-variant-definitions variants 0)))]))

(define (convert-variant-definitions [variants : (List VariantDefinition)] [index : Int])
  : (List i-VariantDefinition)
  (case variants
    [(empty) (empty)]
    [(cons v vs)
     (cons
       (convert-variant-definition v index)
       (convert-variant-definitions vs (+ index 1)))]))

(define (convert-variant-definition
          [variant : VariantDefinition]
          [index : Int])
  : i-VariantDefinition
  (case variant
    [(variant-definition name fields)
     (i-variant-definition
       name
       (u8 index)
       (map convert-variant-field fields))]))

(define (convert-variant-field [field : VariantField]) : i-VariantField
  (case field
    [(variant-field name type)
     (i-variant-field name type)]))

(define (environment-add-local [env : Environment] [local : Bytes] [state : State])
  : (Tuple3 Environment Var State)
  (match-define (environment locals globals name) env)
  (match-define (tuple2 (lifted-int index) state) (get-next-index state))
  (match-define v (var local (var-number index)))
  (tuple3
    (environment (dict-set locals local v) globals name)
    v
    state))

(define (environment-add-locals [env : Environment] [locals : (List Bytes)] [state : State])
  : (Tuple2 Environment State)
  (case locals
    [(empty) (tuple2 env state)]
    [(cons local locals)
     (case (environment-add-local env local state)
       [(tuple3 env _ state)
        (environment-add-locals env locals state)])]))

(define (pattern-bound-vars [p : Pattern]) : (List Bytes)
  (pattern-bound-vars* p (empty)))
(define (pattern-bound-vars* [p : Pattern] [acc : (List Bytes)]) : (List Bytes)
  (case p
    [(bytes-pattern v) acc]
    [(int-pattern v) acc]
    [(variable-pattern v)
     (cons v acc)]
    [(ignore-pattern) acc]
    [(abstraction-pattern _ pats)
     (foldl pattern-bound-vars* pats acc)]))

(define (convert-function-definitions
          [funs : (List FunctionDefinition)]
          [env : Environment]
          [acc : State]) : State
  (case funs
    [(empty) acc]
    [(cons fun funs)
     (convert-function-definitions funs env (convert-function-definition fun env acc))]))

(define (convert-function-definition
          [fun : FunctionDefinition]
          [env : Environment]
          [acc : State])
  : State
  (case fun
    [(function-definition name type-vars args result-type (block defs body))
     (match-define arg-names (map parse-arg-name args))
     (match-define arg-types (map parse-arg-type args))
     (match-define new-type
                     (fun-type type-vars arg-types result-type))
     (match-define (tuple2 env acc) (environment-add-locals env arg-names acc))
     (case (convert-block defs body env acc)
       [(tuple2 i:body acc)
        (add-function
          (i:function-definition
            (bytes-append (varargs list name #"-code"))
            new-type
            (map (lambda ([t : (Tuple2 Bytes Type)])
                   (convert-arg-type t env))
                 args)
            (empty) i:body)
          acc)])]))

;; TODO actually send down the type
(define (convert-arg-type [arg+ty : (Tuple2 Bytes Type)] [env : Environment]) : Var
  (case arg+ty
    [(tuple2 arg ty)
     (case (dict-ref (environment-local-variables env) arg)
       [(nothing) (panic #"No value found for function arg")]
       [(just var) var])]))

(define (parse-arg-name [arg+ty : (Tuple2 Bytes Type)]) : Bytes
  (case arg+ty
    [(tuple2 arg ty) arg]))
(define (parse-arg-type [arg+ty : (Tuple2 Bytes Type)]) : Type
  (case arg+ty
    [(tuple2 arg ty) ty]))

(define (convert-expression [expr : Expression] [env : Environment] [acc : State])
  : (Tuple2 i:Expression State)
  (case expr
    [(int-literal v) (tuple2 (i:int-literal v) acc)]
    [(bytes-literal v)
     (case (get-next-index acc)
       [(tuple2 (lifted-int index) acc)
        (let ([constant-name
                (bytes-append (cons #"bytes-" (cons (integer->decimal-bytes index) (empty))))])
          (tuple2 (i:global-var-expr (top-level-name (environment-module-name env) constant-name))
                  (add-bytes-constant constant-name v acc)))])]
    [(boolean-literal v) (tuple2 (i:boolean-literal v) acc)]
    [(var-expr v)
     (case (dict-ref (environment-local-variables env) v)
       [(just v)
        (tuple2 (i:local-var-expr v) acc)]
       [(nothing)
        (case (dict-ref (environment-global-variables env) v)
          [(just v)
           (tuple2 (i:global-var-expr v) acc)]
          [(nothing)
           (panic #"Unbound variable")])])]
    [(if-expr c t f)
     (case (convert-expression c env acc)
       [(tuple2 ic acc)
        (case (convert-expression t env acc)
          [(tuple2 it acc)
           (case (convert-expression f env acc)
             [(tuple2 if acc)
              (tuple2 (i:if-expr ic it if) acc)])])])]
    [(begin-expr es e)
     (case (convert-expressions es env acc)
       [(tuple2 ies acc)
        (case (convert-expression e env acc)
          [(tuple2 ie acc)
           (tuple2 (i:begin-expr ies ie) acc)])])]
    [(let-expr name expr body)
     (case (convert-expression expr env acc)
       [(tuple2 iexpr acc)
        (case (environment-add-local env name acc)
          [(tuple3 env var acc)
           (case (convert-expression body env acc)
             [(tuple2 ibody acc)
              (tuple2 (i:let-expr var iexpr ibody) acc)])])])]
    [(case-expr expr clauses)
     (case (convert-expression expr env acc)
       [(tuple2 iexpr acc)
        (case (convert-clauses clauses env acc)
          [(tuple2 iclauses acc)
           (tuple2 (i:case-expr iexpr iclauses) acc)])])]
    [(annotated-expr _ expr)
     (convert-expression expr env acc)]
    [(lambda-expr args+tys _ body)
     (let ([outer-env env])
       (let ([args (map parse-arg-name args+tys)])
         (let ([fv (free-variables/expr body (set-add-all (make-set bytes-cmp) args) (make-set bytes-cmp))])
           (case (environment-add-locals env args acc)
             [(tuple2 env acc)
              (case (convert-expression body env acc)
                [(tuple2 ibody acc)
                 (case (get-next-index acc)
                   [(tuple2 (lifted-int index) acc)
                    (match-define closure-name
                      (bytes-append (cons #"lambda_" (cons (integer->decimal-bytes index) (empty)))))
                    (match-define free-local-variables
                      (map
                        (lambda ([v : Bytes]) : Var
                          (case (dict-ref (environment-local-variables outer-env) v)
                            [(nothing) (panic #"No value found for free variable")]
                            [(just var) var]))
                       (set->list (set-intersect (dict-keys (environment-local-variables env)) fv))))
                    ;; TODO use a real type
                    (tuple2
                      (i:create-closure-expr
                        (top-level-name (environment-module-name env) closure-name)
                        (map i:local-var-expr free-local-variables))
                      (add-function
                        (i:function-definition
                          closure-name (var-type #"bogus")
                          (map (lambda ([t : (Tuple2 Bytes Type)])
                                 (convert-arg-type t env))
                               args+tys)
                          free-local-variables ibody)
                        acc))])])]))))]
    [(app-expr tail-position op args)
     (case (convert-expression op env acc)
       [(tuple2 iop acc)
        (case (convert-expressions args env acc)
          [(tuple2 iargs acc)
           (tuple2 (i:call-closure-expr tail-position iop iargs) acc)])])]
    [(varargs-app-expr tail-position op args)
     (case (convert-expression op env acc)
       [(tuple2 iop acc)
        (case (convert-expressions args env acc)
          [(tuple2 iargs acc)
           (tuple2 (i:call-closure-expr tail-position iop (varargs list (i:array-expr iargs))) acc)])])]))

(define (convert-clause [clause : CaseClause] [env : Environment] [acc : State])
  : (Tuple2 i:CaseClause State)
  (case clause
    [(case-clause pat (block defs expr))
     (case (environment-add-locals env (pattern-bound-vars pat) acc)
       [(tuple2 env acc)
        (case (convert-block defs expr env acc)
          [(tuple2 iexpr acc)
           (case (convert-pattern pat env acc)
             [(tuple2 ipat acc)
              (tuple2 (i:case-clause ipat iexpr) acc)])])])]))

(define (convert-pattern [pat : Pattern] [env : Environment] [acc : State]) : (Tuple2 i:Pattern State)
  (case pat
    [(bytes-pattern v)
     (case (get-next-index acc)
       [(tuple2 (lifted-int index) acc)
        (let ([constant-name
                (bytes-append (cons #"bytes-" (cons (integer->decimal-bytes index) (empty))))])
          (tuple2 (i:bytes-pattern (top-level-name (environment-module-name env) constant-name))
                  (add-bytes-constant constant-name v acc)))])]
    [(int-pattern v)
     (tuple2 (i:int-pattern v) acc)]
    [(variable-pattern v)
     (case (dict-ref (environment-local-variables env) v)
       [(nothing) (panic #"Unbound pattern variable")]
       [(just var)
        (tuple2 (i:variable-pattern var) acc)])]
    [(ignore-pattern)
     (tuple2 (i:ignore-pattern) acc)]
    [(abstraction-pattern (pattern-descriptor _ _ _ tag variant-name _) pats)
     (case (convert-patterns pats env acc)
       [(tuple2 ipats acc)
        (tuple2 (i:abstraction-pattern variant-name tag ipats) acc)])]))

(define (convert-patterns [pats : (List Pattern)] [env : Environment] [acc : State]) : (Tuple2 (List i:Pattern) State)
  (case pats
    [(empty) (tuple2 (empty) acc)]
    [(cons pat pats)
     (case (convert-pattern pat env acc)
       [(tuple2 ipat acc)
        (case (convert-patterns pats env acc)
          [(tuple2 ipats acc)
           (tuple2 (cons ipat ipats) acc)])])]))


(define (convert-expressions
          [exprs : (List Expression)]
          [env : Environment]
          [acc : State])
  : (Tuple2 (List i:Expression) State)
  (case exprs
    [(empty) (tuple2 (empty) acc)]
    [(cons e es)
     (case (convert-expression e env acc)
       [(tuple2 ie acc)
        (case (convert-expressions es env acc)
          [(tuple2 ies acc)
           (tuple2 (cons ie ies) acc)])])]))

(define (convert-clauses
          [clauses : (List CaseClause)]
          [env : Environment]
          [acc : State])
  : (Tuple2 (List i:CaseClause) State)
  (case clauses
    [(empty) (tuple2 (empty) acc)]
    [(cons c cs)
     (case (convert-clause c env acc)
       [(tuple2 ic acc)
        (case (convert-clauses cs env acc)
          [(tuple2 ics acc)
           (tuple2 (cons ic ics) acc)])])]))

(define (convert-block [defs : (List BlockDefinition)] [body : Expression] [env : Environment] [acc : State])
  : (Tuple2 i:Expression State)
  (case defs
    [(empty) (convert-expression body env acc)]
    [(cons (match-def pat type expr) defs)
     (case (convert-expression expr env acc)
       [(tuple2 iexpr acc)
        (case (environment-add-locals env (pattern-bound-vars pat) acc)
          [(tuple2 env acc)
           (case (convert-pattern pat env acc)
             [(tuple2 ipat acc)
              (case (convert-block defs body env acc)
                [(tuple2 ibody acc)
                 (tuple2 (i:case-expr iexpr (varargs list (i:case-clause ipat ibody))) acc)])])])])]))

(define (add-function [func : i:FunctionDefinition] [acc : State]) : State
  (case acc
    [(state funcs bytes counter)
     (state (cons func funcs) bytes counter)]))

(define (add-bytes-constant [name : Bytes] [value : Bytes] [acc : State]) : State
  (case acc
    [(state funcs bytes counter)
     (state funcs (cons (bytes-constant name value) bytes) counter)]))

(define (get-next-index [acc : State]) : (Tuple2 LiftedInt State)
  (case acc
    [(state funcs bytes counter)
     (tuple2 (lifted-int counter) (state funcs bytes (+ 1 counter)))]))

(define (setup-value-environment [mod : Module]
                                 [datatype-funs : (List DatatypeFunction)])
  : (Dict Bytes TopLevelName)
  (add-all-imported-functions
    (add-datatype-functions
      (add-locally-defined-functions
        (make-dict bytes-cmp)
        mod)
      (module-name mod)
      datatype-funs)
    mod))

(define (add-all-imported-functions [env : (Dict Bytes TopLevelName)] [mod : Module])
  : (Dict Bytes TopLevelName)
  (match-define (imports values _ _) (module-imports mod))
  (merge-dicts
    (dict-value-map values
      (lambda ([v : ValueSignature])
        (value-signature-value v)))
    env))

(define (add-locally-defined-functions [env : (Dict Bytes TopLevelName)] [mod : Module])
  : (Dict Bytes TopLevelName)
  (let ([var-names (map function-definition-name (module-definitions mod))])
    (let ([top-level-names (get-function-top-level-names (module-name mod) (module-definitions mod))])
      (add-all-globals env var-names top-level-names))))

(define (get-function-top-level-names [mod-name : ModName] [funs : (List FunctionDefinition)])
  : (List TopLevelName)
  (case funs
    [(empty) (empty)]
    [(cons (function-definition name _ _ _ _) funs)
     (cons
       (top-level-name mod-name name)
       (get-function-top-level-names mod-name funs))]))

(define (add-all-globals [env : (Dict Bytes TopLevelName)]
                         [var-names : (List Bytes)]
                         [top-level-names : (List TopLevelName)])
  : (Dict Bytes TopLevelName)
  (case var-names
    [(empty) env]
    [(cons var-name var-names)
     (case top-level-names
       [(empty) (panic #"var-names not the same length as mangled-names")]
       [(cons top-level-name top-level-names)
        (add-all-globals
          (dict-add env var-name top-level-name) var-names top-level-names)])]))

(define (add-datatype-functions
          [env : (Dict Bytes TopLevelName)]
          [mod-name : ModName]
          [funs : (List DatatypeFunction)])
  : (Dict Bytes TopLevelName)
  (foldl
    (lambda ([f : DatatypeFunction] [env : (Dict Bytes TopLevelName)])
      (case f
        [(variant-constructor type-name variant-name _ _)
         (dict-add
           env
           variant-name
           (top-level-name
             mod-name
             (bytes-append
               (varargs list type-name #"_" variant-name #"_closure"))))]
        [(variant-accessor type-name variant-name field-name _)
         (dict-add
           env
           (bytes-append (varargs list variant-name #"-" field-name))
           (top-level-name
             mod-name
             (bytes-append
               (varargs list type-name #"_" variant-name #"_" field-name #"_closure"))))]))
    funs
    env))

(define (type-definitions->functions [defs : (List TypeDefinition)])
  : (List DatatypeFunction)
  (foldl
    (lambda ([def : TypeDefinition] [acc : (List DatatypeFunction)])
      (case def
        [(type-definition name _ (cons variant (empty)))
         (case variant
           [(variant-definition variant-name fields)
            (variant-definition->accessors
              (variant-definition->constructor acc (u8 0) name variant)
              0 name variant-name fields)])]
        [(type-definition name _ variants)
         (variant-definitions->constructors acc 0 name variants)]))
    defs
    (ann (List DatatypeFunction) (empty))))


(define (variant-definitions->constructors
          [acc : (List DatatypeFunction)]
          [tag : Int]
          [type-name : Bytes]
          [defs : (List VariantDefinition)]) : (List DatatypeFunction)
  (case defs
    [(empty) acc]
    [(cons def defs)
     (variant-definitions->constructors
       (variant-definition->constructor acc (u8 tag) type-name def)
       (+ 1 tag)
       type-name
       defs)]))

(define (variant-definition->constructor
          [acc : (List DatatypeFunction)]
          [tag : U8]
          [type-name : Bytes]
          [def : VariantDefinition]) : (List DatatypeFunction)
  (case def
    [(variant-definition name fields)
     (cons
       (variant-constructor type-name name
                            (map variant-field-name fields)
                            tag)
       acc)]))

(define (variant-definition->accessors
          [acc : (List DatatypeFunction)]
          [offset : Int]
          [type-name : Bytes]
          [variant-name : Bytes]
          [fields : (List VariantField)]) : (List DatatypeFunction)
  (case fields
    [(empty) acc]
    [(cons (variant-field name type) fields)
     (variant-definition->accessors
       (cons
         (variant-accessor type-name variant-name name offset)
         acc)
       (+ offset 1)
       type-name
       variant-name
       fields)]))

(define (create-static-info
          [name : ModName]
          [constants : (List i:ConstantDefinition)]
          [funcs : (List i:FunctionDefinition)]
          [datatype-funs : (List DatatypeFunction)]) : (Dict TopLevelName TopLevelSignature)
  (add-datatype-function-static-info
    name
    datatype-funs
    (add-constants-static-info
      name
      constants
      (make-dict top-level-name-cmp))))

(define (add-constants-static-info
          [mod-name : ModName]
          [constants : (List i:ConstantDefinition)]
          [acc : (Dict TopLevelName TopLevelSignature)])
  : (Dict TopLevelName TopLevelSignature)
  (foldl
    (lambda ([const : i:ConstantDefinition] [acc : (Dict TopLevelName TopLevelSignature)])
      (case const
        [(closure-constant name fun-name)
         (dict-add acc (top-level-name mod-name name)
                   (top-level-signature (just (top-level-name mod-name fun-name)) (nothing)))]
        [(bytes-constant _ _)
         acc]
        [(trivial-variant-constant name _)
         acc]))
    constants
    acc))

(define (add-datatype-function-static-info
          [mod-name : ModName]
          [datatype-funs : (List DatatypeFunction)]
          [acc : (Dict TopLevelName TopLevelSignature)]) : (Dict TopLevelName TopLevelSignature)
  (foldl
    (lambda ([datatype : DatatypeFunction] [acc : (Dict TopLevelName TopLevelSignature)])
      (case datatype
        [(variant-constructor type-name variant-name (empty) tag)
         (dict-add
           acc
           (top-level-name mod-name (bytes-append (varargs list type-name #"_" variant-name)))
           (top-level-signature
             (nothing)
             (just
               (zero-arg-constant-inlineable-function
                 (top-level-name
                   mod-name
                   (bytes-append (varargs list type-name #"_" variant-name #"_const")))))))]
        [(variant-constructor type-name variant-name fields tag)
         (dict-add
           acc
           (top-level-name mod-name (bytes-append (varargs list type-name #"_" variant-name)))
           (top-level-signature
             (nothing)
             (just
               ;; TODO include the expected number of args
               (variant-constructor-inlineable-function tag)))) ]
        [(variant-accessor type-name variant-name field-name offset)
         (dict-add
           acc
           (top-level-name
             mod-name
             (bytes-append (varargs list type-name #"_" variant-name #"_" field-name)))
           (top-level-signature
             (nothing)
             (just
               (variant-accessor-inlineable-function offset))))]))
    datatype-funs
    acc))

(define (free-variables/block [block : Block] [env : (Set Bytes)] [acc : (Set Bytes)])
  : (Set Bytes)
  (match-define (block defs body) block)
  (free-variables/block* defs body env acc))

(define (free-variables/block*
          [defs : (List BlockDefinition)]
          [final-expr : Expression]
          [env : (Set Bytes)]
          [acc : (Set Bytes)]) : (Set Bytes)
  (case defs
    [(empty) (free-variables/expr final-expr env acc)]
    [(cons (match-def pattern type expr) defs)
     (free-variables/block*
       defs final-expr
       (set-add-all env (pattern-bound-vars pattern))
       (free-variables/expr expr env acc))]))

(define (free-variables/expr [expr : Expression] [env : (Set Bytes)] [acc : (Set Bytes)])
  : (Set Bytes)
  (case expr
    [(int-literal _) acc]
    [(bytes-literal _) acc]
    [(boolean-literal _) acc]
    [(annotated-expr _ expr)
     (free-variables/expr expr env acc)]
    [(if-expr c t f)
     (free-variables/list (cons c (cons t (cons f (empty)))) env acc)]
    [(begin-expr es e)
     (free-variables/list (cons e es) env acc)]
    [(app-expr _ op args)
     (free-variables/list (cons op args) env acc)]
    [(varargs-app-expr _ op args)
     (free-variables/list (cons op args) env acc)]
    [(let-expr name expr body)
     (free-variables/expr body (set-add env name) (free-variables/expr expr env acc))]
    [(case-expr expr clauses)
     (free-variables/clauses clauses env (free-variables/expr expr env acc))]
    [(lambda-expr args+tys _ body)
     (free-variables/expr body (set-add-all env (map (lambda ([arg+ty : (Tuple2 Bytes Type)])
                                                       (case arg+ty [(tuple2 arg _) arg]))
                                                     args+tys)) acc)]
    [(var-expr v)
     (if (set-member? env v)
         acc
         (set-add acc v))]))

(define (free-variables/list
          [exprs : (List Expression)]
          [env : (Set Bytes)]
          [acc : (Set Bytes)]) : (Set Bytes)
  (case exprs
    [(empty) acc]
    [(cons expr exprs)
     (free-variables/list exprs env (free-variables/expr expr env acc))]))

(define (free-variables/clauses
          [exprs : (List CaseClause)]
          [env : (Set Bytes)]
          [acc : (Set Bytes)]) : (Set Bytes)
  (case exprs
    [(empty) acc]
    [(cons (case-clause pattern body) clauses)
     (free-variables/clauses
       clauses env
       (free-variables/block
         body
         (set-add-all env (pattern-bound-vars pattern))
         acc))]))
