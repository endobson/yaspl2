#:module (source-to-intermediate-language)
#:import {
  (bytes)
  (data lifted-primitives)
  (dict)
  (either)
  {(expanded-datatypes-language)
    {#:values
      expand-datatypes
    }
  }
  (expanded-patterns-language)
  {(intermediate-expression)
    {#:types
      [DefaultCaseClause i:DefaultCaseClause]
      [Expression i:Expression]
      [VariantCaseClause i:VariantCaseClause]
    }
    {#:values
      [array-expr i:array-expr]
      [begin-expr i:begin-expr]
      [boolean-literal i:boolean-literal]
      [bytes-case-clause i:bytes-case-clause]
      [bytes-case-expr i:bytes-case-expr]
      [call-closure-expr i:call-closure-expr]
      [create-closure-expr i:create-closure-expr]
      [default-case-clause i:default-case-clause]
      [global-var-expr i:global-var-expr]
      [halt-expr i:halt-expr]
      [if-expr i:if-expr]
      [int-case-clause i:int-case-clause]
      [int-case-expr i:int-case-expr]
      [int-literal i:int-literal]
      [join-expr i:join-expr]
      [join-point-expr i:join-point-expr]
      [let-expr i:let-expr]
      [local-var-expr i:local-var-expr]
      [make-variant-expr i:make-variant-expr]
      [variant-case-clause i:variant-case-clause]
      [variant-case-expr i:variant-case-expr]
      [variant-field-ref-expr i:variant-field-ref-expr]
    }
  }
  {(intermediate-language)
    {#:types
      [ConstantDefinition i:ConstantDefinition]
      [Exports i:Exports]
      [FunctionDefinition i:FunctionDefinition]
      [Imports i:Imports]
      [Module i:Module]
      [PatternExport i:PatternExport]
      [TypeExport i:TypeExport]
      [ValueExport i:ValueExport]
    }
    {#:values
      bytes-constant
      closure-constant
      [exports i:exports]
      [function-definition i:function-definition]
      [imports i:imports]
      [module i:module]
      [pattern-export i:pattern-export]
      trivial-variant-constant
      [type-export i:type-export]
      [value-export i:value-export]
    }
    {#:patterns
      bytes-constant
      closure-constant
      trivial-variant-constant
    }
  }
  (list)
  (maybe)
  (module-name)
  (module-signature)
  (numbers)
  (prim)
  {(resolved-types-language)
    {#:types
      [Module rt:Module]
    }
  }
  {(resolved-vars-language)
    {#:values
      resolve-vars
    }
  }
  (set)
  (top-level-name)
  (tuples)
  (type-checker)
  (types)
  (yaspl var)
}
(export
  (#:types)
  (#:values source->intermediate)
  (#:patterns))
(types
  (define-type Environment
    (environment
      [module-name : ModName]
      ;; The next var for lifted functions
      [next-var : VarNumber]))
  (define-type State
    (state
      [funcs : (List i:FunctionDefinition)]
      [constants : (List i:ConstantDefinition)]
      [counter : Int])))

(define (source->intermediate [mod : rt:Module])
  : (Either Bytes i:Module)
  (case (type-check mod)
    [(left v) (left (type-check-error->bytes v))]
    [(right mod)
     (match-define mod (expand-datatypes mod))
     (match-define mod (resolve-vars mod))
     (match-define mod (expand-patterns mod))
     (case mod
       [(module name imports exports definitions)
        (case (convert-function-definitions
                definitions
                name
                (state (empty) (empty) 0))
          [(state funcs inner-expr-constants _)
           (match-define constants
             (append
               (create-closures definitions (empty))
               inner-expr-constants))
           (right
             (i:module
               name
               (convert-imports imports)
               (convert-exports exports)
               funcs
               constants
               (create-static-info name constants definitions)))])])]))

(define (convert-imports [i : Imports]) : i:Imports
  (case i
    [(imports _values static-info)
     (i:imports static-info)]))

(define (convert-exports [exports : Exports]) : i:Exports
  (case exports
    [(exports types values patterns)
     (i:exports
       (map convert-type-export types)
       (map convert-value-export values)
       (map convert-pattern-export patterns))]))

(define (convert-type-export [export : TypeExport]) : i:TypeExport
  (case export
    [(type-export exported type)
     (i:type-export exported type)]))

(define (convert-pattern-export [export : PatternExport]) : i:PatternExport
  (case export
    [(pattern-export exported type)
     (i:pattern-export exported type)]))

(define (convert-value-export [export : ValueExport]) : i:ValueExport
  (case export
    [(value-export exported top-level type)
     (i:value-export exported top-level type)]))

(define (create-closures
          [funs : (List FunctionDefinition)]
          [acc : (List i:ConstantDefinition)]) : (List i:ConstantDefinition)
  (foldl
    (lambda ([f : FunctionDefinition] [acc : (List i:ConstantDefinition)])
      (case f
        [(function-definition name _ _ _ _ _)
         (cons (closure-constant name (bytes-append (varargs list name #"-code"))) acc)]
        [(variant-constructor name (empty) tag)
         (cons
           (trivial-variant-constant
             (bytes-append (varargs list name #"_const"))
             tag)
           (cons
             (closure-constant
               (bytes-append (varargs list name #"_closure"))
               name)
             acc))]
        [(variant-constructor name _ _)
         (cons
           (closure-constant
             (bytes-append (varargs list name #"_closure"))
             name)
           acc)]
        [(variant-accessor name _)
         (cons
           (closure-constant
             (bytes-append (varargs list name #"_closure"))
             name)
           acc)]))
    funs
    acc))

(define (convert-function-definitions
          [funs : (List FunctionDefinition)]
          [mod-name : ModName]
          [acc : State]) : State
  (case funs
    [(empty) acc]
    [(cons fun funs)
     (convert-function-definitions funs mod-name (convert-function-definition fun mod-name acc))]))

(define (convert-function-definition
          [fun : FunctionDefinition]
          [mod-name : ModName]
          [acc : State])
  : State
  (case fun
    [(function-definition name type-vars args result-type next-var body)
     (match-define arg-names (map parse-arg-name args))
     (match-define arg-types (map parse-arg-type args))
     (match-define new-type (fun-type type-vars arg-types result-type))
     (match-define env (environment mod-name next-var))
     (case (convert-expression body env acc)
       [(tuple2 i:body acc)
        (add-function
          (i:function-definition
            (bytes-append (varargs list name #"-code"))
            new-type
            arg-names
            (empty)
            next-var
            i:body)
          acc)])]
    [(variant-constructor name (empty) _)
     (match-define const-name
       (bytes-append (varargs list name #"_const")))
     (add-function
       (i:function-definition
         name
         (var-type #"bogus")
         (empty)
         (empty)
         (initial-var-number)
         (i:global-var-expr (top-level-name mod-name const-name)))
       acc)]
    [(variant-constructor name field-names tag)
     (match-define args
       (build-list (length field-names) (lambda ([index : Int]) (var #"arg" (var-number index)))))
     (add-function
       (i:function-definition
         name
         (var-type #"bogus")
         args
         (empty)
         (var-number (length field-names))
         (i:make-variant-expr tag (map i:local-var-expr args)))
       acc)]
    [(variant-accessor name index)
     (match-define arg (var #"arg" (initial-var-number)))
     (add-function
       (i:function-definition
         name
         (var-type #"bogus")
         (varargs list arg)
         (empty)
         (next-var-number (initial-var-number))
         (i:variant-field-ref-expr (i:local-var-expr arg) index))
       acc)]))

(define (parse-arg-name [arg+ty : (Tuple2 Var Type)]) : Var
  (case arg+ty
    [(tuple2 arg _ty) arg]))
(define (parse-arg-type [arg+ty : (Tuple2 Var Type)]) : Type
  (case arg+ty
    [(tuple2 _arg ty) ty]))

(define (convert-expression [expr : Expression] [env : Environment] [acc : State])
  : (Tuple2 i:Expression State)
  (case expr
    [(int-literal v) (tuple2 (i:int-literal v) acc)]
    [(bytes-literal v)
     (case (get-next-index acc)
       [(tuple2 (lifted-int index) acc)
        ;; TODO make this not use the same namespace as function names.
        (let ([constant-name
                (bytes-append (cons #"bytes-constant-" (cons (integer->decimal-bytes index) (empty))))])
          (tuple2 (i:global-var-expr (top-level-name (environment-module-name env) constant-name))
                  (add-bytes-constant constant-name v acc)))])]
    [(boolean-literal v) (tuple2 (i:boolean-literal v) acc)]
    [(local-var-expr v)
     (tuple2 (i:local-var-expr v) acc)]
    [(global-var-expr v)
     (tuple2 (i:global-var-expr v) acc)]
    [(if-expr c t f)
     (case (convert-expression c env acc)
       [(tuple2 ic acc)
        (case (convert-expression t env acc)
          [(tuple2 it acc)
           (case (convert-expression f env acc)
             [(tuple2 if acc)
              (tuple2 (i:if-expr ic it if) acc)])])])]
    [(begin-expr es e)
     (case (convert-expressions es env acc)
       [(tuple2 ies acc)
        (case (convert-expression e env acc)
          [(tuple2 ie acc)
           (tuple2 (i:begin-expr ies ie) acc)])])]
    [(let-expr var expr body)
     (case (convert-expression expr env acc)
       [(tuple2 iexpr acc)
        (case (convert-expression body env acc)
          [(tuple2 ibody acc)
           (tuple2 (i:let-expr var iexpr ibody) acc)])])]
    [(halt-expr)
     (tuple2 (i:halt-expr) acc)]
    [(join-expr j)
     (tuple2 (i:join-expr j) acc)]
    [(join-point-expr j expr body)
     (case (convert-expression expr env acc)
       [(tuple2 iexpr acc)
        (case (convert-expression body env acc)
          [(tuple2 ibody acc)
           (tuple2 (i:join-point-expr j iexpr ibody) acc)])])]
    [(variant-case-expr expr clauses default)
     (case (convert-expression expr env acc)
       [(tuple2 iexpr acc)
        (case (convert-variant-case-clauses clauses env acc)
          [(tuple2 clauses acc)
           (match-define (tuple2 idef acc) : (Tuple2 (Maybe i:DefaultCaseClause) State)
             (case default
               [(just (default-case-clause def))
                (match-define (tuple2 idef acc) (convert-expression def env acc))
                (tuple2 (just (i:default-case-clause idef)) acc)]
               [(nothing)
                (tuple2 (nothing) acc)]))
           (tuple2
             (i:variant-case-expr iexpr clauses idef)
             acc)])])]
    [(int-case-expr expr (int-case-clause val body) (default-case-clause def))
     (case (convert-expression expr env acc)
       [(tuple2 iexpr acc)
        (case (convert-expression body env acc)
          [(tuple2 ibody acc)
           (case (convert-expression def env acc)
             [(tuple2 idef acc)
              (tuple2
                (i:int-case-expr iexpr
                                 (i:int-case-clause val ibody)
                                 (i:default-case-clause idef))
                acc)])])])]
    [(bytes-case-expr expr (bytes-case-clause val body) (default-case-clause def))
     (case (get-next-index acc)
       [(tuple2 (lifted-int index) acc)
        (let ([constant-name
                (bytes-append (cons #"bytes-" (cons (integer->decimal-bytes index) (empty))))])
          (case (convert-expression expr env acc)
            [(tuple2 iexpr acc)
             (case (convert-expression body env acc)
               [(tuple2 ibody acc)
                (case (convert-expression def env acc)
                  [(tuple2 idef acc)
                   (tuple2
                     (i:bytes-case-expr iexpr
                       (i:bytes-case-clause (top-level-name (environment-module-name env)
                                                            constant-name)
                                            ibody)
                       (i:default-case-clause idef))
                     (add-bytes-constant constant-name val acc))])])]))])]
    [(annotated-expr _ expr)
     (convert-expression expr env acc)]
    [(lambda-expr args+tys _ body)
     (let ([outer-env env])
       (let ([args (map parse-arg-name args+tys)])
         (let ([fv (set->list (free-variables/expr body (set-add-all (make-set var-cmp) args)
                                                   (make-set var-cmp)))])
           (case (convert-expression body env acc)
             [(tuple2 ibody acc)
              (case (get-next-index acc)
                [(tuple2 (lifted-int index) acc)
                 (match-define function-name
                   (bytes-append (cons #"lambda_code_" (cons (integer->decimal-bytes index) (empty)))))
                 (match-define closure-name
                   (bytes-append (cons #"lambda_" (cons (integer->decimal-bytes index) (empty)))))
                 (match-define acc
                   (add-function
                     (i:function-definition
                       function-name (var-type #"bogus")
                       (map (lambda ([t : (Tuple2 Var Type)])
                              (case t [(tuple2 var type) var]))
                            args+tys)
                       fv
                       (environment-next-var env)
                       ibody)
                     acc))
                 (if (= (length fv) 0)
                     (tuple2
                       (i:global-var-expr (top-level-name (environment-module-name env) closure-name))
                       (add-closure-constant closure-name function-name acc))
                     (tuple2
                       (i:create-closure-expr
                         (top-level-name (environment-module-name env) function-name)
                         (map i:local-var-expr fv))
                       acc))])]))))]
    [(app-expr tail-position op args)
     (case (convert-expression op env acc)
       [(tuple2 iop acc)
        (case (convert-expressions args env acc)
          [(tuple2 iargs acc)
           (tuple2 (i:call-closure-expr tail-position iop iargs) acc)])])]
    [(varargs-app-expr tail-position op args)
     (case (convert-expression op env acc)
       [(tuple2 iop acc)
        (case (convert-expressions args env acc)
          [(tuple2 iargs acc)
           (tuple2 (i:call-closure-expr tail-position iop (varargs list (i:array-expr iargs))) acc)])])]))

(define (convert-expressions
          [exprs : (List Expression)]
          [env : Environment]
          [acc : State])
  : (Tuple2 (List i:Expression) State)
  (case exprs
    [(empty) (tuple2 (empty) acc)]
    [(cons e es)
     (case (convert-expression e env acc)
       [(tuple2 ie acc)
        (case (convert-expressions es env acc)
          [(tuple2 ies acc)
           (tuple2 (cons ie ies) acc)])])]))

(define (convert-variant-case-clauses
          [clauses : (List VariantCaseClause)]
          [env : Environment]
          [acc : State])
  : (Tuple2 (List i:VariantCaseClause) State)
  (case clauses
    [(empty) (tuple2 (empty) acc)]
    [(cons (variant-case-clause sig fields body) clauses)
     (match-define (pattern-signature variant-name tag _ _ _ _ _) sig)
     (match-define (tuple2 body acc) (convert-expression body env acc))
     (match-define (tuple2 clauses acc) (convert-variant-case-clauses clauses env acc))
     (tuple2
       (cons (i:variant-case-clause variant-name tag fields body) clauses)
       acc)]))

(define (add-function [func : i:FunctionDefinition] [acc : State]) : State
  (case acc
    [(state funcs consts counter)
     (state (cons func funcs) consts counter)]))

(define (add-bytes-constant [name : Bytes] [value : Bytes] [acc : State]) : State
  (case acc
    [(state funcs consts counter)
     (state funcs (cons (bytes-constant name value) consts) counter)]))

(define (add-closure-constant [name : Bytes] [fun-name : Bytes] [acc : State]) : State
  (case acc
    [(state funcs consts counter)
     (state funcs (cons (closure-constant name fun-name) consts) counter)]))


(define (get-next-index [acc : State]) : (Tuple2 LiftedInt State)
  (case acc
    [(state funcs consts counter)
     (tuple2 (lifted-int counter) (state funcs consts (+ 1 counter)))]))

(define (create-static-info
          [name : ModName]
          [constants : (List i:ConstantDefinition)]
          [funcs : (List FunctionDefinition)]) : (Dict TopLevelName TopLevelSignature)
  (add-function-static-info
    name
    funcs
    (add-constants-static-info
      name
      constants
      (make-dict top-level-name-cmp))))

(define (add-constants-static-info
          [mod-name : ModName]
          [constants : (List i:ConstantDefinition)]
          [acc : (Dict TopLevelName TopLevelSignature)])
  : (Dict TopLevelName TopLevelSignature)
  (foldl
    (lambda ([const : i:ConstantDefinition] [acc : (Dict TopLevelName TopLevelSignature)])
      (case const
        [(closure-constant name fun-name)
         (dict-add acc (top-level-name mod-name name)
                   (top-level-signature (just (top-level-name mod-name fun-name)) (nothing)))]
        [(bytes-constant _ _)
         acc]
        [(trivial-variant-constant _ _)
         acc]))
    constants
    acc))

(define (add-function-static-info
          [mod-name : ModName]
          [funs : (List FunctionDefinition)]
          [acc : (Dict TopLevelName TopLevelSignature)]) : (Dict TopLevelName TopLevelSignature)
  (foldl
    (lambda ([f : FunctionDefinition] [acc : (Dict TopLevelName TopLevelSignature)])
      (case f
        [(function-definition _ _ _ _ _ _) acc]
        [(variant-constructor name (empty) _tag)
         (dict-add
           acc
           (top-level-name mod-name name)
           (top-level-signature
             (nothing)
             (just
               (zero-arg-constant-inlineable-function
                 (top-level-name
                   mod-name
                   (bytes-append (varargs list name #"_const")))))))]
        [(variant-constructor name _fields tag)
         (dict-add
           acc
           (top-level-name mod-name name)
           (top-level-signature
             (nothing)
             (just
               ;; TODO include the expected number of args
               (variant-constructor-inlineable-function tag)))) ]
        [(variant-accessor name offset)
         (dict-add
           acc
           (top-level-name mod-name name)
           (top-level-signature
             (nothing)
             (just
               (variant-accessor-inlineable-function offset))))]))
    funs
    acc))

(define (free-variables/expr [expr : Expression] [env : (Set Var)] [acc : (Set Var)])
  : (Set Var)
  (case expr
    [(int-literal _) acc]
    [(bytes-literal _) acc]
    [(boolean-literal _) acc]
    [(annotated-expr _ expr)
     (free-variables/expr expr env acc)]
    [(if-expr c t f)
     (free-variables/list (cons c (cons t (cons f (empty)))) env acc)]
    [(begin-expr es e)
     (free-variables/list (cons e es) env acc)]
    [(app-expr _ op args)
     (free-variables/list (cons op args) env acc)]
    [(varargs-app-expr _ op args)
     (free-variables/list (cons op args) env acc)]
    [(let-expr name expr body)
     (free-variables/expr body (set-add env name) (free-variables/expr expr env acc))]
    [(join-expr _) acc]
    [(join-point-expr _ expr body)
     (free-variables/list (varargs list expr body) env acc)]
    [(lambda-expr args+tys _ body)
     (free-variables/expr body (set-add-all env (map parse-arg-name args+tys)) acc)]
    [(halt-expr) acc]
    [(int-case-expr expr (int-case-clause _ body) (default-case-clause def))
     (free-variables/list (varargs list expr body def) env acc)]
    [(bytes-case-expr expr (bytes-case-clause _ body) (default-case-clause def))
     (free-variables/list (varargs list expr body def) env acc)]
    [(variant-case-expr expr clauses default)
     (match-define default-expr-list : (List Expression)
       (case default
         [(just (default-case-clause expr))
          (varargs list expr)]
         [(nothing) (empty)]))
     (free-variables/variant-case-clauses
       clauses env
       (free-variables/list (cons expr default-expr-list) env acc))]
    [(global-var-expr _) acc]
    [(local-var-expr v)
     (if (set-member? env v)
         acc
         (set-add acc v))]))

(define (free-variables/list
          [exprs : (List Expression)]
          [env : (Set Var)]
          [acc : (Set Var)]) : (Set Var)
  (case exprs
    [(empty) acc]
    [(cons expr exprs)
     (free-variables/list exprs env (free-variables/expr expr env acc))]))

(define (free-variables/variant-case-clauses
          [clauses : (List VariantCaseClause)]
          [env : (Set Var)]
          [acc : (Set Var)]) : (Set Var)
  (case clauses
    [(empty) acc]
    [(cons (variant-case-clause _sig fields body) clauses)
     (free-variables/variant-case-clauses
       clauses env
       (free-variables/expr body (set-add-all env fields) acc))]))
