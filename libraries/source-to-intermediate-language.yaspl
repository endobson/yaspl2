(module source-to-intermediate-language
  (import
    (prim
      #:types (Bytes)
      #:values (panic)
      #:patterns ())
    (bytes bytes-append)
    (list
      #:types (List)
      #:values (empty cons list)
      #:patterns (empty cons))
    (tuples
      #:types (Tuple2)
      #:values (tuple2)
      #:patterns (tuple2))
    (intermediate-language
      #:types
        ((Module i:Module)
         (FunctionDefinition i:FunctionDefinition)
         (Expression i:Expression)
         (CaseClause i:CaseClause))
      #:values
        ((module i:module)
         (function-definition i:function-definition)
         (byte-literal i:byte-literal)
         (bytes-literal i:bytes-literal)
         (boolean-literal i:boolean-literal)
         (local-var-expr i:local-var-expr)
         (if-expr i:if-expr)
         (begin-expr i:begin-expr)
         (create-closure-expr i:create-closure-expr)
         (call-closure-expr i:call-closure-expr)
         (varargs-call-closure-expr i:varargs-call-closure-expr)
         (let-expr i:let-expr)
         (case-expr i:case-expr)
         (case-clause i:case-clause))
      #:patterns ())
    (source-language
      #:types (Module FunctionDefinition Expression CaseClause)
      #:values ()
      #:patterns (module function-definition byte-literal bytes-literal
                  boolean-literal var-expr if-expr begin-expr lambda-expr
                  let-expr case-expr case-clause app-expr varargs-app-expr)))
  (export source->intermediate)
  (types)

  (define (source->intermediate [mod : Module]) : i:Module
    (case mod
      [(module name imports _ types definitions)
       (i:module
         name
         imports
         types
         (convert-function-definitions definitions (empty))
         (create-closures definitions (empty)))]))


  (define (create-closures
            [funs : (List FunctionDefinition)]
            [acc : (List (Tuple2 Bytes Bytes))]) : (List (Tuple2 Bytes Bytes))
    (case funs
      [(empty) acc]
      [(cons (function-definition name type args body) funs)
       (create-closures
         funs
         (cons (tuple2 (bytes-append (varargs list name #"-closure")) name) acc))]))

  (define (convert-function-definitions
            [funs : (List FunctionDefinition)]
            [acc : (List i:FunctionDefinition)]) : (List i:FunctionDefinition)
    (case funs
      [(empty) acc]
      [(cons fun funs)
       (convert-function-definitions funs (convert-function-definition fun acc))]))

  (define (convert-function-definition [fun : FunctionDefinition] [acc : (List i:FunctionDefinition)])
    : (List i:FunctionDefinition)
    (case fun
      [(function-definition name type args body)
       (case (convert-expression body acc)
         [(tuple2 i:body acc)
          (cons
            (i:function-definition name type args (empty) i:body)
            acc)])]))

  (define (convert-expression [expr : Expression] [acc : (List i:FunctionDefinition)])
    : (Tuple2 i:Expression (List i:FunctionDefinition))
    (case expr
      [(byte-literal v) (tuple2 (i:byte-literal v) acc)]
      [(bytes-literal v) (tuple2 (i:bytes-literal v) acc)]
      [(boolean-literal v) (tuple2 (i:boolean-literal v) acc)]
      ;; TODO handle this correctly
      [(var-expr v) (tuple2 (i:local-var-expr v) acc)]
      [(if-expr c t f)
       (case (convert-expression c acc)
         [(tuple2 ic acc)
          (case (convert-expression t acc)
            [(tuple2 it acc)
             (case (convert-expression f acc)
               [(tuple2 if acc)
                (tuple2 (i:if-expr ic it if) acc)])])])]
      [(begin-expr e es)
       (case (convert-expression e acc)
         [(tuple2 ie acc)
          (case (convert-expressions es acc)
            [(tuple2 ies acc)
             (tuple2 (i:begin-expr ie ies) acc)])])]
      [(let-expr name expr body)
       (case (convert-expression expr acc)
         [(tuple2 iexpr acc)
          (case (convert-expression body acc)
            [(tuple2 ibody acc)
             (tuple2 (i:let-expr name iexpr ibody) acc)])])]
      [(case-expr expr clauses)
       (case (convert-expression expr acc)
         [(tuple2 iexpr acc)
          (case (convert-clauses clauses acc)
            [(tuple2 iclauses acc)
             (tuple2 (i:case-expr iexpr iclauses) acc)])])]
      [(lambda-expr args+tys body)
       (case (convert-expression body acc)
         [(tuple2 ibody acc)
          (tuple2 (i:create-closure-expr (i:local-var-expr #"closure-name") (empty)) acc)])]
      [(app-expr op args)
       (case (convert-expression op acc)
         [(tuple2 iop acc)
          (case (convert-expressions args acc)
            [(tuple2 iargs acc)
             (tuple2 (i:call-closure-expr iop iargs) acc)])])]
      [(varargs-app-expr op args)
       (case (convert-expression op acc)
         [(tuple2 iop acc)
          (case (convert-expressions args acc)
            [(tuple2 iargs acc)
             (tuple2 (i:varargs-call-closure-expr iop iargs) acc)])])]))

  (define (convert-clause [clause : CaseClause] [acc : (List i:FunctionDefinition)])
    : (Tuple2 i:CaseClause (List i:FunctionDefinition))
    (case clause
      [(case-clause pat expr)
       (case (convert-expression expr acc)
         [(tuple2 iexpr acc)
          (tuple2 (i:case-clause pat iexpr) acc)])]))

  (define (convert-expressions [exprs : (List Expression)] [acc : (List i:FunctionDefinition)])
    : (Tuple2 (List i:Expression) (List i:FunctionDefinition))
    (case exprs
      [(empty) (tuple2 (empty) acc)]
      [(cons e es)
       (case (convert-expression e acc)
         [(tuple2 ie acc)
          (case (convert-expressions es acc)
            [(tuple2 ies acc)
             (tuple2 (cons ie ies) acc)])])]))

  (define (convert-clauses [clauses : (List CaseClause)] [acc : (List i:FunctionDefinition)])
    : (Tuple2 (List i:CaseClause) (List i:FunctionDefinition))
    (case clauses
      [(empty) (tuple2 (empty) acc)]
      [(cons c cs)
       (case (convert-clause c acc)
         [(tuple2 ic acc)
          (case (convert-clauses cs acc)
            [(tuple2 ics acc)
             (tuple2 (cons ic ics) acc)])])])))
