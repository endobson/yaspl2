(module source-to-intermediate-language
  (import
    (prim
      #:types (Byte Bytes)
      #:values (+)
      #:patterns ())
    (bytes bytes-append bytes=?)
    (list
      #:types (List)
      #:values (empty cons list map)
      #:patterns (empty cons))
    (dict
      #:types (Dict)
      #:values (dict-set make-dict dict-ref)
      #:patterns ())
    (maybe
      #:types (Maybe)
      #:values ()
      #:patterns (just nothing))
    (set
      #:types (Set)
      #:values (set->list set-remove-all)
      #:patterns ())
    (numbers integer->decimal-bytes)
    (tuples
      #:types (Tuple2)
      #:values (tuple2)
      #:patterns (tuple2))
    (free-variables free-variables)
    (intermediate-language
      #:types
        ((Module i:Module)
         (FunctionDefinition i:FunctionDefinition)
         (Expression i:Expression)
         (CaseClause i:CaseClause)
         ClosureConstant)
      #:values
        ((module i:module)
         (function-definition i:function-definition)
         (byte-literal i:byte-literal)
         (bytes-literal i:bytes-literal)
         (boolean-literal i:boolean-literal)
         (local-var-expr i:local-var-expr)
         (if-expr i:if-expr)
         (begin-expr i:begin-expr)
         (create-closure-expr i:create-closure-expr)
         (call-closure-expr i:call-closure-expr)
         (varargs-call-closure-expr i:varargs-call-closure-expr)
         (let-expr i:let-expr)
         (case-expr i:case-expr)
         (case-clause i:case-clause)
         closure-constant)
      #:patterns (closure-constant))
    (source-language
      #:types (Module FunctionDefinition Expression CaseClause PreType)
      #:values (var-pre-type)
      #:patterns (module function-definition byte-literal bytes-literal
                  boolean-literal var-expr if-expr begin-expr lambda-expr
                  let-expr case-expr case-clause app-expr varargs-app-expr)))
  (export source->intermediate)
  (types
    (define-type Environment
      (environment))
    (define-type State
      (state [funcs (List i:FunctionDefinition)] [counter Byte])))

  (define (source->intermediate [mod : Module]) : i:Module
    (case mod
      [(module name imports exports types definitions)
       (i:module
         name
         imports
         exports
         types
         (state-funcs
           (convert-function-definitions
             definitions
             (environment)
             (state (empty) 0)))
         (create-closures definitions (empty)))]))

  (define (create-closures
            [funs : (List FunctionDefinition)]
            [acc : (List ClosureConstant)]) : (List ClosureConstant)
    (case funs
      [(empty) acc]
      [(cons (function-definition name type args body) funs)
       (create-closures
         funs
         (cons (closure-constant name (bytes-append (varargs list name #"-code"))) acc))]))

  (define (convert-function-definitions
            [funs : (List FunctionDefinition)]
            [env : Environment]
            [acc : State]) : State
    (case funs
      [(empty) acc]
      [(cons fun funs)
       (convert-function-definitions funs env (convert-function-definition fun env acc))]))

  (define (convert-function-definition
            [fun : FunctionDefinition]
            [env : Environment]
            [acc : State])
    : State
    (case fun
      [(function-definition name type args body)
       (case (convert-expression body env acc)
         [(tuple2 i:body acc)
          (add-function
            (i:function-definition
              (bytes-append (varargs list name #"-code"))
              type args (empty) i:body)
            acc)])]))

  (define (parse-arg [arg+ty : (Tuple2 Bytes PreType)]) : Bytes
    (case arg+ty
      [(tuple2 arg ty) arg]))

  (define (convert-expression [expr : Expression] [env : Environment] [acc : State])
    : (Tuple2 i:Expression State)
    (case expr
      [(byte-literal v) (tuple2 (i:byte-literal v) acc)]
      [(bytes-literal v) (tuple2 (i:bytes-literal v) acc)]
      [(boolean-literal v) (tuple2 (i:boolean-literal v) acc)]
      ;; TODO handle this correctly
      [(var-expr v) (tuple2 (i:local-var-expr v) acc)]
      [(if-expr c t f)
       (case (convert-expression c env acc)
         [(tuple2 ic acc)
          (case (convert-expression t env acc)
            [(tuple2 it acc)
             (case (convert-expression f env acc)
               [(tuple2 if acc)
                (tuple2 (i:if-expr ic it if) acc)])])])]
      [(begin-expr e es)
       (case (convert-expression e env acc)
         [(tuple2 ie acc)
          (case (convert-expressions es env acc)
            [(tuple2 ies acc)
             (tuple2 (i:begin-expr ie ies) acc)])])]
      [(let-expr name expr body)
       (case (convert-expression expr env acc)
         [(tuple2 iexpr acc)
          (case (convert-expression body env acc)
            [(tuple2 ibody acc)
             (tuple2 (i:let-expr name iexpr ibody) acc)])])]
      [(case-expr expr clauses)
       (case (convert-expression expr env acc)
         [(tuple2 iexpr acc)
          (case (convert-clauses clauses env acc)
            [(tuple2 iclauses acc)
             (tuple2 (i:case-expr iexpr iclauses) acc)])])]
      [(lambda-expr args+tys body)
       (let ([args (map parse-arg args+tys)])
         (let ([fv (set-remove-all (free-variables body) args)])
           (case (convert-expression body env acc)
             [(tuple2 ibody acc)
              (case (get-next-index acc)
                [(tuple2 index acc)
                 (let ([closure-name
                         (bytes-append (cons #"lambda-" (cons (integer->decimal-bytes index) (empty))))])
                   ;; TODO use a real type
                   (tuple2
                     (i:create-closure-expr (i:local-var-expr closure-name)
                                            (map i:local-var-expr (set->list fv)))
                     (add-function
                       (i:function-definition
                         closure-name (var-pre-type #"bogus") args (set->list fv) ibody)
                       acc)))])])))]
      [(app-expr op args)
       (case (convert-expression op env acc)
         [(tuple2 iop acc)
          (case (convert-expressions args env acc)
            [(tuple2 iargs acc)
             (tuple2 (i:call-closure-expr iop iargs) acc)])])]
      [(varargs-app-expr op args)
       (case (convert-expression op env acc)
         [(tuple2 iop acc)
          (case (convert-expressions args env acc)
            [(tuple2 iargs acc)
             (tuple2 (i:varargs-call-closure-expr iop iargs) acc)])])]))

  (define (convert-clause [clause : CaseClause] [env : Environment] [acc : State])
    : (Tuple2 i:CaseClause State)
    (case clause
      [(case-clause pat expr)
       (case (convert-expression expr env acc)
         [(tuple2 iexpr acc)
          (tuple2 (i:case-clause pat iexpr) acc)])]))

  (define (convert-expressions
            [exprs : (List Expression)]
            [env : Environment]
            [acc : State])
    : (Tuple2 (List i:Expression) State)
    (case exprs
      [(empty) (tuple2 (empty) acc)]
      [(cons e es)
       (case (convert-expression e env acc)
         [(tuple2 ie acc)
          (case (convert-expressions es env acc)
            [(tuple2 ies acc)
             (tuple2 (cons ie ies) acc)])])]))

  (define (convert-clauses
            [clauses : (List CaseClause)]
            [env : Environment]
            [acc : State])
    : (Tuple2 (List i:CaseClause) State)
    (case clauses
      [(empty) (tuple2 (empty) acc)]
      [(cons c cs)
       (case (convert-clause c env acc)
         [(tuple2 ic acc)
          (case (convert-clauses cs env acc)
            [(tuple2 ics acc)
             (tuple2 (cons ic ics) acc)])])]))

  (define (add-function [func : i:FunctionDefinition] [acc : State]) : State
    (case acc
      [(state funcs counter)
       (state (cons func funcs) counter)]))

  (define (get-next-index [acc : State]) : (Tuple2 Byte State)
    (case acc
      [(state funcs counter)
       (tuple2 counter (state funcs (+ 1 counter)))])))
