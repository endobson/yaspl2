#:module (os msabi)
#:import {
  (join-list)
  (list)
  (prim)
  (yaspl x86-64-assembly)
}
(export
  (#:values make-function-fragments make-data-fragments))
(types)


(define (make-function-fragments) : (List TextFragment)
  (varargs list
    (function-fragment
      #"call_ms0"
      (varargs append-jl*
        (named-block #"call_ms0_0"
          (varargs join-list
            (pushq (r64mi-reg (rbp)))
            (movq (r64mi-reg (rsp)) (r64m-reg (rbp)))
            ;; Shadow space
            (subq (imm64/s32 32) (rsp))
            (call/indirect (r64m-reg (rdi)))
            (addq (imm64/s32 32) (r64m-reg (rsp)))

            (popq (r64m-reg (rbp)))
            (ret)))))

    (function-fragment
      #"call_ms1"
      (varargs append-jl*
        (named-block #"call_ms1_0"
          (varargs join-list
            (pushq (r64mi-reg (rbp)))
            (movq (r64mi-reg (rsp)) (r64m-reg (rbp)))
            ;; Shadow space
            (subq (imm64/s32 32) (rsp))
            (movq (r64mi-reg (rsi)) (r64m-reg (rcx)))
            (call/indirect (r64m-reg (rdi)))
            (addq (imm64/s32 32) (r64m-reg (rsp)))

            (popq (r64m-reg (rbp)))
            (ret)))))

    (function-fragment
      #"call_ms2"
      (varargs append-jl*
        (named-block #"call_ms2_0"
          (varargs join-list
            (pushq (r64mi-reg (rbp)))
            (movq (r64mi-reg (rsp)) (r64m-reg (rbp)))
            ;; Shadow space
            (subq (imm64/s32 32) (rsp))
            (movq (r64mi-reg (rsi)) (r64m-reg (rcx)))
            ; This happens to be a noop.
            ; (movq (r64mi-reg (rdx)) (r64m-reg (rdx)))
            (call/indirect (r64m-reg (rdi)))
            (addq (imm64/s32 32) (r64m-reg (rsp)))

            (popq (r64m-reg (rbp)))
            (ret)))))


    (function-fragment
      #"call_ms5"
      (varargs append-jl*
        (named-block #"call_ms5_0"
          (varargs join-list
            (pushq (r64mi-reg (rbp)))
            (movq (r64mi-reg (rsp)) (r64m-reg (rbp)))
            ;; Do arguments in reverse order to avoid overwriting.
            (pushq (imm64/s32 0))                       ;; Padding to keep 16 byte aligned
            (pushq (r64mi-reg (r9)))                    ;; Argument 5
            ;; Shadow space
            (subq (imm64/s32 32) (rsp))
            (movq (r64mi-reg (r8)) (r64m-reg (r9)))     ;; Argument 4
            (movq (r64mi-reg (rcx)) (r64m-reg (r8)))    ;; Argument 3
            ; This happens to be a noop.
            ; (movq (r64mi-reg (rdx)) (r64m-reg (rdx))) ;; Argument 2
            (movq (r64mi-reg (rsi)) (r64m-reg (rcx)))   ;; Argument 1
            (call/indirect (r64m-reg (rdi)))
            (addq (imm64/s32 48) (r64m-reg (rsp)))

            (popq (r64m-reg (rbp)))
            (ret)))))



    (function-fragment
      #"call_sysv0"
      (varargs append-jl*
        (named-block #"call_sysv0_0"
          (varargs join-list
            (pushq (r64mi-reg (rbp)))
            (movq (r64mi-reg (rsp)) (r64m-reg (rbp)))
            ;; Save RDI and RSI
            (pushq (r64mi-reg (rdi)))
            (pushq (r64mi-reg (rsi)))
            (call/indirect (r64m-reg (rcx)))
            (popq (r64m-reg (rsi)))
            (popq (r64m-reg (rdi)))

            (popq (r64m-reg (rbp)))
            (ret)))))


    (function-fragment
      #"call_sysv1"
      (varargs append-jl*
        (named-block #"call_sysv1_0"
          (varargs join-list
            (pushq (r64mi-reg (rbp)))
            (movq (r64mi-reg (rsp)) (r64m-reg (rbp)))
            ;; Save RDI and RSI
            (pushq (r64mi-reg (rdi)))
            (pushq (r64mi-reg (rsi)))
            (movq (r64mi-reg (rdx)) (r64m-reg (rdi)))
            (call/indirect (r64m-reg (rcx)))
            (popq (r64m-reg (rsi)))
            (popq (r64m-reg (rdi)))

            (popq (r64m-reg (rbp)))
            (ret)))))

    (function-fragment
      #"call_sysv2"
      (varargs append-jl*
        (named-block #"call_sysv2_0"
          (varargs join-list
            (pushq (r64mi-reg (rbp)))
            (movq (r64mi-reg (rsp)) (r64m-reg (rbp)))
            ;; Save RDI and RSI
            (pushq (r64mi-reg (rdi)))
            (pushq (r64mi-reg (rsi)))
            (movq (r64mi-reg (rdx)) (r64m-reg (rdi)))
            (movq (r64mi-reg (r8)) (r64m-reg (rsi)))
            (call/indirect (r64m-reg (rcx)))
            (popq (r64m-reg (rsi)))
            (popq (r64m-reg (rdi)))

            (popq (r64m-reg (rbp)))
            (ret)))))


    ))

(define (make-data-fragments) : (List ConstFragment)
  (varargs list
    ;; TODO Make this less hacky
    (const-fragment
      #"call_ms0c" 3
      (varargs list
        (bytes-fragment (make-bytes 8))
        (address-fragment #"call_ms0" 0)))
    (const-fragment
      #"call_ms1c" 3
      (varargs list
        (bytes-fragment (make-bytes 8))
        (address-fragment #"call_ms1" 0)))
    (const-fragment
      #"call_ms2c" 3
      (varargs list
        (bytes-fragment (make-bytes 8))
        (address-fragment #"call_ms2" 0)))
    (const-fragment
      #"call_ms5c" 3
      (varargs list
        (bytes-fragment (make-bytes 8))
        (address-fragment #"call_ms5" 0)))
    (const-fragment
      #"yprim_trivial_closure_variant_descriptor" 8
      (varargs list (bytes-fragment (make-bytes 8))))
    (const-fragment
      #"yprim_bytes_variant_descriptor" 8
      (varargs list (bytes-fragment (make-bytes 8))))))
