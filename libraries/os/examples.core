#:module (os)

#:declare_external call_ms0c (U64 -> U64)
#:declare_external call_ms1c (U64, U64 -> U64)
#:declare_external call_ms2c (U64, U64, U64 -> U64)
#:declare_external call_ms5c (U64, U64, U64, U64, U64, U64 -> U64)
#:declare_external read_serial U64
#:declare_external write_serial U64

// External functions for interrupts
#:declare_external irqfun_com1 U64
#:declare_external irqfun_nic U64
#:declare_external irqfun_default U64

#:define_function
U64 a(U64 arg, U64 arg2, U64 arg3, U64 arg4) {
  return arg4 + 7;
}

#:define_function
U64 g(U64 arg, U64 arg2) {
  return arg2;
}

#:define_function
U64 write_bytes(Bytes bytes) {
  U64[]* bytes_ptr := as<U64[]*>(bytes);
  U64 size := bytes_ptr->[1];
  U64 index := 0;
  while (index < size) {
    U64 base := as<U64>(bytes_ptr->&[2]);
    U64* addr := as<U64*>(base + index);
    U64 value := (*addr) & #xff;
    <> call_ms1c(write_serial, value);
    index := index + 1;
  }
  return 0;
}

#:define_function
U64 write_hex_byte(U64 byte) {
  <> call_ms1c(write_serial, nibble_to_hex((byte / 16) & #x0f));
  <> call_ms1c(write_serial, nibble_to_hex(byte & #x0f));
  return 0;
}


#:define_function
U64 nibble_to_hex(U64 v) {
  if (v < 10) {
    return 48 + v;
  } else {
    return 87 + v;
  }
}

#:define_global U64 serial_counter

#:define_function
U64 serialTaskStart(U64 arg, U64 arg2, U64 arg3, U64 arg4) {
  while (1 > 0) {
    U64 v := call_ms0c(read_serial);
    <> write_bytes(#"SerialInput (");
    <> write_hex_byte(*serial_counter);
    <> write_bytes(#"): ");
    <> write_hex_byte(v);
    <> write_bytes(#"\n");
    *serial_counter <- (*serial_counter) + 1;
  }
}

#:define_function
U64 welcomeMessage() {
  <> write_bytes(#"\x1bc");
  <> write_bytes(#"Welcome to Yaspl OS.\r\n");
  return 0;
}


#:define_function
U64 memset(U8[]* memory, U8 value, U64 size) {
  U64 index := 0;
  while (index < size) {
    *memory->&[index] <- value;
    index := index + 1;
  }
  return 0;
}

#:define_struct EfiHandle {}

#:define_struct EfiTableHeader {
  U32 signature;
  U32 revision;
  U32 header_size;
  U32 crc32;
  U32 reserved1;
}

#:define_struct EfiRuntimeServices {}

#:define_struct EfiUnknown {}

#:define_struct EfiBootServices {
    EfiTableHeader Hdr;
    U32 padding1;
    EfiUnknown*    RaiseTPL;
    EfiUnknown*    RestoreTPL;
    EfiUnknown*    AllocatePages;
    EfiUnknown*    FreePages;
    U64            GetMemoryMap;
    U64            AllocatePool;
    EfiUnknown*    FreePool;
    EfiUnknown*    CreateEvent;
    EfiUnknown*    SetTimer;
    EfiUnknown*    WaitForEvent;
    EfiUnknown*    SignalEvent;
    EfiUnknown*    CloseEvent;
    EfiUnknown*    CheckEvent;
    EfiUnknown*    InstallProtocolInterface;
    EfiUnknown*    ReinstallProtocolInterface;
    EfiUnknown*    UninstallProtocolInterface;
    EfiUnknown*    HandleProtocol;
    EfiUnknown*    Reserved;
    EfiUnknown*    RegisterProtocolNotify;
    EfiUnknown*    LocateHandle;
    EfiUnknown*    LocateDevicePath;
    EfiUnknown*    InstallConfigurationTable;
    EfiUnknown*    LoadImage;
    EfiUnknown*    StartImage;
    EfiUnknown*    Exit;
    EfiUnknown*    UnloadImage;
    U64            ExitBootServices;


}

#:define_struct EfiSystemTable {
  EfiTableHeader header;
  U32 padding1;
  U16* firmware_vendor;
  U32 firmware_revision;
  U32 padding2;
  EfiHandle* console_in_handle;
  U64* console_in;
  EfiHandle* console_out_handle;
  EfiSimpleTextOutputProtocol* console_out;
  EfiHandle* console_err_handle;
  EfiSimpleTextOutputProtocol* console_err;
  EfiRuntimeServices* runtime_services;
  EfiBootServices* boot_services;
}

#:define_struct EfiTextString {}

#:define_struct EfiSimpleTextOutputProtocol {
  U64* reset;
  EfiTextString* output_string;
}

#:define_struct EfiMemoryMap {}

#:define_global U64 efi_memory_map_size
#:define_global U8[4096] efi_memory_map_space
#:define_global U64 efi_memory_map_key
#:define_global U64 efi_memory_descriptor_size
#:define_global U32 efi_memory_descriptor_version

#:define_global U8[4096] efi_output_buffer
#:define_global U8*      efi_writer

#:define_function
U64 reset_efi_writer() {
  *efi_writer <- efi_output_buffer->&[0];
  return 0;
}

#:define_function
U64 terminate_efi_writer() {
  return efi_writer_add_byte(as<U8>(0));
}

#:define_function
U64 efi_writer_add_byte(U8 v) {
  *(*efi_writer) <- v;
  *efi_writer <- as<U8*>(as<U64>(*efi_writer) + 2);
  return 0;
}

#:define_function
U64 efi_writer_add_hex_U8(U8 byte) {
  <> efi_writer_add_byte(as<U8>(nibble_to_hex((as<U64>(byte) / 16) & #x0f)));
  <> efi_writer_add_byte(as<U8>(nibble_to_hex(as<U64>(byte) & #x0f)));
  return 0;
}

#:define_function
U64 efi_writer_add_hex_U64(U64 v) {
  // <> efi_writer_add_hex_U8(as<U8>(nibble_to_hex((v / 268435456) & #x0f)));
  // <> efi_writer_add_hex_U8(as<U8>(nibble_to_hex((v /  16777216) & #x0f)));
  // <> efi_writer_add_hex_U8(as<U8>(nibble_to_hex((v /   1048576) & #x0f)));
  // <> efi_writer_add_hex_U8(as<U8>(nibble_to_hex((v /     65536) & #x0f)));
  // <> efi_writer_add_hex_U8(as<U8>(nibble_to_hex((v /      4096) & #x0f)));
  // <> efi_writer_add_hex_U8(as<U8>(nibble_to_hex((v /       256) & #x0f)));
  // <> efi_writer_add_hex_U8(as<U8>(nibble_to_hex((v /        16) & #x0f)));
  // <> efi_writer_add_hex_U8(as<U8>(nibble_to_hex((v /         1) & #x0f)));
  <> efi_writer_add_hex_U8(as<U8>(((v /  16777216) /  16777216) & #xff));
  <> efi_writer_add_hex_U8(as<U8>(((v /  16777216) /     65536) & #xff));
  <> efi_writer_add_hex_U8(as<U8>(((v /  16777216) /       256) & #xff));
  <> efi_writer_add_hex_U8(as<U8>(((v /  16777216) /         1) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v /   16777216) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v /      65536) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v /        256) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v /          1) & #xff));
  return 0;
}



#:define_function
U64 exitBootServices(U64 image_handle, EfiSystemTable* st) {
  EfiSimpleTextOutputProtocol* output := st->console_out;

  *efi_memory_map_size <- 4096;
  U64 status := call_ms5c((st->boot_services)->GetMemoryMap,
                          as<U64>(efi_memory_map_size),
                          as<U64>(efi_memory_map_space),
                          as<U64>(efi_memory_map_key),
                          as<U64>(efi_memory_descriptor_size),
                          as<U64>(efi_memory_descriptor_version));
  if (status != 0) {
    <> reset_efi_writer();
    <> efi_writer_add_hex_U64(status);
    <> efi_writer_add_byte(as<U8>(#x0d));
    <> efi_writer_add_byte(as<U8>(#x0a));
    <> terminate_efi_writer();
    <> call_ms2c(as<U64>(output->output_string), as<U64>(output), as<U64>(efi_output_buffer));
    return status;
  }

  status := call_ms2c((st->boot_services)->ExitBootServices, image_handle, *efi_memory_map_key);
  if (status != 0) {
    <> reset_efi_writer();
    <> efi_writer_add_hex_U64(status);
    <> efi_writer_add_byte(as<U8>(#x0d));
    <> efi_writer_add_byte(as<U8>(#x0a));
    <> terminate_efi_writer();
    <> call_ms2c(as<U64>(output->output_string), as<U64>(output), as<U64>(efi_output_buffer));
    return status;
  }

  return 0;
}

#:define_struct IdtEntry {
  U16 offset_1;  // offset bits 0..15
  U16 selector;  // a code segment selector in GDT or LDT
  U8  ist;       // bits 0..2 holds Interrupt Stack Table offset, rest of bits zero.
  U8  type_attr; // type and attributes
  U16 offset_2;  // offset bits 16..31
  U32 offset_3;  // offset bits 32..63
  U32 zero;      // reserved
}

#:define_struct IdtDescriptor {
  U16 limit;
  U64 base_address;
}

#:define_global IdtEntry[256] idt_entries
#:define_global IdtDescriptor idt_descriptor


#:define_function
U64 initializeIdt() {
  <> write_bytes(#"IDT code\r\n");
  U64 idt_entry_size := 16;
  <> memset(as<U8[]*>(idt_entries), as<U8>(0), idt_entry_size * 256);
  U64 i := 0;
  while (i < 256) {
    U64 irq_addr := irqfun_default;
    // if (i == 36) {
    //   irq_addr := irqfun_com1;
    // } else if (i == 43) {
    //   irq_addr := irqfun_nic;
    // } else {
    //   irq_addr := irqfun_default;
    // }

    // *(idt_entries->&[i])->&offset_1 <- as<U16>(irq_addr & #xffff);
    //idt_entries[i].selector = 0x38;
    *(idt_entries->&[i])->&ist <- as<U8>(0);
    //idt_entries[i].type_attr = 0x8e;
    //idt_entries[i].offset_2 = (irq_addr >> 16) & 0xffff;
    //idt_entries[i].offset_3 = irq_addr >> 32;
    //idt_entries[i].zero = 0;
    i := i + 1;
  }
//
//  idt_descr.limit = sizeof(IDTEntry) * 256 - 1;
//  idt_descr.base_addr = (uint64_t) &idt_entries;
//  load_idt(&idt_descr);

  return 0;
}
