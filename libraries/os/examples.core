#:module (os)

#:declare_external call_ms0c (U64 -> U64)
#:declare_external call_ms1c (U64, U64 -> U64)
#:declare_external call_ms2c (U64, U64, U64 -> U64)
#:declare_external call_ms5c (U64, U64, U64, U64, U64, U64 -> U64)

// External functions for interrupts
#:declare_external y_irqfun_com1 U64
#:declare_external y_irqfun_nic U64
#:declare_external y_irqfun_default U64
#:declare_external y_lidtc (U64 -> U64)
#:declare_external y_outbc (U8, U16 -> U64)
#:declare_external y_outwc (U16, U16 -> U64)
#:declare_external y_outdc (U32, U16 -> U64)
#:declare_external y_inbc (U16 -> U8)
#:declare_external y_inwc (U16 -> U16)
#:declare_external y_indc (U16 -> U32)
#:declare_external y_panicc (-> U64)

#:declare_external enable_interruptsc (-> U64)
#:declare_external enable_interrupts_and_haltc (-> U64)
#:declare_external disable_interruptsc (-> U64)
#:declare_external y_switch_to_taskc (TaskDescriptor*, TaskDescriptor* -> U64)

// External datastructures for network
#:declare_external net_send_queue VirtioQueue256*
#:declare_external net_recv_queue VirtioQueue256*

#:declare_external net_send_buffers VirtioBuffer[]*
#:declare_external net_recv_buffers VirtioBuffer[]*

// External datastructures for tasks
#:declare_external serial_task_stack U8[]*
#:declare_external network_task_stack U8[]*



#:define_function
U64 a(U64 arg, U64 arg2, U64 arg3, U64 arg4) {
  return arg4 + 7;
}

#:define_function
U64 g(U64 arg, U64 arg2) {
  return arg2;
}

#:define_function
Boolean is_transmit_empty() {
  // #x3F8 is SERIAL_COM1_BASE
  U64 port := #x3F8;
  U64 result := as<U64>(y_inbc(as<U16>(port + 5)));
  return (result & #x20) != 0;
}

#:define_function
U64 write_serial(U8 v) {
  // #x3F8 is SERIAL_COM1_BASE
  U64 port := #x3F8;

  while (!is_transmit_empty()) {
    // Busy Loop
  }

  <> y_outbc(v, as<U16>(port));
  return 0;
}


#:define_function
U64 write_bytes(Bytes bytes) {
  U64[]* bytes_ptr := as<U64[]*>(bytes);
  U64 size := bytes_ptr->[1];
  U64 index := 0;
  while (index < size) {
    U64 base := as<U64>(bytes_ptr->&[2]);
    U64* addr := as<U64*>(base + index);
    U64 value := (*addr) & #xff;
    <> write_serial(as<U8>(value));
    index := index + 1;
  }
  return 0;
}


#:define_function
U8 nibble_to_hex(U64 v) {
  if (v < 10) {
    return as<U8>(48 + v);
  } else {
    return as<U8>(87 + v);
  }
}

#:define_function
U64 write_hex_byte(U8 b) {
  U64 v := as<U64>(b);
  <> write_serial(nibble_to_hex((v >> 4) & #x0f));
  <> write_serial(nibble_to_hex(v & #x0f));
  return 0;
}

#:define_function
U64 write_hex_U64(U64 v) {
  <> write_hex_byte(as<U8>((v >> 56) & #xff));
  <> write_hex_byte(as<U8>((v >> 48) & #xff));
  <> write_hex_byte(as<U8>((v >> 40) & #xff));
  <> write_hex_byte(as<U8>((v >> 32) & #xff));
  <> write_hex_byte(as<U8>((v >> 24) & #xff));
  <> write_hex_byte(as<U8>((v >> 16) & #xff));
  <> write_hex_byte(as<U8>((v >>  8) & #xff));
  <> write_hex_byte(as<U8>((v >>  0) & #xff));
  return 0;
}


#:define_function
Boolean serial_received() {
  // #x3F8 is SERIAL_COM1_BASE
  U64 port := #x3F8;
  U64 result := as<U64>(y_inbc(as<U16>(port + 5)));
  return (result & 1) != 0;
}

#:define_function
U8 read_serial() {

 if (!serial_received()) {
   <> disable_interruptsc();
   while (!serial_received()) {
      <> yield(as<U32>(1)); // Blocked
   }
   <> enable_interruptsc();
 }

 // #x3F8 is SERIAL_COM1_BASE
 U64 port := #x3F8;
 return y_inbc(as<U16>(port));
}


#:define_global U8 serial_counter

#:define_function
U64 serialTaskStart() {
  while (1 > 0) {
    U8 v := read_serial();
    <> write_bytes(#"SerialInput (");
    <> write_hex_byte(*serial_counter);
    <> write_bytes(#"): ");
    <> write_hex_byte(v);
    <> write_bytes(#"\n");
    *serial_counter <- as<U8>(as<U64>(*serial_counter) + 1);
  }
}


#:define_function
U64 networkTaskStart() {
  while (1 > 0) {
    <> waitNetworkInterrupt();
  }
}

#:define_function
U64 welcomeMessage() {
  <> write_bytes(#"\x1bc");
  <> write_bytes(#"Welcome to Yaspl OS.\r\n");
  return 0;
}


#:define_function
U64 memset(U8[]* memory, U8 value, U64 size) {
  U64 index := 0;
  while (index < size) {
    *memory->&[index] <- value;
    index := index + 1;
  }
  return 0;
}

#:define_struct EfiHandle {}

#:define_struct EfiTableHeader {
  U32 signature;
  U32 revision;
  U32 header_size;
  U32 crc32;
  U32 reserved1;
}

#:define_struct EfiRuntimeServices {}

#:define_struct EfiUnknown {}

#:define_struct EfiBootServices {
    EfiTableHeader Hdr;
    U32 padding1;
    EfiUnknown*    RaiseTPL;
    EfiUnknown*    RestoreTPL;
    EfiUnknown*    AllocatePages;
    EfiUnknown*    FreePages;
    U64            GetMemoryMap;
    U64            AllocatePool;
    EfiUnknown*    FreePool;
    EfiUnknown*    CreateEvent;
    EfiUnknown*    SetTimer;
    EfiUnknown*    WaitForEvent;
    EfiUnknown*    SignalEvent;
    EfiUnknown*    CloseEvent;
    EfiUnknown*    CheckEvent;
    EfiUnknown*    InstallProtocolInterface;
    EfiUnknown*    ReinstallProtocolInterface;
    EfiUnknown*    UninstallProtocolInterface;
    EfiUnknown*    HandleProtocol;
    EfiUnknown*    Reserved;
    EfiUnknown*    RegisterProtocolNotify;
    EfiUnknown*    LocateHandle;
    EfiUnknown*    LocateDevicePath;
    EfiUnknown*    InstallConfigurationTable;
    EfiUnknown*    LoadImage;
    EfiUnknown*    StartImage;
    EfiUnknown*    Exit;
    EfiUnknown*    UnloadImage;
    U64            ExitBootServices;


}

#:define_struct EfiSystemTable {
  EfiTableHeader header;
  U32 padding1;
  U16* firmware_vendor;
  U32 firmware_revision;
  U32 padding2;
  EfiHandle* console_in_handle;
  U64* console_in;
  EfiHandle* console_out_handle;
  EfiSimpleTextOutputProtocol* console_out;
  EfiHandle* console_err_handle;
  EfiSimpleTextOutputProtocol* console_err;
  EfiRuntimeServices* runtime_services;
  EfiBootServices* boot_services;
}

#:define_struct EfiTextString {}

#:define_struct EfiSimpleTextOutputProtocol {
  U64* reset;
  EfiTextString* output_string;
}

#:define_struct EfiMemoryMap {}

#:define_global U64 efi_memory_map_size
#:define_global U8[4096] efi_memory_map_space
#:define_global U64 efi_memory_map_key
#:define_global U64 efi_memory_descriptor_size
#:define_global U32 efi_memory_descriptor_version

#:define_global U8[4096] efi_output_buffer
#:define_global U8*      efi_writer

#:define_function
U64 reset_efi_writer() {
  *efi_writer <- efi_output_buffer->&[0];
  return 0;
}

#:define_function
U64 terminate_efi_writer() {
  return efi_writer_add_byte(as<U8>(0));
}

#:define_function
U64 efi_writer_add_byte(U8 v) {
  *(*efi_writer) <- v;
  *efi_writer <- as<U8*>(as<U64>(*efi_writer) + 2);
  return 0;
}

#:define_function
U64 efi_writer_add_hex_U8(U8 byte) {
  <> efi_writer_add_byte(nibble_to_hex((as<U64>(byte) >> 4) & #x0f));
  <> efi_writer_add_byte(nibble_to_hex(as<U64>(byte) & #x0f));
  return 0;
}

#:define_function
U64 efi_writer_add_hex_U64(U64 v) {
  <> efi_writer_add_hex_U8(as<U8>((v >> 56) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v >> 48) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v >> 40) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v >> 32) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v >> 24) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v >> 16) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v >>  8) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v >>  0) & #xff));
  return 0;
}



#:define_function
U64 exitBootServices(U64 image_handle, EfiSystemTable* st) {
  EfiSimpleTextOutputProtocol* output := st->console_out;

  *efi_memory_map_size <- 4096;
  U64 status := call_ms5c((st->boot_services)->GetMemoryMap,
                          as<U64>(efi_memory_map_size),
                          as<U64>(efi_memory_map_space),
                          as<U64>(efi_memory_map_key),
                          as<U64>(efi_memory_descriptor_size),
                          as<U64>(efi_memory_descriptor_version));
  if (status != 0) {
    <> reset_efi_writer();
    <> efi_writer_add_hex_U64(status);
    <> efi_writer_add_byte(as<U8>(#x0d));
    <> efi_writer_add_byte(as<U8>(#x0a));
    <> terminate_efi_writer();
    <> call_ms2c(as<U64>(output->output_string), as<U64>(output), as<U64>(efi_output_buffer));
    return status;
  }

  status := call_ms2c((st->boot_services)->ExitBootServices, image_handle, *efi_memory_map_key);
  if (status != 0) {
    <> reset_efi_writer();
    <> efi_writer_add_hex_U64(status);
    <> efi_writer_add_byte(as<U8>(#x0d));
    <> efi_writer_add_byte(as<U8>(#x0a));
    <> terminate_efi_writer();
    <> call_ms2c(as<U64>(output->output_string), as<U64>(output), as<U64>(efi_output_buffer));
    return status;
  }

  return 0;
}

#:define_struct IdtEntry {
  U16 offset_1;  // offset bits 0..15
  U16 selector;  // a code segment selector in GDT or LDT
  U8  ist;       // bits 0..2 holds Interrupt Stack Table offset, rest of bits zero.
  U8  type_attr; // type and attributes
  U16 offset_2;  // offset bits 16..31
  U32 offset_3;  // offset bits 32..63
  U32 zero;      // reserved
}

#:define_struct IdtDescriptor {
  U16 limit;
  U64 base_address;
}

#:define_global IdtEntry[256] idt_entries
#:define_global IdtDescriptor idt_descriptor


#:define_function
U64 initializeIdt() {
  <> write_bytes(#"IDT code\r\n");
  U64 idt_entry_size := 16;
  <> memset(as<U8[]*>(idt_entries), as<U8>(0), idt_entry_size * 256);
  U64 i := 0;
  while (i < 256) {
    U64 irq_addr := y_irqfun_default;
    if (i == 36) {
      irq_addr := y_irqfun_com1;
    } else if (i == 43) {
      irq_addr := y_irqfun_nic;
    }

    *(idt_entries->&[i])->&offset_1 <- as<U16>(irq_addr & #xffff);
    *(idt_entries->&[i])->&selector <- as<U16>(#x38);
    *(idt_entries->&[i])->&ist <- as<U8>(0);
    *(idt_entries->&[i])->&type_attr <- as<U8>(#x8e);
    *(idt_entries->&[i])->&offset_2 <- as<U16>((irq_addr >> 16) & #xffff);
    *(idt_entries->&[i])->&offset_3 <- as<U32>(irq_addr >> 32);
    *(idt_entries->&[i])->&zero <- as<U32>(0);
    i := i + 1;
  }

  *idt_descriptor->&limit <- as<U16>(idt_entry_size * 256 - 1);
  *idt_descriptor->&base_address <- as<U64>(idt_entries);
  <> y_lidtc(as<U64>(idt_descriptor));
  <> write_bytes(#"IDT code done\r\n");
  return 0;
}

#:define_function
U64 initializeSerial() {
  <> write_bytes(#"Serial code\r\n");

  // #x3F8 is SERIAL_COM1_BASE
  U64 port := #x3F8;

  // Disable all interrupts on the port while setup happens
  <> y_outbc(as<U8>(#x00), as<U16>(port + 1));
  // Enable the DLAB. This changes the meaning of ports 0/1 which allows
  // setting the baud rate divisor.
  <> y_outbc(as<U8>(#x80), as<U16>(port + 3));
  // Set divisor to 3 (low byte) 38400 baud
  <> y_outbc(as<U8>(#x03), as<U16>(port + 0));
  <> y_outbc(as<U8>(#x00), as<U16>(port + 1));

  // Clear the DLAB, and set the protcol as:
  // 8 bits, no parity, one stop bit
  <> y_outbc(as<U8>(#x03), as<U16>(port + 3));
  // Don't set FIFOs as they don't seem to do anything in QEMU.
  // Enable IRQs on Receive.
  <> y_outbc(as<U8>(#x01), as<U16>(port + 1));

  <> write_bytes(#"Serial code done\r\n");
  return 0;
}

#:define_function
U64 initializePic() {
  <> write_bytes(#"PIC code\r\n");

  // Base port numbers for the Master/Slave PICs.
  U64 pic1 := #x20;
  U64 pic2 := #xA0;
  // Command and data port numbers
  U64 pic1_command := pic1 + 0;
  U64 pic1_data    := pic1 + 1;
  U64 pic2_command := pic2 + 0;
  U64 pic2_data    := pic2 + 1;

  U64 icw1_init := #x10; // This is an initialization command
  U64 icw1_icw4 := #x01; // This initialization uses command word 4
  // Start the initialization sequence (in cascade mode)
  <> y_outbc(as<U8>(icw1_init | icw1_icw4), as<U16>(pic1_command));
  <> y_outbc(as<U8>(icw1_init | icw1_icw4), as<U16>(pic2_command));

  // Set the PICs to use the entries in the IDT range [32, 47).
  U64 offset1 := 32;
  U64 offset2 := 40;
  <> y_outbc(as<U8>(offset1), as<U16>(pic1_data));    // ICW2: Master PIC vector offset
  <> y_outbc(as<U8>(offset2), as<U16>(pic2_data));    // ICW2: Slave PIC vector offset
  // ICW3: tell Master PIC that there is a slave PIC at IRQ2 (0b00000100)
  <> y_outbc(as<U8>(#x04), as<U16>(pic1_data));
  <> y_outbc(as<U8>(#x02), as<U16>(pic2_data));  // ICW3: tell Slave PIC its cascade identity

  // // Set 8086 mode
  U64 icw4_8086 := #x01;
  <> y_outbc(as<U8>(icw4_8086), as<U16>(pic1_data));
  <> y_outbc(as<U8>(icw4_8086), as<U16>(pic2_data));

  // Only enable some interrupts.
  // PIC 1, bit 2: Allow PIC2 through
  // PIC 1, bit 4: COM1 serial port
  U64 pic1_interrupts := #xEB; // ~((1 << 2) | (1 << 4));
  // // PIC 2, bit 3: NIC
  U64 pic2_interrupts := #xF7; // ~(1 << 3);
  // Mask all interrupts that shouldn't be enabled.
  <> y_outbc(as<U8>(pic1_interrupts), as<U16>(pic1_data));
  <> y_outbc(as<U8>(pic2_interrupts), as<U16>(pic2_data));


  <> write_bytes(#"PIC code done\r\n");
  return 0;
}

#:define_struct VirtioQueue256BufferInfo {
  U64 address;
  U32 length;
  U16 flags;
  U16 next;
}

#:define_struct VirtioQueue256AvailableInfo {
  U16 flags;
  U16 index;
  U16[256] ring;
  U16 event_index;
}

#:define_struct VirtioQueue256UsedRingInfo {
  U32 index;
  U32 length;
}

#:define_struct VirtioQueue256UsedInfo {
  U16 flags;
  U16 index;
  VirtioQueue256UsedRingInfo[256] ring;
  U16 avail_event;
}

#:define_struct VirtioQueue256 {
  VirtioQueue256BufferInfo[256] buffers;
  VirtioQueue256AvailableInfo available;
  U8[3578] padding;
  VirtioQueue256UsedInfo used;
}



#:define_struct VirtioBuffer {
  U8[4096] bytes;
}

#:define_function
U64 initializeNetwork() {
  <> write_bytes(#"Network code\r\n");

  U64 feature_mac := 5;
  U64 device_features_port := #x00;
  U64 guest_features_port  := #x04;
  U64 queue_address_port   := #x08;
  U64 queue_size_port      := #x0c;
  U64 queue_select_port    := #x0e;
  U64 device_status_port   := #x12;

  U64 device_acknowledged := #x01;
  U64 device_driver       := #x02;
  U64 device_features_ok  := #x08;
  U64 device_driver_ok    := #x04;

  U64 net_base_port := #x6060;


  // Acknowledge the device.
  <> y_outbc(as<U8>(device_acknowledged),
             as<U16>(net_base_port + device_status_port));
  // Tell the device that we know how to drive it.
  <> y_outbc(as<U8>(device_acknowledged | device_driver),
             as<U16>(net_base_port + device_status_port));

  U64 device_features := as<U64>(y_indc(as<U16>(net_base_port + device_features_port)));
  if ((device_features & (1 << feature_mac)) == 0) {
     return 1;
  }

  U32 guest_features := as<U32>(1 << feature_mac);
  <> y_outdc(guest_features, as<U16>(net_base_port + guest_features_port));

  // Tell the device that we are finalized on our feature decisions.
  <> y_outbc(as<U8>(device_acknowledged | device_driver | device_features_ok),
             as<U16>(net_base_port + device_status_port));

  U64 device_status := as<U64>(y_inbc(as<U16>(net_base_port + device_status_port)));
  if (device_status != (device_acknowledged | device_driver | device_features_ok)) {
    return 1;
  }

  U64 queue_num := 0;
  while (queue_num < 2) {
    <> y_outwc(as<U16>(queue_num), as<U16>(net_base_port + queue_select_port));
    U64 queue_size := as<U64>(y_inwc(as<U16>(net_base_port + queue_size_port)));
    if (queue_size != #x100) {
      return 1;
    }

    queue_num := queue_num + 1;
  }

  U64 net_queue_size := (256 * 16) + (4096) + 6 + (256 * 8);

  <> memset(as<U8[]*>(net_send_queue), as<U8>(0), net_queue_size);
  <> memset(as<U8[]*>(net_recv_queue), as<U8>(0), net_queue_size);


  // Tell the device about our queues
  <> y_outwc(as<U16>(0), as<U16>(net_base_port + queue_select_port));
  <> y_outdc(as<U32>(as<U64>(net_recv_queue) >> 12),
             as<U16>(net_base_port + queue_address_port));

  <> y_outwc(as<U16>(1), as<U16>(net_base_port + queue_select_port));
  <> y_outdc(as<U32>(as<U64>(net_send_queue) >> 12),
             as<U16>(net_base_port + queue_address_port));

  // Tell the device that we are ready!
  <> y_outbc(as<U8>(device_acknowledged | device_driver | device_features_ok | device_driver_ok),
             as<U16>(net_base_port + device_status_port));
  device_status := as<U64>(y_inbc(as<U16>(net_base_port + device_status_port)));
  if (device_status != (device_acknowledged | device_driver | device_features_ok | device_driver_ok)) {
    return 1;
  }

  <> write_bytes(#"Network code done\r\n");
  return 0;
}

#:define_struct TaskDescriptor {
  U64 stack_pointer;
  TaskDescriptor* next;
  U32 state;
}

#:define_global TaskDescriptor root_task
#:define_global TaskDescriptor* current_task

#:define_function
U64 initializeScheduler() {
  <> write_bytes(#"Scheduler code\r\n");

  // Initialize root_task
  *root_task->&stack_pointer <- 0;
  *root_task->&next <- root_task;
  *root_task->&state <- as<U32>(0); // Runnable

  // Initialize the current task as the root_task;
  *current_task <- root_task;

  <> write_bytes(#"Scheduler code done\r\n");
  return 0;
}

#:define_function
U64 scheduler_start_task((-> U64) func) {
  <> enable_interruptsc();

  <> func();
}

#:define_function
U64 add_task(TaskDescriptor* task, U64 stack_address, (-> U64) start_func) {

  // Push initial values onto the stack.
  U64 stack_pointer := stack_address;

  // First return address
  stack_pointer := stack_pointer - 8;
  *(as<U64*>(stack_pointer)) <- as<U64[]*>(scheduler_start_task)->[1];
  // Setup initial registers.
  U64 i := 0;
  while (i < 15) {
    U64 val := 0;
    if (i == 6) { // rdi
      val := as<U64>(start_func);
    }

    stack_pointer := stack_pointer - 8;
    *(as<U64*>(stack_pointer)) <- val;
    i := i + 1;
  }

  *task->&stack_pointer <- stack_pointer;

  // Add the task and mark as runnable.
  *task->&state <- as<U32>(0); // Runnable
  *task->&next <- (*current_task)->next;
  *((*current_task)->&next) <- task;

  return 0;
}

#:define_global TaskDescriptor serial_task
#:define_global TaskDescriptor network_task

#:define_function
U64 addInitialTasks() {
  <> write_bytes(#"Initial tasks\r\n");

  <> add_task(serial_task, as<U64>(serial_task_stack->&[8192]),
                                   serialTaskStart);
  <> add_task(network_task, as<U64>(network_task_stack->&[8192]),
                                   networkTaskStart);
  <> write_bytes(#"Initial tasks done\r\n");
  return 0;
}


#:define_function
U64 runSchedulerLoop() {
  while (1 != 0) {
    <> disable_interruptsc();
    // 0 for input = Runnable, 0 for output = no other Runnable tasks
    while (yield(as<U32>(0))) {}
    <> enable_interrupts_and_haltc();
  }
}

// Marks all the tasks runnable. Called by interrupt handlers.
#:define_function
U64 markAllRunnable() {
  TaskDescriptor* task := *current_task;
  *task->&state <- as<U32>(0); // Runnable
  task := task->next;
  while (as<U64>(task) != as<U64>(*current_task)) {
    *task->&state <- as<U32>(0); // Runnable
    task := task->next;
  }
  return 0;
}


#:define_function
Boolean yield(U32 new_old_state) {
  TaskDescriptor* old_task := *current_task;
  TaskDescriptor* new_task := old_task->next;

  while ((as<U64>(new_task) != as<U64>(old_task))
         && (as<U64>(new_task->state) != 0)) {
    new_task := new_task->next;
  }

  Boolean ret_val := (0 == 1);
  if (as<U64>(new_task) != as<U64>(old_task)) {
    ret_val := (1 == 1);
    *old_task->&state <- new_old_state;
    *current_task <- new_task;
    <> y_switch_to_taskc(old_task, new_task);
  }

  return ret_val;
}

#:define_function
U64 postBootServices() {
  // UEFI is now finished.
  // Start initializing sub systems.

  <> initializeIdt();
  <> initializeSerial();
  <> initializePic();
  if ((initializeNetwork()) != 0) {
    <> write_bytes(#"Network initialization failed\r\n");
    return 1;
  }

  <> initializeScheduler();
  <> addInitialTasks();
  <> enable_interruptsc();

  <> welcomeMessage();
  // Run the main OS loop
  <> runSchedulerLoop();
}

#:define_function
U64 main(U64 image_handle, EfiSystemTable* st) {

  U64 s := 0;
  s := exitBootServices(image_handle, st);
  if (s != 0) { return s; }
  s := postBootServices();
  if (s != 0) { return s; }

  return 0;
}

#:define_struct PacketData {}

#:define_struct VirtioNetHeader {
  U8[10] header;
  PacketData data;
}

#:define_struct BigEndianU16 {
  U8 byte0;
  U8 byte1;
}

#:define_struct EthernetHeader {
  U8[6] destination_mac;
  U8[6] source_mac;
  BigEndianU16 ethertype;
  PacketData data;
}

#:define_struct IpHeader {
  U8 version_header_length;
  U8 dcsp_ecn;
  BigEndianU16 total_length;
  BigEndianU16 identification;
  BigEndianU16 flags_fragment_offset;
  U8 time_to_live;
  U8 protocol;
  BigEndianU16 header_checksum;
  U8[4] source_ip;
  U8[4] destination_ip;
  PacketData data;
}

#:define_struct UdpHeader {
  BigEndianU16 source_port;
  BigEndianU16 destination_port;
  BigEndianU16 length;
  BigEndianU16 checksum;
  PacketData data;
}

// This struct assumes that the sizing is consistent with IPv4/Ethernet
// ARP packets.
#:define_struct ArpPacket {
  BigEndianU16 hardware_type;
  BigEndianU16 protocol_type;
  U8 hardware_length;
  U8 protocol_length;
  BigEndianU16 operation_type;
  U8[6] sender_hardware_address;
  U8[4] sender_protocol_address;
  U8[6] target_hardware_address;
  U8[4] target_protocol_address;
}


#:define_struct BytesLayout {
  U64* descriptor;
  U64 length;
  PacketData data;
}


#:define_function
U64 sendUdpPacket(U16 dest_port) {
  <> write_bytes(#"Sending Yaspl UDP Packet\r\n");

  U64 net_base_port     := #x6060;
  U64 isr_status_port   := #x13;
  U64 queue_notify_port := #x10;

  U64 index := as<U64>((net_send_queue->&available)->index);

  U64 i := index % 256;
  VirtioNetHeader* virtio_header := as<VirtioNetHeader*>(net_send_buffers->&[i]);

  U64 j := 0;
  while (j < 10) {
    *(virtio_header->&header)->&[i] <- as<U8>(0);
    j := j + 1;
  }

  EthernetHeader* ethernet_header := as<EthernetHeader*>(virtio_header->&data);
  *(ethernet_header->&destination_mac)->&[0] <- as<U8>(#x52);
  *(ethernet_header->&destination_mac)->&[1] <- as<U8>(#x55);
  *(ethernet_header->&destination_mac)->&[2] <- as<U8>(#x0a);
  *(ethernet_header->&destination_mac)->&[3] <- as<U8>(#x00);
  *(ethernet_header->&destination_mac)->&[4] <- as<U8>(#x02);
  *(ethernet_header->&destination_mac)->&[5] <- as<U8>(#x02);

  *(ethernet_header->&source_mac)->&[0] <- as<U8>(#x52);
  *(ethernet_header->&source_mac)->&[1] <- as<U8>(#x54);
  *(ethernet_header->&source_mac)->&[2] <- as<U8>(#x00);
  *(ethernet_header->&source_mac)->&[3] <- as<U8>(#x12);
  *(ethernet_header->&source_mac)->&[4] <- as<U8>(#x34);
  *(ethernet_header->&source_mac)->&[5] <- as<U8>(#x56);

  *(ethernet_header->&ethertype)->&byte0 <- as<U8>(#x08);
  *(ethernet_header->&ethertype)->&byte1 <- as<U8>(#x00);

  Bytes response := #"abcdefghijklmnop\n";
  U64 response_length := 17;
  BytesLayout* response_raw := as<BytesLayout*>(response);

  IpHeader* ip_header := as<IpHeader*>(ethernet_header->&data);
  *ip_header->&version_header_length <- as<U8>(#x45);
  *ip_header->&dcsp_ecn <- as<U8>(#x00);
  U64 udp_header_size := 8;
  U64 ip_header_size := 20;
  U64 total_length := ip_header_size + udp_header_size + response_length;
  *(ip_header->&total_length)->&byte0 <- as<U8>((total_length >> 8) & #xff);
  *(ip_header->&total_length)->&byte1 <- as<U8>((total_length >> 0) & #xff);
  *(ip_header->&flags_fragment_offset)->&byte0 <- as<U8>(0);
  *(ip_header->&flags_fragment_offset)->&byte1 <- as<U8>(0);
  *ip_header->&time_to_live <- as<U8>(64);
  *ip_header->&protocol <- as<U8>(17); // UDP
  *(ip_header->&header_checksum)->&byte0 <- as<U8>(#x62);
  *(ip_header->&header_checksum)->&byte1 <- as<U8>(#xb0);
  *(ip_header->&source_ip)->&[0] <- as<U8>(10);
  *(ip_header->&source_ip)->&[1] <- as<U8>(0);
  *(ip_header->&source_ip)->&[2] <- as<U8>(2);
  *(ip_header->&source_ip)->&[3] <- as<U8>(15);
  *(ip_header->&destination_ip)->&[0] <- as<U8>(10);
  *(ip_header->&destination_ip)->&[1] <- as<U8>(0);
  *(ip_header->&destination_ip)->&[2] <- as<U8>(2);
  *(ip_header->&destination_ip)->&[3] <- as<U8>(2);

  UdpHeader* udp_header := as<UdpHeader*>(ip_header->&data);
  *(udp_header->&source_port)->&byte0 <- as<U8>(0);
  *(udp_header->&source_port)->&byte1 <- as<U8>(7);
  *(udp_header->&destination_port)->&byte0 <- as<U8>((as<U64>(dest_port) >> 8) & #xff);
  *(udp_header->&destination_port)->&byte1 <- as<U8>((as<U64>(dest_port) >> 0) & #xff);
  U64 udp_packet_length := udp_header_size + response_length;
  *(udp_header->&length)->&byte0 <- as<U8>((udp_packet_length >> 8) & #xff);
  *(udp_header->&length)->&byte1 <- as<U8>((udp_packet_length >> 0) & #xff);
  *(udp_header->&checksum)->&byte0 <- as<U8>(0);
  *(udp_header->&checksum)->&byte1 <- as<U8>(0);

  j := 0;
  while (j < response_length) {
    *as<U8[]*>(udp_header->&data)->&[j] <- (as<U8[]*>(response_raw->&data))->[j];
    j := j + 1;
  }

  U64 ethernet_header_size := 14;
  U64 virtio_net_header_size := 10;

  *((net_send_queue->&buffers)->&[i])->&address <- as<U64>(net_send_buffers->&[i]);
  *((net_send_queue->&buffers)->&[i])->&length <-
    as<U32>(response_length + udp_header_size + ip_header_size + ethernet_header_size +
            virtio_net_header_size);
  *((net_send_queue->&buffers)->&[i])->&flags <- as<U16>(0);
  *((net_send_queue->&buffers)->&[i])->&next <- as<U16>(0);

  *((net_send_queue->&available)->&ring)->&[i] <- as<U16>(i);
  *(net_send_queue->&available)->&index <- as<U16>(as<U64>((net_send_queue->&available)->index) + 1);

  // Tell the device that queue 1 (send) has a new buffer.
  <> y_outwc(as<U16>(1), as<U16>(net_base_port + queue_notify_port));


  <> disable_interruptsc();
  Boolean msg_recieved := 1 == 0;
  while (!msg_recieved) {
    // Read the interrupt status register to clear the interrupt state.
    <> y_inbc(as<U16>(net_base_port + isr_status_port));
    msg_recieved := as<U64>((net_send_queue->&used)->index) == ((index + 1) & #xffff);
    if (!msg_recieved) {
      <> yield(as<U32>(1)); // Blocked
    }
  }
  <> enable_interruptsc();



  return 0;
}


#:define_function
U64 sendArpPacket() {
  <> write_bytes(#"Sending Yaspl Arp Packet\r\n");

  U64 net_base_port     := #x6060;
  U64 isr_status_port   := #x13;
  U64 queue_notify_port := #x10;

  U64 index := as<U64>((net_send_queue->&available)->index);

  U64 i := index % 256;



  VirtioNetHeader* virtio_header := as<VirtioNetHeader*>(net_send_buffers->&[i]);

  U64 j := 0;
  while (j < 10) {
    *(virtio_header->&header)->&[i] <- as<U8>(0);
    j := j + 1;
  }

  EthernetHeader* ethernet_header := as<EthernetHeader*>(virtio_header->&data);
  *(ethernet_header->&destination_mac)->&[0] <- as<U8>(#x52);
  *(ethernet_header->&destination_mac)->&[1] <- as<U8>(#x55);
  *(ethernet_header->&destination_mac)->&[2] <- as<U8>(#x0a);
  *(ethernet_header->&destination_mac)->&[3] <- as<U8>(#x00);
  *(ethernet_header->&destination_mac)->&[4] <- as<U8>(#x02);
  *(ethernet_header->&destination_mac)->&[5] <- as<U8>(#x02);

  *(ethernet_header->&source_mac)->&[0] <- as<U8>(#x52);
  *(ethernet_header->&source_mac)->&[1] <- as<U8>(#x54);
  *(ethernet_header->&source_mac)->&[2] <- as<U8>(#x00);
  *(ethernet_header->&source_mac)->&[3] <- as<U8>(#x12);
  *(ethernet_header->&source_mac)->&[4] <- as<U8>(#x34);
  *(ethernet_header->&source_mac)->&[5] <- as<U8>(#x56);

  *(ethernet_header->&ethertype)->&byte0 <- as<U8>(#x08);
  *(ethernet_header->&ethertype)->&byte1 <- as<U8>(#x06);

  ArpPacket* arp_packet := as<ArpPacket*>(ethernet_header->&data);

  *(arp_packet->&hardware_type)->&byte0 <- as<U8>(#x00);
  *(arp_packet->&hardware_type)->&byte1 <- as<U8>(#x01);
  *(arp_packet->&protocol_type)->&byte0 <- as<U8>(#x08);
  *(arp_packet->&protocol_type)->&byte1 <- as<U8>(#x00);
  *arp_packet->&hardware_length <- as<U8>(6);
  *arp_packet->&protocol_length <- as<U8>(4);
  *(arp_packet->&operation_type)->&byte0 <- as<U8>(#x00);
  *(arp_packet->&operation_type)->&byte1 <- as<U8>(#x02);
  *(arp_packet->&sender_hardware_address)->&[0] <- as<U8>(#x52);
  *(arp_packet->&sender_hardware_address)->&[1] <- as<U8>(#x54);
  *(arp_packet->&sender_hardware_address)->&[2] <- as<U8>(#x00);
  *(arp_packet->&sender_hardware_address)->&[3] <- as<U8>(#x12);
  *(arp_packet->&sender_hardware_address)->&[4] <- as<U8>(#x34);
  *(arp_packet->&sender_hardware_address)->&[5] <- as<U8>(#x56);

  *(arp_packet->&sender_protocol_address)->&[0] <- as<U8>(#x0a);
  *(arp_packet->&sender_protocol_address)->&[1] <- as<U8>(#x00);
  *(arp_packet->&sender_protocol_address)->&[2] <- as<U8>(#x02);
  *(arp_packet->&sender_protocol_address)->&[3] <- as<U8>(#x0f);

  *(arp_packet->&target_hardware_address)->&[0] <- as<U8>(#x52);
  *(arp_packet->&target_hardware_address)->&[1] <- as<U8>(#x55);
  *(arp_packet->&target_hardware_address)->&[2] <- as<U8>(#x0a);
  *(arp_packet->&target_hardware_address)->&[3] <- as<U8>(#x00);
  *(arp_packet->&target_hardware_address)->&[4] <- as<U8>(#x02);
  *(arp_packet->&target_hardware_address)->&[5] <- as<U8>(#x02);
  *(arp_packet->&target_protocol_address)->&[0] <- as<U8>(#x0a);
  *(arp_packet->&target_protocol_address)->&[1] <- as<U8>(#x00);
  *(arp_packet->&target_protocol_address)->&[2] <- as<U8>(#x02);
  *(arp_packet->&target_protocol_address)->&[3] <- as<U8>(#x02);


  U64 arp_packet_size := 28;
  U64 ethernet_header_size := 14;
  U64 virtio_net_header_size := 10;

  *((net_send_queue->&buffers)->&[i])->&address <- as<U64>(net_send_buffers->&[i]);
  *((net_send_queue->&buffers)->&[i])->&length <-
    as<U32>(arp_packet_size + ethernet_header_size + virtio_net_header_size);
  *((net_send_queue->&buffers)->&[i])->&flags <- as<U16>(0);
  *((net_send_queue->&buffers)->&[i])->&next <- as<U16>(0);

  *((net_send_queue->&available)->&ring)->&[i] <- as<U16>(i);
  *(net_send_queue->&available)->&index <- as<U16>(as<U64>((net_send_queue->&available)->index) + 1);

  // Tell the device that queue 1 (send) has a new buffer.
  <> y_outwc(as<U16>(1), as<U16>(net_base_port + queue_notify_port));

  <> disable_interruptsc();
  Boolean msg_recieved := 1 == 0;
  while (!msg_recieved) {
    // Read the interrupt status register to clear the interrupt state.
    <> y_inbc(as<U16>(net_base_port + isr_status_port));
    msg_recieved := as<U64>((net_send_queue->&used)->index) == ((index + 1) & #xffff);
    if (!msg_recieved) {
      <> yield(as<U32>(1)); // Blocked
    }
  }
  <> enable_interruptsc();

  <> write_bytes(#"Done sending Yaspl Arp Packet\r\n");
  return 0;
}

#:define_function
U16 be_u16_to_le(BigEndianU16* be) {
  return as<U16>((as<U64>(be->byte0) << 8) |
                 (as<U64>(be->byte1) << 0));
}

#:define_function
U64 waitNetworkInterrupt() {

  U64 net_base_port      := #x6060;
  U64 device_status_port := #x12;
  U64 isr_status_port    := #x13;
  U64 queue_notify_port  := #x10;


  U64 index := as<U64>((net_recv_queue->&available)->index);

  U64 i := index % 256;

  *((net_recv_queue->&buffers)->&[i])->&address <- as<U64>(net_recv_buffers->&[i]);
  *((net_recv_queue->&buffers)->&[i])->&length  <- as<U32>(4096);
  *((net_recv_queue->&buffers)->&[i])->&flags   <- as<U16>(2); // Device writable
  *((net_recv_queue->&buffers)->&[i])->&next    <- as<U16>(0);

  *((net_recv_queue->&available)->&ring)->&[i] <- as<U16>(i);
  *(net_recv_queue->&available)->&index <- as<U16>(as<U64>((net_recv_queue->&available)->index) + 1);

  // Tell the device that queue 0 (recv) has a new buffer.
  <> y_outwc(as<U16>(0), as<U16>(net_base_port + queue_notify_port));

  <> disable_interruptsc();
  Boolean msg_recieved := 1 == 0;
  while (!msg_recieved) {
    // Read the interrupt status register to clear the interrupt state.
    <> y_inbc(as<U16>(net_base_port + isr_status_port));
    msg_recieved := as<U64>((net_recv_queue->&used)->index) == ((index + 1) & #xffff);
    if (!msg_recieved) {
      <> yield(as<U32>(1)); // Blocked
    }
  }
  <> enable_interruptsc();


  U64 ring_i := index % 256;
  U64 buffer_i := as<U64>((((net_recv_queue->&used)->&ring)->&[ring_i])->index);
  if (buffer_i != ring_i) {
    <> y_panicc();
  }
  U64 remaining_packet_length := as<U64>((((net_recv_queue->&used)->&ring)->&[ring_i])->length);
  U8[]* raw_buffer := as<U8[]*>(((net_recv_queue->&buffers)->&[buffer_i])->address);

  U64 virtio_net_header_size := 10;
  U64 ethernet_header_size := 14;


  if (remaining_packet_length < virtio_net_header_size) {
    <> y_panicc();
  }
  VirtioNetHeader* virtio_header := as<VirtioNetHeader*>(raw_buffer);
  remaining_packet_length := remaining_packet_length - virtio_net_header_size;

  if (remaining_packet_length < ethernet_header_size) {
    <> y_panicc();
  }
  EthernetHeader* ethernet_header := as<EthernetHeader*>(virtio_header->&data);
  remaining_packet_length := remaining_packet_length - ethernet_header_size;

  if ((as<U64>((ethernet_header->&ethertype)->byte0) == #x08) &&
      (as<U64>((ethernet_header->&ethertype)->byte1) == #x06)) {
    U64 arp_packet_size := 28;
    if (remaining_packet_length < arp_packet_size) {
      <> y_panicc();
    }
    ArpPacket* arp_packet := as<ArpPacket*>(ethernet_header->&data);
    remaining_packet_length := remaining_packet_length - arp_packet_size;

    if (remaining_packet_length != 0) {
      <> y_panicc();
    }

    if (as<U64>(be_u16_to_le(arp_packet->&hardware_type)) != 1) {
      <> y_panicc();
    }
    if (as<U64>(be_u16_to_le(arp_packet->&protocol_type)) != #x0800) {
      <> y_panicc();
    }
    if (as<U64>(arp_packet->hardware_length) != 6) {
      <> y_panicc();
    }
    if (as<U64>(arp_packet->protocol_length) != 4) {
      <> y_panicc();
    }


    <> sendArpPacket();
  } else if ((as<U64>((ethernet_header->&ethertype)->byte0) == #x08) &&
             (as<U64>((ethernet_header->&ethertype)->byte1) == #x00)) {
    <> write_bytes(#"IPv4 packet\r\n");

    U64 udp_header_size := 8;
    U64 ip_header_size := 20;

    if (remaining_packet_length < ip_header_size) {
        <> y_panicc();
    }
    IpHeader* ip_header := as<IpHeader*>(ethernet_header->&data);

    if (remaining_packet_length != as<U64>(be_u16_to_le(ip_header->&total_length))) {
       <> y_panicc();
    }

    U64 header_length := as<U64>(ip_header->version_header_length) & #x0F;
    if (header_length != 5) {
      <> y_panicc();
    }
    remaining_packet_length := remaining_packet_length - ip_header_size;

    if (remaining_packet_length < udp_header_size) {
      <> y_panicc();
    }
    UdpHeader* udp_header := as<UdpHeader*>(ip_header->&data);

    if (remaining_packet_length != as<U64>(be_u16_to_le(udp_header->&length))) {
      <> y_panicc();
    }
    remaining_packet_length := remaining_packet_length - udp_header_size;

    <> sendUdpPacket(be_u16_to_le(udp_header->&source_port));
  } else {
    <> write_bytes(#"Unknown packet type\r\n");
  }
  return 0;
}
