#:module (os)

#:import_module (prim os)
#:import_module (os serial)

#:define_function
U64 write_bytes(Bytes bytes) {
  BytesLayout* bytes_ptr := as<BytesLayout*>(bytes);
  U8[]* buffer := as<U8[]*>(bytes_ptr->&data);
  <> write_raw_buffer(buffer, bytes_ptr->length);
  return 0;
}


#:define_function
U64 write_raw_buffer(U8[]* buffer, U64 amount) {
  U64 i := 0;
  while (i < amount) {
    <> write_serial(buffer->[i]);
    i := i + 1;
  }
  return 0;
}


#:define_function
U8 nibble_to_hex(U64 v) {
  if (v < 10) {
    return as<U8>(48 + v);
  } else {
    return as<U8>(87 + v);
  }
}

#:define_function
U64 write_hex_byte(U8 b) {
  U64 v := as<U64>(b);
  <> write_serial(nibble_to_hex((v >> 4) & #x0f));
  <> write_serial(nibble_to_hex(v & #x0f));
  return 0;
}

#:define_function
U64 write_hex_U8(U8 v) {
  return write_hex_byte(v);
}

#:define_function
U64 write_hex_U16(U16 v) {
  <> write_hex_byte(as<U8>((as<U64>(v) >>  8) & #xff));
  <> write_hex_byte(as<U8>((as<U64>(v) >>  0) & #xff));
  return 0;
}

#:define_function
U64 write_hex_U32(U32 v) {
  <> write_hex_byte(as<U8>((as<U64>(v) >> 24) & #xff));
  <> write_hex_byte(as<U8>((as<U64>(v) >> 16) & #xff));
  <> write_hex_byte(as<U8>((as<U64>(v) >>  8) & #xff));
  <> write_hex_byte(as<U8>((as<U64>(v) >>  0) & #xff));
  return 0;
}


#:define_function
U64 write_hex_U64(U64 v) {
  <> write_hex_byte(as<U8>((v >> 56) & #xff));
  <> write_hex_byte(as<U8>((v >> 48) & #xff));
  <> write_hex_byte(as<U8>((v >> 40) & #xff));
  <> write_hex_byte(as<U8>((v >> 32) & #xff));
  <> write_hex_byte(as<U8>((v >> 24) & #xff));
  <> write_hex_byte(as<U8>((v >> 16) & #xff));
  <> write_hex_byte(as<U8>((v >>  8) & #xff));
  <> write_hex_byte(as<U8>((v >>  0) & #xff));
  return 0;
}


#:define_function
Boolean serial_received() {
  // #x3F8 is SERIAL_COM1_BASE
  U64 port := #x3F8;
  U64 result := as<U64>(inb(as<U16>(port + 5)));
  return (result & 1) != 0;
}

#:define_function
U8 read_serial() {

 if (!serial_received()) {
   <> disable_interrupts();
   while (!serial_received()) {
      <> yield(as<U32>(1)); // Blocked
   }
   <> enable_interrupts();
 }

 // #x3F8 is SERIAL_COM1_BASE
 U64 port := #x3F8;
 return inb(as<U16>(port));
}


#:define_global U8 serial_counter

#:define_function
U64 serialTaskStart() {
  while (1 > 0) {
    U8 v := read_serial();
    <> write_bytes(#"SerialInput (");
    <> write_hex_byte(*serial_counter);
    <> write_bytes(#"): ");
    <> write_hex_byte(v);
    <> write_bytes(#"\r\n");
    *serial_counter <- as<U8>(as<U64>(*serial_counter) + 1);
  }
}


#:define_function
U64 networkTaskStart() {
  while (1 > 0) {
    <> waitNetworkInterrupt();
  }
}

#:define_function
U64 welcomeMessage() {
  <> write_bytes(#"\x1bc");
  <> write_bytes(#"Welcome to Yaspl OS.\r\n");
  return 0;
}


#:define_function
U64 memset(U8[]* memory, U8 value, U64 size) {
  U64 index := 0;
  while (index < size) {
    *memory->&[index] <- value;
    index := index + 1;
  }
  return 0;
}

#:define_struct EfiHandle {}

#:define_struct EfiTableHeader {
  U32 signature;
  U32 revision;
  U32 header_size;
  U32 crc32;
  U32 reserved1;
}

#:define_struct EfiRuntimeServices {}

#:define_struct EfiUnknown {}

#:define_struct EfiBootServices {
    EfiTableHeader Hdr;
    U32 padding1;
    EfiUnknown*    RaiseTPL;
    EfiUnknown*    RestoreTPL;
    EfiUnknown*    AllocatePages;
    EfiUnknown*    FreePages;
    U64            GetMemoryMap;
    U64            AllocatePool;
    EfiUnknown*    FreePool;
    EfiUnknown*    CreateEvent;
    EfiUnknown*    SetTimer;
    EfiUnknown*    WaitForEvent;
    EfiUnknown*    SignalEvent;
    EfiUnknown*    CloseEvent;
    EfiUnknown*    CheckEvent;
    EfiUnknown*    InstallProtocolInterface;
    EfiUnknown*    ReinstallProtocolInterface;
    EfiUnknown*    UninstallProtocolInterface;
    EfiUnknown*    HandleProtocol;
    EfiUnknown*    Reserved;
    EfiUnknown*    RegisterProtocolNotify;
    EfiUnknown*    LocateHandle;
    EfiUnknown*    LocateDevicePath;
    EfiUnknown*    InstallConfigurationTable;
    EfiUnknown*    LoadImage;
    EfiUnknown*    StartImage;
    EfiUnknown*    Exit;
    EfiUnknown*    UnloadImage;
    U64            ExitBootServices;
}

#:define_struct EfiGuid {
  U32   data1;
  U16   data2;
  U16   data3;
  U8[8] data4;
}

#:define_struct EfiConfigurationTable {
  EfiGuid guid;
  U64 address;
}

#:define_struct EfiSystemTable {
  EfiTableHeader header;
  U32 padding1;
  U16* firmware_vendor;
  U32 firmware_revision;
  U32 padding2;
  EfiHandle* console_in_handle;
  U64* console_in;
  EfiHandle* console_out_handle;
  EfiSimpleTextOutputProtocol* console_out;
  EfiHandle* console_err_handle;
  EfiSimpleTextOutputProtocol* console_err;
  EfiRuntimeServices* runtime_services;
  EfiBootServices* boot_services;
  U64 number_of_table_entries;
  EfiConfigurationTable[]* configuration_tables;
}

#:define_struct EfiTextString {}

#:define_struct EfiSimpleTextOutputProtocol {
  U64* reset;
  EfiTextString* output_string;
}

#:define_struct EfiMemoryMap {}

#:define_global U64 efi_memory_map_size
#:define_global U8[4096] efi_memory_map_space
#:define_global U64 efi_memory_map_key
#:define_global U64 efi_memory_descriptor_size
#:define_global U32 efi_memory_descriptor_version

#:define_global U8[4096] efi_output_buffer
#:define_global U8*      efi_writer

#:define_function
U64 reset_efi_writer() {
  *efi_writer <- efi_output_buffer->&[0];
  return 0;
}

#:define_function
U64 terminate_efi_writer() {
  return efi_writer_add_byte(as<U8>(0));
}

#:define_function
U64 efi_writer_add_byte(U8 v) {
  *(*efi_writer) <- v;
  *efi_writer <- as<U8*>(as<U64>(*efi_writer) + 2);
  return 0;
}

#:define_function
U64 efi_writer_add_hex_U8(U8 byte) {
  <> efi_writer_add_byte(nibble_to_hex((as<U64>(byte) >> 4) & #x0f));
  <> efi_writer_add_byte(nibble_to_hex(as<U64>(byte) & #x0f));
  return 0;
}


#:define_function
U64 efi_writer_add_hex_U16(U16 v) {
  <> efi_writer_add_hex_U8(as<U8>((as<U64>(v) >> 8) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((as<U64>(v) >> 0) & #xff));
  return 0;
}

#:define_function
U64 efi_writer_add_hex_U32(U32 v) {
  <> efi_writer_add_hex_U8(as<U8>((as<U64>(v) >> 24) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((as<U64>(v) >> 16) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((as<U64>(v) >>  8) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((as<U64>(v) >>  0) & #xff));
  return 0;
}

#:define_function
U64 efi_writer_add_hex_U64(U64 v) {
  <> efi_writer_add_hex_U8(as<U8>((v >> 56) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v >> 48) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v >> 40) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v >> 32) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v >> 24) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v >> 16) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v >>  8) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v >>  0) & #xff));
  return 0;
}

#:define_function
U64 efi_writer_add_guid(EfiGuid* guid) {
  <> efi_writer_add_hex_U32(guid->data1);
  <> efi_writer_add_byte(as<U8>(45));
  <> efi_writer_add_hex_U16(guid->data2);
  <> efi_writer_add_byte(as<U8>(45));
  <> efi_writer_add_hex_U16(guid->data3);
  <> efi_writer_add_byte(as<U8>(45));
  <> efi_writer_add_hex_U8((guid->&data4)->[0]);
  <> efi_writer_add_hex_U8((guid->&data4)->[1]);
  <> efi_writer_add_hex_U8((guid->&data4)->[2]);
  <> efi_writer_add_hex_U8((guid->&data4)->[3]);
  <> efi_writer_add_hex_U8((guid->&data4)->[4]);
  <> efi_writer_add_hex_U8((guid->&data4)->[5]);
  <> efi_writer_add_hex_U8((guid->&data4)->[6]);
  <> efi_writer_add_hex_U8((guid->&data4)->[7]);
  return 0;
}

#:define_function
U64 efi_writer_add_bytes(Bytes bytes) {
  BytesLayout* bytes_ptr := as<BytesLayout*>(bytes);
  U8[]* buffer := as<U8[]*>(bytes_ptr->&data);
  U64 length := bytes_ptr->length;
  U64 i := 0;
  while (i < length) {
    <> efi_writer_add_byte(buffer->[i]);
    i := i + 1;
  }
  return 0;
}

#:define_function
U64 efi_writer_finish_line() {
  <> efi_writer_add_bytes(#"\r\n");
  return 0;
}



#:define_function
U64 exitBootServices(U64 image_handle, EfiSystemTable* st) {
  EfiSimpleTextOutputProtocol* output := st->console_out;

  *efi_memory_map_size <- 4096;
  U64 status := call_ms5((st->boot_services)->GetMemoryMap,
                         as<U64>(efi_memory_map_size),
                         as<U64>(efi_memory_map_space),
                         as<U64>(efi_memory_map_key),
                         as<U64>(efi_memory_descriptor_size),
                         as<U64>(efi_memory_descriptor_version));
  if (status != 0) {
    <> reset_efi_writer();
    <> efi_writer_add_hex_U64(status);
    <> efi_writer_finish_line();
    <> terminate_efi_writer();
    <> call_ms2(as<U64>(output->output_string), as<U64>(output), as<U64>(efi_output_buffer));
    return status;
  }

  status := call_ms2((st->boot_services)->ExitBootServices, image_handle, *efi_memory_map_key);
  if (status != 0) {
    <> reset_efi_writer();
    <> efi_writer_add_hex_U64(status);
    <> efi_writer_finish_line();
    <> terminate_efi_writer();
    <> call_ms2(as<U64>(output->output_string), as<U64>(output), as<U64>(efi_output_buffer));
    return status;
  }

  return 0;
}

#:define_struct IdtEntry {
  U16 offset_1;  // offset bits 0..15
  U16 selector;  // a code segment selector in GDT or LDT
  U8  ist;       // bits 0..2 holds Interrupt Stack Table offset, rest of bits zero.
  U8  type_attr; // type and attributes
  U16 offset_2;  // offset bits 16..31
  U32 offset_3;  // offset bits 32..63
  U32 zero;      // reserved
}

#:define_struct IdtDescriptor {
  U16 limit;
  U64 base_address;
}

#:define_global IdtEntry[256] idt_entries
#:define_global IdtDescriptor idt_descriptor


#:define_function
U64 initializeIdt() {
  <> write_bytes(#"IDT code\r\n");
  U64 idt_entry_size := 16;
  <> memset(as<U8[]*>(idt_entries), as<U8>(0), idt_entry_size * 256);
  U64 i := 0;
  while (i < 256) {
    U64 irq_addr := as<U64[]*>(irqfun_default)->[1];
    if (i == 36) {
      irq_addr := as<U64[]*>(irqfun_com1)->[1];
    } else if (i == 43) {
      irq_addr := as<U64[]*>(irqfun_nic)->[1];
    }

    *(idt_entries->&[i])->&offset_1 <- as<U16>(irq_addr & #xffff);
    *(idt_entries->&[i])->&selector <- as<U16>(#x38);
    *(idt_entries->&[i])->&ist <- as<U8>(0);
    *(idt_entries->&[i])->&type_attr <- as<U8>(#x8e);
    *(idt_entries->&[i])->&offset_2 <- as<U16>((irq_addr >> 16) & #xffff);
    *(idt_entries->&[i])->&offset_3 <- as<U32>(irq_addr >> 32);
    *(idt_entries->&[i])->&zero <- as<U32>(0);
    i := i + 1;
  }

  *idt_descriptor->&limit <- as<U16>(idt_entry_size * 256 - 1);
  *idt_descriptor->&base_address <- as<U64>(idt_entries);
  <> lidt(as<U64>(idt_descriptor));
  <> write_bytes(#"IDT code done\r\n");
  return 0;
}

#:define_function
U64 initializeSerial() {
  <> write_bytes(#"Serial code\r\n");

  // #x3F8 is SERIAL_COM1_BASE
  U64 port := #x3F8;

  // Disable all interrupts on the port while setup happens
  <> outb(as<U8>(#x00), as<U16>(port + 1));
  // Enable the DLAB. This changes the meaning of ports 0/1 which allows
  // setting the baud rate divisor.
  <> outb(as<U8>(#x80), as<U16>(port + 3));
  // Set divisor to 3 (low byte) 38400 baud
  <> outb(as<U8>(#x03), as<U16>(port + 0));
  <> outb(as<U8>(#x00), as<U16>(port + 1));

  // Clear the DLAB, and set the protcol as:
  // 8 bits, no parity, one stop bit
  <> outb(as<U8>(#x03), as<U16>(port + 3));

  // Add a 14 byte fifo
  <> outb(as<U8>(#xC7), as<U16>(port + 2));
  // Turn on all featuers in the Modem Status Register
  <> outb(as<U8>(#x0F), as<U16>(port + 4));

  // Enable IRQs on Receive.
  <> outb(as<U8>(#x01), as<U16>(port + 1));

  <> write_bytes(#"Serial code done\r\n");
  return 0;
}

#:define_function
U64 initializePic() {
  <> write_bytes(#"PIC code\r\n");

  // Base port numbers for the Master/Slave PICs.
  U64 pic1 := #x20;
  U64 pic2 := #xA0;
  // Command and data port numbers
  U64 pic1_command := pic1 + 0;
  U64 pic1_data    := pic1 + 1;
  U64 pic2_command := pic2 + 0;
  U64 pic2_data    := pic2 + 1;

  U64 icw1_init := #x10; // This is an initialization command
  U64 icw1_icw4 := #x01; // This initialization uses command word 4
  // Start the initialization sequence (in cascade mode)
  <> outb(as<U8>(icw1_init | icw1_icw4), as<U16>(pic1_command));
  <> outb(as<U8>(icw1_init | icw1_icw4), as<U16>(pic2_command));

  // Set the PICs to use the entries in the IDT range [32, 47).
  U64 offset1 := 32;
  U64 offset2 := 40;
  <> outb(as<U8>(offset1), as<U16>(pic1_data));    // ICW2: Master PIC vector offset
  <> outb(as<U8>(offset2), as<U16>(pic2_data));    // ICW2: Slave PIC vector offset
  // ICW3: tell Master PIC that there is a slave PIC at IRQ2 (0b00000100)
  <> outb(as<U8>(#x04), as<U16>(pic1_data));
  <> outb(as<U8>(#x02), as<U16>(pic2_data));  // ICW3: tell Slave PIC its cascade identity

  // // Set 8086 mode
  U64 icw4_8086 := #x01;
  <> outb(as<U8>(icw4_8086), as<U16>(pic1_data));
  <> outb(as<U8>(icw4_8086), as<U16>(pic2_data));

  // Only enable some interrupts.
  // PIC 1, bit 2: Allow PIC2 through
  // PIC 1, bit 4: COM1 serial port
  U64 pic1_interrupts := #xEB; // ~((1 << 2) | (1 << 4));
  // // PIC 2, bit 3: NIC
  U64 pic2_interrupts := #xF7; // ~(1 << 3);
  // Mask all interrupts that shouldn't be enabled.
  <> outb(as<U8>(pic1_interrupts), as<U16>(pic1_data));
  <> outb(as<U8>(pic2_interrupts), as<U16>(pic2_data));


  <> write_bytes(#"PIC code done\r\n");
  return 0;
}

#:define_struct VirtioQueueBufferInfo {
  U64 address;
  U32 length;
  U16 flags;
  U16 next;
}

#:define_struct VirtioQueue256AvailableInfo {
  U16 flags;
  U16 index;
  U16[256] ring;
  U16 event_index;
}


#:define_struct VirtioQueue4096AvailableInfo {
  U16 flags;
  U16 index;
  U16[4096] ring;
  U16 event_index;
}

#:define_struct VirtioQueueUsedRingInfo {
  U32 index;
  U32 length;
}

#:define_struct VirtioQueue256UsedInfo {
  U16 flags;
  U16 index;
  VirtioQueueUsedRingInfo[256] ring;
  U16 avail_event;
}


#:define_struct VirtioQueue4096UsedInfo {
  U16 flags;
  U16 index;
  VirtioQueueUsedRingInfo[4096] ring;
  U16 avail_event;
}

#:define_struct VirtioQueue256 {
  VirtioQueueBufferInfo[256] buffers;
  VirtioQueue256AvailableInfo available;
  U8[3578] padding;
  VirtioQueue256UsedInfo used;
}

#:define_struct VirtioQueue4096 {
  VirtioQueueBufferInfo[4096] buffers;
  VirtioQueue4096AvailableInfo available;
  U8[4090] padding;
  VirtioQueue4096UsedInfo used;
}



#:define_struct VirtioBuffer {
  U8[4096] bytes;
}

#:define_function
U64 initializeNetwork() {
  <> write_bytes(#"Network code\r\n");

  // Read the device configuration to find the port.
  *net_base_port <- find_network_device();
  if (as<U64>(*net_base_port) == 0) {
    <> write_bytes(#"Couldn't find base port.");

    return 1;
  }

  U64 feature_mac := 5;
  U16 device_features_port := as<U16>(as<U64>(*net_base_port) + #x00);
  U16 guest_features_port  := as<U16>(as<U64>(*net_base_port) + #x04);
  U16 queue_address_port   := as<U16>(as<U64>(*net_base_port) + #x08);
  U16 queue_size_port      := as<U16>(as<U64>(*net_base_port) + #x0c);
  U16 queue_select_port    := as<U16>(as<U64>(*net_base_port) + #x0e);
  U16 device_status_port   := as<U16>(as<U64>(*net_base_port) + #x12);

  U64 device_acknowledged := #x01;
  U64 device_driver       := #x02;
  U64 device_features_ok  := #x08;
  U64 device_driver_ok    := #x04;


  // Acknowledge the device.
  <> outb(as<U8>(device_acknowledged), device_status_port);
  // Tell the device that we know how to drive it.
  <> outb(as<U8>(device_acknowledged | device_driver), device_status_port);

  U64 device_features := as<U64>(ind(device_features_port));
  <> write_bytes(#"Device features: ");
  <> write_hex_U64(device_features);
  <> write_bytes(#"\r\n");
  if ((device_features & (1 << feature_mac)) == 0) {
    <> write_bytes(#"Device features not as expected.");

    return 1;
  }

  U32 guest_features := as<U32>(1 << feature_mac);
  <> outd(guest_features, guest_features_port);

  // Tell the device that we are finalized on our feature decisions.
  <> outb(as<U8>(device_acknowledged | device_driver | device_features_ok),
          device_status_port);

  U64 device_status := as<U64>(inb(device_status_port));
  if (device_status != (device_acknowledged | device_driver | device_features_ok)) {
    <> write_bytes(#"Device did not like our selected features: ");
    <> write_hex_U64(device_status);
    <> write_bytes(#"\r\n");

    return 1;
  }



  U64 queue_size1 := 0;
  U64 queue_size2 := 0;

  U64 queue_num := 0;
  while (queue_num < 2) {
    <> outw(as<U16>(queue_num), queue_select_port);
    U64 queue_size := as<U64>(inw(queue_size_port));
    if ((queue_size != #x1000) && (queue_size != #x100)) {
      <> write_bytes(#"Queue size is not 256 or 4096: ");
      <> write_hex_U64(queue_size);
      <> write_bytes(#"\r\n");

      return 1;
    }

    if (queue_num == 0) {
      queue_size1 := queue_size;
    } else if (queue_num == 1) {
      queue_size2 := queue_size;
    }

    queue_num := queue_num + 1;
  }

  if (queue_size1 != queue_size2) {
    <> write_bytes(#"Queue sizes need to match");
    return 1;
  }

  U64 queue_size := queue_size1;
  Boolean use_large_queues := (queue_size == #x1000);

  U64 net_queue_byte_size := (256 * 16) + (4096) + 6 + (256 * 8);
  if (use_large_queues) {
    net_queue_byte_size := (4096 * 16) + (4096 * 3) + 6 + (4096 * 8);
  }

  U8[]* raw_recv_queue := as<U8[]*>(net_recv_queue_small);
  U8[]* raw_send_queue := as<U8[]*>(net_send_queue_small);
  if (use_large_queues) {
    raw_recv_queue := as<U8[]*>(net_recv_queue_large);
    raw_send_queue := as<U8[]*>(net_send_queue_large);
  }

  <> memset(raw_recv_queue, as<U8>(0), net_queue_byte_size);
  <> memset(raw_send_queue, as<U8>(0), net_queue_byte_size);

  U64 recv_queue_addr := as<U64>(raw_recv_queue);
  U64 send_queue_addr := as<U64>(raw_send_queue);

  // Tell the device about our queues
  <> outw(as<U16>(0), queue_select_port);
  <> outd(as<U32>(recv_queue_addr >> 12), queue_address_port);

  <> outw(as<U16>(1), queue_select_port);
  <> outd(as<U32>(send_queue_addr >> 12), queue_address_port);

  // Tell the device that we are ready!
  <> outb(as<U8>(device_acknowledged | device_driver | device_features_ok | device_driver_ok),
          device_status_port);
  device_status := as<U64>(inb(device_status_port));
  if (device_status != (device_acknowledged | device_driver | device_features_ok | device_driver_ok)) {
    <> write_bytes(#"Device didn't like our queues: ");
    <> write_hex_U64(device_status);
    <> write_bytes(#"\r\n");

    return 1;
  }

  *net_queue_size <- as<U16>(queue_size);
  if (use_large_queues) {
    *net_send_available_index <- (net_send_queue_large->&available)->&index;
    *net_send_available_ring  <- (net_send_queue_large->&available)->&ring;
    *net_send_buffer_infos    <- (net_send_queue_large->&buffers);
    *net_send_used_index      <- (net_send_queue_large->&used)->&index;
    *net_recv_available_index <- (net_recv_queue_large->&available)->&index;
    *net_recv_available_ring  <- (net_recv_queue_large->&available)->&ring;
    *net_recv_buffer_infos    <- (net_recv_queue_large->&buffers);
    *net_recv_used_index      <- (net_recv_queue_large->&used)->&index;
    *net_recv_used_ring       <- (net_recv_queue_large->&used)->&ring;
  } else {
    *net_send_available_index <- (net_send_queue_small->&available)->&index;
    *net_send_available_ring  <- (net_send_queue_small->&available)->&ring;
    *net_send_buffer_infos    <- (net_send_queue_small->&buffers);
    *net_send_used_index      <- (net_send_queue_small->&used)->&index;
    *net_recv_available_index <- (net_recv_queue_small->&available)->&index;
    *net_recv_available_ring  <- (net_recv_queue_small->&available)->&ring;
    *net_recv_buffer_infos    <- (net_recv_queue_small->&buffers);
    *net_recv_used_index      <- (net_recv_queue_small->&used)->&index;
    *net_recv_used_ring       <- (net_recv_queue_small->&used)->&ring;
  }
  <> write_bytes(#"Network code done\r\n");
  return 0;
}

#:define_struct TaskDescriptor {
  U64 stack_pointer;
  TaskDescriptor* next;
  U32 state;
}

#:define_global TaskDescriptor root_task
#:define_global TaskDescriptor* current_task

#:define_function
U64 initializeScheduler() {
  <> write_bytes(#"Scheduler code\r\n");

  // Initialize root_task
  *root_task->&stack_pointer <- 0;
  *root_task->&next <- root_task;
  *root_task->&state <- as<U32>(0); // Runnable

  // Initialize the current task as the root_task;
  *current_task <- root_task;

  <> write_bytes(#"Scheduler code done\r\n");
  return 0;
}

#:define_function
U64 scheduler_start_task((-> U64) func) {
  <> enable_interrupts();

  <> func();
}

#:define_function
U64 add_task(TaskDescriptor* task, U64 stack_address, (-> U64) start_func) {

  // Push initial values onto the stack.
  U64 stack_pointer := stack_address;

  // First return address
  stack_pointer := stack_pointer - 8;
  *(as<U64*>(stack_pointer)) <- as<U64[]*>(scheduler_start_task)->[1];
  // Setup initial registers.
  U64 i := 0;
  while (i < 15) {
    U64 val := 0;
    if (i == 6) { // rdi
      val := as<U64>(start_func);
    }

    stack_pointer := stack_pointer - 8;
    *(as<U64*>(stack_pointer)) <- val;
    i := i + 1;
  }

  *task->&stack_pointer <- stack_pointer;

  // Add the task and mark as runnable.
  *task->&state <- as<U32>(0); // Runnable
  *task->&next <- (*current_task)->next;
  *((*current_task)->&next) <- task;

  return 0;
}

#:define_global TaskDescriptor serial_task
#:define_global #:alignment_bits 12 U8[8192] serial_task_stack
#:define_global TaskDescriptor network_task
#:define_global #:alignment_bits 12 U8[8192] network_task_stack

#:define_function
U64 addInitialTasks() {
  <> write_bytes(#"Initial tasks\r\n");

  <> add_task(serial_task, as<U64>(serial_task_stack->&[8192]),
                                   serialTaskStart);
  <> add_task(network_task, as<U64>(network_task_stack->&[8192]),
                                   networkTaskStart);
  <> write_bytes(#"Initial tasks done\r\n");
  return 0;
}


#:define_function
U64 runSchedulerLoop() {
  while (1 != 0) {
    <> disable_interrupts();
    // 0 for input = Runnable, 0 for output = no other Runnable tasks
    while (yield(as<U32>(0))) {}
    <> enable_interrupts_and_halt();
  }
}

// Marks all the tasks runnable. Called by interrupt handlers.
#:define_function
U64 markAllRunnable() {
  TaskDescriptor* task := *current_task;
  *task->&state <- as<U32>(0); // Runnable
  task := task->next;
  while (as<U64>(task) != as<U64>(*current_task)) {
    *task->&state <- as<U32>(0); // Runnable
    task := task->next;
  }
  return 0;
}


#:define_function
Boolean yield(U32 new_old_state) {
  TaskDescriptor* old_task := *current_task;
  TaskDescriptor* new_task := old_task->next;

  while ((as<U64>(new_task) != as<U64>(old_task))
         && (as<U64>(new_task->state) != 0)) {
    new_task := new_task->next;
  }

  Boolean ret_val := (0 == 1);
  if (as<U64>(new_task) != as<U64>(old_task)) {
    ret_val := (1 == 1);
    *old_task->&state <- new_old_state;
    *current_task <- new_task;
    <> switch_stack(old_task->&stack_pointer, new_task->&stack_pointer);
  }

  return ret_val;
}

#:define_function
U64 postBootServices(RsdpDescriptor* rsdp_descriptor) {
  // UEFI is now finished.
  // Start initializing sub systems.

  // Clear screen/formatting
  <> write_bytes(#"\x1bc");

  <> disable_apic();

  <> initializeIdt();
  <> initializeSerial();
  <> initializePic();

  // Print out machine information from the RSDP.
  <> examine_rsdp(rsdp_descriptor);

  if ((initializeNetwork()) != 0) {
    <> write_bytes(#"Network initialization failed\r\n");
    return 1;
  }

  <> initializeScheduler();
  <> addInitialTasks();
  <> enable_interrupts();

  <> welcomeMessage();
  // Run the main OS loop
  <> runSchedulerLoop();
}

#:define_function
U64 main(U64 image_handle, EfiSystemTable* st) {
  // Find the RSDP descriptor which is the root of all the ACPI tables.
  RsdpDescriptor* rsdp_descriptor := find_rsdp(st);
  if (as<U64>(rsdp_descriptor) == 0) {
    return 1;
  }

  U64 s := 0;
  s := exitBootServices(image_handle, st);
  if (s != 0) { return s; }

  s := postBootServices(rsdp_descriptor);
  if (s != 0) { return s; }

  return 0;
}

#:define_struct PacketData {}

#:define_struct VirtioNetHeader {
  U8[10] header;
  PacketData data;
}

#:define_struct BigEndianU16 {
  U8 byte0;
  U8 byte1;
}

#:define_struct MacAddress {
  U8[6] octets;
}

#:define_struct EthernetHeader {
  MacAddress destination_mac;
  MacAddress source_mac;
  BigEndianU16 ethertype;
  PacketData data;
}

#:define_struct IpAddress {
  U8[4] octets;
}


#:define_struct IpHeader {
  U8 version_header_length;
  U8 dcsp_ecn;
  BigEndianU16 total_length;
  BigEndianU16 identification;
  BigEndianU16 flags_fragment_offset;
  U8 time_to_live;
  U8 protocol;
  BigEndianU16 header_checksum;
  IpAddress source_ip;
  IpAddress destination_ip;
  PacketData data;
}

#:define_struct UdpHeader {
  BigEndianU16 source_port;
  BigEndianU16 destination_port;
  BigEndianU16 length;
  BigEndianU16 checksum;
  PacketData data;
}


// This struct assumes that the sizing is consistent with IPv4/Ethernet
// ARP packets.
#:define_struct ArpPacket {
  BigEndianU16 hardware_type;
  BigEndianU16 protocol_type;
  U8 hardware_length;
  U8 protocol_length;
  BigEndianU16 operation_type;
  MacAddress sender_hardware_address;
  IpAddress sender_protocol_address;
  MacAddress target_hardware_address;
  IpAddress target_protocol_address;
}


#:define_struct BytesLayout {
  U64* descriptor;
  U64 length;
  PacketData data;
}

#:define_global #:alignment_bits 12 VirtioQueue256 net_send_queue_small
#:define_global #:alignment_bits 12 VirtioQueue256 net_recv_queue_small

#:define_global #:alignment_bits 12 VirtioQueue4096 net_send_queue_large
#:define_global #:alignment_bits 12 VirtioQueue4096 net_recv_queue_large

#:define_global #:alignment_bits 12 VirtioBuffer[4096] net_send_buffers
#:define_global #:alignment_bits 12 VirtioBuffer[4096] net_recv_buffers

#:define_global U16    net_base_port
#:define_global U16    net_queue_size
#:define_global U16*   net_send_available_index
#:define_global U16[]* net_send_available_ring
#:define_global VirtioQueueBufferInfo[]* net_send_buffer_infos
#:define_global U16*   net_send_used_index
#:define_global U16*   net_recv_available_index
#:define_global U16[]* net_recv_available_ring
#:define_global VirtioQueueBufferInfo[]* net_recv_buffer_infos
#:define_global U16*   net_recv_used_index
#:define_global VirtioQueueUsedRingInfo[]* net_recv_used_ring

#:define_function
U64 sendUdpPacket(U16 dest_port) {
  <> write_bytes(#"Sending Yaspl UDP Packet\r\n");

  U16 isr_status_port    := as<U16>(as<U64>(*net_base_port) + #x13);
  U16 queue_notify_port := as<U16>(as<U64>(*net_base_port) + #x10);

  U64 index := as<U64>(**net_send_available_index);

  U64 i := index % as<U64>(*net_queue_size);
  VirtioNetHeader* virtio_header := as<VirtioNetHeader*>(net_send_buffers->&[i]);

  U64 j := 0;
  while (j < 10) {
    *(virtio_header->&header)->&[i] <- as<U8>(0);
    j := j + 1;
  }

  EthernetHeader* ethernet_header := as<EthernetHeader*>(virtio_header->&data);
  *((ethernet_header->&destination_mac)->&octets)->&[0] <- as<U8>(#x52);
  *((ethernet_header->&destination_mac)->&octets)->&[1] <- as<U8>(#x55);
  *((ethernet_header->&destination_mac)->&octets)->&[2] <- as<U8>(#x0a);
  *((ethernet_header->&destination_mac)->&octets)->&[3] <- as<U8>(#x00);
  *((ethernet_header->&destination_mac)->&octets)->&[4] <- as<U8>(#x02);
  *((ethernet_header->&destination_mac)->&octets)->&[5] <- as<U8>(#x02);

  *((ethernet_header->&source_mac)->&octets)->&[0] <- as<U8>(#x52);
  *((ethernet_header->&source_mac)->&octets)->&[1] <- as<U8>(#x54);
  *((ethernet_header->&source_mac)->&octets)->&[2] <- as<U8>(#x00);
  *((ethernet_header->&source_mac)->&octets)->&[3] <- as<U8>(#x12);
  *((ethernet_header->&source_mac)->&octets)->&[4] <- as<U8>(#x34);
  *((ethernet_header->&source_mac)->&octets)->&[5] <- as<U8>(#x56);

  *(ethernet_header->&ethertype)->&byte0 <- as<U8>(#x08);
  *(ethernet_header->&ethertype)->&byte1 <- as<U8>(#x00);

  Bytes response := #"abcdefghijklmnop\n";
  U64 response_length := 17;
  BytesLayout* response_raw := as<BytesLayout*>(response);

  IpHeader* ip_header := as<IpHeader*>(ethernet_header->&data);
  *ip_header->&version_header_length <- as<U8>(#x45);
  *ip_header->&dcsp_ecn <- as<U8>(#x00);
  U64 udp_header_size := 8;
  U64 ip_header_size := 20;
  U64 total_length := ip_header_size + udp_header_size + response_length;
  *(ip_header->&total_length)->&byte0 <- as<U8>((total_length >> 8) & #xff);
  *(ip_header->&total_length)->&byte1 <- as<U8>((total_length >> 0) & #xff);
  *(ip_header->&flags_fragment_offset)->&byte0 <- as<U8>(0);
  *(ip_header->&flags_fragment_offset)->&byte1 <- as<U8>(0);
  *ip_header->&time_to_live <- as<U8>(64);
  *ip_header->&protocol <- as<U8>(17); // UDP
  *(ip_header->&header_checksum)->&byte0 <- as<U8>(#x62);
  *(ip_header->&header_checksum)->&byte1 <- as<U8>(#xb0);
  *((ip_header->&source_ip)->&octets)->&[0] <- as<U8>(10);
  *((ip_header->&source_ip)->&octets)->&[1] <- as<U8>(0);
  *((ip_header->&source_ip)->&octets)->&[2] <- as<U8>(2);
  *((ip_header->&source_ip)->&octets)->&[3] <- as<U8>(15);
  *((ip_header->&destination_ip)->&octets)->&[0] <- as<U8>(10);
  *((ip_header->&destination_ip)->&octets)->&[1] <- as<U8>(0);
  *((ip_header->&destination_ip)->&octets)->&[2] <- as<U8>(2);
  *((ip_header->&destination_ip)->&octets)->&[3] <- as<U8>(2);

  UdpHeader* udp_header := as<UdpHeader*>(ip_header->&data);
  *(udp_header->&source_port)->&byte0 <- as<U8>(0);
  *(udp_header->&source_port)->&byte1 <- as<U8>(7);
  *(udp_header->&destination_port)->&byte0 <- as<U8>((as<U64>(dest_port) >> 8) & #xff);
  *(udp_header->&destination_port)->&byte1 <- as<U8>((as<U64>(dest_port) >> 0) & #xff);
  U64 udp_packet_length := udp_header_size + response_length;
  *(udp_header->&length)->&byte0 <- as<U8>((udp_packet_length >> 8) & #xff);
  *(udp_header->&length)->&byte1 <- as<U8>((udp_packet_length >> 0) & #xff);
  *(udp_header->&checksum)->&byte0 <- as<U8>(0);
  *(udp_header->&checksum)->&byte1 <- as<U8>(0);

  j := 0;
  while (j < response_length) {
    *as<U8[]*>(udp_header->&data)->&[j] <- (as<U8[]*>(response_raw->&data))->[j];
    j := j + 1;
  }

  U64 ethernet_header_size := 14;
  U64 virtio_net_header_size := 10;


  *((*net_send_buffer_infos)->&[i])->&address <- as<U64>(net_send_buffers->&[i]);
  *((*net_send_buffer_infos)->&[i])->&length <-
    as<U32>(response_length + udp_header_size + ip_header_size + ethernet_header_size +
            virtio_net_header_size);
  *((*net_send_buffer_infos)->&[i])->&flags <- as<U16>(0);
  *((*net_send_buffer_infos)->&[i])->&next <- as<U16>(0);

  *(*net_send_available_ring)->&[i] <- as<U16>(i);
  *(*net_send_available_index) <- as<U16>(as<U64>(**net_send_available_index) + 1);

  // Tell the device that queue 1 (send) has a new buffer.
  <> outw(as<U16>(1), queue_notify_port);


  <> disable_interrupts();
  Boolean msg_recieved := 1 == 0;
  while (!msg_recieved) {
    // Read the interrupt status register to clear the interrupt state.
    <> inb(isr_status_port);
    msg_recieved := as<U64>(**net_send_used_index) == ((index + 1) & #xffff);
    if (!msg_recieved) {
      <> yield(as<U32>(1)); // Blocked
    }
  }
  <> enable_interrupts();



  return 0;
}


#:define_function
U64 sendArpPacket() {
  <> write_bytes(#"Sending Yaspl Arp Packet\r\n");

  U16 isr_status_port    := as<U16>(as<U64>(*net_base_port) + #x13);
  U16 queue_notify_port := as<U16>(as<U64>(*net_base_port) + #x10);

  U64 index := as<U64>(**net_send_available_index);
  U64 i := index % as<U64>(*net_queue_size);


  VirtioNetHeader* virtio_header := as<VirtioNetHeader*>(net_send_buffers->&[i]);

  U64 j := 0;
  while (j < 10) {
    *(virtio_header->&header)->&[i] <- as<U8>(0);
    j := j + 1;
  }

  EthernetHeader* ethernet_header := as<EthernetHeader*>(virtio_header->&data);
  *((ethernet_header->&destination_mac)->&octets)->&[0] <- as<U8>(#x52);
  *((ethernet_header->&destination_mac)->&octets)->&[1] <- as<U8>(#x55);
  *((ethernet_header->&destination_mac)->&octets)->&[2] <- as<U8>(#x0a);
  *((ethernet_header->&destination_mac)->&octets)->&[3] <- as<U8>(#x00);
  *((ethernet_header->&destination_mac)->&octets)->&[4] <- as<U8>(#x02);
  *((ethernet_header->&destination_mac)->&octets)->&[5] <- as<U8>(#x02);

  *((ethernet_header->&source_mac)->&octets)->&[0] <- as<U8>(#x52);
  *((ethernet_header->&source_mac)->&octets)->&[1] <- as<U8>(#x54);
  *((ethernet_header->&source_mac)->&octets)->&[2] <- as<U8>(#x00);
  *((ethernet_header->&source_mac)->&octets)->&[3] <- as<U8>(#x12);
  *((ethernet_header->&source_mac)->&octets)->&[4] <- as<U8>(#x34);
  *((ethernet_header->&source_mac)->&octets)->&[5] <- as<U8>(#x56);

  *(ethernet_header->&ethertype)->&byte0 <- as<U8>(#x08);
  *(ethernet_header->&ethertype)->&byte1 <- as<U8>(#x06);

  ArpPacket* arp_packet := as<ArpPacket*>(ethernet_header->&data);

  *(arp_packet->&hardware_type)->&byte0 <- as<U8>(#x00);
  *(arp_packet->&hardware_type)->&byte1 <- as<U8>(#x01);
  *(arp_packet->&protocol_type)->&byte0 <- as<U8>(#x08);
  *(arp_packet->&protocol_type)->&byte1 <- as<U8>(#x00);
  *arp_packet->&hardware_length <- as<U8>(6);
  *arp_packet->&protocol_length <- as<U8>(4);
  *(arp_packet->&operation_type)->&byte0 <- as<U8>(#x00);
  *(arp_packet->&operation_type)->&byte1 <- as<U8>(#x02);
  *((arp_packet->&sender_hardware_address)->&octets)->&[0] <- as<U8>(#x52);
  *((arp_packet->&sender_hardware_address)->&octets)->&[1] <- as<U8>(#x54);
  *((arp_packet->&sender_hardware_address)->&octets)->&[2] <- as<U8>(#x00);
  *((arp_packet->&sender_hardware_address)->&octets)->&[3] <- as<U8>(#x12);
  *((arp_packet->&sender_hardware_address)->&octets)->&[4] <- as<U8>(#x34);
  *((arp_packet->&sender_hardware_address)->&octets)->&[5] <- as<U8>(#x56);

  *((arp_packet->&sender_protocol_address)->&octets)->&[0] <- as<U8>(#x0a);
  *((arp_packet->&sender_protocol_address)->&octets)->&[1] <- as<U8>(#x00);
  *((arp_packet->&sender_protocol_address)->&octets)->&[2] <- as<U8>(#x02);
  *((arp_packet->&sender_protocol_address)->&octets)->&[3] <- as<U8>(#x0f);

  *((arp_packet->&target_hardware_address)->&octets)->&[0] <- as<U8>(#x52);
  *((arp_packet->&target_hardware_address)->&octets)->&[1] <- as<U8>(#x55);
  *((arp_packet->&target_hardware_address)->&octets)->&[2] <- as<U8>(#x0a);
  *((arp_packet->&target_hardware_address)->&octets)->&[3] <- as<U8>(#x00);
  *((arp_packet->&target_hardware_address)->&octets)->&[4] <- as<U8>(#x02);
  *((arp_packet->&target_hardware_address)->&octets)->&[5] <- as<U8>(#x02);
  *((arp_packet->&target_protocol_address)->&octets)->&[0] <- as<U8>(#x0a);
  *((arp_packet->&target_protocol_address)->&octets)->&[1] <- as<U8>(#x00);
  *((arp_packet->&target_protocol_address)->&octets)->&[2] <- as<U8>(#x02);
  *((arp_packet->&target_protocol_address)->&octets)->&[3] <- as<U8>(#x02);


  U64 arp_packet_size := 28;
  U64 ethernet_header_size := 14;
  U64 virtio_net_header_size := 10;

  *((*net_send_buffer_infos)->&[i])->&address <- as<U64>(net_send_buffers->&[i]);
  *((*net_send_buffer_infos)->&[i])->&length <-
    as<U32>(arp_packet_size + ethernet_header_size + virtio_net_header_size);
  *((*net_send_buffer_infos)->&[i])->&flags <- as<U16>(0);
  *((*net_send_buffer_infos)->&[i])->&next <- as<U16>(0);

  *(*net_send_available_ring)->&[i] <- as<U16>(i);
  *(*net_send_available_index) <- as<U16>(as<U64>(**net_send_available_index) + 1);

  // Tell the device that queue 1 (send) has a new buffer.
  <> outw(as<U16>(1), queue_notify_port);

  <> disable_interrupts();
  Boolean msg_recieved := 1 == 0;
  while (!msg_recieved) {
    // Read the interrupt status register to clear the interrupt state.
    <> inb(isr_status_port);
    msg_recieved := as<U64>(**net_send_used_index) == ((index + 1) & #xffff);
    if (!msg_recieved) {
      <> yield(as<U32>(1)); // Blocked
    }
  }
  <> enable_interrupts();

  <> write_bytes(#"Done sending Yaspl Arp Packet\r\n");
  return 0;
}

#:define_function
U16 be_u16_to_le(BigEndianU16* be) {
  return as<U16>((as<U64>(be->byte0) << 8) |
                 (as<U64>(be->byte1) << 0));
}

#:define_function
U64 waitNetworkInterrupt() {
  U16 isr_status_port    := as<U16>(as<U64>(*net_base_port) + #x13);
  U16 queue_notify_port  := as<U16>(as<U64>(*net_base_port) + #x10);

  U64 index := as<U64>(**net_recv_available_index);

  U64 i := index % as<U64>(*net_queue_size);

  *((*net_recv_buffer_infos)->&[i])->&address <- as<U64>(net_recv_buffers->&[i]);
  *((*net_recv_buffer_infos)->&[i])->&length  <- as<U32>(4096);
  *((*net_recv_buffer_infos)->&[i])->&flags   <- as<U16>(2); // Device writable
  *((*net_recv_buffer_infos)->&[i])->&next    <- as<U16>(0);

  *(*net_recv_available_ring)->&[i] <- as<U16>(i);
  *(*net_recv_available_index) <- as<U16>(as<U64>(**net_recv_available_index) + 1);

  // Tell the device that queue 0 (recv) has a new buffer.
  <> outw(as<U16>(0), queue_notify_port);

  <> disable_interrupts();
  Boolean msg_recieved := 1 == 0;
  while (!msg_recieved) {
    // Read the interrupt status register to clear the interrupt state.
    <> inb(isr_status_port);
    msg_recieved := as<U64>(**net_recv_used_index) == ((index + 1) & #xffff);
    if (!msg_recieved) {
      <> yield(as<U32>(1)); // Blocked
    }
  }
  <> enable_interrupts();


  U64 ring_i := index % as<U64>(*net_queue_size);
  U64 buffer_i := as<U64>(((*net_recv_used_ring)->&[ring_i])->index);
  if (buffer_i != ring_i) {
    <> panic_msg(#"Buffer doesn't match ring");
  }
  U64 remaining_packet_length := as<U64>(((*net_recv_used_ring)->&[ring_i])->length);
  U8[]* raw_buffer := as<U8[]*>(((*net_recv_buffer_infos)->&[buffer_i])->address);

  U64 virtio_net_header_size := 10;
  U64 ethernet_header_size := 14;


  if (remaining_packet_length < virtio_net_header_size) {
    <> panic_msg(#"Packet length shorter than virtio net header size");
  }
  VirtioNetHeader* virtio_header := as<VirtioNetHeader*>(raw_buffer);
  remaining_packet_length := remaining_packet_length - virtio_net_header_size;

  if (remaining_packet_length < ethernet_header_size) {
    <> panic_msg(#"Packet shorter than ethernet header");
  }
  EthernetHeader* ethernet_header := as<EthernetHeader*>(virtio_header->&data);
  remaining_packet_length := remaining_packet_length - ethernet_header_size;

  if ((as<U64>((ethernet_header->&ethertype)->byte0) == #x08) &&
      (as<U64>((ethernet_header->&ethertype)->byte1) == #x06)) {
    U64 arp_packet_size := 28;
    if (remaining_packet_length < arp_packet_size) {
      <> panic_msg(#"Packet shorter than arp packet size");
    }
    ArpPacket* arp_packet := as<ArpPacket*>(ethernet_header->&data);
    remaining_packet_length := remaining_packet_length - arp_packet_size;

    if (remaining_packet_length != 0) {
      <> panic();
    }

    if (as<U64>(be_u16_to_le(arp_packet->&hardware_type)) != 1) {
      <> panic_msg(#"Arp Packet has bad hardware type");
    }
    if (as<U64>(be_u16_to_le(arp_packet->&protocol_type)) != #x0800) {
      <> panic_msg(#"Arp Packet has bad protocol type");
    }
    if (as<U64>(arp_packet->hardware_length) != 6) {
      <> panic_msg(#"Arp Packet has bad hardware length");
    }
    if (as<U64>(arp_packet->protocol_length) != 4) {
      <> panic_msg(#"Arp Packet has bad protocol length");
    }


    <> sendArpPacket();
  } else if ((as<U64>((ethernet_header->&ethertype)->byte0) == #x08) &&
             (as<U64>((ethernet_header->&ethertype)->byte1) == #x00)) {
    <> write_bytes(#"IPv4 packet\r\n");

    U64 udp_header_size := 8;
    U64 ip_header_size := 20;

    if (remaining_packet_length < ip_header_size) {
        <> panic();
    }
    IpHeader* ip_header := as<IpHeader*>(ethernet_header->&data);

    if (remaining_packet_length != as<U64>(be_u16_to_le(ip_header->&total_length))) {
       <> panic();
    }

    U64 header_length := as<U64>(ip_header->version_header_length) & #x0F;
    if (header_length != 5) {
      <> panic();
    }
    remaining_packet_length := remaining_packet_length - ip_header_size;

    if (remaining_packet_length < udp_header_size) {
      <> panic();
    }
    UdpHeader* udp_header := as<UdpHeader*>(ip_header->&data);

    if (remaining_packet_length != as<U64>(be_u16_to_le(udp_header->&length))) {
      <> panic();
    }
    remaining_packet_length := remaining_packet_length - udp_header_size;

    <> sendUdpPacket(be_u16_to_le(udp_header->&source_port));
  } else {
    <> write_bytes(#"Unknown packet type\r\n");
  }
  return 0;
}

#:define_function
U64 disable_apic() {
  U64 apic_base_value := read_msr(#x1b);
  <> write_bytes(#"APIC MSR value: ");
  <> write_hex_U64(apic_base_value);
  <> write_bytes(#"\r\n");

  U64 write_value := apic_base_value - #x800;
  <> write_msr(write_value, #x1b);
  <> write_bytes(#"Written APIC MSR value: ");
  <> write_hex_U64(write_value);
  <> write_bytes(#"\r\n");

  U64 new_apic_base_value := read_msr(#x1b);
  <> write_bytes(#"Reread APIC MSR value: ");
  <> write_hex_U64(new_apic_base_value);
  <> write_bytes(#"\r\n");

  return 0;
}

#:define_struct RsdpDescriptor {
  U8[8] signature;
  U8 checksum;
  U8[6] oem_id;
  U8 revision;
  U32 rsdt_address;
  U32 length;
  U64 xsdt_address;
  U8 extended_checksum;
  U8[3] reserved;
}

#:define_function
Boolean is_efi_acpi_table_guid(EfiGuid* guid) {
  return (as<U64>(guid->data1) == #x8868e871) &&
         (as<U64>(guid->data2) == #xe4f1) &&
         (as<U64>(guid->data3) == #x11d3) &&
         (as<U64>((guid->&data4)->[0]) == #xbc) &&
         (as<U64>((guid->&data4)->[1]) == #x22) &&
         (as<U64>((guid->&data4)->[2]) == #x00) &&
         (as<U64>((guid->&data4)->[3]) == #x80) &&
         (as<U64>((guid->&data4)->[4]) == #xc7) &&
         (as<U64>((guid->&data4)->[5]) == #x3c) &&
         (as<U64>((guid->&data4)->[6]) == #x88) &&
         (as<U64>((guid->&data4)->[7]) == #x81);
}

#:define_function
RsdpDescriptor* find_rsdp(EfiSystemTable* st) {
  EfiSimpleTextOutputProtocol* output := st->console_out;

  U64 i := 0;
  while (i < st->number_of_table_entries) {
    EfiConfigurationTable* table := (st->configuration_tables)->&[i];

    if (is_efi_acpi_table_guid(table->&guid)) {
      <> reset_efi_writer();
      <> efi_writer_add_bytes(#"Found RSDP");
      <> efi_writer_finish_line();
      <> terminate_efi_writer();
      <> call_ms2(as<U64>(output->output_string), as<U64>(output), as<U64>(efi_output_buffer));
      return as<RsdpDescriptor*>(table->address);
    }

    i := i + 1;
  }

  <> reset_efi_writer();
  <> efi_writer_add_bytes(#"Did not find RSDP");
  <> efi_writer_finish_line();
  <> terminate_efi_writer();
  <> call_ms2(as<U64>(output->output_string), as<U64>(output), as<U64>(efi_output_buffer));

  return as<RsdpDescriptor*>(0);
}

#:define_struct AcpiSdtHeader {
  U8[4] signature;
  U32 length;
  U8 revision;
  U8 checksum;
  U8[6] oem_id;
  U8[8] oem_table_id;
  U32 oem_revision;
  U32 creator_id;
  U32 creator_revision;
}

#:define_struct XSDT {
  AcpiSdtHeader header;
  PacketData other_tables;
}

#:define_struct ConfigSpaceAllocation {
  U64 base_address;
  U16 group_number;
  U8  start_bus_number;
  U8  end_bus_number;
  U32 reserved;
}


#:define_struct MCFG {
  AcpiSdtHeader header;
  U64 reserved;
  PacketData config_space_allocations;
}


#:define_struct PciHeader0 {
  U16 vendor_id;
  U16 device_id;
  U16 command;
  U16 status;
  U8 revison;
  U8 prog_if;
  U8 subclass;
  U8 class;
  U8 cache_line_size;
  U8 latency_timer;
  U8 header_type;
  U8 bist;
  U32[6] base_address;
  U32 cis_pointer;
  U16 subsystem_vendor_id;
  U16 subsystem_id;
  U32 expansion_rom_base_address;
  U8 capabilities_pointer;
  U8[7] reserved;
  U8 interrupt_line;
  U8 interrupt_pin;
  U8 min_grant;
  U8 max_latency;
}

#:define_function
U16 find_network_device() {

  // Try reading config through old api.
  U64 i := 0;
  U64 device_num := 32;
  while (i < 32) {
    U32 vendor_and_device := read_pci_config(as<U8>(0), as<U8>(i), as<U8>(0), as<U8>(0));
    <> write_bytes(#"PCI read (");
    <> write_hex_U8(as<U8>(i));
    <> write_bytes(#"): ");
    <> write_hex_U32(vendor_and_device);
    <> write_bytes(#"\r\n");

    // This is the vendor and device id for a Virtio Network Device
    if (as<U64>(vendor_and_device) == #x10001af4) {
      device_num := i;
    }

    i := i + 1;
  }

  // Return early if no such device found.
  if (device_num == 32) {
    return as<U16>(0);
  }

  // Print out the full configuration space of the device.
  i := 0;
  while (i < 256) {
    U32 value := read_pci_config(as<U8>(0), as<U8>(device_num), as<U8>(0), as<U8>(i));
    <> write_bytes(#"PCI value read (");
    <> write_hex_U8(as<U8>(i));
    <> write_bytes(#"): ");
    <> write_hex_U32(value);
    <> write_bytes(#"\r\n");
    i := i + 4;
  }

  U32 bar1_value := read_pci_config(as<U8>(0), as<U8>(device_num), as<U8>(0), as<U8>(#x10));
  <> write_bytes(#"Bar1 value: ");
  <> write_hex_U32(bar1_value);
  <> write_bytes(#"\r\n");


  // TODO validate that this is actually in the U16 range
  return as<U16>(as<U64>(bar1_value) - 1);
}


#:define_function
U64 examine_rsdp(RsdpDescriptor* rsdp) {

  <> write_bytes(#"RSDP signature (RSD PTR ): ");
  <> write_raw_buffer(rsdp->&signature, 8);
  <> write_bytes(#"\r\n");

  XSDT* xsdt := as<XSDT*>(rsdp->xsdt_address);

  <> write_bytes(#"XSDT signature (XSDT): ");
  <> write_raw_buffer((xsdt->&header)->&signature, 4);
  <> write_bytes(#"\r\n");

  U64 acpi_sdt_header_size := 36;
  U64 num_tables := (as<U64>((xsdt->&header)->length) - acpi_sdt_header_size) / 8;

  <> write_bytes(#"Found ");
  <> write_hex_U64(num_tables);
  <> write_bytes(#" ACPI Tables\r\n");

  AcpiSdtHeader*[]* other_tables := as<AcpiSdtHeader*[]*>(xsdt->&other_tables);

  U64 i := 0;
  while (i < num_tables) {
    AcpiSdtHeader* sdt := other_tables->[i];
    <> write_bytes(#"Table signature: ");
    <> write_raw_buffer(sdt->&signature, 4);
    <> write_bytes(#"\r\n");
    i := i + 1;
  }

  // Disabled code that prints the MCFG table.
  // GCE doesn't have this so we need to go a different way.
  if (1 == 0) {
    MCFG* mcfg := as<MCFG*>(other_tables->[3]);
    <> write_bytes(#"MCFG signature (MCFG): ");
    <> write_raw_buffer((mcfg->&header)->&signature, 4);
    <> write_bytes(#"\r\n");

    <> write_bytes(#"MCFG length: ");
    <> write_hex_U32((mcfg->&header)->length);
    <> write_bytes(#"\r\n");

    U64 num_mcfg_configs := (as<U64>((mcfg->&header)->length) - acpi_sdt_header_size) / 16;

    <> write_bytes(#"Number of MCFG configs: ");
    <> write_hex_U32(as<U32>(num_mcfg_configs));
    <> write_bytes(#"\r\n");

    ConfigSpaceAllocation[]* mcfg_csas :=
      as<ConfigSpaceAllocation[]*>(mcfg->&config_space_allocations);

    i := 0;
    while (i < num_mcfg_configs) {
      ConfigSpaceAllocation* csa := mcfg_csas->&[i];
      <> write_bytes(#"Config Space Base Address: ");
      <> write_hex_U64(csa->base_address);
      <> write_bytes(#"\r\n");
      <> write_bytes(#"Config Space Group: ");
      <> write_hex_U16(csa->group_number);
      <> write_bytes(#"\r\n");
      <> write_bytes(#"Config Space Start Bus Number: ");
      <> write_hex_U8(csa->start_bus_number);
      <> write_bytes(#"\r\n");
      <> write_bytes(#"Config Space End Bus Number: ");
      <> write_hex_U8(csa->end_bus_number);
      <> write_bytes(#"\r\n");
      i := i + 1;
    }

    ConfigSpaceAllocation* csa := mcfg_csas->&[0];

    PciHeader0 * device_header := as<PciHeader0*>((csa->base_address) + (0 << 20) + (2 << 15) + (0 << 12));

    <> write_bytes(#"Device Vendor Id: ");
    <> write_hex_U16(device_header->vendor_id);
    <> write_bytes(#"\r\n");

    <> write_bytes(#"Device Device Id: ");
    <> write_hex_U16(device_header->device_id);
    <> write_bytes(#"\r\n");

    <> write_bytes(#"Base Addresses:");
    <> write_bytes(#"\r\n");
    <> write_hex_U32((device_header->&base_address)->[0]);
    <> write_bytes(#"\r\n");
    <> write_hex_U32((device_header->&base_address)->[1]);
    <> write_bytes(#"\r\n");
    <> write_hex_U32((device_header->&base_address)->[2]);
    <> write_bytes(#"\r\n");
    <> write_hex_U32((device_header->&base_address)->[3]);
    <> write_bytes(#"\r\n");
    <> write_hex_U32((device_header->&base_address)->[4]);
    <> write_bytes(#"\r\n");
    <> write_hex_U32((device_header->&base_address)->[5]);
    <> write_bytes(#"\r\n");

    <> write_bytes(#"Device Subsystem Vendor Id: ");
    <> write_hex_U16(device_header->subsystem_vendor_id);
    <> write_bytes(#"\r\n");

    <> write_bytes(#"Device Subsystem Id: ");
    <> write_hex_U16(device_header->subsystem_id);
    <> write_bytes(#"\r\n");

  }

  return 0;
}

#:define_function
U32 read_pci_config(U8 bus, U8 device, U8 func, U8 offset) {
    U64 address := (as<U64>(bus) << 16) | (as<U64>(device) << 11) | (as<U64>(func) << 8) |
                   as<U64>(offset) | #x80000000;

    // Write out the address
    <> outd(as<U32>(address), as<U16>(#xCF8));
    // Read in the data
    return ind(as<U16>(#xCFC));

}

#:define_function
U64 panic_msg(Bytes msg) {
  <> write_bytes(#"\r\nPANIC: ");
  <> write_bytes(msg);
  <> write_bytes(#"\r\n");
  <> panic();
}

#:define_function
U64 write_ip_address(IpAddress* addr) {
  <> write_hex_byte((addr->&octets)->[0]);
  <> write_bytes(#".");
  <> write_hex_byte((addr->&octets)->[1]);
  <> write_bytes(#".");
  <> write_hex_byte((addr->&octets)->[2]);
  <> write_bytes(#".");
  <> write_hex_byte((addr->&octets)->[3]);
  return 0;
}

#:define_function
U64 write_mac_address(MacAddress* addr) {
  <> write_hex_byte((addr->&octets)->[0]);
  <> write_bytes(#":");
  <> write_hex_byte((addr->&octets)->[1]);
  <> write_bytes(#":");
  <> write_hex_byte((addr->&octets)->[2]);
  <> write_bytes(#":");
  <> write_hex_byte((addr->&octets)->[3]);
  <> write_bytes(#":");
  <> write_hex_byte((addr->&octets)->[4]);
  <> write_bytes(#":");
  <> write_hex_byte((addr->&octets)->[5]);
  return 0;
}


#:define_function
U64 printArpPacket(ArpPacket* arp) {
  <> write_bytes(#"Sender Hardware Address: ");
  <> write_mac_address(arp->&sender_hardware_address);
  <> write_bytes(#"\r\n");

  <> write_bytes(#"Sender Protocol Address: ");
  <> write_ip_address(arp->&sender_protocol_address);
  <> write_bytes(#"\r\n");

  <> write_bytes(#"Target Hardware Address: ");
  <> write_mac_address(arp->&target_hardware_address);
  <> write_bytes(#"\r\n");

  <> write_bytes(#"Target Protocol Address: ");
  <> write_ip_address(arp->&target_protocol_address);
  <> write_bytes(#"\r\n");

  return 0;
}
