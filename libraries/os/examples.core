#:module (os)

#:import_module (prim os)
#:import_module (os read_serial)
#:import_module (os write_serial)
#:import_module (os scheduler)
#:import_module (os efi)


#:define_global U8 serial_counter

#:define_function
U64 serialTaskStart() {
  while (1 > 0) {
    U8 v := read_serial();
    <> write_bytes(#"SerialInput (");
    <> write_hex_byte(*serial_counter);
    <> write_bytes(#"): ");
    <> write_hex_byte(v);
    <> write_bytes(#"\r\n");
    *serial_counter <- as<U8>(as<U64>(*serial_counter) + 1);

    // Send an arp request packet for testing
    <> sendArpRequestPacket();
  }
}


#:define_function
U64 networkTaskStart() {
  while (1 > 0) {
    <> waitNetworkInterrupt();
  }
}

#:define_function
U64 welcomeMessage() {
  <> write_bytes(#"\x1bc");
  <> write_bytes(#"Welcome to Yaspl OS.\r\n");
  return 0;
}


#:define_function
U64 memset(U8[]* memory, U8 value, U64 size) {
  U64 index := 0;
  while (index < size) {
    *memory->&[index] <- value;
    index := index + 1;
  }
  return 0;
}



#:define_struct IdtEntry {
  U16 offset_1;  // offset bits 0..15
  U16 selector;  // a code segment selector in GDT or LDT
  U8  ist;       // bits 0..2 holds Interrupt Stack Table offset, rest of bits zero.
  U8  type_attr; // type and attributes
  U16 offset_2;  // offset bits 16..31
  U32 offset_3;  // offset bits 32..63
  U32 zero;      // reserved
}

#:define_struct IdtDescriptor {
  U16 limit;
  U64 base_address;
}

#:define_global IdtEntry[256] idt_entries
#:define_global IdtDescriptor idt_descriptor


#:define_function
U64 initializeIdt() {
  <> write_bytes(#"IDT code\r\n");
  U64 idt_entry_size := 16;
  <> memset(as<U8[]*>(idt_entries), as<U8>(0), idt_entry_size * 256);
  U64 i := 0;
  while (i < 256) {
    U64 irq_addr := as<U64[]*>(irqfun_default)->[1];
    if (i == 36) {
      irq_addr := as<U64[]*>(irqfun_com1)->[1];
    } else if (i == 43) {
      irq_addr := as<U64[]*>(irqfun_nic)->[1];
    }

    *(idt_entries->&[i])->&offset_1 <- as<U16>(irq_addr & #xffff);
    *(idt_entries->&[i])->&selector <- as<U16>(#x38);
    *(idt_entries->&[i])->&ist <- as<U8>(0);
    *(idt_entries->&[i])->&type_attr <- as<U8>(#x8e);
    *(idt_entries->&[i])->&offset_2 <- as<U16>((irq_addr >> 16) & #xffff);
    *(idt_entries->&[i])->&offset_3 <- as<U32>(irq_addr >> 32);
    *(idt_entries->&[i])->&zero <- as<U32>(0);
    i := i + 1;
  }

  *idt_descriptor->&limit <- as<U16>(idt_entry_size * 256 - 1);
  *idt_descriptor->&base_address <- as<U64>(idt_entries);
  <> lidt(as<U64>(idt_descriptor));
  <> write_bytes(#"IDT code done\r\n");
  return 0;
}

#:define_function
U64 initializeSerial() {
  <> write_bytes(#"Serial code\r\n");

  // #x3F8 is SERIAL_COM1_BASE
  U64 port := #x3F8;

  // Disable all interrupts on the port while setup happens
  <> outb(as<U8>(#x00), as<U16>(port + 1));
  // Enable the DLAB. This changes the meaning of ports 0/1 which allows
  // setting the baud rate divisor.
  <> outb(as<U8>(#x80), as<U16>(port + 3));
  // Set divisor to 3 (low byte) 38400 baud
  <> outb(as<U8>(#x03), as<U16>(port + 0));
  <> outb(as<U8>(#x00), as<U16>(port + 1));

  // Clear the DLAB, and set the protcol as:
  // 8 bits, no parity, one stop bit
  <> outb(as<U8>(#x03), as<U16>(port + 3));

  // Add a 14 byte fifo
  <> outb(as<U8>(#xC7), as<U16>(port + 2));
  // Turn on all featuers in the Modem Status Register
  <> outb(as<U8>(#x0F), as<U16>(port + 4));

  // Enable IRQs on Receive.
  <> outb(as<U8>(#x01), as<U16>(port + 1));

  <> write_bytes(#"Serial code done\r\n");
  return 0;
}

#:define_function
U64 initializePic() {
  <> write_bytes(#"PIC code\r\n");

  // Base port numbers for the Master/Slave PICs.
  U64 pic1 := #x20;
  U64 pic2 := #xA0;
  // Command and data port numbers
  U64 pic1_command := pic1 + 0;
  U64 pic1_data    := pic1 + 1;
  U64 pic2_command := pic2 + 0;
  U64 pic2_data    := pic2 + 1;

  U64 icw1_init := #x10; // This is an initialization command
  U64 icw1_icw4 := #x01; // This initialization uses command word 4
  // Start the initialization sequence (in cascade mode)
  <> outb(as<U8>(icw1_init | icw1_icw4), as<U16>(pic1_command));
  <> outb(as<U8>(icw1_init | icw1_icw4), as<U16>(pic2_command));

  // Set the PICs to use the entries in the IDT range [32, 47).
  U64 offset1 := 32;
  U64 offset2 := 40;
  <> outb(as<U8>(offset1), as<U16>(pic1_data));    // ICW2: Master PIC vector offset
  <> outb(as<U8>(offset2), as<U16>(pic2_data));    // ICW2: Slave PIC vector offset
  // ICW3: tell Master PIC that there is a slave PIC at IRQ2 (0b00000100)
  <> outb(as<U8>(#x04), as<U16>(pic1_data));
  <> outb(as<U8>(#x02), as<U16>(pic2_data));  // ICW3: tell Slave PIC its cascade identity

  // // Set 8086 mode
  U64 icw4_8086 := #x01;
  <> outb(as<U8>(icw4_8086), as<U16>(pic1_data));
  <> outb(as<U8>(icw4_8086), as<U16>(pic2_data));

  // Only enable some interrupts.
  // PIC 1, bit 2: Allow PIC2 through
  // PIC 1, bit 4: COM1 serial port
  U64 pic1_interrupts := #xEB; // ~((1 << 2) | (1 << 4));
  // // PIC 2, bit 3: NIC
  U64 pic2_interrupts := #xF7; // ~(1 << 3);
  // Mask all interrupts that shouldn't be enabled.
  <> outb(as<U8>(pic1_interrupts), as<U16>(pic1_data));
  <> outb(as<U8>(pic2_interrupts), as<U16>(pic2_data));


  <> write_bytes(#"PIC code done\r\n");
  return 0;
}

#:define_struct VirtioQueueBufferInfo {
  U64 address;
  U32 length;
  U16 flags;
  U16 next;
}

#:define_struct VirtioQueue256AvailableInfo {
  U16 flags;
  U16 index;
  U16[256] ring;
  U16 event_index;
}


#:define_struct VirtioQueue4096AvailableInfo {
  U16 flags;
  U16 index;
  U16[4096] ring;
  U16 event_index;
}

#:define_struct VirtioQueueUsedRingInfo {
  U32 index;
  U32 length;
}

#:define_struct VirtioQueue256UsedInfo {
  U16 flags;
  U16 index;
  VirtioQueueUsedRingInfo[256] ring;
  U16 avail_event;
}


#:define_struct VirtioQueue4096UsedInfo {
  U16 flags;
  U16 index;
  VirtioQueueUsedRingInfo[4096] ring;
  U16 avail_event;
}

#:define_struct VirtioQueue256 {
  VirtioQueueBufferInfo[256] buffers;
  VirtioQueue256AvailableInfo available;
  U8[3578] padding;
  VirtioQueue256UsedInfo used;
}

#:define_struct VirtioQueue4096 {
  VirtioQueueBufferInfo[4096] buffers;
  VirtioQueue4096AvailableInfo available;
  U8[4090] padding;
  VirtioQueue4096UsedInfo used;
}



#:define_struct VirtioBuffer {
  U8[4096] bytes;
}

#:define_function
U64 initializeNetwork() {
  <> write_bytes(#"Network code\r\n");

  // Read the device configuration to find the port.
  *net_base_port <- find_network_device();
  if (as<U64>(*net_base_port) == 0) {
    <> write_bytes(#"Couldn't find base port.");

    return 1;
  }

  U64 feature_mac := 5;
  U16 device_features_port := as<U16>(as<U64>(*net_base_port) + #x00);
  U16 guest_features_port  := as<U16>(as<U64>(*net_base_port) + #x04);
  U16 queue_address_port   := as<U16>(as<U64>(*net_base_port) + #x08);
  U16 queue_size_port      := as<U16>(as<U64>(*net_base_port) + #x0c);
  U16 queue_select_port    := as<U16>(as<U64>(*net_base_port) + #x0e);
  U16 device_status_port   := as<U16>(as<U64>(*net_base_port) + #x12);

  U16 mac1_port   := as<U16>(as<U64>(*net_base_port) + #x14);
  U16 mac2_port   := as<U16>(as<U64>(*net_base_port) + #x15);
  U16 mac3_port   := as<U16>(as<U64>(*net_base_port) + #x16);
  U16 mac4_port   := as<U16>(as<U64>(*net_base_port) + #x17);
  U16 mac5_port   := as<U16>(as<U64>(*net_base_port) + #x18);
  U16 mac6_port   := as<U16>(as<U64>(*net_base_port) + #x19);

  U64 device_acknowledged := #x01;
  U64 device_driver       := #x02;
  U64 device_features_ok  := #x08;
  U64 device_driver_ok    := #x04;


  // Acknowledge the device.
  <> outb(as<U8>(device_acknowledged), device_status_port);
  // Tell the device that we know how to drive it.
  <> outb(as<U8>(device_acknowledged | device_driver), device_status_port);

  U64 device_features := as<U64>(ind(device_features_port));
  <> write_bytes(#"Device features: ");
  <> write_hex_U64(device_features);
  <> write_bytes(#"\r\n");
  if ((device_features & (1 << feature_mac)) == 0) {
    <> write_bytes(#"Device features not as expected.");

    return 1;
  }

  U32 guest_features := as<U32>(1 << feature_mac);
  <> outd(guest_features, guest_features_port);

  // Tell the device that we are finalized on our feature decisions.
  <> outb(as<U8>(device_acknowledged | device_driver | device_features_ok),
          device_status_port);

  U64 device_status := as<U64>(inb(device_status_port));
  if (device_status != (device_acknowledged | device_driver | device_features_ok)) {
    <> write_bytes(#"Device did not like our selected features: ");
    <> write_hex_U64(device_status);
    <> write_bytes(#"\r\n");

    return 1;
  }



  U64 queue_size1 := 0;
  U64 queue_size2 := 0;

  U64 queue_num := 0;
  while (queue_num < 2) {
    <> outw(as<U16>(queue_num), queue_select_port);
    U64 queue_size := as<U64>(inw(queue_size_port));
    if ((queue_size != #x1000) && (queue_size != #x100)) {
      <> write_bytes(#"Queue size is not 256 or 4096: ");
      <> write_hex_U64(queue_size);
      <> write_bytes(#"\r\n");

      return 1;
    }

    if (queue_num == 0) {
      queue_size1 := queue_size;
    } else if (queue_num == 1) {
      queue_size2 := queue_size;
    }

    queue_num := queue_num + 1;
  }

  if (queue_size1 != queue_size2) {
    <> write_bytes(#"Queue sizes need to match");
    return 1;
  }

  U64 queue_size := queue_size1;
  Boolean use_large_queues := (queue_size == #x1000);

  U64 net_queue_byte_size := (256 * 16) + (4096) + 6 + (256 * 8);
  if (use_large_queues) {
    net_queue_byte_size := (4096 * 16) + (4096 * 3) + 6 + (4096 * 8);
  }

  U64 send_queue_addr := as<U64>(net_send_queue_space);
  send_queue_addr := (send_queue_addr + #x10000) - (send_queue_addr & #xFFFF);
  U64 recv_queue_addr := as<U64>(net_recv_queue_space);
  recv_queue_addr := (recv_queue_addr + #x10000) - (recv_queue_addr & #xFFFF);


  // Tell the device about our queues
  <> outw(as<U16>(0), queue_select_port);
  <> outd(as<U32>(recv_queue_addr >> 12), queue_address_port);

  <> outw(as<U16>(1), queue_select_port);
  <> outd(as<U32>(send_queue_addr >> 12), queue_address_port);

  // Tell the device that we are ready!
  <> outb(as<U8>(device_acknowledged | device_driver | device_features_ok | device_driver_ok),
          device_status_port);
  device_status := as<U64>(inb(device_status_port));
  if (device_status != (device_acknowledged | device_driver | device_features_ok | device_driver_ok)) {
    <> write_bytes(#"Device didn't like our queues: ");
    <> write_hex_U64(device_status);
    <> write_bytes(#"\r\n");

    return 1;
  }

  *net_queue_size <- as<U16>(queue_size);
  if (use_large_queues) {
    VirtioQueue4096* net_send_queue := as<VirtioQueue4096*>(send_queue_addr);
    VirtioQueue4096* net_recv_queue := as<VirtioQueue4096*>(recv_queue_addr);

    *net_send_available_index <- (net_send_queue->&available)->&index;
    *net_send_available_ring  <- (net_send_queue->&available)->&ring;
    *net_send_buffer_infos    <- (net_send_queue->&buffers);
    *net_send_used_index      <- (net_send_queue->&used)->&index;
    *net_recv_available_index <- (net_recv_queue->&available)->&index;
    *net_recv_available_ring  <- (net_recv_queue->&available)->&ring;
    *net_recv_buffer_infos    <- (net_recv_queue->&buffers);
    *net_recv_used_index      <- (net_recv_queue->&used)->&index;
    *net_recv_used_ring       <- (net_recv_queue->&used)->&ring;
  } else {
    VirtioQueue256* net_send_queue := as<VirtioQueue256*>(send_queue_addr);
    VirtioQueue256* net_recv_queue := as<VirtioQueue256*>(recv_queue_addr);

    *net_send_available_index <- (net_send_queue->&available)->&index;
    *net_send_available_ring  <- (net_send_queue->&available)->&ring;
    *net_send_buffer_infos    <- (net_send_queue->&buffers);
    *net_send_used_index      <- (net_send_queue->&used)->&index;
    *net_recv_available_index <- (net_recv_queue->&available)->&index;
    *net_recv_available_ring  <- (net_recv_queue->&available)->&ring;
    *net_recv_buffer_infos    <- (net_recv_queue->&buffers);
    *net_recv_used_index      <- (net_recv_queue->&used)->&index;
    *net_recv_used_ring       <- (net_recv_queue->&used)->&ring;
  }

  *((net_mac_address->&octets)->&[0]) <- inb(mac1_port);
  *((net_mac_address->&octets)->&[1]) <- inb(mac2_port);
  *((net_mac_address->&octets)->&[2]) <- inb(mac3_port);
  *((net_mac_address->&octets)->&[3]) <- inb(mac4_port);
  *((net_mac_address->&octets)->&[4]) <- inb(mac5_port);
  *((net_mac_address->&octets)->&[5]) <- inb(mac6_port);

  if ((as<U64>((net_mac_address->&octets)->[0]) == #x52) &&
      (as<U64>((net_mac_address->&octets)->[1]) == #x54)) {
    // QEMU case
    *((net_ip_address->&octets)->&[0]) <- as<U8>(10);
    *((net_ip_address->&octets)->&[1]) <- as<U8>(0);
    *((net_ip_address->&octets)->&[2]) <- as<U8>(2);
    *((net_ip_address->&octets)->&[3]) <- as<U8>(15);

    *((gateway_mac_address->&octets)->&[0]) <- as<U8>(#x52);
    *((gateway_mac_address->&octets)->&[1]) <- as<U8>(#x55);
    *((gateway_mac_address->&octets)->&[2]) <- as<U8>(#x0a);
    *((gateway_mac_address->&octets)->&[3]) <- as<U8>(#x00);
    *((gateway_mac_address->&octets)->&[4]) <- as<U8>(#x02);
    *((gateway_mac_address->&octets)->&[5]) <- as<U8>(#x02);

    *((gateway_ip_address->&octets)->&[0]) <- as<U8>(#x0a);
    *((gateway_ip_address->&octets)->&[1]) <- as<U8>(#x00);
    *((gateway_ip_address->&octets)->&[2]) <- as<U8>(#x02);
    *((gateway_ip_address->&octets)->&[3]) <- as<U8>(#x02);
  } else {
    // GCE case
    *((net_ip_address->&octets)->&[0]) <- (net_mac_address->&octets)->[2];
    *((net_ip_address->&octets)->&[1]) <- (net_mac_address->&octets)->[3];
    *((net_ip_address->&octets)->&[2]) <- (net_mac_address->&octets)->[4];
    *((net_ip_address->&octets)->&[3]) <- (net_mac_address->&octets)->[5];

    *((gateway_mac_address->&octets)->&[0]) <- (net_mac_address->&octets)->[0];
    *((gateway_mac_address->&octets)->&[1]) <- (net_mac_address->&octets)->[1];
    *((gateway_mac_address->&octets)->&[2]) <- (net_mac_address->&octets)->[2];
    *((gateway_mac_address->&octets)->&[3]) <- (net_mac_address->&octets)->[3];
    *((gateway_mac_address->&octets)->&[4]) <- as<U8>(0);
    *((gateway_mac_address->&octets)->&[5]) <- as<U8>(1);

    *((gateway_ip_address->&octets)->&[0]) <- (net_mac_address->&octets)->[2];
    *((gateway_ip_address->&octets)->&[1]) <- (net_mac_address->&octets)->[3];
    *((gateway_ip_address->&octets)->&[2]) <- as<U8>(0);
    *((gateway_ip_address->&octets)->&[3]) <- as<U8>(1);
  }

  *((broadcast_mac_address->&octets)->&[0]) <- as<U8>(#xff);
  *((broadcast_mac_address->&octets)->&[1]) <- as<U8>(#xff);
  *((broadcast_mac_address->&octets)->&[2]) <- as<U8>(#xff);
  *((broadcast_mac_address->&octets)->&[3]) <- as<U8>(#xff);
  *((broadcast_mac_address->&octets)->&[4]) <- as<U8>(#xff);
  *((broadcast_mac_address->&octets)->&[5]) <- as<U8>(#xff);

  <> write_bytes(#"Network configuration:\r\n");
  <> write_bytes(#"MAC address: ");
  <> write_mac_address(net_mac_address);
  <> write_bytes(#"\r\n");
  <> write_bytes(#"IP address: ");
  <> write_ip_address(net_ip_address);
  <> write_bytes(#"\r\n");

  <> write_bytes(#"Send Available index addr: ");
  <> write_hex_U64(as<U64>(*net_send_available_index));
  <> write_bytes(#"\r\n");
  <> write_bytes(#"Send Available ring addr: ");
  <> write_hex_U64(as<U64>(*net_send_available_ring));
  <> write_bytes(#"\r\n");
  <> write_bytes(#"Send buffers addr: ");
  <> write_hex_U64(as<U64>(*net_send_buffer_infos));
  <> write_bytes(#"\r\n");
  <> write_bytes(#"Send used index addr: ");
  <> write_hex_U64(as<U64>(*net_send_used_index));
  <> write_bytes(#"\r\n");

  <> write_bytes(#"Recv Available index addr: ");
  <> write_hex_U64(as<U64>(*net_recv_available_index));
  <> write_bytes(#"\r\n");
  <> write_bytes(#"Recv Available ring addr: ");
  <> write_hex_U64(as<U64>(*net_recv_available_ring));
  <> write_bytes(#"\r\n");
  <> write_bytes(#"Recv buffers addr: ");
  <> write_hex_U64(as<U64>(*net_recv_buffer_infos));
  <> write_bytes(#"\r\n");
  <> write_bytes(#"Recv used index addr: ");
  <> write_hex_U64(as<U64>(*net_recv_used_index));
  <> write_bytes(#"\r\n");
  <> write_bytes(#"Recv used ring addr: ");
  <> write_hex_U64(as<U64>(*net_recv_used_ring));
  <> write_bytes(#"\r\n");

  <> write_bytes(#"Network code done\r\n");
  return 0;
}

#:define_global TaskDescriptor serial_task
#:define_global #:alignment_bits 12 U8[8192] serial_task_stack
#:define_global TaskDescriptor network_task
#:define_global #:alignment_bits 12 U8[8192] network_task_stack

#:define_function
U64 addInitialTasks() {
  <> write_bytes(#"Initial tasks\r\n");

  <> add_task(serial_task, as<U64>(serial_task_stack->&[8192]),
                                   serialTaskStart);
  <> add_task(network_task, as<U64>(network_task_stack->&[8192]),
                                   networkTaskStart);
  <> write_bytes(#"Initial tasks done\r\n");
  return 0;
}

#:define_function
U64 postBootServices(RsdpDescriptor* rsdp_descriptor) {
  // UEFI is now finished.
  // Start initializing sub systems.

  // Clear screen/formatting
  <> write_bytes(#"\x1bc");

  <> disable_apic();

  <> initializeIdt();
  <> initializeSerial();
  <> initializePic();

  // Print out machine information from the RSDP.
  <> examine_rsdp(rsdp_descriptor);

  if ((initializeNetwork()) != 0) {
    <> write_bytes(#"Network initialization failed\r\n");
    return 1;
  }

  <> initializeScheduler();
  <> addInitialTasks();
  <> enable_interrupts();

  <> welcomeMessage();
  // Run the main OS loop
  <> runSchedulerLoop();
}

#:define_function
U64 main(U64 image_handle, EfiSystemTable* st) {
  // Find the RSDP descriptor which is the root of all the ACPI tables.
  RsdpDescriptor* rsdp_descriptor := find_rsdp(st);
  if (as<U64>(rsdp_descriptor) == 0) {
    return 1;
  }

  U64 s := 0;
  s := exitBootServices(image_handle, st);
  if (s != 0) { return s; }

  s := postBootServices(rsdp_descriptor);
  if (s != 0) { return s; }

  return 0;
}

#:define_struct VirtioNetHeader {
  U8[10] header;
  TrailingData data;
}

#:define_struct BigEndianU16 {
  U8 byte0;
  U8 byte1;
}

#:define_struct MacAddress {
  U8[6] octets;
}

#:define_struct EthernetHeader {
  MacAddress destination_mac;
  MacAddress source_mac;
  BigEndianU16 ethertype;
  TrailingData data;
}

#:define_struct IpAddress {
  U8[4] octets;
}


#:define_struct IpHeader {
  U8 version_header_length;
  U8 dcsp_ecn;
  BigEndianU16 total_length;
  BigEndianU16 identification;
  BigEndianU16 flags_fragment_offset;
  U8 time_to_live;
  U8 protocol;
  BigEndianU16 header_checksum;
  IpAddress source_ip;
  IpAddress destination_ip;
  TrailingData data;
}

#:define_struct UdpHeader {
  BigEndianU16 source_port;
  BigEndianU16 destination_port;
  BigEndianU16 length;
  BigEndianU16 checksum;
  TrailingData data;
}


// This struct assumes that the sizing is consistent with IPv4/Ethernet
// ARP packets.
#:define_struct ArpPacket {
  BigEndianU16 hardware_type;
  BigEndianU16 protocol_type;
  U8 hardware_length;
  U8 protocol_length;
  BigEndianU16 operation_type;
  MacAddress sender_hardware_address;
  IpAddress sender_protocol_address;
  MacAddress target_hardware_address;
  IpAddress target_protocol_address;
}

// We need the net_send_queue to be aligned on 2^16 (#x10000). The amount of space
// needed for the queue is RoundUp((16 * Qsize) + 6, 4096) + 6 + (8 * Qsize).
// The max queue size that is supported is 4096. So we allocate 3*(2^16) bytes of space
// for the queue and manually align the structure within there. We cannot rely on global alignment,
// because PE files don't support 16 bit alignment.
#:define_global U8[#x30000] net_send_queue_space
#:define_global U8[#x30000] net_recv_queue_space

#:define_global #:alignment_bits 12 VirtioBuffer[4096] net_send_buffers
#:define_global #:alignment_bits 12 VirtioBuffer[4096] net_recv_buffers

#:define_global MacAddress net_mac_address
#:define_global IpAddress  net_ip_address
#:define_global U16    net_base_port
#:define_global U16    net_queue_size
#:define_global U16*   net_send_available_index
#:define_global U16[]* net_send_available_ring
#:define_global VirtioQueueBufferInfo[]* net_send_buffer_infos
#:define_global U16*   net_send_used_index
#:define_global U16*   net_recv_available_index
#:define_global U16[]* net_recv_available_ring
#:define_global VirtioQueueBufferInfo[]* net_recv_buffer_infos
#:define_global U16*   net_recv_used_index
#:define_global VirtioQueueUsedRingInfo[]* net_recv_used_ring

// Common Addresses
#:define_global MacAddress gateway_mac_address
#:define_global IpAddress  gateway_ip_address
#:define_global MacAddress zero_mac_address
#:define_global MacAddress broadcast_mac_address

#:define_function
U64 sendUdpPacket(IpAddress* dest_ip_address, U16 dest_port) {
  <> write_bytes(#"Sending Yaspl UDP Packet\r\n");

  VirtioNetHeader* virtio_header := get_send_network_packet_buffer();
  <> memset(virtio_header->&header, as<U8>(0), 10);

  EthernetHeader* ethernet_header := as<EthernetHeader*>(virtio_header->&data);
  <> copy_mac_address(gateway_mac_address, ethernet_header->&destination_mac);
  <> copy_mac_address(net_mac_address, ethernet_header->&source_mac);
  <> le_to_be_u16(as<U16>(#x0800), ethernet_header->&ethertype);

  Bytes response := #"abcdefghijklmnop\n";
  U64 response_length := 15;
  BytesLayout* response_raw := as<BytesLayout*>(response);

  IpHeader* ip_header := as<IpHeader*>(ethernet_header->&data);
  *ip_header->&version_header_length <- as<U8>(#x45);
  *ip_header->&dcsp_ecn <- as<U8>(#x00);
  U64 udp_header_size := 8;
  U64 ip_header_size := 20;
  U64 total_length := ip_header_size + udp_header_size + response_length;
  <> le_to_be_u16(as<U16>(total_length), ip_header->&total_length);
  <> le_to_be_u16(as<U16>(0), ip_header->&flags_fragment_offset);
  *ip_header->&time_to_live <- as<U8>(64);
  *ip_header->&protocol <- as<U8>(17); // UDP
  <> le_to_be_u16(as<U16>(#x62b0), ip_header->&header_checksum);
  <> copy_ip_address(net_ip_address, ip_header->&source_ip);
  <> copy_ip_address(dest_ip_address, ip_header->&destination_ip);

  <> fill_ip_header_checksum(ip_header);

  UdpHeader* udp_header := as<UdpHeader*>(ip_header->&data);
  <> le_to_be_u16(as<U16>(#x0007), udp_header->&source_port);
  <> le_to_be_u16(as<U16>(dest_port), udp_header->&destination_port);
  <> le_to_be_u16(as<U16>(udp_header_size + response_length), udp_header->&length);
  <> le_to_be_u16(as<U16>(0), udp_header->&checksum);

  U64 j := 0;
  while (j < response_length) {
    *as<U8[]*>(udp_header->&data)->&[j] <- (as<U8[]*>(response_raw->&data))->[j];
    j := j + 1;
  }

  U64 ethernet_header_size := 14;
  U64 virtio_net_header_size := 10;
  U64 length :=
    (response_length + udp_header_size + ip_header_size + ethernet_header_size +
     virtio_net_header_size);
  <> send_network_packet(length);

  return 0;
}

#:define_function
U64 fill_ip_header_checksum(IpHeader* ip_header) {
  <> le_to_be_u16(as<U16>(#x0000), ip_header->&header_checksum);
  BigEndianU16[]* u16_view := as<BigEndianU16[]*>(ip_header);
  U64 sum := 0;
  U64 i := 0;
  while (i < 10) {
    sum := sum + as<U64>(be_u16_to_le(u16_view->&[i]));
    i := i + 1;
  }
  U64 shifted_sum := (sum & #xffff) + ((sum & #xff0000) >> 16);
  U64 complemented_sum := #xffff - shifted_sum;
  <> le_to_be_u16(as<U16>(complemented_sum), ip_header->&header_checksum);
  return 0;
}

#:define_function
U64 sendArpReplyPacket() {
  <> write_bytes(#"Sending Yaspl Arp Reply Packet\r\n");

  VirtioNetHeader* virtio_header := get_send_network_packet_buffer();
  <> memset(virtio_header->&header, as<U8>(0), 10);

  EthernetHeader* ethernet_header := as<EthernetHeader*>(virtio_header->&data);
  <> copy_mac_address(gateway_mac_address, ethernet_header->&destination_mac);
  <> copy_mac_address(net_mac_address, ethernet_header->&source_mac);
  <> le_to_be_u16(as<U16>(#x0806), ethernet_header->&ethertype);

  ArpPacket* arp_packet := as<ArpPacket*>(ethernet_header->&data);

  <> le_to_be_u16(as<U16>(#x0001), arp_packet->&hardware_type);
  <> le_to_be_u16(as<U16>(#x0800), arp_packet->&protocol_type);
  *arp_packet->&hardware_length <- as<U8>(6);
  *arp_packet->&protocol_length <- as<U8>(4);
  <> le_to_be_u16(as<U16>(#x0002), arp_packet->&operation_type);

  <> copy_mac_address(net_mac_address, arp_packet->&sender_hardware_address);
  <> copy_ip_address(net_ip_address, arp_packet->&sender_protocol_address);

  <> copy_mac_address(gateway_mac_address, arp_packet->&target_hardware_address);
  <> copy_ip_address(gateway_ip_address, arp_packet->&target_protocol_address);

  U64 arp_packet_size := 28;
  U64 ethernet_header_size := 14;
  U64 virtio_net_header_size := 10;
  U64 length := (arp_packet_size + ethernet_header_size + virtio_net_header_size);
  <> send_network_packet(length);

  <> write_bytes(#"Done sending Yaspl Arp Reply Packet\r\n");
  return 0;
}

#:define_function
VirtioNetHeader* get_send_network_packet_buffer() {
  U64 index := as<U64>(**net_send_available_index);
  U64 buffer_index := index % as<U64>(*net_queue_size);

  return as<VirtioNetHeader*>(net_send_buffers->&[buffer_index]);
}


#:define_function
U64 send_network_packet(U64 length) {
  U16 queue_notify_port := as<U16>(as<U64>(*net_base_port) + #x10);
  U16 isr_status_port   := as<U16>(as<U64>(*net_base_port) + #x13);

  U64 index := as<U64>(**net_send_available_index);
  U64 i := index % as<U64>(*net_queue_size);

  *((*net_send_buffer_infos)->&[i])->&address <- as<U64>(net_send_buffers->&[i]);
  *((*net_send_buffer_infos)->&[i])->&length <- as<U32>(length);
  *((*net_send_buffer_infos)->&[i])->&flags <- as<U16>(0);
  *((*net_send_buffer_infos)->&[i])->&next <- as<U16>(0);

  *(*net_send_available_ring)->&[i] <- as<U16>(i);
  *(*net_send_available_index) <- as<U16>(as<U64>(**net_send_available_index) + 1);

  // Tell the device that queue 1 (send) has a new buffer.
  <> outw(as<U16>(1), queue_notify_port);

  <> disable_interrupts();
  Boolean msg_recieved := 1 == 0;
  while (!msg_recieved) {
    // Read the interrupt status register to clear the interrupt state.
    <> inb(isr_status_port);
    msg_recieved := as<U64>(**net_send_used_index) == ((index + 1) & #xffff);
    if (!msg_recieved) {
      <> yield(as<U32>(1)); // Blocked
    }
  }
  <> enable_interrupts();

  return 0;
}

#:define_function
U64 sendArpRequestPacket() {
  <> write_bytes(#"Sending Yaspl Arp Request Packet\r\n");

  VirtioNetHeader* virtio_header := get_send_network_packet_buffer();
  <> memset(virtio_header->&header, as<U8>(0), 10);

  EthernetHeader* ethernet_header := as<EthernetHeader*>(virtio_header->&data);
  <> copy_mac_address(gateway_mac_address, ethernet_header->&destination_mac);
  <> copy_mac_address(net_mac_address, ethernet_header->&source_mac);
  <> le_to_be_u16(as<U16>(#x0806), ethernet_header->&ethertype);

  ArpPacket* arp_packet := as<ArpPacket*>(ethernet_header->&data);

  <> le_to_be_u16(as<U16>(#x0001), arp_packet->&hardware_type);
  <> le_to_be_u16(as<U16>(#x0800), arp_packet->&protocol_type);
  *arp_packet->&hardware_length <- as<U8>(6);
  *arp_packet->&protocol_length <- as<U8>(4);
  <> le_to_be_u16(as<U16>(#x0001), arp_packet->&operation_type);

  <> copy_mac_address(net_mac_address, arp_packet->&sender_hardware_address);
  <> copy_ip_address(net_ip_address, arp_packet->&sender_protocol_address);

  <> copy_mac_address(zero_mac_address, arp_packet->&target_hardware_address);
  <> copy_ip_address(gateway_ip_address, arp_packet->&target_protocol_address);

  U64 arp_packet_size := 28;
  U64 ethernet_header_size := 14;
  U64 virtio_net_header_size := 10;
  U64 length := (arp_packet_size + ethernet_header_size + virtio_net_header_size);
  <> send_network_packet(length);

  <> write_bytes(#"Sent Arp request:\r\n");
  <> printArpPacket(arp_packet);

  <> write_bytes(#"Raw packet:\r\n");
  U64 j := 0;
  while (j < (arp_packet_size + ethernet_header_size)) {
    U8[]* data := as<U8[]*>(ethernet_header);
    <> write_hex_U8(data->[j]);
    <> write_hex_U8(data->[j+1]);
    <> write_bytes(#" ");
    j := j + 2;
    if ((j % 16) == 0) {
      <> write_bytes(#"\r\n");
    }
  }
  <> write_bytes(#"\r\n");

  <> write_bytes(#"Done sending Yaspl Arp Request Packet\r\n");
  return 0;
}

#:define_function
U16 be_u16_to_le(BigEndianU16* be) {
  return as<U16>((as<U64>(be->byte0) << 8) |
                 (as<U64>(be->byte1) << 0));
}

#:define_function
U64 le_to_be_u16(U16 le, BigEndianU16* be) {
  *be->&byte0 <- as<U8>((as<U64>(le) >> 8) & #xff);
  *be->&byte1 <- as<U8>((as<U64>(le) >> 0) & #xff);
  return 0;
}


#:define_function
U64 waitNetworkInterrupt() {
  U16 isr_status_port    := as<U16>(as<U64>(*net_base_port) + #x13);
  U16 queue_notify_port  := as<U16>(as<U64>(*net_base_port) + #x10);

  U64 index := as<U64>(**net_recv_available_index);

  U64 i := index % as<U64>(*net_queue_size);

  *((*net_recv_buffer_infos)->&[i])->&address <- as<U64>(net_recv_buffers->&[i]);
  *((*net_recv_buffer_infos)->&[i])->&length  <- as<U32>(4096);
  *((*net_recv_buffer_infos)->&[i])->&flags   <- as<U16>(2); // Device writable
  *((*net_recv_buffer_infos)->&[i])->&next    <- as<U16>(0);

  *(*net_recv_available_ring)->&[i] <- as<U16>(i);
  *(*net_recv_available_index) <- as<U16>(as<U64>(**net_recv_available_index) + 1);

  // Tell the device that queue 0 (recv) has a new buffer.
  <> outw(as<U16>(0), queue_notify_port);

  <> disable_interrupts();
  Boolean msg_recieved := 1 == 0;
  while (!msg_recieved) {
    // Read the interrupt status register to clear the interrupt state.
    <> inb(isr_status_port);
    msg_recieved := as<U64>(**net_recv_used_index) == ((index + 1) & #xffff);
    if (!msg_recieved) {
      <> yield(as<U32>(1)); // Blocked
    }
  }
  <> enable_interrupts();


  U64 ring_i := index % as<U64>(*net_queue_size);
  U64 buffer_i := as<U64>(((*net_recv_used_ring)->&[ring_i])->index);
  if (buffer_i != ring_i) {
    <> panic_msg(#"Buffer doesn't match ring");
  }
  U64 remaining_packet_length := as<U64>(((*net_recv_used_ring)->&[ring_i])->length);
  U8[]* raw_buffer := as<U8[]*>(((*net_recv_buffer_infos)->&[buffer_i])->address);

  U64 virtio_net_header_size := 10;
  U64 ethernet_header_size := 14;


  if (remaining_packet_length < virtio_net_header_size) {
    <> panic_msg(#"Packet length shorter than virtio net header size");
  }
  VirtioNetHeader* virtio_header := as<VirtioNetHeader*>(raw_buffer);
  remaining_packet_length := remaining_packet_length - virtio_net_header_size;

  if (remaining_packet_length < ethernet_header_size) {
    <> panic_msg(#"Packet shorter than ethernet header");
  }
  EthernetHeader* ethernet_header := as<EthernetHeader*>(virtio_header->&data);
  remaining_packet_length := remaining_packet_length - ethernet_header_size;

  if ((as<U64>((ethernet_header->&ethertype)->byte0) == #x08) &&
      (as<U64>((ethernet_header->&ethertype)->byte1) == #x06)) {
    <> write_bytes(#"Got ARP packet\r\n");
    U64 arp_packet_size := 28;
    if (remaining_packet_length < arp_packet_size) {
      <> panic_msg(#"Packet shorter than arp packet size");
    }
    ArpPacket* arp_packet := as<ArpPacket*>(ethernet_header->&data);
    remaining_packet_length := remaining_packet_length - arp_packet_size;

    // Remaining packet length may still be positive because some implementations send long ARP
    // packets.

    if (as<U64>(be_u16_to_le(arp_packet->&hardware_type)) != 1) {
      <> panic_msg(#"Arp Packet has bad hardware type");
    }
    if (as<U64>(be_u16_to_le(arp_packet->&protocol_type)) != #x0800) {
      <> panic_msg(#"Arp Packet has bad protocol type");
    }
    if (as<U64>(arp_packet->hardware_length) != 6) {
      <> panic_msg(#"Arp Packet has bad hardware length");
    }
    if (as<U64>(arp_packet->protocol_length) != 4) {
      <> panic_msg(#"Arp Packet has bad protocol length");
    }

    if ((as<U64>((arp_packet->&operation_type)->byte0) == 0) &&
        (as<U64>((arp_packet->&operation_type)->byte1) == 1)) {
      // <> printArpRequestPacket(arp_packet);
      <> sendArpReplyPacket();
    } else if ((as<U64>((arp_packet->&operation_type)->byte0) == 0) &&
               (as<U64>((arp_packet->&operation_type)->byte1) == 2)) {
      <> printArpReplyPacket(arp_packet);
    } else {
      <> panic_msg(#"Unknown operation");
    }
  } else if ((as<U64>((ethernet_header->&ethertype)->byte0) == #x08) &&
             (as<U64>((ethernet_header->&ethertype)->byte1) == #x00)) {
    <> write_bytes(#"IPv4 packet\r\n");

    U64 udp_header_size := 8;
    U64 ip_header_size := 20;

    if (remaining_packet_length < ip_header_size) {
        <> panic();
    }
    IpHeader* ip_header := as<IpHeader*>(ethernet_header->&data);

    if (remaining_packet_length != as<U64>(be_u16_to_le(ip_header->&total_length))) {
       <> panic();
    }

    U64 header_length := as<U64>(ip_header->version_header_length) & #x0F;
    if (header_length != 5) {
      <> panic();
    }
    remaining_packet_length := remaining_packet_length - ip_header_size;

    if (remaining_packet_length < udp_header_size) {
      <> panic();
    }
    UdpHeader* udp_header := as<UdpHeader*>(ip_header->&data);

    if (remaining_packet_length != as<U64>(be_u16_to_le(udp_header->&length))) {
      <> panic();
    }
    remaining_packet_length := remaining_packet_length - udp_header_size;

    <> write_bytes(#"Got UDP Packet: ");
    <> write_ip_address(ip_header->&source_ip);
    <> write_bytes(#" -> ");
    <> write_ip_address(ip_header->&destination_ip);
    <> write_bytes(#"\r\n");

    <> sendUdpPacket(ip_header->&source_ip, be_u16_to_le(udp_header->&source_port));
  } else {
    <> write_bytes(#"Unknown packet type\r\n");
  }
  return 0;
}

#:define_function
U64 disable_apic() {
  U64 apic_base_value := read_msr(#x1b);
  <> write_bytes(#"APIC MSR value: ");
  <> write_hex_U64(apic_base_value);
  <> write_bytes(#"\r\n");

  U64 write_value := apic_base_value - #x800;
  <> write_msr(write_value, #x1b);
  <> write_bytes(#"Written APIC MSR value: ");
  <> write_hex_U64(write_value);
  <> write_bytes(#"\r\n");

  U64 new_apic_base_value := read_msr(#x1b);
  <> write_bytes(#"Reread APIC MSR value: ");
  <> write_hex_U64(new_apic_base_value);
  <> write_bytes(#"\r\n");

  return 0;
}


#:define_struct AcpiSdtHeader {
  U8[4] signature;
  U32 length;
  U8 revision;
  U8 checksum;
  U8[6] oem_id;
  U8[8] oem_table_id;
  U32 oem_revision;
  U32 creator_id;
  U32 creator_revision;
}

#:define_struct XSDT {
  AcpiSdtHeader header;
  TrailingData other_tables;
}

#:define_struct ConfigSpaceAllocation {
  U64 base_address;
  U16 group_number;
  U8  start_bus_number;
  U8  end_bus_number;
  U32 reserved;
}


#:define_struct MCFG {
  AcpiSdtHeader header;
  U64 reserved;
  TrailingData config_space_allocations;
}


#:define_struct PciHeader0 {
  U16 vendor_id;
  U16 device_id;
  U16 command;
  U16 status;
  U8 revison;
  U8 prog_if;
  U8 subclass;
  U8 class;
  U8 cache_line_size;
  U8 latency_timer;
  U8 header_type;
  U8 bist;
  U32[6] base_address;
  U32 cis_pointer;
  U16 subsystem_vendor_id;
  U16 subsystem_id;
  U32 expansion_rom_base_address;
  U8 capabilities_pointer;
  U8[7] reserved;
  U8 interrupt_line;
  U8 interrupt_pin;
  U8 min_grant;
  U8 max_latency;
}

#:define_function
U16 find_network_device() {

  // Try reading config through old api.
  U64 i := 0;
  U64 device_num := 32;
  while (i < 32) {
    U32 vendor_and_device := read_pci_config(as<U8>(0), as<U8>(i), as<U8>(0), as<U8>(0));
    <> write_bytes(#"PCI read (");
    <> write_hex_U8(as<U8>(i));
    <> write_bytes(#"): ");
    <> write_hex_U32(vendor_and_device);
    <> write_bytes(#"\r\n");

    // This is the vendor and device id for a Virtio Network Device
    if (as<U64>(vendor_and_device) == #x10001af4) {
      device_num := i;
    }

    i := i + 1;
  }

  // Return early if no such device found.
  if (device_num == 32) {
    return as<U16>(0);
  }

  // Print out the full configuration space of the device.
  i := 0;
  while (i < 256) {
    U32 value := read_pci_config(as<U8>(0), as<U8>(device_num), as<U8>(0), as<U8>(i));
    <> write_bytes(#"PCI value read (");
    <> write_hex_U8(as<U8>(i));
    <> write_bytes(#"): ");
    <> write_hex_U32(value);
    <> write_bytes(#"\r\n");
    i := i + 4;
  }

  U32 bar1_value := read_pci_config(as<U8>(0), as<U8>(device_num), as<U8>(0), as<U8>(#x10));
  <> write_bytes(#"Bar1 value: ");
  <> write_hex_U32(bar1_value);
  <> write_bytes(#"\r\n");


  // TODO validate that this is actually in the U16 range
  return as<U16>(as<U64>(bar1_value) - 1);
}


#:define_function
U64 examine_rsdp(RsdpDescriptor* rsdp) {

  <> write_bytes(#"RSDP signature (RSD PTR ): ");
  <> write_raw_buffer(rsdp->&signature, 8);
  <> write_bytes(#"\r\n");

  XSDT* xsdt := as<XSDT*>(rsdp->xsdt_address);

  <> write_bytes(#"XSDT signature (XSDT): ");
  <> write_raw_buffer((xsdt->&header)->&signature, 4);
  <> write_bytes(#"\r\n");

  U64 acpi_sdt_header_size := 36;
  U64 num_tables := (as<U64>((xsdt->&header)->length) - acpi_sdt_header_size) / 8;

  <> write_bytes(#"Found ");
  <> write_hex_U64(num_tables);
  <> write_bytes(#" ACPI Tables\r\n");

  AcpiSdtHeader*[]* other_tables := as<AcpiSdtHeader*[]*>(xsdt->&other_tables);

  U64 i := 0;
  while (i < num_tables) {
    AcpiSdtHeader* sdt := other_tables->[i];
    <> write_bytes(#"Table signature: ");
    <> write_raw_buffer(sdt->&signature, 4);
    <> write_bytes(#"\r\n");
    i := i + 1;
  }

  // Disabled code that prints the MCFG table.
  // GCE doesn't have this so we need to go a different way.
  if (1 == 0) {
    MCFG* mcfg := as<MCFG*>(other_tables->[3]);
    <> write_bytes(#"MCFG signature (MCFG): ");
    <> write_raw_buffer((mcfg->&header)->&signature, 4);
    <> write_bytes(#"\r\n");

    <> write_bytes(#"MCFG length: ");
    <> write_hex_U32((mcfg->&header)->length);
    <> write_bytes(#"\r\n");

    U64 num_mcfg_configs := (as<U64>((mcfg->&header)->length) - acpi_sdt_header_size) / 16;

    <> write_bytes(#"Number of MCFG configs: ");
    <> write_hex_U32(as<U32>(num_mcfg_configs));
    <> write_bytes(#"\r\n");

    ConfigSpaceAllocation[]* mcfg_csas :=
      as<ConfigSpaceAllocation[]*>(mcfg->&config_space_allocations);

    i := 0;
    while (i < num_mcfg_configs) {
      ConfigSpaceAllocation* csa := mcfg_csas->&[i];
      <> write_bytes(#"Config Space Base Address: ");
      <> write_hex_U64(csa->base_address);
      <> write_bytes(#"\r\n");
      <> write_bytes(#"Config Space Group: ");
      <> write_hex_U16(csa->group_number);
      <> write_bytes(#"\r\n");
      <> write_bytes(#"Config Space Start Bus Number: ");
      <> write_hex_U8(csa->start_bus_number);
      <> write_bytes(#"\r\n");
      <> write_bytes(#"Config Space End Bus Number: ");
      <> write_hex_U8(csa->end_bus_number);
      <> write_bytes(#"\r\n");
      i := i + 1;
    }

    ConfigSpaceAllocation* csa := mcfg_csas->&[0];

    PciHeader0 * device_header := as<PciHeader0*>((csa->base_address) + (0 << 20) + (2 << 15) + (0 << 12));

    <> write_bytes(#"Device Vendor Id: ");
    <> write_hex_U16(device_header->vendor_id);
    <> write_bytes(#"\r\n");

    <> write_bytes(#"Device Device Id: ");
    <> write_hex_U16(device_header->device_id);
    <> write_bytes(#"\r\n");

    <> write_bytes(#"Base Addresses:");
    <> write_bytes(#"\r\n");
    <> write_hex_U32((device_header->&base_address)->[0]);
    <> write_bytes(#"\r\n");
    <> write_hex_U32((device_header->&base_address)->[1]);
    <> write_bytes(#"\r\n");
    <> write_hex_U32((device_header->&base_address)->[2]);
    <> write_bytes(#"\r\n");
    <> write_hex_U32((device_header->&base_address)->[3]);
    <> write_bytes(#"\r\n");
    <> write_hex_U32((device_header->&base_address)->[4]);
    <> write_bytes(#"\r\n");
    <> write_hex_U32((device_header->&base_address)->[5]);
    <> write_bytes(#"\r\n");

    <> write_bytes(#"Device Subsystem Vendor Id: ");
    <> write_hex_U16(device_header->subsystem_vendor_id);
    <> write_bytes(#"\r\n");

    <> write_bytes(#"Device Subsystem Id: ");
    <> write_hex_U16(device_header->subsystem_id);
    <> write_bytes(#"\r\n");

  }

  return 0;
}

#:define_function
U32 read_pci_config(U8 bus, U8 device, U8 func, U8 offset) {
    U64 address := (as<U64>(bus) << 16) | (as<U64>(device) << 11) | (as<U64>(func) << 8) |
                   as<U64>(offset) | #x80000000;

    // Write out the address
    <> outd(as<U32>(address), as<U16>(#xCF8));
    // Read in the data
    return ind(as<U16>(#xCFC));

}

#:define_function
U64 panic_msg(Bytes msg) {
  <> write_bytes(#"\r\nPANIC: ");
  <> write_bytes(msg);
  <> write_bytes(#"\r\n");
  <> panic();
}

#:define_function
U64 write_ip_address(IpAddress* addr) {
  <> write_hex_byte((addr->&octets)->[0]);
  <> write_bytes(#".");
  <> write_hex_byte((addr->&octets)->[1]);
  <> write_bytes(#".");
  <> write_hex_byte((addr->&octets)->[2]);
  <> write_bytes(#".");
  <> write_hex_byte((addr->&octets)->[3]);
  return 0;
}

#:define_function
U64 write_mac_address(MacAddress* addr) {
  <> write_hex_byte((addr->&octets)->[0]);
  <> write_bytes(#":");
  <> write_hex_byte((addr->&octets)->[1]);
  <> write_bytes(#":");
  <> write_hex_byte((addr->&octets)->[2]);
  <> write_bytes(#":");
  <> write_hex_byte((addr->&octets)->[3]);
  <> write_bytes(#":");
  <> write_hex_byte((addr->&octets)->[4]);
  <> write_bytes(#":");
  <> write_hex_byte((addr->&octets)->[5]);
  return 0;
}

#:define_function
U64 copy_ip_address(IpAddress* src, IpAddress* dest) {
  *(dest->&octets)->&[0] <- (src->&octets)->[0];
  *(dest->&octets)->&[1] <- (src->&octets)->[1];
  *(dest->&octets)->&[2] <- (src->&octets)->[2];
  *(dest->&octets)->&[3] <- (src->&octets)->[3];
  return 0;
}

#:define_function
U64 copy_mac_address(MacAddress* src, MacAddress* dest) {
  *(dest->&octets)->&[0] <- (src->&octets)->[0];
  *(dest->&octets)->&[1] <- (src->&octets)->[1];
  *(dest->&octets)->&[2] <- (src->&octets)->[2];
  *(dest->&octets)->&[3] <- (src->&octets)->[3];
  *(dest->&octets)->&[4] <- (src->&octets)->[4];
  *(dest->&octets)->&[5] <- (src->&octets)->[5];
  return 0;
}


#:define_function
U64 printArpReplyPacket(ArpPacket* arp) {
  <> write_bytes(#"Got Arp Response:\r\n");
  <> printArpPacket(arp);

  return 0;
}

#:define_function
U64 printArpRequestPacket(ArpPacket* arp) {
  <> write_bytes(#"Got Arp Request:\r\n");
  <> printArpPacket(arp);

  return 0;
}

#:define_function
U64 printArpPacket(ArpPacket* arp) {
  <> write_bytes(#"Sender Hardware Address: ");
  <> write_mac_address(arp->&sender_hardware_address);
  <> write_bytes(#"\r\n");

  <> write_bytes(#"Sender Protocol Address: ");
  <> write_ip_address(arp->&sender_protocol_address);
  <> write_bytes(#"\r\n");

  <> write_bytes(#"Target Hardware Address: ");
  <> write_mac_address(arp->&target_hardware_address);
  <> write_bytes(#"\r\n");

  <> write_bytes(#"Target Protocol Address: ");
  <> write_ip_address(arp->&target_protocol_address);
  <> write_bytes(#"\r\n");

  return 0;
}
