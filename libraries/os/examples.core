#:module (os)

#:declare_external call_ms0c (U64 -> U64)
#:declare_external call_ms1c (U64, U64 -> U64)
#:declare_external call_ms2c (U64, U64, U64 -> U64)
#:declare_external call_ms5c (U64, U64, U64, U64, U64, U64 -> U64)
#:declare_external read_serial U64
#:declare_external write_serial U64

// External functions for interrupts
#:declare_external irqfun_com1 U64
#:declare_external irqfun_nic U64
#:declare_external irqfun_default U64
#:declare_external y_lidtc (U64 -> U64)
#:declare_external y_outbc (U8, U16 -> U64)

#:define_function
U64 a(U64 arg, U64 arg2, U64 arg3, U64 arg4) {
  return arg4 + 7;
}

#:define_function
U64 g(U64 arg, U64 arg2) {
  return arg2;
}

#:define_function
U64 write_bytes(Bytes bytes) {
  U64[]* bytes_ptr := as<U64[]*>(bytes);
  U64 size := bytes_ptr->[1];
  U64 index := 0;
  while (index < size) {
    U64 base := as<U64>(bytes_ptr->&[2]);
    U64* addr := as<U64*>(base + index);
    U64 value := (*addr) & #xff;
    <> call_ms1c(write_serial, value);
    index := index + 1;
  }
  return 0;
}

#:define_function
U64 write_hex_byte(U64 byte) {
  <> call_ms1c(write_serial, nibble_to_hex((byte / 16) & #x0f));
  <> call_ms1c(write_serial, nibble_to_hex(byte & #x0f));
  return 0;
}


#:define_function
U64 nibble_to_hex(U64 v) {
  if (v < 10) {
    return 48 + v;
  } else {
    return 87 + v;
  }
}

#:define_global U64 serial_counter

#:define_function
U64 serialTaskStart(U64 arg, U64 arg2, U64 arg3, U64 arg4) {
  while (1 > 0) {
    U64 v := call_ms0c(read_serial);
    <> write_bytes(#"SerialInput (");
    <> write_hex_byte(*serial_counter);
    <> write_bytes(#"): ");
    <> write_hex_byte(v);
    <> write_bytes(#"\n");
    *serial_counter <- (*serial_counter) + 1;
  }
}

#:define_function
U64 welcomeMessage() {
  <> write_bytes(#"\x1bc");
  <> write_bytes(#"Welcome to Yaspl OS.\r\n");
  return 0;
}


#:define_function
U64 memset(U8[]* memory, U8 value, U64 size) {
  U64 index := 0;
  while (index < size) {
    *memory->&[index] <- value;
    index := index + 1;
  }
  return 0;
}

#:define_struct EfiHandle {}

#:define_struct EfiTableHeader {
  U32 signature;
  U32 revision;
  U32 header_size;
  U32 crc32;
  U32 reserved1;
}

#:define_struct EfiRuntimeServices {}

#:define_struct EfiUnknown {}

#:define_struct EfiBootServices {
    EfiTableHeader Hdr;
    U32 padding1;
    EfiUnknown*    RaiseTPL;
    EfiUnknown*    RestoreTPL;
    EfiUnknown*    AllocatePages;
    EfiUnknown*    FreePages;
    U64            GetMemoryMap;
    U64            AllocatePool;
    EfiUnknown*    FreePool;
    EfiUnknown*    CreateEvent;
    EfiUnknown*    SetTimer;
    EfiUnknown*    WaitForEvent;
    EfiUnknown*    SignalEvent;
    EfiUnknown*    CloseEvent;
    EfiUnknown*    CheckEvent;
    EfiUnknown*    InstallProtocolInterface;
    EfiUnknown*    ReinstallProtocolInterface;
    EfiUnknown*    UninstallProtocolInterface;
    EfiUnknown*    HandleProtocol;
    EfiUnknown*    Reserved;
    EfiUnknown*    RegisterProtocolNotify;
    EfiUnknown*    LocateHandle;
    EfiUnknown*    LocateDevicePath;
    EfiUnknown*    InstallConfigurationTable;
    EfiUnknown*    LoadImage;
    EfiUnknown*    StartImage;
    EfiUnknown*    Exit;
    EfiUnknown*    UnloadImage;
    U64            ExitBootServices;


}

#:define_struct EfiSystemTable {
  EfiTableHeader header;
  U32 padding1;
  U16* firmware_vendor;
  U32 firmware_revision;
  U32 padding2;
  EfiHandle* console_in_handle;
  U64* console_in;
  EfiHandle* console_out_handle;
  EfiSimpleTextOutputProtocol* console_out;
  EfiHandle* console_err_handle;
  EfiSimpleTextOutputProtocol* console_err;
  EfiRuntimeServices* runtime_services;
  EfiBootServices* boot_services;
}

#:define_struct EfiTextString {}

#:define_struct EfiSimpleTextOutputProtocol {
  U64* reset;
  EfiTextString* output_string;
}

#:define_struct EfiMemoryMap {}

#:define_global U64 efi_memory_map_size
#:define_global U8[4096] efi_memory_map_space
#:define_global U64 efi_memory_map_key
#:define_global U64 efi_memory_descriptor_size
#:define_global U32 efi_memory_descriptor_version

#:define_global U8[4096] efi_output_buffer
#:define_global U8*      efi_writer

#:define_function
U64 reset_efi_writer() {
  *efi_writer <- efi_output_buffer->&[0];
  return 0;
}

#:define_function
U64 terminate_efi_writer() {
  return efi_writer_add_byte(as<U8>(0));
}

#:define_function
U64 efi_writer_add_byte(U8 v) {
  *(*efi_writer) <- v;
  *efi_writer <- as<U8*>(as<U64>(*efi_writer) + 2);
  return 0;
}

#:define_function
U64 efi_writer_add_hex_U8(U8 byte) {
  <> efi_writer_add_byte(as<U8>(nibble_to_hex((as<U64>(byte) / 16) & #x0f)));
  <> efi_writer_add_byte(as<U8>(nibble_to_hex(as<U64>(byte) & #x0f)));
  return 0;
}

#:define_function
U64 efi_writer_add_hex_U64(U64 v) {
  <> efi_writer_add_hex_U8(as<U8>(((v /  4294967296) /  16777216) & #xff));
  <> efi_writer_add_hex_U8(as<U8>(((v /  4294967296) /     65536) & #xff));
  <> efi_writer_add_hex_U8(as<U8>(((v /  4294967296) /       256) & #xff));
  <> efi_writer_add_hex_U8(as<U8>(((v /  4294967296) /         1) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v /     16777216) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v /        65536) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v /          256) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v /            1) & #xff));
  return 0;
}



#:define_function
U64 exitBootServices(U64 image_handle, EfiSystemTable* st) {
  EfiSimpleTextOutputProtocol* output := st->console_out;

  *efi_memory_map_size <- 4096;
  U64 status := call_ms5c((st->boot_services)->GetMemoryMap,
                          as<U64>(efi_memory_map_size),
                          as<U64>(efi_memory_map_space),
                          as<U64>(efi_memory_map_key),
                          as<U64>(efi_memory_descriptor_size),
                          as<U64>(efi_memory_descriptor_version));
  if (status != 0) {
    <> reset_efi_writer();
    <> efi_writer_add_hex_U64(status);
    <> efi_writer_add_byte(as<U8>(#x0d));
    <> efi_writer_add_byte(as<U8>(#x0a));
    <> terminate_efi_writer();
    <> call_ms2c(as<U64>(output->output_string), as<U64>(output), as<U64>(efi_output_buffer));
    return status;
  }

  status := call_ms2c((st->boot_services)->ExitBootServices, image_handle, *efi_memory_map_key);
  if (status != 0) {
    <> reset_efi_writer();
    <> efi_writer_add_hex_U64(status);
    <> efi_writer_add_byte(as<U8>(#x0d));
    <> efi_writer_add_byte(as<U8>(#x0a));
    <> terminate_efi_writer();
    <> call_ms2c(as<U64>(output->output_string), as<U64>(output), as<U64>(efi_output_buffer));
    return status;
  }

  return 0;
}

#:define_struct IdtEntry {
  U16 offset_1;  // offset bits 0..15
  U16 selector;  // a code segment selector in GDT or LDT
  U8  ist;       // bits 0..2 holds Interrupt Stack Table offset, rest of bits zero.
  U8  type_attr; // type and attributes
  U16 offset_2;  // offset bits 16..31
  U32 offset_3;  // offset bits 32..63
  U32 zero;      // reserved
}

#:define_struct IdtDescriptor {
  U16 limit;
  U64 base_address;
}

#:define_global IdtEntry[256] idt_entries
#:define_global IdtDescriptor idt_descriptor


#:define_function
U64 initializeIdt() {
  <> write_bytes(#"IDT code\r\n");
  U64 idt_entry_size := 16;
  <> memset(as<U8[]*>(idt_entries), as<U8>(0), idt_entry_size * 256);
  U64 i := 0;
  while (i < 256) {
    U64 irq_addr := irqfun_default;
    if (i == 36) {
      irq_addr := irqfun_com1;
    } else if (i == 43) {
      irq_addr := irqfun_nic;
    } else {
      irq_addr := irqfun_default;
    }

    *(idt_entries->&[i])->&offset_1 <- as<U16>(irq_addr & #xffff);
    *(idt_entries->&[i])->&selector <- as<U16>(#x38);
    *(idt_entries->&[i])->&ist <- as<U8>(0);
    *(idt_entries->&[i])->&type_attr <- as<U8>(#x8e);
    *(idt_entries->&[i])->&offset_2 <- as<U16>((irq_addr / 65536) & #xffff);
    *(idt_entries->&[i])->&offset_3 <- as<U32>(irq_addr / 4294967296);
    *(idt_entries->&[i])->&zero <- as<U32>(0);
    i := i + 1;
  }

  *idt_descriptor->&limit <- as<U16>(idt_entry_size * 256 - 1);
  *idt_descriptor->&base_address <- as<U64>(idt_entries);
  <> y_lidtc(as<U64>(idt_descriptor));
  <> write_bytes(#"IDT code done\r\n");
  return 0;
}

#:define_function
U64 initializeSerial() {
  <> write_bytes(#"Serial code\r\n");

  // #x3F8 is SERIAL_COM1_BASE
  U64 port := #x3F8;

  // Disable all interrupts on the port while setup happens
  <> y_outbc(as<U8>(#x00), as<U16>(port + 1));
  // // Enable the DLAB. This changes the meaning of ports 0/1 which allows
  // // setting the baud rate divisor.
  <> y_outbc(as<U8>(#x80), as<U16>(port + 3));
  // // Set divisor to 3 (low byte) 38400 baud
  <> y_outbc(as<U8>(#x03), as<U16>(port + 0));
  <> y_outbc(as<U8>(#x00), as<U16>(port + 1));

  // // Clear the DLAB, and set the protcol as:
  // // 8 bits, no parity, one stop bit
  <> y_outbc(as<U8>(#x03), as<U16>(port + 3));
  // // Don't set FIFOs as they don't seem to do anything in QEMU.
  // // Enable IRQs on Receive.
  <> y_outbc(as<U8>(#x01), as<U16>(port + 1));

  <> write_bytes(#"Serial code done\r\n");
  return 0;
}

#:define_function
U64 initializePic() {
  <> write_bytes(#"PIC code\r\n");

  // Base port numbers for the Master/Slave PICs.
  U64 pic1 := #x20;
  U64 pic2 := #xA0;
  // Command and data port numbers
  U64 pic1_command := pic1 + 0;
  U64 pic1_data    := pic1 + 1;
  U64 pic2_command := pic2 + 0;
  U64 pic2_data    := pic2 + 1;

  U64 icw1_init := #x10; // This is an initialization command
  U64 icw1_icw4 := #x01; // This initialization uses command word 4
  // Start the initialization sequence (in cascade mode)
  <> y_outbc(as<U8>(icw1_init | icw1_icw4), as<U16>(pic1_command));
  <> y_outbc(as<U8>(icw1_init | icw1_icw4), as<U16>(pic2_command));

  // // Set the PICs to use the entries in the IDT range [32, 47).
  U64 offset1 := 32;
  U64 offset2 := 40;
  <> y_outbc(as<U8>(offset1), as<U16>(pic1_data));    // ICW2: Master PIC vector offset
  <> y_outbc(as<U8>(offset2), as<U16>(pic2_data));    // ICW2: Slave PIC vector offset
  <> y_outbc(as<U8>(#x04), as<U16>(pic1_data));  // ICW3: tell Master PIC that there is a slave PIC at IRQ2 (0b00000100)
  <> y_outbc(as<U8>(#x02), as<U16>(pic2_data));  // ICW3: tell Slave PIC its cascade identity

  // // Set 8086 mode
  U64 icw4_8086 := #x01;
  <> y_outbc(as<U8>(icw4_8086), as<U16>(pic1_data));
  <> y_outbc(as<U8>(icw4_8086), as<U16>(pic2_data));

  // Only enable some interrupts.
  // PIC 1, bit 2: Allow PIC2 through
  // PIC 1, bit 4: COM1 serial port
  U64 pic1_interrupts := #xEB; // ~((1 << 2) | (1 << 4));
  // // PIC 2, bit 3: NIC
  U64 pic2_interrupts := #xF7; // ~(1 << 3);
  // Mask all interrupts that shouldn't be enabled.
  <> y_outbc(as<U8>(pic1_interrupts), as<U16>(pic1_data));
  <> y_outbc(as<U8>(pic2_interrupts), as<U16>(pic2_data));


  <> write_bytes(#"PIC code done\r\n");
  return 0;
}
