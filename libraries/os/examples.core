#:module (os)

#:declare_external call_ms0c (U64 -> U64)
#:declare_external call_ms1c (U64, U64 -> U64)
#:declare_external call_ms2c (U64, U64, U64 -> U64)
#:declare_external call_ms5c (U64, U64, U64, U64, U64, U64 -> U64)

// External functions for interrupts
#:declare_external y_irqfun_com1 U64
#:declare_external y_irqfun_nic U64
#:declare_external y_irqfun_default U64
#:declare_external y_lidtc (U64 -> U64)
#:declare_external y_outbc (U8, U16 -> U64)
#:declare_external y_outwc (U16, U16 -> U64)
#:declare_external y_outdc (U32, U16 -> U64)
#:declare_external y_inbc (U16 -> U8)
#:declare_external y_inwc (U16 -> U16)
#:declare_external y_indc (U16 -> U32)

#:define_function
U64 a(U64 arg, U64 arg2, U64 arg3, U64 arg4) {
  return arg4 + 7;
}

#:define_function
U64 g(U64 arg, U64 arg2) {
  return arg2;
}

#:define_function
Boolean is_transmit_empty() {
  // #x3F8 is SERIAL_COM1_BASE
  U64 port := #x3F8;
  U64 result := as<U64>(y_inbc(as<U16>(port + 5)));
  return (result & #x20) != 0;
}

#:define_function
U64 write_serial(U8 v) {
  // #x3F8 is SERIAL_COM1_BASE
  U64 port := #x3F8;

  while (!is_transmit_empty()) {
    // Busy Loop
  }

  <> y_outbc(v, as<U16>(port));
  return 0;
}


#:define_function
U64 write_bytes(Bytes bytes) {
  U64[]* bytes_ptr := as<U64[]*>(bytes);
  U64 size := bytes_ptr->[1];
  U64 index := 0;
  while (index < size) {
    U64 base := as<U64>(bytes_ptr->&[2]);
    U64* addr := as<U64*>(base + index);
    U64 value := (*addr) & #xff;
    <> write_serial(as<U8>(value));
    index := index + 1;
  }
  return 0;
}

#:define_function
U64 write_hex_byte(U8 b) {
  U64 v := as<U64>(b);
  <> write_serial(nibble_to_hex((v >> 4) & #x0f));
  <> write_serial(nibble_to_hex(v & #x0f));
  return 0;
}


#:define_function
U8 nibble_to_hex(U64 v) {
  if (v < 10) {
    return as<U8>(48 + v);
  } else {
    return as<U8>(87 + v);
  }
}

#:define_function
Boolean serial_received() {
  // #x3F8 is SERIAL_COM1_BASE
  U64 port := #x3F8;
  U64 result := as<U64>(y_inbc(as<U16>(port + 5)));
  return (result & 1) != 0;
}

#:define_function
U8 read_serial() {

 if (!serial_received()) {
   <> disable_interruptsc();
   while (!serial_received()) {
      <> yield(as<U32>(1)); // Blocked
   }
   <> enable_interruptsc();
 }

 // #x3F8 is SERIAL_COM1_BASE
 U64 port := #x3F8;
 return y_inbc(as<U16>(port));
}


#:define_global U8 serial_counter

#:define_function
U64 serialTaskStart(U64 arg, U64 arg2, U64 arg3, U64 arg4) {
  while (1 > 0) {
    U8 v := read_serial();
    <> write_bytes(#"SerialInput (");
    <> write_hex_byte(*serial_counter);
    <> write_bytes(#"): ");
    <> write_hex_byte(v);
    <> write_bytes(#"\n");
    *serial_counter <- as<U8>(as<U64>(*serial_counter) + 1);
  }
}

#:define_function
U64 welcomeMessage() {
  <> write_bytes(#"\x1bc");
  <> write_bytes(#"Welcome to Yaspl OS.\r\n");
  return 0;
}


#:define_function
U64 memset(U8[]* memory, U8 value, U64 size) {
  U64 index := 0;
  while (index < size) {
    *memory->&[index] <- value;
    index := index + 1;
  }
  return 0;
}

#:define_struct EfiHandle {}

#:define_struct EfiTableHeader {
  U32 signature;
  U32 revision;
  U32 header_size;
  U32 crc32;
  U32 reserved1;
}

#:define_struct EfiRuntimeServices {}

#:define_struct EfiUnknown {}

#:define_struct EfiBootServices {
    EfiTableHeader Hdr;
    U32 padding1;
    EfiUnknown*    RaiseTPL;
    EfiUnknown*    RestoreTPL;
    EfiUnknown*    AllocatePages;
    EfiUnknown*    FreePages;
    U64            GetMemoryMap;
    U64            AllocatePool;
    EfiUnknown*    FreePool;
    EfiUnknown*    CreateEvent;
    EfiUnknown*    SetTimer;
    EfiUnknown*    WaitForEvent;
    EfiUnknown*    SignalEvent;
    EfiUnknown*    CloseEvent;
    EfiUnknown*    CheckEvent;
    EfiUnknown*    InstallProtocolInterface;
    EfiUnknown*    ReinstallProtocolInterface;
    EfiUnknown*    UninstallProtocolInterface;
    EfiUnknown*    HandleProtocol;
    EfiUnknown*    Reserved;
    EfiUnknown*    RegisterProtocolNotify;
    EfiUnknown*    LocateHandle;
    EfiUnknown*    LocateDevicePath;
    EfiUnknown*    InstallConfigurationTable;
    EfiUnknown*    LoadImage;
    EfiUnknown*    StartImage;
    EfiUnknown*    Exit;
    EfiUnknown*    UnloadImage;
    U64            ExitBootServices;


}

#:define_struct EfiSystemTable {
  EfiTableHeader header;
  U32 padding1;
  U16* firmware_vendor;
  U32 firmware_revision;
  U32 padding2;
  EfiHandle* console_in_handle;
  U64* console_in;
  EfiHandle* console_out_handle;
  EfiSimpleTextOutputProtocol* console_out;
  EfiHandle* console_err_handle;
  EfiSimpleTextOutputProtocol* console_err;
  EfiRuntimeServices* runtime_services;
  EfiBootServices* boot_services;
}

#:define_struct EfiTextString {}

#:define_struct EfiSimpleTextOutputProtocol {
  U64* reset;
  EfiTextString* output_string;
}

#:define_struct EfiMemoryMap {}

#:define_global U64 efi_memory_map_size
#:define_global U8[4096] efi_memory_map_space
#:define_global U64 efi_memory_map_key
#:define_global U64 efi_memory_descriptor_size
#:define_global U32 efi_memory_descriptor_version

#:define_global U8[4096] efi_output_buffer
#:define_global U8*      efi_writer

#:define_function
U64 reset_efi_writer() {
  *efi_writer <- efi_output_buffer->&[0];
  return 0;
}

#:define_function
U64 terminate_efi_writer() {
  return efi_writer_add_byte(as<U8>(0));
}

#:define_function
U64 efi_writer_add_byte(U8 v) {
  *(*efi_writer) <- v;
  *efi_writer <- as<U8*>(as<U64>(*efi_writer) + 2);
  return 0;
}

#:define_function
U64 efi_writer_add_hex_U8(U8 byte) {
  <> efi_writer_add_byte(nibble_to_hex((as<U64>(byte) >> 4) & #x0f));
  <> efi_writer_add_byte(nibble_to_hex(as<U64>(byte) & #x0f));
  return 0;
}

#:define_function
U64 efi_writer_add_hex_U64(U64 v) {
  <> efi_writer_add_hex_U8(as<U8>((v >> 56) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v >> 48) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v >> 40) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v >> 32) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v >> 24) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v >> 16) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v >>  8) & #xff));
  <> efi_writer_add_hex_U8(as<U8>((v >>  0) & #xff));
  return 0;
}



#:define_function
U64 exitBootServices(U64 image_handle, EfiSystemTable* st) {
  EfiSimpleTextOutputProtocol* output := st->console_out;

  *efi_memory_map_size <- 4096;
  U64 status := call_ms5c((st->boot_services)->GetMemoryMap,
                          as<U64>(efi_memory_map_size),
                          as<U64>(efi_memory_map_space),
                          as<U64>(efi_memory_map_key),
                          as<U64>(efi_memory_descriptor_size),
                          as<U64>(efi_memory_descriptor_version));
  if (status != 0) {
    <> reset_efi_writer();
    <> efi_writer_add_hex_U64(status);
    <> efi_writer_add_byte(as<U8>(#x0d));
    <> efi_writer_add_byte(as<U8>(#x0a));
    <> terminate_efi_writer();
    <> call_ms2c(as<U64>(output->output_string), as<U64>(output), as<U64>(efi_output_buffer));
    return status;
  }

  status := call_ms2c((st->boot_services)->ExitBootServices, image_handle, *efi_memory_map_key);
  if (status != 0) {
    <> reset_efi_writer();
    <> efi_writer_add_hex_U64(status);
    <> efi_writer_add_byte(as<U8>(#x0d));
    <> efi_writer_add_byte(as<U8>(#x0a));
    <> terminate_efi_writer();
    <> call_ms2c(as<U64>(output->output_string), as<U64>(output), as<U64>(efi_output_buffer));
    return status;
  }

  return 0;
}

#:define_struct IdtEntry {
  U16 offset_1;  // offset bits 0..15
  U16 selector;  // a code segment selector in GDT or LDT
  U8  ist;       // bits 0..2 holds Interrupt Stack Table offset, rest of bits zero.
  U8  type_attr; // type and attributes
  U16 offset_2;  // offset bits 16..31
  U32 offset_3;  // offset bits 32..63
  U32 zero;      // reserved
}

#:define_struct IdtDescriptor {
  U16 limit;
  U64 base_address;
}

#:define_global IdtEntry[256] idt_entries
#:define_global IdtDescriptor idt_descriptor


#:define_function
U64 initializeIdt() {
  <> write_bytes(#"IDT code\r\n");
  U64 idt_entry_size := 16;
  <> memset(as<U8[]*>(idt_entries), as<U8>(0), idt_entry_size * 256);
  U64 i := 0;
  while (i < 256) {
    U64 irq_addr := y_irqfun_default;
    if (i == 36) {
      irq_addr := y_irqfun_com1;
    } else if (i == 43) {
      irq_addr := y_irqfun_nic;
    }

    *(idt_entries->&[i])->&offset_1 <- as<U16>(irq_addr & #xffff);
    *(idt_entries->&[i])->&selector <- as<U16>(#x38);
    *(idt_entries->&[i])->&ist <- as<U8>(0);
    *(idt_entries->&[i])->&type_attr <- as<U8>(#x8e);
    *(idt_entries->&[i])->&offset_2 <- as<U16>((irq_addr >> 16) & #xffff);
    *(idt_entries->&[i])->&offset_3 <- as<U32>(irq_addr >> 32);
    *(idt_entries->&[i])->&zero <- as<U32>(0);
    i := i + 1;
  }

  *idt_descriptor->&limit <- as<U16>(idt_entry_size * 256 - 1);
  *idt_descriptor->&base_address <- as<U64>(idt_entries);
  <> y_lidtc(as<U64>(idt_descriptor));
  <> write_bytes(#"IDT code done\r\n");
  return 0;
}

#:define_function
U64 initializeSerial() {
  <> write_bytes(#"Serial code\r\n");

  // #x3F8 is SERIAL_COM1_BASE
  U64 port := #x3F8;

  // Disable all interrupts on the port while setup happens
  <> y_outbc(as<U8>(#x00), as<U16>(port + 1));
  // Enable the DLAB. This changes the meaning of ports 0/1 which allows
  // setting the baud rate divisor.
  <> y_outbc(as<U8>(#x80), as<U16>(port + 3));
  // Set divisor to 3 (low byte) 38400 baud
  <> y_outbc(as<U8>(#x03), as<U16>(port + 0));
  <> y_outbc(as<U8>(#x00), as<U16>(port + 1));

  // Clear the DLAB, and set the protcol as:
  // 8 bits, no parity, one stop bit
  <> y_outbc(as<U8>(#x03), as<U16>(port + 3));
  // Don't set FIFOs as they don't seem to do anything in QEMU.
  // Enable IRQs on Receive.
  <> y_outbc(as<U8>(#x01), as<U16>(port + 1));

  <> write_bytes(#"Serial code done\r\n");
  return 0;
}

#:define_function
U64 initializePic() {
  <> write_bytes(#"PIC code\r\n");

  // Base port numbers for the Master/Slave PICs.
  U64 pic1 := #x20;
  U64 pic2 := #xA0;
  // Command and data port numbers
  U64 pic1_command := pic1 + 0;
  U64 pic1_data    := pic1 + 1;
  U64 pic2_command := pic2 + 0;
  U64 pic2_data    := pic2 + 1;

  U64 icw1_init := #x10; // This is an initialization command
  U64 icw1_icw4 := #x01; // This initialization uses command word 4
  // Start the initialization sequence (in cascade mode)
  <> y_outbc(as<U8>(icw1_init | icw1_icw4), as<U16>(pic1_command));
  <> y_outbc(as<U8>(icw1_init | icw1_icw4), as<U16>(pic2_command));

  // Set the PICs to use the entries in the IDT range [32, 47).
  U64 offset1 := 32;
  U64 offset2 := 40;
  <> y_outbc(as<U8>(offset1), as<U16>(pic1_data));    // ICW2: Master PIC vector offset
  <> y_outbc(as<U8>(offset2), as<U16>(pic2_data));    // ICW2: Slave PIC vector offset
  // ICW3: tell Master PIC that there is a slave PIC at IRQ2 (0b00000100)
  <> y_outbc(as<U8>(#x04), as<U16>(pic1_data));
  <> y_outbc(as<U8>(#x02), as<U16>(pic2_data));  // ICW3: tell Slave PIC its cascade identity

  // // Set 8086 mode
  U64 icw4_8086 := #x01;
  <> y_outbc(as<U8>(icw4_8086), as<U16>(pic1_data));
  <> y_outbc(as<U8>(icw4_8086), as<U16>(pic2_data));

  // Only enable some interrupts.
  // PIC 1, bit 2: Allow PIC2 through
  // PIC 1, bit 4: COM1 serial port
  U64 pic1_interrupts := #xEB; // ~((1 << 2) | (1 << 4));
  // // PIC 2, bit 3: NIC
  U64 pic2_interrupts := #xF7; // ~(1 << 3);
  // Mask all interrupts that shouldn't be enabled.
  <> y_outbc(as<U8>(pic1_interrupts), as<U16>(pic1_data));
  <> y_outbc(as<U8>(pic2_interrupts), as<U16>(pic2_data));


  <> write_bytes(#"PIC code done\r\n");
  return 0;
}

#:define_struct VirtioQueue256BufferInfo {
  U64 address;
  U32 length;
  U16 flags;
  U16 next;
}

#:define_struct VirtioQueue256AvailableInfo {
  U16 flags;
  U16 index;
  U16[256] ring;
  U16 event_index;
}

#:define_struct VirtioQueue256UsedRingInfo {
  U32 index;
  U32 length;
}

#:define_struct VirtioQueue256UsedInfo {
  U16 flags;
  U16 index;
  VirtioQueue256UsedRingInfo[256] ring;
  U16 avail_event;
}

#:define_struct VirtioQueue256 {
  VirtioQueue256BufferInfo[256] buffers;
  VirtioQueue256AvailableInfo available;
  U8[3578] padding;
  VirtioQueue256UsedInfo used;
}


#:declare_external net_send_queue VirtioQueue256[]*
#:declare_external net_recv_queue VirtioQueue256[]*

#:define_struct VirtioBuffer {
  U8[4096] bytes;
}

#:declare_external net_send_buffers VirtioBuffer[]*
#:declare_external net_recv_buffers VirtioBuffer[]*

#:define_function
U64 initializeNetwork() {
  <> write_bytes(#"Network code\r\n");

  U64 feature_mac := 5;
  U64 device_features_port := #x00;
  U64 guest_features_port  := #x04;
  U64 queue_address_port   := #x08;
  U64 queue_size_port      := #x0c;
  U64 queue_select_port    := #x0e;
  U64 device_status_port   := #x12;

  U64 device_acknowledged := #x01;
  U64 device_driver       := #x02;
  U64 device_features_ok  := #x08;
  U64 device_driver_ok    := #x04;

  U64 net_base_port := #x6060;


  // Acknowledge the device.
  <> y_outbc(as<U8>(device_acknowledged),
             as<U16>(net_base_port + device_status_port));
  // Tell the device that we know how to drive it.
  <> y_outbc(as<U8>(device_acknowledged | device_driver),
             as<U16>(net_base_port + device_status_port));

  U64 device_features := as<U64>(y_indc(as<U16>(net_base_port + device_features_port)));
  if ((device_features & (1 << feature_mac)) == 0) {
     return 1;
  }

  U32 guest_features := as<U32>(1 << feature_mac);
  <> y_outdc(guest_features, as<U16>(net_base_port + guest_features_port));

  // Tell the device that we are finalized on our feature decisions.
  <> y_outbc(as<U8>(device_acknowledged | device_driver | device_features_ok),
             as<U16>(net_base_port + device_status_port));

  U64 device_status := as<U64>(y_inbc(as<U16>(net_base_port + device_status_port)));
  if (device_status != (device_acknowledged | device_driver | device_features_ok)) {
    return 1;
  }

  U64 queue_num := 0;
  while (queue_num < 2) {
    <> y_outwc(as<U16>(queue_num), as<U16>(net_base_port + queue_select_port));
    U64 queue_size := as<U64>(y_inwc(as<U16>(net_base_port + queue_size_port)));
    if (queue_size != #x100) {
      return 1;
    }

    queue_num := queue_num + 1;
  }

  U64 net_queue_size := (256 * 16) + (4096) + 6 + (256 * 8);

  <> memset(as<U8[]*>(net_send_queue), as<U8>(0), net_queue_size);
  <> memset(as<U8[]*>(net_recv_queue), as<U8>(0), net_queue_size);


  // Tell the device about our queues
  <> y_outwc(as<U16>(0), as<U16>(net_base_port + queue_select_port));
  <> y_outdc(as<U32>(as<U64>(net_recv_queue) >> 12),
             as<U16>(net_base_port + queue_address_port));

  <> y_outwc(as<U16>(1), as<U16>(net_base_port + queue_select_port));
  <> y_outdc(as<U32>(as<U64>(net_send_queue) >> 12),
             as<U16>(net_base_port + queue_address_port));

  // Tell the device that we are ready!
  <> y_outbc(as<U8>(device_acknowledged | device_driver | device_features_ok | device_driver_ok),
             as<U16>(net_base_port + device_status_port));
  device_status := as<U64>(y_inbc(as<U16>(net_base_port + device_status_port)));
  if (device_status != (device_acknowledged | device_driver | device_features_ok | device_driver_ok)) {
    return 1;
  }

  <> write_bytes(#"Network code done\r\n");
  return 0;
}

#:define_struct TaskDescriptor {
  U64 stack_pointer;
  TaskDescriptor* next;
  U32 state;
}

#:declare_external root_task TaskDescriptor*
#:declare_external current_task TaskDescriptor**


#:define_function
U64 initializeScheduler() {
  <> write_bytes(#"Scheduler code\r\n");

  // Initialize root_task
  *root_task->&stack_pointer <- 0;
  *root_task->&next <- root_task;
  *root_task->&state <- as<U32>(0); // Runnable

  // Initialize the current task as the root_task;
  *current_task <- root_task;

  <> write_bytes(#"Scheduler code done\r\n");
  return 0;
}

// Address of the code at the start of a task.
#:declare_external scheduler_start_task U64

#:define_function
U64 add_task(TaskDescriptor* task, U64 stack_address, U64 start_func) {

  // Push initial values onto the stack.
  U64 stack_pointer := stack_address;

  // First return address
  stack_pointer := stack_pointer - 8;
  *(as<U64*>(stack_pointer)) <- scheduler_start_task;
  // Setup initial registers.
  U64 i := 0;
  while (i < 15) {
    U64 val := 0;
    if (i == 2) { // rcx
      val := start_func;
    }

    stack_pointer := stack_pointer - 8;
    *(as<U64*>(stack_pointer)) <- val;
    i := i + 1;
  }

  *task->&stack_pointer <- stack_pointer;

  // Add the task and mark as runnable.
  *task->&state <- as<U32>(0); // Runnable
  *task->&next <- (*current_task)->next;
  *((*current_task)->&next) <- task;

  return 0;
}

#:declare_external serial_task TaskDescriptor*
#:declare_external network_task TaskDescriptor*
#:declare_external serial_task_stack U8[]*
#:declare_external network_task_stack U8[]*
#:declare_external yos_serialTaskStart U64
#:declare_external network_task_start U64

#:define_function
U64 addInitialTasks() {
  <> write_bytes(#"Initial tasks\r\n");
  <> add_task(serial_task, as<U64>(serial_task_stack->&[8192]), yos_serialTaskStart);
  <> add_task(network_task, as<U64>(network_task_stack->&[8192]), network_task_start);
  <> write_bytes(#"Initial tasks done\r\n");
  return 0;
}

#:declare_external enable_interruptsc (-> U64)
#:declare_external enable_interrupts_and_haltc (-> U64)
#:declare_external disable_interruptsc (-> U64)

#:define_function
U64 runSchedulerLoop() {
  while (1 != 0) {
    <> disable_interruptsc();
    // 0 for input = Runnable, 0 for output = no other Runnable tasks
    while (yield(as<U32>(0))) {}
    <> enable_interrupts_and_haltc();
  }
}

// Marks all the tasks runnable. Called by interrupt handlers.
#:define_function
U64 markAllRunnable() {
  TaskDescriptor* task := *current_task;
  *task->&state <- as<U32>(0); // Runnable
  task := task->next;
  while (as<U64>(task) != as<U64>(*current_task)) {
    *task->&state <- as<U32>(0); // Runnable
    task := task->next;
  }
  return 0;
}

#:declare_external switch_to_task U64

#:define_function
Boolean yield(U32 new_old_state) {
  TaskDescriptor* old_task := *current_task;
  TaskDescriptor* new_task := old_task->next;

  while ((as<U64>(new_task) != as<U64>(old_task))
         && (as<U64>(new_task->state) != 0)) {
    new_task := new_task->next;
  }

  Boolean ret_val := (0 == 1);
  if (as<U64>(new_task) != as<U64>(old_task)) {
    ret_val := (1 == 1);
    *old_task->&state <- new_old_state;
    *current_task <- new_task;
    <> call_ms2c(switch_to_task, as<U64>(old_task), as<U64>(new_task));
  }

  return ret_val;
}

#:define_function
U64 postBootServices() {
  // UEFI is now finished.
  // Start initializing sub systems.

  <> initializeIdt();
  <> initializeSerial();
  <> initializePic();
  if ((initializeNetwork()) != 0) {
    <> write_bytes(#"Network initialization failed\r\n");
    return 1;
  }

  <> initializeScheduler();
  <> addInitialTasks();
  <> enable_interruptsc();

  <> welcomeMessage();
  // Run the main OS loop
  <> runSchedulerLoop();
}

#:define_function
U64 main(U64 image_handle, EfiSystemTable* st) {

  U64 s := 0;
  s := exitBootServices(image_handle, st);
  if (s != 0) { return s; }
  s := postBootServices();
  if (s != 0) { return s; }

  return 0;
}
