(module print-stack-function
  (import
    (bytes bytes=? bytes-append)
    (compiler compile-modules parse-module-files)
    (either
      #:types (Either)
      #:values (left right)
      #:patterns (left right))
    (io write-all-bytes write-line)
    (join-list
      #:types (JoinList)
      #:values (append-jl append-jl* concat-jl cons-jl empty-jl jl->list join-list single-jl snoc-jl)
      #:patterns ())
    (list
      #:types (List)
      #:values (array->list list map)
      #:patterns (cons empty))
    (numbers integer->decimal-bytes)
    (prim
      #:types (Array Bytes InputPort Int OutputPort Void)
      #:values (+)
      #:patterns ())
    (stack-machine
      #:types (StackBasicBlock StackCmd StackFunction StackTerminal TopLevelObject VariantCases)
      #:values ()
      #:patterns (alloc-variant-cmd array-length-cmd array-ref-cmd array-set!-cmd bin-add-op
                  bin-bitwise-and-op bin-bitwise-ior-op bin-logic-math-cmd bin-logical-shift-left-op
                  bin-logical-shift-right-op bin-math-cmd bin-mult-op bin-quotient-op bin-remainder-op
                  bin-sub-op boolean-jmp boolean-lit-cmd bytes-cmp-cmd catch-all-case
                  create-closure-cmd dup-cmd dup-free-var-cmd equal-op fun-call-cmd function-tlo
                  greater-than-op greater-than-or-equal-op known-fun-call-cmd known-tail-call
                  less-than-op less-than-or-equal-op load-global-cmd make-array-cmd
                  make-array-from-stack-cmd no-catch-all-case num-lit-cmd pop-cmd return
                  stack-basic-block stack-function swap-cmd tail-call uncond-jmp variant-case
                  variant-ref-cmd variant-switch)))
  (export
    #:types ()
    #:values (extract-top-level-objects function->bytes command->bytes terminal->bytes)
    #:patterns ())
  (types)

  (define (find-function [name : Bytes] [code : (List TopLevelObject)]) : (Either Bytes StackFunction)
    (case code
      [(empty) (left #"Function not found")]
      [(cons (function-tlo func) code)
       (case func
         [(stack-function func-name _ _)
          (if (bytes=? name func-name)
              (right func)
              (find-function name code))])]
      [(cons _ code)
       (find-function name code)]))

  (define (print-function [fun : StackFunction] [output : OutputPort]) : Void
    (case fun
     [(stack-function fun-name _ blocks)
      (write-all-bytes
        (bytes-append (jl->list (function->bytes fun)))
        output)]))

  (define (function->bytes [fun : StackFunction]) : (JoinList Bytes)
    (case fun
     [(stack-function fun-name _ blocks)
      (cons-jl
        fun-name
        (cons-jl
          #"\n"
          (blocks->bytes blocks 0)))]))

  (define (blocks->bytes [blocks : (List StackBasicBlock)] [index : Int]) : (JoinList Bytes)
    (case blocks
     [(empty) (empty-jl)]
     [(cons block blocks)
      (varargs append-jl*
        (single-jl #"Block ")
        (single-jl (integer->decimal-bytes index))
        (single-jl #"\n")
        (block->bytes block)
        (blocks->bytes blocks (+ 1 index)))]))

  (define (block->bytes [block : StackBasicBlock]) : (JoinList Bytes)
    (case block
      [(stack-basic-block cmds terminal)
       (append-jl
         (concat-jl (map make-indented-line (map command->bytes cmds)))
         (make-indented-line (terminal->bytes terminal)))]))

  (define (command->bytes [command : StackCmd]) : (JoinList Bytes)
    (case command
      [(num-lit-cmd v)
       (varargs join-list
         #"numeric-literal: "
         (integer->decimal-bytes v))]
      [(boolean-lit-cmd v)
       (varargs join-list
         #"boolean-literal: "
         (if v #"true" #"false"))]
      [(bytes-cmp-cmd)
       (single-jl #"bytes-cmp")]
      [(create-closure-cmd free-vars)
       (varargs join-list
         #"create-closure: "
         (integer->decimal-bytes free-vars))]
      [(load-global-cmd name)
       (varargs join-list
         #"load-global: "
         name)]
      [(dup-cmd offset)
       (varargs join-list
         #"dup: "
         (integer->decimal-bytes offset))]
      [(dup-free-var-cmd index offset)
       (varargs join-list
         #"dup-free-var: "
         (integer->decimal-bytes index)
         #" "
         (integer->decimal-bytes offset))]
      [(alloc-variant-cmd tag _)
       (varargs join-list
         #"alloc-variant: "
         (integer->decimal-bytes tag))]
      [(variant-ref-cmd tag field)
       (varargs join-list
         #"variant-ref: "
         (integer->decimal-bytes tag)
         #" "
         (integer->decimal-bytes field))]
      [(bin-math-cmd op)
       (single-jl
         (case op
           [(bin-add-op) #"add"]
           [(bin-sub-op) #"sub"]
           [(bin-mult-op) #"mult"]
           [(bin-quotient-op) #"quotient"]
           [(bin-remainder-op) #"remainder"]
           [(bin-bitwise-and-op) #"bitwise and"]
           [(bin-bitwise-ior-op) #"bitwise ior"]
           [(bin-logical-shift-left-op) #"logical shift left"]
           [(bin-logical-shift-right-op) #"logical shift right"]
           [_ #"unknown math op"]))]
      [(bin-logic-math-cmd op)
       (single-jl
         (case op
           [(less-than-op) #"<"]
           [(less-than-or-equal-op) #"<="]
           [(equal-op) #"="]
           [(greater-than-or-equal-op) #">="]
           [(greater-than-op) #">"]
           [_ #"unknown comparison op"]))]
      [(make-array-from-stack-cmd num-args)
       (varargs join-list
         #"make-array-from-stack: "
         (integer->decimal-bytes num-args))]
      [(make-array-cmd)
       (single-jl #"make-array")]
      [(array-length-cmd)
       (single-jl #"array-length")]
      [(array-ref-cmd)
       (single-jl #"array-ref")]
      [(array-set!-cmd)
       (single-jl #"array-set!")]
      [(pop-cmd)
       (single-jl #"pop")]
      [(swap-cmd)
       (single-jl #"swap")]
      [(fun-call-cmd num-args)
       (varargs join-list
         #"fun-call: "
         (integer->decimal-bytes num-args))]
      [(known-fun-call-cmd name num-args)
       (varargs join-list
         #"known-fun-call: "
         name
         #" "
         (integer->decimal-bytes num-args))]
      [_
       (single-jl #"unknown-op")]))


  (define (make-indented-line [text : (JoinList Bytes)]) : (JoinList Bytes)
    (snoc-jl (cons-jl #"  " text) #"\n"))

  (define (terminal->bytes [terminal : StackTerminal]) : (JoinList Bytes)
    (case terminal
      [(boolean-jmp true false)
       (varargs join-list
         #"cond-jmp "
         (integer->decimal-bytes true)
         #" "
         (integer->decimal-bytes false))]
      [(uncond-jmp index)
       (varargs join-list
         #"jmp "
         (integer->decimal-bytes index))]
      [(variant-switch cases)
       (cons-jl #"switch" (cases->bytes cases))]
      [(return n)
       (varargs join-list
         #"ret "
         (integer->decimal-bytes n))]
      [(tail-call num-args num-cleanup)
       (varargs join-list
         #"tail-call "
         (integer->decimal-bytes num-args)
         #" "
         (integer->decimal-bytes num-cleanup))]
      [(known-tail-call name num-args num-cleanup)
       (varargs join-list
         #"known-tail-call: "
         name
         #" "
         (integer->decimal-bytes num-args)
         #" "
         (integer->decimal-bytes num-cleanup))]))

  (define (cases->bytes [cases : VariantCases]) : (JoinList Bytes)
    (case cases
      [(no-catch-all-case) (single-jl #"")]
      [(catch-all-case index)
       (varargs join-list
         #" _->"
         (integer->decimal-bytes index))]
      [(variant-case tag index cases)
       (append-jl
         (varargs join-list
           #" "
           (integer->decimal-bytes tag)
           #"->"
           (integer->decimal-bytes index))
         (cases->bytes cases))]))

  (define (extract-top-level-objects [module-files : (List Bytes)])
    : (Either Bytes (List TopLevelObject))
    (case (parse-module-files module-files)
      [(left v)
       (left v)]
      [(right modules)
       (compile-modules modules)]))

  (define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Int
    (case (array->list args)
      [(empty)
       (begin
         (write-line #"No executable specified???" stderr)
         1)]
      [(cons _ (empty))
       (begin
         (write-line #"No function name supplied." stderr)
         1)]
      [(cons _ (cons _ (empty)))
       (begin
         (write-line #"No module name supplied" stderr)
         1)]
      [(cons _ (cons function-name (cons module-name module-files)))
        (case (extract-top-level-objects module-files)
          [(left v)
           (begin
             (write-line v stderr)
             1)]
          [(right code)
           (case (find-function
                   (bytes-append (varargs list function-name #"_" module-name))
                   code)
             [(left msg)
              (begin
                (write-line msg stderr)
                1)]
             [(right func)
              (begin
                (print-function func stdout)
                0)])])])))
