#:module (print-stack-function)
#:import {
  (bytes)
  (compiler)
  (either)
  (io)
  (join-list)
  (list)
  (numbers)
  (prim)
  (stack-machine)
  (yaspl math-operations)
  (yaspl top-level-objects)
}
(export
  #:types ()
  #:values (extract-top-level-objects function->bytes command->bytes terminal->bytes)
  #:patterns ())
(types)

(define (find-function [name : Bytes] [code : (List TopLevelObject)]) : (Either Bytes StackFunction)
  (case code
    [(empty) (left #"Function not found")]
    [(cons (stack-function-tlo func) code)
     (case func
       [(stack-function func-name _ _)
        (if (bytes=? name func-name)
            (right func)
            (find-function name code))])]
    [(cons _ code)
     (find-function name code)]))

(define (print-function [fun : StackFunction] [output : OutputPort]) : Void
  (case fun
   [(stack-function fun-name _ blocks)
    (write-all-bytes
      (bytes-append (jl->list (function->bytes fun)))
      output)]))

(define (function->bytes [fun : StackFunction]) : (JoinList Bytes)
  (case fun
   [(stack-function fun-name _ blocks)
    (cons-jl
      fun-name
      (cons-jl
        #"\n"
        (blocks->bytes blocks 0)))]))

(define (blocks->bytes [blocks : (List StackBasicBlock)] [index : Int]) : (JoinList Bytes)
  (case blocks
   [(empty) (empty-jl)]
   [(cons block blocks)
    (varargs append-jl*
      (single-jl #"Block ")
      (single-jl (integer->decimal-bytes index))
      (single-jl #"\n")
      (block->bytes block)
      (blocks->bytes blocks (+ 1 index)))]))

(define (block->bytes [block : StackBasicBlock]) : (JoinList Bytes)
  (case block
    [(stack-basic-block cmds terminal)
     (append-jl
       (concat-jl (map make-indented-line (map command->bytes cmds)))
       (make-indented-line (terminal->bytes terminal)))]))

(define (command->bytes [command : StackCmd]) : (JoinList Bytes)
  (case command
    [(num-lit-cmd v)
     (varargs join-list
       #"numeric-literal: "
       (integer->decimal-bytes v))]
    [(boolean-lit-cmd v)
     (varargs join-list
       #"boolean-literal: "
       (if v #"true" #"false"))]
    [(bytes-cmp-cmd)
     (single-jl #"bytes-cmp")]
    [(create-closure-cmd fun free-vars)
     (varargs join-list
       #"create-closure("
       fun
       #"): "
       (integer->decimal-bytes free-vars))]
    [(load-global-cmd name)
     (varargs join-list
       #"load-global: "
       name)]
    [(dup-cmd offset)
     (varargs join-list
       #"dup: "
       (integer->decimal-bytes offset))]
    [(dup-free-var-cmd index offset)
     (varargs join-list
       #"dup-free-var: "
       (integer->decimal-bytes index)
       #" "
       (integer->decimal-bytes offset))]
    [(alloc-variant-cmd tag _)
     (varargs join-list
       #"alloc-variant: "
       (integer->decimal-bytes tag))]
    [(variant-ref-cmd tag field)
     (varargs join-list
       #"variant-ref: "
       (integer->decimal-bytes tag)
       #" "
       (integer->decimal-bytes field))]
    [(bin-numeric-cmd op)
     (single-jl (numeric-bin-op->bytes op))]
    [(bin-comparison-cmd op)
     (single-jl (comparison-bin-op->bytes op))]
    [(bin-logical-cmd op)
     (single-jl (logical-bin-op->bytes op))]
    [(make-array-from-stack-cmd num-args)
     (varargs join-list
       #"make-array-from-stack: "
       (integer->decimal-bytes num-args))]
    [(make-array-cmd)
     (single-jl #"make-array")]
    [(array-length-cmd)
     (single-jl #"array-length")]
    [(array-ref-cmd)
     (single-jl #"array-ref")]
    [(array-set!-cmd)
     (single-jl #"array-set!")]
    [(pop-cmd)
     (single-jl #"pop")]
    [(swap-cmd)
     (single-jl #"swap")]
    [(fun-call-cmd num-args)
     (varargs join-list
       #"fun-call: "
       (integer->decimal-bytes num-args))]
    [(known-fun-call-cmd name num-args)
     (varargs join-list
       #"known-fun-call: "
       name
       #" "
       (integer->decimal-bytes num-args))]))


(define (make-indented-line [text : (JoinList Bytes)]) : (JoinList Bytes)
  (snoc-jl (cons-jl #"  " text) #"\n"))

(define (terminal->bytes [terminal : StackTerminal]) : (JoinList Bytes)
  (case terminal
    [(boolean-jmp true false)
     (varargs join-list
       #"cond-jmp "
       (integer->decimal-bytes true)
       #" "
       (integer->decimal-bytes false))]
    [(uncond-jmp index)
     (varargs join-list
       #"jmp "
       (integer->decimal-bytes index))]
    [(variant-switch cases)
     (cons-jl #"switch" (cases->bytes cases))]
    [(return n)
     (varargs join-list
       #"ret "
       (integer->decimal-bytes n))]
    [(tail-call num-args num-cleanup)
     (varargs join-list
       #"tail-call "
       (integer->decimal-bytes num-args)
       #" "
       (integer->decimal-bytes num-cleanup))]
    [(known-tail-call name num-args num-cleanup)
     (varargs join-list
       #"known-tail-call: "
       name
       #" "
       (integer->decimal-bytes num-args)
       #" "
       (integer->decimal-bytes num-cleanup))]))

(define (cases->bytes [cases : VariantCases]) : (JoinList Bytes)
  (case cases
    [(no-catch-all-case) (single-jl #"")]
    [(catch-all-case index)
     (varargs join-list
       #" _->"
       (integer->decimal-bytes index))]
    [(variant-case tag index cases)
     (append-jl
       (varargs join-list
         #" "
         (integer->decimal-bytes tag)
         #"->"
         (integer->decimal-bytes index))
       (cases->bytes cases))]))

(define (extract-top-level-objects [module-files : (List Bytes)])
  : (Either Bytes (List TopLevelObject))
  (case (parse-module-files module-files)
    [(left v)
     (left v)]
    [(right modules)
     (compile-modules modules)]))

(define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Int
  (case (array->list args)
    [(empty)
     (begin
       (write-line #"No executable specified???" stderr)
       1)]
    [(cons _ (empty))
     (begin
       (write-line #"No function name supplied." stderr)
       1)]
    [(cons _ (cons _ (empty)))
     (begin
       (write-line #"No module name supplied" stderr)
       1)]
    [(cons _ (cons function-name (cons module-name module-files)))
      (case (extract-top-level-objects module-files)
        [(left v)
         (begin
           (write-line v stderr)
           1)]
        [(right code)
         (case (find-function
                 (bytes-append (varargs list function-name #"_" module-name))
                 code)
           [(left msg)
            (begin
              (write-line msg stderr)
              1)]
           [(right func)
            (begin
              (print-function func stdout)
              0)])])]))
