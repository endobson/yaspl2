(module print-stack-function
  (import
    (prim
      #:types (Bytes Byte InputPort OutputPort Array Void)
      #:values (panic make-bytes read-bytes < + = array-length array-ref open-input-file
                open-output-file close-output-port void bytes-set!)
      #:patterns ())
    (io read-all-bytes write-all-bytes write-line newline)
    (list
      #:types (List)
      #:values (empty cons append map list)
      #:patterns (empty cons))
    (numbers integer->decimal-bytes)
    (maybe
      #:types (Maybe)
      #:values ()
      #:patterns (just nothing))
    (join-list
      #:types (JoinList)
      #:values (empty-jl cons-jl append-jl append-jl* join-list jl->list single-jl)
      #:patterns ())
    (dict make-dict)
    (tuples tuple2)
    (bytes bytes=? bytes-append make-null-terminated)
    (source-language
      #:types (Module)
      #:values (parse-module)
      #:patterns ())
    (sexp-parser
      #:types (Sexp)
      #:values (parse-sexps)
      #:patterns ())
    (intermediate-to-stack
      #:types ()
      #:values (compile-module)
      #:patterns (compiled-module))
    (intermediate-to-module-signature
      #:types (ModuleSignature)
      #:values (module-signature)
      #:patterns ())
    (stack-machine
      #:types (StackFunction StackBasicBlock StackCmd StackTerminal VariantCases BinMathOp
               BinLogicMathOp TopLevelObject)
      #:values ()
      #:patterns (
          stack-function stack-basic-block boolean-jmp uncond-jmp variant-switch return
          no-catch-all-case catch-all-case variant-case num-lit-cmd boolean-lit-cmd
          bytes-lit-cmd bytes-cmp-cmd create-closure-cmd dup-cmd alloc-variant-cmd variant-ref-cmd
          make-array-from-stack-cmd make-array-cmd
          array-length-cmd array-ref-cmd array-set!-cmd pop-cmd swap-cmd fun-call-cmd
          known-fun-call-cmd load-global-cmd dup-free-var-cmd
          bin-math-cmd bin-add-op bin-sub-op bin-mult-op bin-quotient-op bin-remainder-op
          bin-logic-math-cmd less-than-op less-than-or-equal-op equal-op greater-than-or-equal-op
          greater-than-op function-tlo trivial-closure-tlo))
    (prim-implementation prim-implementation)
    (either
      #:types (Either)
      #:values (left right)
      #:patterns (left right))
    (compiler compile-modules extract-modules extract-sexps read-module-files prim-signature)
    (stack-machine-optimizer optimize-stack-function))
  (export extract-top-level-objects)
  (types)

  (define (find-function [name : Bytes] [code : (List TopLevelObject)]) : (Either Bytes StackFunction)
    (case code
      [(empty) (left #"Function not found")]
      [(cons (function-tlo func) code)
       (case func
         [(stack-function func-name _)
          (if (bytes=? name func-name)
              (right func)
              (find-function name code))])]
      [(cons (trivial-closure-tlo _ _) code)
       (find-function name code)]))

  (define (print-function [fun : StackFunction] [output : OutputPort]) : Void
    (case fun
     [(stack-function fun-name blocks)
      (begin
        (write-line fun-name output)
        (print-blocks blocks 0 output))]))

  (define (print-blocks [blocks : (List StackBasicBlock)] [index : Byte] [output : OutputPort]) : Void
    (case blocks
     [(empty) (void)]
     [(cons (stack-basic-block cmds terminal) blocks)
      (begin
        (write-all-bytes #"Block " output)
        (write-all-bytes (integer->decimal-bytes index) output)
        (newline output)
        (print-commands cmds output)
        (print-terminal terminal output)
        (print-blocks blocks (+ 1 index) output))]))

  (define (print-commands [commands : (List StackCmd)] [output : OutputPort]) : Void
    (write-all-bytes (bytes-append (jl->list (commands->bytes commands (empty-jl)))) output))

  (define (newline-bytes) : Bytes
    (let ([bytes (make-bytes 1)])
      (begin
        (bytes-set! bytes 0 10)
        bytes)))


  (define (commands->bytes [commands : (List StackCmd)] [acc : (JoinList Bytes)]) : Void
    (case commands
     [(empty) acc]
     [(cons command commands)
      (commands->bytes commands
        (varargs append-jl*
          (single-jl #"  ")
          (case command
            [(num-lit-cmd v)
             (varargs join-list
               #"numeric-literal: "
               (integer->decimal-bytes v)
               (newline-bytes))]
            [(boolean-lit-cmd v)
             (varargs join-list
               #"boolean-literal: "
               (if v #"true" #"false")
               (newline-bytes))]
            [(bytes-lit-cmd v)
             (varargs join-list
               #"bytes-literal: "
               v
               (newline-bytes))]
            [(bytes-cmp-cmd)
             (varargs join-list
               write-line #"bytes-cmp" 
               (newline-bytes))]
            [(create-closure-cmd free-vars)
             (varargs join-list
               #"create-closure: "
               (integer->decimal-bytes free-vars)
               (newline-bytes))]
            [(load-global-cmd name)
             (varargs join-list
               #"load-global: "
               name
               (newline-bytes))]
            [(dup-cmd offset)
             (varargs join-list
               #"dup: "
               (integer->decimal-bytes offset)
               (newline-bytes))]
            [(dup-free-var-cmd index offset)
             (varargs join-list
               #"dup-free-var: "
               (integer->decimal-bytes index)
               #" "
               (integer->decimal-bytes offset)
               (newline-bytes))]
            [(alloc-variant-cmd tag _)
             (varargs join-list
               #"alloc-variant: "
               (integer->decimal-bytes tag)
               (newline-bytes))]
            [(variant-ref-cmd tag field)
             (varargs join-list
               #"variant-ref: "
               (integer->decimal-bytes tag)
               #" "
               (integer->decimal-bytes field)
               (newline-bytes))]
            [(bin-math-cmd op)
             (varargs join-list
               (case op
                 [(bin-add-op) #"add"]
                 [(bin-sub-op) #"sub"]
                 [(bin-mult-op) #"mult"]
                 [(bin-quotient-op) #"quotient"]
                 [(bin-remainder-op) #"remainder"])
               (newline-bytes))]
            [(bin-logic-math-cmd op)
             (varargs join-list
               (case op
                 [(less-than-op) #"<"]
                 [(less-than-or-equal-op) #"<="]
                 [(equal-op) #"="]
                 [(greater-than-or-equal-op) #">="]
                 [(greater-than-op) #">"])
               (newline-bytes))]
            [(make-array-from-stack-cmd num-args)
             (varargs join-list
               #"make-array-from-stack: "
               (integer->decimal-bytes num-args)
               (newline-bytes))]
            [(make-array-cmd)
             (varargs join-list
               #"make-array"
               (newline-bytes))]
            [(array-length-cmd)
             (varargs join-list
               #"array-length"
               (newline-bytes))]
            [(array-ref-cmd)
             (varargs join-list
               #"array-ref"
               (newline-bytes))]
            [(array-set!-cmd)
             (varargs join-list
               #"array-set!"
               (newline-bytes))]
            [(pop-cmd)
             (varargs join-list
               #"pop"
               (newline-bytes))]
            [(swap-cmd)
             (varargs join-list
               #"swap"
               (newline-bytes))]
            [(fun-call-cmd num-args)
             (varargs join-list
               #"fun-call: "
               (integer->decimal-bytes num-args)
               (newline-bytes))]
            [(known-fun-call-cmd name num-args)
             (varargs join-list
               #"known-fun-call: "
               name
               #" "
               (integer->decimal-bytes num-args)
               (newline-bytes))])
          acc))]))

  (define (print-terminal [terminal : StackTerminal] [output : OutputPort]) : Void
    (begin
      (write-all-bytes #"  " output)
      (case terminal
        [(boolean-jmp true false)
         (begin
           (write-all-bytes #"cond-jmp " output)
           (write-all-bytes (integer->decimal-bytes true) output)
           (write-all-bytes #" " output)
           (write-all-bytes (integer->decimal-bytes false) output)
           (newline output))]
        [(uncond-jmp index)
         (begin
           (write-all-bytes #"jmp " output)
           (write-all-bytes (integer->decimal-bytes index) output)
           (newline output))]
        [(variant-switch cases)
         (begin
           (write-all-bytes #"switch" output)
           (print-cases cases output))]
        [(return _)
         (begin
           (write-line #"ret" output))])))

  (define (print-cases [cases : VariantCases] [output : OutputPort]) : Void
    (case cases
      [(no-catch-all-case) (newline output)]
      [(catch-all-case index)
       (begin
         (write-all-bytes #" _->" output)
         (write-all-bytes (integer->decimal-bytes index) output)
         (newline output))]
      [(variant-case tag index cases)
       (begin
         (write-all-bytes #" " output)
         (write-all-bytes (integer->decimal-bytes tag) output)
         (write-all-bytes #"->" output)
         (write-all-bytes (integer->decimal-bytes index) output)
         (print-cases cases output))]))

  (define (extract-top-level-objects [offset : Byte] [args : (Array Bytes)] [stderr : OutputPort])
    : (Either Bytes (List TopLevelObject))
    (case (extract-modules
            (map parse-module
              (extract-sexps
                (parse-sexps (bytes-append (read-module-files 3 args)))
                stderr)))
      [(left v)
       (left v)]
      [(right modules)
       (compile-modules
         modules
         (cons (prim-signature) (empty))
         (prim-implementation))]))

  (define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Byte
    (if (< (array-length args) 3)
        (begin
          (write-line #"Module/Function name not supplied" stderr)
          1)
        (case (extract-top-level-objects 3 args stderr) 
          [(left v)
           (begin
             (write-line v stderr)
             1)]
          [(right code)
           (case (find-function
                   (bytes-append (varargs list (array-ref args 1) #"_" (array-ref args 2)))
                   code)
             [(left msg)
              (begin
                (write-line msg stderr)
                1)]
             [(right func)
              (begin
                (print-function (optimize-stack-function func) stdout)
                0)])]))))
