(module print-stack-function
  (import
    (prim
      #:types (Bytes InputPort OutputPort Array Void Int)
      #:values (+)
      #:patterns ())
    (io write-all-bytes write-line)
    (list
      #:types (List)
      #:values (list array->list)
      #:patterns (empty cons))
    (numbers integer->decimal-bytes)
    (join-list
      #:types (JoinList)
      #:values (empty-jl cons-jl append-jl append-jl* join-list jl->list single-jl)
      #:patterns ())
    (bytes bytes=? bytes-append)
    (stack-machine
      #:types (StackFunction StackBasicBlock StackCmd StackTerminal VariantCases TopLevelObject)
      #:values ()
      #:patterns (
          stack-function stack-basic-block boolean-jmp uncond-jmp variant-switch return
          no-catch-all-case catch-all-case variant-case num-lit-cmd boolean-lit-cmd
          bytes-cmp-cmd create-closure-cmd dup-cmd alloc-variant-cmd variant-ref-cmd
          make-array-from-stack-cmd make-array-cmd
          array-length-cmd array-ref-cmd array-set!-cmd pop-cmd swap-cmd fun-call-cmd
          known-fun-call-cmd load-global-cmd dup-free-var-cmd
          bin-math-cmd bin-add-op bin-sub-op bin-mult-op bin-quotient-op bin-remainder-op
          bin-bitwise-and-op bin-bitwise-ior-op bin-logical-shift-left-op bin-logical-shift-right-op
          bin-logic-math-cmd less-than-op less-than-or-equal-op equal-op greater-than-or-equal-op
          tail-call known-tail-call
          greater-than-op function-tlo))
    (either
      #:types (Either)
      #:values (left right)
      #:patterns (left right))
    (compiler compile-modules parse-module-files))
  (export
    #:types ()
    #:values (extract-top-level-objects function->bytes block->bytes)
    #:patterns ())
  (types)

  (define (find-function [name : Bytes] [code : (List TopLevelObject)]) : (Either Bytes StackFunction)
    (case code
      [(empty) (left #"Function not found")]
      [(cons (function-tlo func) code)
       (case func
         [(stack-function func-name _ _)
          (if (bytes=? name func-name)
              (right func)
              (find-function name code))])]
      [(cons _ code)
       (find-function name code)]))

  (define (print-function [fun : StackFunction] [output : OutputPort]) : Void
    (case fun
     [(stack-function fun-name _ blocks)
      (write-all-bytes
        (bytes-append (jl->list (function->bytes fun)))
        output)]))

  (define (function->bytes [fun : StackFunction]) : (JoinList Bytes)
    (case fun
     [(stack-function fun-name _ blocks)
      (cons-jl
        fun-name
        (cons-jl
          #"\n"
          (blocks->bytes blocks 0)))]))

  (define (blocks->bytes [blocks : (List StackBasicBlock)] [index : Int]) : (JoinList Bytes)
    (case blocks
     [(empty) (empty-jl)]
     [(cons block blocks)
      (varargs append-jl*
        (single-jl #"Block ")
        (single-jl (integer->decimal-bytes index))
        (single-jl #"\n")
        (block->bytes block)
        (blocks->bytes blocks (+ 1 index)))]))

  (define (block->bytes [block : StackBasicBlock]) : (JoinList Bytes)
    (case block
      [(stack-basic-block cmds terminal)
       (append-jl
         (commands->bytes cmds)
         (terminal->bytes terminal))]))

  (define (commands->bytes [commands : (List StackCmd)]) : (JoinList Bytes)
    (case commands
     [(empty) (empty-jl)]
     [(cons command commands)
      (varargs append-jl*
        (single-jl #"  ")
        (case command
          [(num-lit-cmd v)
           (varargs join-list
             #"numeric-literal: "
             (integer->decimal-bytes v)
             #"\n")]
          [(boolean-lit-cmd v)
           (varargs join-list
             #"boolean-literal: "
             (if v #"true" #"false")
             #"\n")]
          [(bytes-cmp-cmd)
           (single-jl #"bytes-cmp \n")]
          [(create-closure-cmd free-vars)
           (varargs join-list
             #"create-closure: "
             (integer->decimal-bytes free-vars)
             #"\n")]
          [(load-global-cmd name)
           (varargs join-list
             #"load-global: "
             name
             #"\n")]
          [(dup-cmd offset)
           (varargs join-list
             #"dup: "
             (integer->decimal-bytes offset)
             #"\n")]
          [(dup-free-var-cmd index offset)
           (varargs join-list
             #"dup-free-var: "
             (integer->decimal-bytes index)
             #" "
             (integer->decimal-bytes offset)
             #"\n")]
          [(alloc-variant-cmd tag _)
           (varargs join-list
             #"alloc-variant: "
             (integer->decimal-bytes tag)
             #"\n")]
          [(variant-ref-cmd tag field)
           (varargs join-list
             #"variant-ref: "
             (integer->decimal-bytes tag)
             #" "
             (integer->decimal-bytes field)
             #"\n")]
          [(bin-math-cmd op)
           (varargs join-list
             (case op
               [(bin-add-op) #"add"]
               [(bin-sub-op) #"sub"]
               [(bin-mult-op) #"mult"]
               [(bin-quotient-op) #"quotient"]
               [(bin-remainder-op) #"remainder"]
               [(bin-bitwise-and-op) #"bitwise and"]
               [(bin-bitwise-ior-op) #"bitwise ior"]
               [(bin-logical-shift-left-op) #"logical shift left"]
               [(bin-logical-shift-right-op) #"logical shift right"]
               [_ #"unknown math op"])
             #"\n")]
          [(bin-logic-math-cmd op)
           (varargs join-list
             (case op
               [(less-than-op) #"<"]
               [(less-than-or-equal-op) #"<="]
               [(equal-op) #"="]
               [(greater-than-or-equal-op) #">="]
               [(greater-than-op) #">"]
               [_ #"unknown comparison op"])
             #"\n")]
          [(make-array-from-stack-cmd num-args)
           (varargs join-list
             #"make-array-from-stack: "
             (integer->decimal-bytes num-args)
             #"\n")]
          [(make-array-cmd)
           (single-jl #"make-array\n")]
          [(array-length-cmd)
           (single-jl #"array-length\n")]
          [(array-ref-cmd)
           (single-jl #"array-ref\n")]
          [(array-set!-cmd)
           (single-jl #"array-set!\n")]
          [(pop-cmd)
           (single-jl #"pop\n")]
          [(swap-cmd)
           (single-jl #"swap\n")]
          [(fun-call-cmd num-args)
           (varargs join-list
             #"fun-call: "
             (integer->decimal-bytes num-args)
             #"\n")]
          [(known-fun-call-cmd name num-args)
           (varargs join-list
             #"known-fun-call: "
             name
             #" "
             (integer->decimal-bytes num-args)
             #"\n")]
          [_
           (single-jl #"unknown-op\n")])
          (commands->bytes commands))]))

  (define (terminal->bytes [terminal : StackTerminal]) : (JoinList Bytes)
    (append-jl
      (single-jl #"  ")
      (case terminal
        [(boolean-jmp true false)
         (varargs join-list
           #"cond-jmp "
           (integer->decimal-bytes true)
           #" "
           (integer->decimal-bytes false)
           #"\n")]
        [(uncond-jmp index)
         (varargs join-list
           #"jmp "
           (integer->decimal-bytes index)
           #"\n")]
        [(variant-switch cases)
         (cons-jl #"switch" (cases->bytes cases))]
        [(return n)
         (varargs join-list
           #"ret "
           (integer->decimal-bytes n)
           #"\n")]
        [(tail-call num-args num-cleanup)
         (varargs join-list
           #"tail-call "
           (integer->decimal-bytes num-args)
           #" "
           (integer->decimal-bytes num-cleanup)
           #"\n")]
        [(known-tail-call name num-args num-cleanup)
         (varargs join-list
           #"known-tail-call: "
           name
           #" "
           (integer->decimal-bytes num-args)
           #" "
           (integer->decimal-bytes num-cleanup)
           #"\n")])))

  (define (cases->bytes [cases : VariantCases]) : (JoinList Bytes)
    (case cases
      [(no-catch-all-case) (single-jl #"\n")]
      [(catch-all-case index)
       (varargs join-list
         #" _->"
         (integer->decimal-bytes index)
         #"\n")]
      [(variant-case tag index cases)
       (append-jl
         (varargs join-list
           #" "
           (integer->decimal-bytes tag)
           #"->"
           (integer->decimal-bytes index))
         (cases->bytes cases))]))

  (define (extract-top-level-objects [module-files : (List Bytes)])
    : (Either Bytes (List TopLevelObject))
    (case (parse-module-files module-files)
      [(left v)
       (left v)]
      [(right modules)
       (compile-modules modules)]))

  (define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Int
    (case (array->list args)
      [(empty)
       (begin
         (write-line #"No executable specified???" stderr)
         1)]
      [(cons _ (empty))
       (begin
         (write-line #"No function name supplied." stderr)
         1)]
      [(cons _ (cons _ (empty)))
       (begin
         (write-line #"No module name supplied" stderr)
         1)]
      [(cons _ (cons function-name (cons module-name module-files)))
        (case (extract-top-level-objects module-files)
          [(left v)
           (begin
             (write-line v stderr)
             1)]
          [(right code)
           (case (find-function
                   (bytes-append (varargs list function-name #"_" module-name))
                   code)
             [(left msg)
              (begin
                (write-line msg stderr)
                1)]
             [(right func)
              (begin
                (print-function func stdout)
                0)])])])))
