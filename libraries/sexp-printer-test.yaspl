#:module (sexp-printer-test)
#:import {
  (bytes) {
    #:values
      bytes=?
  }
  (either) {
    #:patterns
      left
      right
  }
  (list) {
    #:values
      list
  }
  (prim) {
    #:types
      Array
      Boolean
      Bytes
      InputPort
      Int
      OutputPort
  }
  (sexp-parser) {
    #:values
      parse-single-sexp
  }
  (sexp-printer) {
    #:values
      print-sexp
  }
  (yunit) {
    #:values
      test-case
      yunit/main
  }
}
(export)
(types)


(define (canonical-sexp [bytes : Bytes]) : (-> Boolean)
  (lambda ()
    (case (parse-single-sexp bytes)
      [(left _) #f]
      [(right sexp)
       (bytes=? (print-sexp sexp) bytes)])))

(define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Int
  (yunit/main stderr
    (varargs list
      (test-case #"#t" (canonical-sexp #"#t"))
      (test-case #"#f" (canonical-sexp #"#f"))
      (test-case #"symbol abc" (canonical-sexp #"abc"))
      (test-case #"bytes abc" (canonical-sexp #"#\"abc\""))
      (test-case #"keyword abc" (canonical-sexp #"#:abc"))
      (test-case #"number 123" (canonical-sexp #"123"))
      (test-case #"parens ()" (canonical-sexp #"()"))
      (test-case #"parens (())" (canonical-sexp #"(())"))
      (test-case #"parens (() ())" (canonical-sexp #"(() ())"))
      (test-case #"complex ((123 456 seven) #:eight (#\"nine\"))"
                 (canonical-sexp #"((123 456 seven) #:eight (#\"nine\"))")))))
