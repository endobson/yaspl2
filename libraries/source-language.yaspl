#:module (source-language)
#:import {
  (either) {
    #:types
      Either
    #:values
      left
      right
    #:patterns
      left
      right
  }
  (list) {
    #:types
      List
    #:values
      cons
      empty
      extract-justs
      map
      reverse
    #:patterns
      cons
      empty
  }
  (maybe) {
    #:types
      Maybe
    #:values
      just
      nothing
    #:patterns
      just
      nothing
  }
  (module-name) {
    #:types
      ModName
    #:values
      mod-name
  }
  (prim) {
    #:types
      Boolean
      Bytes
      Int
  }
  (sexp-parser) {
    #:types
      Sexp
    #:patterns
      boolean-sexp
      brace-node
      bracket-node
      bytes-sexp
      keyword-sexp
      node
      number-sexp
      symbol-sexp
  }
  (tuples) {
    #:types
      Tuple2
    #:values
      tuple2
    #:patterns
      tuple2
  }
}
(export
  #:types (Module Imports Import Exports Export TypeDefinition VariantDefinition VariantField PreType
           FunctionDefinition Expression CaseClause Pattern Block BlockDefinition)
  #:values (module-name module-types module-definitions parse-module function-definition-name
           exports-values type-definition-variants var-pre-type export variant-field-type
           case-clause-body module-exports exports-patterns exports-types
           export-local-name export-exported-name module-imports import-exported-name
           type-definition-name var-expr app-expr function-definition-body
           variant-definition-name case-clause-pattern boolean-literal ignore-pattern int-literal
           case-clause case-expr bytes-pattern bytes-literal block)
  #:patterns (int-literal bytes-literal boolean-literal var-expr if-expr begin-expr app-expr
              varargs-app-expr let-expr lambda-expr case-expr case-clause module
              bytes-pattern int-pattern variable-pattern ignore-pattern abstraction-pattern
              function-definition variant-definition type-definition variant-field export exports
              import partial-imports block match-def
              var-pre-type fun-pre-type type-app-pre-type))
(types
  (define-type Module
    (module [name : ModName]
            [imports : (List Imports)]
            [exports : Exports]
            [types : (List TypeDefinition)]
            [definitions : (List FunctionDefinition)]))
  (define-type Imports
    (partial-imports
      [module-name : ModName]
      [types : (List Import)]
      [values : (List Import)]
      [patterns : (List Import)]))
  (define-type Import
    (import [exported-name : Bytes] [local-name : Bytes]))
  (define-type Exports
    (exports [types : (List Export)]
             [values : (List Export)]
             [patterns : (List Export)]))
  (define-type Export
    (export [local-name : Bytes] [exported-name : Bytes]))
  (define-type TypeDefinition
    (type-definition [name : Bytes] [vars : (Maybe (List Bytes))] [variants : (List VariantDefinition)]))
  (define-type VariantDefinition
    (variant-definition [name : Bytes] [fields : (List VariantField)]))
  (define-type VariantField
    (variant-field [name : Bytes] [type : PreType]))
  (define-type PreType
    (var-pre-type [v : Bytes])
    (fun-pre-type [type-vars : (List Bytes)] [args : (List PreType)] [result : PreType])
    (type-app-pre-type [constructor : Bytes] [args : (List PreType)]))
  ;; TODO make this have type variables because the type variables here scope over the body
  (define-type FunctionDefinition
    (function-definition [name : Bytes] [type : PreType] [args : (List Bytes)] [body : Block]))
  (define-type Block
    (block [definitions : (List BlockDefinition)] [expr : Expression]))
  (define-type BlockDefinition
    (match-def [pattern : Pattern] [expr : Expression]))

  (define-type Expression
    (int-literal [v : Int])
    (bytes-literal [v : Bytes])
    (boolean-literal [v : Boolean])
    (var-expr [v : Bytes])
    (if-expr [cond : Expression] [true : Expression] [false : Expression])
    (begin-expr [first-expr : Expression] [exprs : (List Expression)])
    (app-expr [op : Expression] [args : (List Expression)])
    (varargs-app-expr [op : Expression] [args : (List Expression)])
    (let-expr [name : Bytes] [expr : Expression] [body : Expression])
    (lambda-expr [args : (List (Tuple2 Bytes PreType))] [type : (Maybe PreType)] [body : Expression])
    (case-expr [expr : Expression] [clauses : (List CaseClause)]))

  (define-type CaseClause
    (case-clause [pattern : Pattern] [body : Block]))

  (define-type Pattern
    (bytes-pattern [v : Bytes])
    (int-pattern [v : Int])
    (variable-pattern [v : Bytes])
    (ignore-pattern)
    (abstraction-pattern [name : Bytes] [patterns : (List Pattern)])))

(define (a) (right/bytes [v : a]) : (Either Bytes a)
  (right v))
(define (nothing/pre-type) : (Maybe PreType)
  (nothing))

(define (a b) (leftmost-error [eithers : (List (Either a b))]) : (Either a (List b))
  (leftmost-error/helper eithers (empty)))

(define (a b) (leftmost-error/helper [eithers : (List (Either a b))] [acc : (List b)]) : (Either a (List b))
  (case eithers
    [(empty) (right (reverse acc))]
    [(cons (left v) _) (left v)]
    [(cons (right v) es)
     (leftmost-error/helper es (cons v acc))]))

(define (a b r)
  (either-app2
    [f : (a b -> r)]
    [e1 : (Either Bytes a)]
    [e2 : (Either Bytes b)]) : (Either Bytes r)
  (case e1
    [(left v) (left v)]
    [(right v1)
     (case e2
       [(left v) (left v)]
       [(right v2)
        (right (f v1 v2))])]))

(define (a b c r)
  (either-app3
    [f : (a b c -> r)]
    [e1 : (Either Bytes a)]
    [e2 : (Either Bytes b)]
    [e3 : (Either Bytes c)]) : (Either Bytes r)
  (case e1
    [(left v) (left v)]
    [(right v1)
     (case e2
       [(left v) (left v)]
       [(right v2)
        (case e3
          [(left v) (left v)]
          [(right v3)
           (right (f v1 v2 v3))])])]))

(define (parse-imports [sexps : (List Sexp)]) : (Either Bytes (List Imports))
  (case sexps
    [(empty)
     (right (empty))]
    [(cons _ (empty))
     (left #"Bad import form: odd number of elements")]
    [(cons (node module-name)
           (cons (brace-node import-elems)
                 next-imports))
     (case (parse-module-name module-name)
       [(left v) (left v)]
       [(right module-name)
        (case (parse-import-elems module-name import-elems)
          [(left v) (left v)]
          [(right imports)
           (case (parse-imports next-imports)
             [(left err) (left err)]
             [(right importss) (right (cons imports importss))])])])]
    [(cons _ (cons _ next-imports))
     (left #"Bad import form: not module name followed by brace")]))


(define (parse-import-elem-prefix [sexps : (List Sexp)]) : (Tuple2 (List Import) (List Sexp))
  (parse-import-elem-prefix* sexps (empty)))

(define (parse-import-elem-prefix* [sexps : (List Sexp)] [acc : (List Import)])
  : (Tuple2 (List Import) (List Sexp))
  (case sexps
    [(cons (symbol-sexp name) sexps)
     (parse-import-elem-prefix* sexps (cons (import name name) acc))]
    [(cons (bracket-node (cons (symbol-sexp exported-name) (cons (symbol-sexp local-name) (empty))))
           sexps)
     (parse-import-elem-prefix* sexps (cons (import exported-name local-name) acc))]
    [_
     (tuple2 (reverse acc) sexps)]))

(define (parse-import-elems [mod-name : ModName] [sexps : (List Sexp)]) : (Either Bytes Imports)
  (match-define no-imports ((lambda () : (List Import) (empty))))

  (match-define (tuple2 types sexps)
    (case sexps
      [(cons (keyword-sexp #"types") sexps)
       (parse-import-elem-prefix sexps)]
      [_
       (tuple2 no-imports sexps)]))
  (match-define (tuple2 values sexps)
    (case sexps
      [(cons (keyword-sexp #"values") sexps)
       (parse-import-elem-prefix sexps)]
      [_
       (tuple2 no-imports sexps)]))
  (match-define (tuple2 patterns sexps)
    (case sexps
      [(cons (keyword-sexp #"patterns") sexps)
       (parse-import-elem-prefix sexps)]
      [_
       (tuple2 no-imports sexps)]))

  (case sexps
    [(empty)
     (right (partial-imports mod-name types values patterns))]
    [_
     (left #"Not a valid imports clause")]))


(define (parse-exports/top [sexp : Sexp]) : (Either Bytes Exports)
  (case sexp
    [(node (cons (symbol-sexp #"export") (empty)))
     (right (exports (empty) (empty) (empty)))]
    [(node
       (cons (symbol-sexp #"export")
         (cons (keyword-sexp #"types")
           (cons (node type-exports)
             (cons (keyword-sexp #"values")
              (cons (node value-exports)
                 (cons (keyword-sexp #"patterns")
                   (cons (node pattern-exports)
                     (empty)))))))))
     (case (leftmost-error (map parse-exported-symbol type-exports))
       [(left v) (left v)]
       [(right type-names)
        (case (leftmost-error (map parse-exported-symbol value-exports))
          [(left v) (left v)]
          [(right value-names)
           (case (leftmost-error (map parse-exported-symbol pattern-exports))
             [(left v) (left v)]
             [(right pattern-names)
              (let ([convert (lambda ([name : Bytes]) (export name name))])
                (right (exports
                         (map convert type-names)
                         (map convert value-names)
                         (map convert pattern-names))))])])])]
    [_ (left #"Bad exports")]))

(define (parse-exported-symbol [sexp : Sexp]) : (Either Bytes Bytes)
  (case sexp
    [(symbol-sexp bytes) (right bytes)]
    [_ (left #"Not a valid export")]))


(define (parse-types/top [sexp : Sexp]) : (Either Bytes (List TypeDefinition))
  (case sexp
    [(node (cons (symbol-sexp #"types") type-definitions))
     (leftmost-error (map parse-type-definition type-definitions))]
    [_ (left #"Bad types")]))

(define (parse-type-definition [sexp : Sexp]) : (Either Bytes TypeDefinition)
  (case sexp
    [(node (cons (symbol-sexp #"define-type") (cons type-name/vars variants)))
     (case (extract-type-name type-name/vars)
       [(left v) (left v)]
       [(right type-name)
        (case (extract-type-vars type-name/vars)
          [(left v) (left v)]
          [(right type-vars)
           (case (leftmost-error (map parse-variant variants))
             [(left v) (left v)]
             [(right variants)
              (right (type-definition type-name type-vars variants))])])])]
    [_ (left #"Bad type definition")]))

(define (parse-variant [sexp : Sexp]) : (Either Bytes VariantDefinition)
  (case sexp
    [(node (cons (symbol-sexp variant-name) fields))
     (case (leftmost-error (map parse-variant-field fields))
       [(left v) (left v)]
       [(right fields)
        (right (variant-definition variant-name fields))])]
    [_ (left #"Bad variant definition")]))

(define (parse-variant-field [sexp : Sexp]) : (Either Bytes VariantField)
  (case sexp
    [(bracket-node (cons (symbol-sexp field-name) (cons (symbol-sexp #":") (cons type (empty)))))
     (case (parse-pre-type type)
       [(left v) (left v)]
       [(right type)
        (right (variant-field field-name type))])]
    [_ (left #"Bad variant field")]))

(define (extract-type-name [sexp : Sexp]) : (Either Bytes Bytes)
  (case sexp
    [(symbol-sexp type-name)
     (right type-name)]
    [(node (cons (symbol-sexp type-name) _))
     (right type-name)]
    [_ (left #"Bad type-name/vars")]))

(define (extract-type-vars [sexp : Sexp]) : (Either Bytes (Maybe (List Bytes)))
  (case sexp
    [(symbol-sexp _)
     (right (nothing))]
    [(node (cons _ type-var-sexps))
     (case (leftmost-error (map parse-type-var-symbol type-var-sexps))
       [(left v) (left v)]
       [(right type-vars)
        (right (just type-vars))])]
    [_ (left #"Bad type-name/vars")]))

(define (parse-type-var-symbol [sexp : Sexp]) : (Either Bytes Bytes)
  (case sexp
    [(symbol-sexp bytes) (right bytes)]
    [_ (left #"Not a valid type variable")]))


(define (parse-pre-type [sexp : Sexp]) : (Either Bytes PreType)
  (case sexp
    [(symbol-sexp v) (right (var-pre-type v))]
    ;; TODO Make function parsing better
    [(node (cons (symbol-sexp #"->") (cons result (empty))))
     (case (parse-pre-type result)
       [(left v) (left v)]
       [(right result)
        (right (fun-pre-type (empty) (empty) result))])]
    [(node (cons arg1 (cons (symbol-sexp #"->") (cons result (empty)))))
     (case (parse-pre-type arg1)
       [(left v) (left v)]
       [(right arg1)
        (case (parse-pre-type result)
          [(left v) (left v)]
          [(right result)
           (right (fun-pre-type (empty) (cons arg1 (empty)) result))])])]
    [(node (cons arg1 (cons arg2 (cons (symbol-sexp #"->") (cons result (empty))))))
     (case (parse-pre-type arg1)
       [(left v) (left v)]
       [(right arg1)
        (case (parse-pre-type arg2)
          [(left v) (left v)]
          [(right arg2)
           (case (parse-pre-type result)
             [(left v) (left v)]
             [(right result)
              (right (fun-pre-type (empty) (cons arg1 (cons arg2 (empty))) result))])])])]
    [(node (cons arg1 (cons arg2 (cons arg3 (cons (symbol-sexp #"->") (cons result (empty)))))))
     (case (parse-pre-type arg1)
       [(left v) (left v)]
       [(right arg1)
        (case (parse-pre-type arg2)
          [(left v) (left v)]
          [(right arg2)
           (case (parse-pre-type arg3)
             [(left v) (left v)]
             [(right arg3)
              (case (parse-pre-type result)
                [(left v) (left v)]
                [(right result)
                 (right (fun-pre-type (empty) (cons arg1 (cons arg2 (cons arg3 (empty)))) result))])])])])]
    [(node (cons (symbol-sexp constructor) args))
     (case (leftmost-error (map parse-pre-type args))
       [(left v) (left v)]
       [(right args)
        (right (type-app-pre-type constructor args))])]
    [_ (left #"Not a valid Type")]))

(define (parse-function-definition [sexp : Sexp]) : (Either Bytes FunctionDefinition)
  (case sexp
    [(node (cons (symbol-sexp #"define")
                 (cons (node type-vars)
                       (cons (node (cons (symbol-sexp function-name) args))
                             (cons (symbol-sexp #":")
                                   (cons result-type body))))))
     (case (leftmost-error (map parse-arg-type args))
       [(left v) (left v)]
       [(right arg-types)
        (case (leftmost-error (map parse-arg-name args))
          [(left v) (left v)]
          [(right arg-names)
           (case (leftmost-error (map parse-type-var-symbol type-vars))
             [(left v) (left v)]
             [(right type-vars)
              (case (parse-pre-type result-type)
                [(left v) (left v)]
                [(right result-type)
                 (case (parse-block body (empty))
                   [(left v) (left v)]
                   [(right body)
                    (right
                      (function-definition
                        function-name
                        (fun-pre-type type-vars arg-types result-type)
                        arg-names
                        body))])])])])])]
    [(node (cons (symbol-sexp #"define")
                 (cons (node (cons (symbol-sexp function-name) args))
                       (cons (symbol-sexp #":")
                             (cons result-type body)))))
     (case (leftmost-error (map parse-arg-type args))
       [(left v) (left v)]
       [(right arg-types)
        (case (leftmost-error (map parse-arg-name args))
          [(left v) (left v)]
          [(right arg-names)
           (case (parse-pre-type result-type)
             [(left v) (left v)]
             [(right result-type)
              (case (parse-block body (empty))
                [(left v) (left v)]
                [(right body)
                 (right
                   (function-definition
                     function-name
                     (fun-pre-type (empty) arg-types result-type)
                     arg-names
                     body))])])])])]
    [_ (left #"Not a valid function definition")]))

(define (parse-arg-type [sexp : Sexp]) : (Either Bytes PreType)
  (case sexp
    [(bracket-node (cons (symbol-sexp _) (cons (symbol-sexp #":") (cons type (empty)))))
     (parse-pre-type type)]
    [_ (left #"Not a valid argument")]))
(define (parse-arg-name [sexp : Sexp]) : (Either Bytes Bytes)
  (case sexp
    [(bracket-node (cons (symbol-sexp name) (cons (symbol-sexp #":") (cons _ (empty)))))
     (right name)]
    [_ (left #"Not a valid argument")]))
(define (parse-arg [sexp : Sexp]) : (Either Bytes (Tuple2 Bytes PreType))
  (case sexp
    [(bracket-node (cons (symbol-sexp name) (cons (symbol-sexp #":") (cons type (empty)))))
     (case (parse-pre-type type)
       [(left v) (left v)]
       [(right pre-type)
        (right (tuple2 name pre-type))])]
    [_ (left #"Not a valid argument")]))

(define (parse-block [sexps : (List Sexp)] [rev-defs : (List BlockDefinition)]) : (Either Bytes Block)
  (case sexps
    [(empty) (left #"Block must have at least one form")]
    [(cons expr (empty))
     (case (parse-expression expr)
       [(left v) (left v)]
       [(right expr)
        (right (block (reverse rev-defs) expr))])]
    [(cons def sexps)
     (case (parse-block-definition def)
       [(left v) (left v)]
       [(right def)
        (parse-block sexps (cons def rev-defs))])]))

(define (parse-block-definition [sexp : Sexp]) : (Either Bytes BlockDefinition)
  (case sexp
    [(node (cons (symbol-sexp #"match-define") (cons pattern-sexp (cons expr-sexp (empty)))))
     (case (parse-pattern pattern-sexp)
       [(left v) (left v)]
       [(right pattern)
        (case (parse-expression expr-sexp)
          [(left v) (left v)]
          [(right expr)
           (right (match-def pattern expr))])])]
    [_ (left #"Not a valid block definition")]))

(define (parse-expression [sexp : Sexp]) : (Either Bytes Expression)
  (case sexp
    [(number-sexp v) (right (int-literal v))]
    [(bytes-sexp v) (right (bytes-literal v))]
    [(boolean-sexp v) (right (boolean-literal v))]
    [(symbol-sexp v) (right (var-expr v))]
    [(node (cons (symbol-sexp #"if") (cons cond (cons true (cons false (empty))))))
     (either-app3 if-expr (parse-expression cond) (parse-expression true) (parse-expression false))]
    [(node (cons (symbol-sexp #"begin") (cons first-expr exprs)))
     (either-app2 begin-expr
       (parse-expression first-expr)
       (leftmost-error (map parse-expression exprs)))]
    [(node (cons (symbol-sexp #"varargs") (cons op-expr exprs)))
     (either-app2 varargs-app-expr (parse-expression op-expr) (leftmost-error (map parse-expression exprs)))]
    [(node (cons (symbol-sexp #"let")
                 (cons (node (cons (bracket-node (cons (symbol-sexp name) (cons expr (empty)))) (empty)))
                       (cons body (empty)))))
     (either-app3 let-expr
       (right/bytes name) (parse-expression expr) (parse-expression body))]
    [(node (cons (symbol-sexp #"case") (cons expr clauses)))
     (either-app2 case-expr (parse-expression expr) (leftmost-error (map parse-case-clause clauses)))]
    [(node (cons (symbol-sexp #"lambda") (cons (node arg+tys) (cons body-expr (empty)))))
     (either-app3 lambda-expr
       (leftmost-error (map parse-arg arg+tys))
       (right/bytes (nothing/pre-type))
       (parse-expression body-expr))]
    [(node (cons (symbol-sexp #"lambda")
                 (cons (node arg+tys)
                       (cons (symbol-sexp #":")
                             (cons type-expr
                                   (cons body-expr (empty)))))))
     (case (parse-pre-type type-expr)
       [(left v) (left v)]
       [(right pre-type)
        (either-app3 lambda-expr
          (leftmost-error (map parse-arg arg+tys))
          (right/bytes (just pre-type))
          (parse-expression body-expr))])]
    [(node (cons op-expr arg-exprs))
     (either-app2 app-expr
       (parse-expression op-expr)
       (leftmost-error (map parse-expression arg-exprs)))]
    [(node (empty))
     (left #"Application needs an operator")]
    [(bracket-node _)
     (left #"Bracketed nodes are not valid expressions")]
    [(brace-node _)
     (left #"Braced nodes are not valid expressions")]
    [(keyword-sexp _)
     (left #"Keywords are not valid expressions")]))

(define (parse-case-clause [sexp : Sexp]) : (Either Bytes CaseClause)
  (case sexp
    [(bracket-node (cons pattern body))
     (either-app2 case-clause (parse-pattern pattern) (parse-block body (empty)))]
    [_ (left #"Not a valid case clause")]))

(define (parse-pattern [sexp : Sexp]) : (Either Bytes Pattern)
  (case sexp
    [(symbol-sexp #"_") (right (ignore-pattern))]
    [(symbol-sexp sym) (right (variable-pattern sym))]
    [(bytes-sexp v) (right (bytes-pattern v))]
    [(number-sexp v) (right (int-pattern v))]
    [(node (cons (symbol-sexp name) patterns))
     (either-app2 abstraction-pattern
       (right/bytes name)
       (leftmost-error (map parse-pattern patterns)))]
    [_ (left #"Not a valid pattern")]))


(define (parse-module [sexp : (List Sexp)]) : (Either Bytes Module)
  (case sexp
    [(cons (keyword-sexp #"module") bodies)
     (parse-module-inner bodies)]
    [_ (left #"Bad module form")]))

(define (parse-module-inner [bodies : (List Sexp)]) : (Either Bytes Module)
  (case bodies
    [(cons (node module-name-parts)
           (cons (keyword-sexp #"import")
                 (cons (brace-node import-sexps)
                       (cons exports
                             (cons types
                                   definitions)))))
     (case (parse-module-name module-name-parts)
       [(left v) (left v)]
       [(right module-name)
        (case (parse-imports import-sexps)
          [(left v) (left v)]
          [(right imports)
           (case (parse-exports/top exports)
             [(left v) (left v)]
             [(right exports)
              (case (parse-types/top types)
                [(left v) (left v)]
                [(right types)
                 (case (leftmost-error (map parse-function-definition definitions))
                   [(left v) (left v)]
                   [(right defs)
                    (right (module module-name imports exports types defs))])])])])])]
    [_ (left #"Bad module form")]))

(define (parse-module-name [forms : (List Sexp)]) : (Either Bytes ModName)
  (case (extract-justs (map parse-symbol forms))
    [(just vs) (right (mod-name vs))]
    [(nothing) (left #"Bod module name")]))

(define (parse-symbol [form : Sexp]) : (Maybe Bytes)
  (case form
    [(symbol-sexp v) (just v)]
    [_ (nothing)]))
