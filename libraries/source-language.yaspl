(module source-language
  (import
    (prim
      #:types (Bytes InputPort OutputPort Byte Boolean Array)
      #:values ()
      #:patterns ())
    (sexp-parser
      #:types (Sexp)
      #:values (parse-sexp)
      #:patterns (node symbol-sexp number-sexp bytes-sexp keyword-sexp boolean-sexp))
    (io write-all-bytes read-all-bytes)
    (tuples
      #:types (Tuple2)
      #:values (tuple2)
      #:patterns ())
    (either
      #:types (Either)
      #:values (left right)
      #:patterns (left right))
    (maybe
      #:types (Maybe)
      #:values (just nothing)
      #:patterns ())
    (list
      #:types (List)
      #:values (cons empty map reverse append)
      #:patterns (cons empty)))
  (export
    #:types(Module Imports Import Exports Export TypeDefinition VariantDefinition VariantField PreType
            FunctionDefinition Expression CaseClause Pattern)
    #:values (main module-name module-types module-definitions parse-module function-definition-name
             exports-values type-definition-variants var-pre-type export)
    #:patterns (byte-literal bytes-literal boolean-literal var-expr if-expr begin-expr app-expr
                varargs-app-expr let-expr lambda-expr case-expr case-clause module
                bytes-pattern byte-pattern variable-pattern ignore-pattern abstraction-pattern
                function-definition variant-definition type-definition variant-field export exports
                import imports))
  (types
    (define-type Module
      (module [name Bytes]
              [imports (List Imports)]
              [exports Exports]
              [types (List TypeDefinition)]
              [definitions (List FunctionDefinition)]))
    (define-type Imports
      (imports [module-name Bytes] [types (List Import)] [values (List Import)] [patterns (List Import)]))
    (define-type Import
      (import [exported-name Bytes] [local-name Bytes]))
    (define-type Exports
      (exports [types (List Export)]
               [values (List Export)]
               [patterns (List Export)]))
    (define-type Export
      (export [local-name Bytes] [exported-name Bytes]))
    (define-type TypeDefinition
      (type-definition [name Bytes] [vars (Maybe (List Bytes))] [variants (List VariantDefinition)]))
    (define-type VariantDefinition
      (variant-definition [name Bytes] [fields (List VariantField)]))
    (define-type VariantField
      (variant-field [name Bytes] [type PreType]))
    (define-type PreType
      (var-pre-type [v Bytes])
      (fun-pre-type [type-vars (List Bytes)] [args (List PreType)] [result PreType])
      (type-app-pre-type [constructor Bytes] [args (List PreType)]))
    (define-type FunctionDefinition
      (function-definition [name Bytes] [type PreType] [args (List Bytes)] [body Expression]))

    (define-type Expression
      (byte-literal [v Byte])
      (bytes-literal [v Bytes])
      (boolean-literal [v Boolean])
      (var-expr [v Bytes])
      (if-expr [cond Expression] [true Expression] [false Expression])
      (begin-expr [first-expr Expression] [exprs (List Expression)])
      (app-expr [op Expression] [args (List Expression)])
      (varargs-app-expr [op Expression] [args (List Expression)])
      (let-expr [name Bytes] [expr Expression] [body Expression])
      (lambda-expr [args (List (Tuple2 Bytes PreType))] [body Expression])
      (case-expr [expr Expression] [clauses (List CaseClause)]))

    (define-type CaseClause
      (case-clause [pattern Pattern] [expr Expression]))

    (define-type Pattern
      (bytes-pattern [v Bytes])
      (byte-pattern [v Byte])
      (variable-pattern [v Bytes])
      (ignore-pattern)
      (abstraction-pattern [name Bytes] [patterns (List Pattern)])))

  (define (a) (right/bytes [v : a]) : (Either Bytes a)
    (right v))

  (define (a b) (leftmost-error [eithers : (List (Either a b))]) : (Either a (List b))
    (leftmost-error/helper eithers (empty)))

  (define (a b) (leftmost-error/helper [eithers : (List (Either a b))] [acc : (List b)]) : (Either a (List b))
    (case eithers
      [(empty) (right (reverse acc))]
      [(cons (left v) _) (left v)]
      [(cons (right v) es)
       (leftmost-error/helper es (cons v acc))]))

  (define (a r) (either-app1 [f : (a -> r)] [e1 : (Either Bytes a)]) : (Either Bytes r)
    (case e1
      [(left v) (left v)]
      [(right v1)
       (right (f v1))]))

  (define (a b r)
    (either-app2
      [f : (a b -> r)]
      [e1 : (Either Bytes a)]
      [e2 : (Either Bytes b)]) : (Either Bytes r)
    (case e1
      [(left v) (left v)]
      [(right v1)
       (case e2
         [(left v) (left v)]
         [(right v2)
          (right (f v1 v2))])]))

  (define (a b c r)
    (either-app3
      [f : (a b c -> r)]
      [e1 : (Either Bytes a)]
      [e2 : (Either Bytes b)]
      [e3 : (Either Bytes c)]) : (Either Bytes r)
    (case e1
      [(left v) (left v)]
      [(right v1)
       (case e2
         [(left v) (left v)]
         [(right v2)
          (case e3
            [(left v) (left v)]
            [(right v3)
             (right (f v1 v2 v3))])])]))


  (define (parse-imports/top [sexp : Sexp]) : (Either Bytes (List Imports))
    (case sexp
      [(node (cons (symbol-sexp #"import") imports))
       (leftmost-error (map parse-imports imports))]
      [_ (left #"Not a valid imports section")]))

  (define (parse-imports [sexp : Sexp]) : (Either Bytes Imports)
    (case sexp
      [(node (cons (symbol-sexp mod-name) inner))
       (case inner
         [(cons (keyword-sexp #"types")
            (cons (node type-imports)
              (cons (keyword-sexp #"values")
               (cons (node value-imports)
                  (cons (keyword-sexp #"patterns")
                    (cons (node pattern-imports)
                      (empty)))))))
          (case (leftmost-error (map parse-import type-imports))
            [(left v) (left v)]
            [(right types)
             (case (leftmost-error (map parse-import value-imports))
               [(left v) (left v)]
               [(right values)
                (case (leftmost-error (map parse-import pattern-imports))
                  [(left v) (left v)]
                  [(right patterns)
                   (right (imports mod-name types values patterns))])])])]
         [_
          (case (leftmost-error (map parse-import inner))
            [(left v) (left v)]
            [(right values)
             (right (imports mod-name (empty) values (empty)))])])]
      [_ (left #"Not a valid imports clause")]))

  (define (parse-import [sexp : Sexp]) : (Either Bytes Import)
    (case sexp
      [(symbol-sexp v) (right (import v v))]
      [(node (cons (symbol-sexp external-name) (cons (symbol-sexp local-name) (empty))))
       (right (import external-name local-name))]
      [_ (left #"Not a valid import clause")]))


  (define (parse-exports/top [sexp : Sexp]) : (Either Bytes Exports)
    (case sexp
      [(node (cons (symbol-sexp #"export") (empty)))
       (right (exports (empty) (empty) (empty)))]
      [(node
         (cons (symbol-sexp #"export")
           (cons (keyword-sexp #"types")
             (cons (node type-exports)
               (cons (keyword-sexp #"values")
                (cons (node value-exports)
                   (cons (keyword-sexp #"patterns")
                     (cons (node pattern-exports)
                       (empty)))))))))
       (case (leftmost-error (map parse-exported-symbol type-exports))
         [(left v) (left v)]
         [(right type-names)
          (case (leftmost-error (map parse-exported-symbol value-exports))
            [(left v) (left v)]
            [(right value-names)
             (case (leftmost-error (map parse-exported-symbol pattern-exports))
               [(left v) (left v)]
               [(right pattern-names)
                (let ([convert (lambda ([name : Bytes]) (export name name))])
                  (right (exports
                           (map convert type-names)
                           (map convert value-names)
                           (map convert pattern-names))))])])])]
      [_ (left #"Bad exports")]))

  (define (parse-exported-symbol [sexp : Sexp]) : (Either Bytes Bytes)
    (case sexp
      [(symbol-sexp bytes) (right bytes)]
      [_ (left #"Not a valid export")]))


  (define (parse-types/top [sexp : Sexp]) : (Either Bytes (List TypeDefinition))
    (case sexp
      [(node (cons (symbol-sexp #"types") type-definitions))
       (leftmost-error (map parse-type-definition type-definitions))]
      [_ (left #"Bad types")]))

  (define (parse-type-definition [sexp : Sexp]) : (Either Bytes TypeDefinition)
    (case sexp
      [(node (cons (symbol-sexp #"define-type") (cons type-name/vars variants)))
       (case (extract-type-name type-name/vars)
         [(left v) (left v)]
         [(right type-name)
          (case (extract-type-vars type-name/vars)
            [(left v) (left v)]
            [(right type-vars)
             (case (leftmost-error (map parse-variant variants))
               [(left v) (left v)]
               [(right variants)
                (right (type-definition type-name type-vars variants))])])])]
      [_ (left #"Bad type definition")]))

  (define (parse-variant [sexp : Sexp]) : (Either Bytes VariantDefinition)
    (case sexp
      [(node (cons (symbol-sexp variant-name) fields))
       (case (leftmost-error (map parse-variant-field fields))
         [(left v) (left v)]
         [(right fields)
          (right (variant-definition variant-name fields))])]
      [_ (left #"Bad variant definition")]))

  (define (parse-variant-field [sexp : Sexp]) : (Either Bytes VariantField)
    (case sexp
      [(node (cons (symbol-sexp field-name) (cons type (empty))))
       (case (parse-pre-type type)
         [(left v) (left v)]
         [(right type)
          (right (variant-field field-name type))])]
      [_ (left #"Bad variant field")]))

  (define (extract-type-name [sexp : Sexp]) : (Either Bytes Bytes)
    (case sexp
      [(symbol-sexp type-name)
       (right type-name)]
      [(node (cons (symbol-sexp type-name) _))
       (right type-name)]
      [_ (left #"Bad type-name/vars")]))

  (define (extract-type-vars [sexp : Sexp]) : (Either Bytes (Maybe (List Bytes)))
    (case sexp
      [(symbol-sexp _)
       (right (nothing))]
      [(node (cons _ type-var-sexps))
       (case (leftmost-error (map parse-type-var-symbol type-var-sexps))
         [(left v) (left v)]
         [(right type-vars)
          (right (just type-vars))])]
      [_ (left #"Bad type-name/vars")]))

  (define (parse-type-var-symbol [sexp : Sexp]) : (Either Bytes Bytes)
    (case sexp
      [(symbol-sexp bytes) (right bytes)]
      [_ (left #"Not a valid type variable")]))


  (define (parse-pre-type [sexp : Sexp]) : (Either Bytes PreType)
    (case sexp
      [(symbol-sexp v) (right (var-pre-type v))]
      ;; TODO Make function parsing better
      [(node (cons arg (cons (symbol-sexp #"->") (cons result (empty)))))
       (case (parse-pre-type arg)
         [(left v) (left v)]
         [(right arg)
          (case (parse-pre-type result)
            [(left v) (left v)]
            [(right result)
             (right (fun-pre-type (empty) (cons arg (empty)) result))])])]
      [(node (cons (symbol-sexp constructor) args))
       (case (leftmost-error (map parse-pre-type args))
         [(left v) (left v)]
         [(right args)
          (right (type-app-pre-type constructor args))])]
      [_ (left #"Not a valid Type")]))

  (define (parse-function-definition [sexp : Sexp]) : (Either Bytes FunctionDefinition)
    (case sexp
      [(node (cons (symbol-sexp #"define")
                   (cons (node type-vars)
                         (cons (node (cons (symbol-sexp function-name) args))
                               (cons (symbol-sexp #":")
                                     (cons result-type (cons body (empty))))))))
       (case (leftmost-error (map parse-arg-type args))
         [(left v) (left v)]
         [(right arg-types)
          (case (leftmost-error (map parse-arg-name args))
            [(left v) (left v)]
            [(right arg-names)
             (case (leftmost-error (map parse-type-var-symbol type-vars))
               [(left v) (left v)]
               [(right type-vars)
                (case (parse-pre-type result-type)
                  [(left v) (left v)]
                  [(right result-type)
                   (case (parse-expression body)
                     [(left v) (left v)]
                     [(right expression)
                      (right
                        (function-definition
                          function-name
                          (fun-pre-type type-vars arg-types result-type)
                          arg-names 
                          expression))])])])])])]
      [(node (cons (symbol-sexp #"define")
                   (cons (node (cons (symbol-sexp function-name) args))
                         (cons (symbol-sexp #":")
                               (cons result-type (cons body (empty)))))))
       (case (leftmost-error (map parse-arg-type args))
         [(left v) (left v)]
         [(right arg-types)
          (case (leftmost-error (map parse-arg-name args))
            [(left v) (left v)]
            [(right arg-names)
             (case (parse-pre-type result-type)
               [(left v) (left v)]
               [(right result-type)
                (case (parse-expression body)
                  [(left v) (left v)]
                  [(right expression)
                   (right
                     (function-definition
                       function-name
                       (fun-pre-type (empty) arg-types result-type)
                       arg-names
                       expression))])])])])]
      [_ (left #"Not a valid function definition")]))

  (define (parse-arg-type [sexp : Sexp]) : (Either Bytes PreType)
    (case sexp
      [(node (cons (symbol-sexp _) (cons (symbol-sexp #":") (cons type (empty)))))
       (parse-pre-type type)]
      [_ (left #"Not a valid argument")]))
  (define (parse-arg-name [sexp : Sexp]) : (Either Bytes Bytes)
    (case sexp
      [(node (cons (symbol-sexp name) (cons (symbol-sexp #":") (cons _ (empty)))))
       (right name)]
      [_ (left #"Not a valid argument")]))
  (define (parse-arg [sexp : Sexp]) : (Either Bytes (Tuple2 Bytes PreType))
    (case sexp
      [(node (cons (symbol-sexp name) (cons (symbol-sexp #":") (cons type (empty)))))
       (case (parse-pre-type type)
         [(left v) (left v)]
         [(right pre-type)
          (right (tuple2 name pre-type))])]
      [_ (left #"Not a valid argument")]))

  (define (parse-expression [sexp : Sexp]) : (Either Bytes Expression)
    (case sexp
      [(number-sexp v) (right (byte-literal v))]
      [(bytes-sexp v) (right (bytes-literal v))]
      [(boolean-sexp v) (right (boolean-literal v))]
      [(symbol-sexp v) (right (var-expr v))]
      [(node (cons (symbol-sexp #"if") (cons cond (cons true (cons false (empty))))))
       (either-app3 if-expr (parse-expression cond) (parse-expression true) (parse-expression false))]
      [(node (cons (symbol-sexp #"begin") (cons first-expr exprs)))
       (either-app2 begin-expr
         (parse-expression first-expr)
         (leftmost-error (map parse-expression exprs)))]
      [(node (cons (symbol-sexp #"varargs") (cons op-expr exprs)))
       (either-app2 varargs-app-expr (parse-expression op-expr) (leftmost-error (map parse-expression exprs)))]
      [(node (cons (symbol-sexp #"let")
                   (cons (node (cons (node (cons (symbol-sexp name) (cons expr (empty)))) (empty)))
                         (cons body (empty)))))
       (either-app3 let-expr
         (right/bytes name) (parse-expression expr) (parse-expression body))]
      [(node (cons (symbol-sexp #"case") (cons expr clauses)))
       (either-app2 case-expr (parse-expression expr) (leftmost-error (map parse-case-clause clauses)))]
      [(node (cons (symbol-sexp #"lambda") (cons (node arg+tys) (cons body-expr (empty)))))
       (either-app2 lambda-expr
         (leftmost-error (map parse-arg arg+tys))
         (parse-expression body-expr))]
      [(node (cons op-expr arg-exprs))
       (either-app2 app-expr
         (parse-expression op-expr)
         (leftmost-error (map parse-expression arg-exprs)))]
      [(node (empty))
       (left #"Application needs an operator")]
      [(keyword-sexp _)
       (left #"Keywords are not valid expressions")]))

  (define (parse-case-clause [sexp : Sexp]) : (Either Bytes CaseClause)
    (case sexp
      [(node (cons pattern (cons expr (empty))))
       (either-app2 case-clause (parse-pattern pattern) (parse-expression expr))]
      [_ (left #"Not a valid case clause")]))

  (define (parse-pattern [sexp : Sexp]) : (Either Bytes Pattern)
    (case sexp
      [(symbol-sexp #"_") (right (ignore-pattern))]
      [(symbol-sexp sym) (right (variable-pattern sym))]
      [(bytes-sexp v) (right (bytes-pattern v))]
      [(number-sexp v) (right (byte-pattern v))]
      [(node (cons (symbol-sexp name) patterns))
       (either-app2 abstraction-pattern
         (right/bytes name)
         (leftmost-error (map parse-pattern patterns)))]
      [_ (left #"Not a valid pattern")]))


  (define (parse-module [sexp : Sexp]) : (Either Bytes Module)
    (case sexp
      [(node (cons (symbol-sexp #"module")
                   (cons (symbol-sexp name)
                         (cons imports
                               (cons exports
                                     (cons types
                                           definitions))))))
       (case (parse-imports/top imports)
         [(left v) (left v)]
         [(right imports)
          (case (parse-exports/top exports)
            [(left v) (left v)]
            [(right exports)
             (case (parse-types/top types)
               [(left v) (left v)]
               [(right types)
                (case (leftmost-error (map parse-function-definition definitions))
                  [(left v) (left v)]
                  [(right defs)
                   (right (module name imports exports types defs))])])])])]
      [_ (left #"Bad module form")]))


  (define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Byte
    (case (parse-sexp (read-all-bytes stdin))
      [(left bytes)
       (begin
         (write-all-bytes bytes stderr)
         1)]
      [(right sexp)
       (case (parse-module sexp)
         [(right _) 0]
         [(left bytes)
          (begin
            (write-all-bytes bytes stderr)
            1)])])))
