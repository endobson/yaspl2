#:module (source-language)
#:import {
  (bytes)
  (either)
  (list)
  (maybe)
  (module-name)
  (prim)
  (sexp-parser)
  (tuples)
}
(export
  (#:types Module Imports Import Exports Export TypeDefinition VariantDefinition VariantField PreType
           FunctionDefinition Expression CaseClause Pattern Block BlockDefinition)
  (#:values module-name module-types module-definitions parse-module function-definition-name
            exports-values type-definition-variants var-pre-type fun-pre-type export variant-field-type
            case-clause-body module-exports exports-patterns exports-types
            export-local-name export-exported-name module-imports import-exported-name
            type-definition-name var-expr app-expr function-definition-body
            variant-definition-name variant-field-name case-clause-pattern boolean-literal
            ignore-pattern int-literal case-clause case-expr bytes-pattern bytes-literal block
            import-local-name partial-imports full-imports import
            parse-expression)
  (#:patterns int-literal bytes-literal boolean-literal var-expr if-expr begin-expr app-expr
              varargs-app-expr let-expr lambda-expr case-expr annotated-expr case-clause module
              bytes-pattern int-pattern variable-pattern ignore-pattern abstraction-pattern
              function-definition variant-definition type-definition variant-field export exports
              import partial-imports block match-def
              var-pre-type fun-pre-type type-app-pre-type full-imports))
(types
  (define-type Module
    (module [name : ModName]
            [imports : (List Imports)]
            [exports : Exports]
            [types : (List TypeDefinition)]
            [definitions : (List FunctionDefinition)]))
  (define-type Imports
    (full-imports [module-name : ModName])
    (partial-imports
      [module-name : ModName]
      [types : (List Import)]
      [values : (List Import)]
      [patterns : (List Import)]))
  (define-type Import
    (import [exported-name : Bytes] [local-name : Bytes]))
  (define-type Exports
    (exports [types : (List Export)]
             [values : (List Export)]
             [patterns : (List Export)]))
  (define-type Export
    (export [local-name : Bytes] [exported-name : Bytes]))
  (define-type TypeDefinition
    (type-definition [name : Bytes] [vars : (Maybe (List Bytes))] [variants : (List VariantDefinition)]))
  (define-type VariantDefinition
    (variant-definition [name : Bytes] [fields : (List VariantField)]))
  (define-type VariantField
    (variant-field [name : Bytes] [type : PreType]))
  (define-type PreType
    (var-pre-type [v : Bytes])
    (fun-pre-type [type-vars : (List Bytes)] [args : (List PreType)] [result : PreType])
    (type-app-pre-type [constructor : Bytes] [args : (List PreType)]))
  (define-type FunctionDefinition
    (function-definition [name : Bytes]
                         [type-vars : (List Bytes)]
                         [args : (List (Tuple2 Bytes PreType))]
                         [return-type : PreType]
                         [body : Block]))
  (define-type Block
    (block [definitions : (List BlockDefinition)] [expr : Expression]))
  (define-type BlockDefinition
    (match-def [pattern : Pattern] [type : (Maybe PreType)] [expr : Expression]))

  (define-type Expression
    (int-literal [v : Int])
    (bytes-literal [v : Bytes])
    (boolean-literal [v : Boolean])
    (var-expr [v : Bytes])
    (annotated-expr [t : PreType] [e : Expression])
    (if-expr [cond : Expression] [true : Expression] [false : Expression])
    (begin-expr [exprs : (List Expression)] [last-expr : Expression])
    (app-expr [tail-position : Boolean] [op : Expression] [args : (List Expression)])
    (varargs-app-expr [tail-position : Boolean] [op : Expression] [args : (List Expression)])
    (let-expr [name : Bytes] [expr : Expression] [body : Block])
    (lambda-expr [args : (List (Tuple2 Bytes PreType))] [type : (Maybe PreType)] [body : Expression])
    (case-expr [expr : Expression] [clauses : (List CaseClause)]))

  (define-type CaseClause
    (case-clause [pattern : Pattern] [body : Block]))

  (define-type Pattern
    (bytes-pattern [v : Bytes])
    (int-pattern [v : Int])
    (variable-pattern [v : Bytes])
    (ignore-pattern)
    (abstraction-pattern [name : Bytes] [patterns : (List Pattern)])))

(define (a) (right/bytes [v : a]) : (Either Bytes a)
  (right v))
(define (nothing/pre-type) : (Maybe PreType)
  (nothing))

(define (a b r)
  (either-app2
    [f : (a b -> r)]
    [e1 : (Either Bytes a)]
    [e2 : (Either Bytes b)]) : (Either Bytes r)
  (case e1
    [(left v) (left v)]
    [(right v1)
     (case e2
       [(left v) (left v)]
       [(right v2)
        (right (f v1 v2))])]))

(define (a b c r)
  (either-app3
    [f : (a b c -> r)]
    [e1 : (Either Bytes a)]
    [e2 : (Either Bytes b)]
    [e3 : (Either Bytes c)]) : (Either Bytes r)
  (case e1
    [(left v) (left v)]
    [(right v1)
     (case e2
       [(left v) (left v)]
       [(right v2)
        (case e3
          [(left v) (left v)]
          [(right v3)
           (right (f v1 v2 v3))])])]))

(define (parse-imports [sexps : (List Sexp)]) : (Either Bytes (List Imports))
  (case sexps
    [(empty)
     (right (empty))]
    [(cons (brace-node (cons (node module-name) import-elems)) next-imports)
     (case (parse-module-name module-name)
       [(left v) (left v)]
       [(right module-name)
        (case (parse-import-elems module-name import-elems)
          [(left v) (left v)]
          [(right imports)
           (case (parse-imports next-imports)
             [(left err) (left err)]
             [(right importss) (right (cons imports importss))])])])]
    [(cons (node module-name) next-imports)
     (case (parse-module-name module-name)
       [(left v) (left v)]
       [(right module-name)
        (case (parse-imports next-imports)
          [(left err) (left err)]
          [(right importss) (right (cons (full-imports module-name) importss))])])]
    [_
     (left #"Bad import form")]))


(define (parse-partial-import-items [sexps : (List Sexp)]) : (Either Bytes (List Import))
  (parse-partial-import-items* sexps (empty)))

(define (parse-partial-import-items* [sexps : (List Sexp)] [acc : (List Import)])
  : (Either Bytes (List Import))
  (case sexps
    [(empty)
     (right (reverse acc))]
    [(cons (symbol-sexp name) sexps)
     (parse-partial-import-items* sexps (cons (import name name) acc))]
    [(cons (bracket-node (cons (symbol-sexp exported-name) (cons (symbol-sexp local-name) (empty))))
           sexps)
     (parse-partial-import-items* sexps (cons (import exported-name local-name) acc))]
    [_
     (left #"Bad input, invalid partial import item")]))

(define (parse-partial-imports-section [section : Bytes] [sexps : (List Sexp)])
  : (Either Bytes (Tuple2 (List Import) (List Sexp)))
  (case sexps
    [(cons (brace-node (cons (keyword-sexp actual-section) inner-sexps)) next-sexps)
     (if (bytes=? actual-section section)
         (case (parse-partial-import-items inner-sexps)
           [(right imports)
            (right (tuple2 imports next-sexps))]
           [(left v)
            (left v)])
         (right (tuple2 (empty) sexps)))]
    [_
     (right (tuple2 (empty) sexps))]))

(define (parse-import-elems [mod-name : ModName] [sexps : (List Sexp)]) : (Either Bytes Imports)
  (case (parse-partial-imports-section #"types" sexps)
    [(left v)
     (left v)]
    [(right (tuple2 types sexps))
     (case (parse-partial-imports-section #"values" sexps)
       [(left v)
        (left v)]
       [(right (tuple2 values sexps))
        (case (parse-partial-imports-section #"patterns" sexps)
          [(left v)
           (left v)]
          [(right (tuple2 patterns sexps))
           (case sexps
             [(empty)
              (right (partial-imports mod-name types values patterns))]
             [_
              (left #"Not a valid imports clause")])])])]))


(define (parse-exports/top [sexp : Sexp]) : (Either Bytes Exports)
  (case sexp
    [(node (cons (symbol-sexp #"export") (empty)))
     (right (exports (empty) (empty) (empty)))]
    [(node
       (cons (symbol-sexp #"export")
         (cons (node (cons (keyword-sexp #"types") type-exports))
           (cons (node (cons (keyword-sexp #"values") value-exports))
             (cons (node (cons (keyword-sexp #"patterns") pattern-exports))
               (empty))))))
     (case (extract-rights (map parse-exported-symbol type-exports))
       [(left v) (left v)]
       [(right type-names)
        (case (extract-rights (map parse-exported-symbol value-exports))
          [(left v) (left v)]
          [(right value-names)
           (case (extract-rights (map parse-exported-symbol pattern-exports))
             [(left v) (left v)]
             [(right pattern-names)
              (let ([convert (lambda ([name : Bytes]) (export name name))])
                (right (exports
                         (map convert type-names)
                         (map convert value-names)
                         (map convert pattern-names))))])])])]

    [_ (left #"Bad exports")]))

(define (parse-exported-symbol [sexp : Sexp]) : (Either Bytes Bytes)
  (case sexp
    [(symbol-sexp bytes) (right bytes)]
    [_ (left #"Not a valid export")]))


(define (parse-types/top [sexp : Sexp]) : (Either Bytes (List TypeDefinition))
  (case sexp
    [(node (cons (symbol-sexp #"types") type-definitions))
     (extract-rights (map parse-type-definition type-definitions))]
    [_ (left #"Bad types")]))

(define (parse-type-definition [sexp : Sexp]) : (Either Bytes TypeDefinition)
  (case sexp
    [(node (cons (symbol-sexp #"define-type") (cons type-name/vars variants)))
     (case (extract-type-name type-name/vars)
       [(left v) (left v)]
       [(right type-name)
        (case (extract-type-vars type-name/vars)
          [(left v) (left v)]
          [(right type-vars)
           (case (extract-rights (map parse-variant variants))
             [(left v) (left v)]
             [(right variants)
              (right (type-definition type-name type-vars variants))])])])]
    [_ (left #"Bad type definition: expecting (define-type ...)")]))

(define (parse-variant [sexp : Sexp]) : (Either Bytes VariantDefinition)
  (case sexp
    [(node (cons (symbol-sexp variant-name) fields))
     (case (extract-rights (map parse-variant-field fields))
       [(left v) (left v)]
       [(right fields)
        (right (variant-definition variant-name fields))])]
    [_ (left #"Bad variant definition")]))

(define (parse-variant-field [sexp : Sexp]) : (Either Bytes VariantField)
  (case sexp
    [(bracket-node (cons (symbol-sexp field-name) (cons (symbol-sexp #":") (cons type (empty)))))
     (case (parse-pre-type type)
       [(left v) (left v)]
       [(right type)
        (right (variant-field field-name type))])]
    [_ (left #"Bad variant field")]))

(define (extract-type-name [sexp : Sexp]) : (Either Bytes Bytes)
  (case sexp
    [(symbol-sexp type-name)
     (right type-name)]
    [(node (cons (symbol-sexp type-name) _))
     (right type-name)]
    [_ (left #"Bad type-name/vars")]))

(define (extract-type-vars [sexp : Sexp]) : (Either Bytes (Maybe (List Bytes)))
  (case sexp
    [(symbol-sexp _)
     (right (nothing))]
    [(node (cons _ type-var-sexps))
     (case (extract-rights (map parse-type-var-symbol type-var-sexps))
       [(left v) (left v)]
       [(right type-vars)
        (right (just type-vars))])]
    [_ (left #"Bad type-name/vars")]))

(define (parse-type-var-symbol [sexp : Sexp]) : (Either Bytes Bytes)
  (case sexp
    [(symbol-sexp bytes) (right bytes)]
    [_ (left #"Not a valid type variable")]))


(define (parse-pre-type [sexp : Sexp]) : (Either Bytes PreType)
  (case sexp
    [(symbol-sexp v) (right (var-pre-type v))]
    ;; TODO Make function parsing better
    [(node (cons (symbol-sexp #"->") (cons result (empty))))
     (case (parse-pre-type result)
       [(left v) (left v)]
       [(right result)
        (right (fun-pre-type (empty) (empty) result))])]
    [(node (cons arg1 (cons (symbol-sexp #"->") (cons result (empty)))))
     (case (parse-pre-type arg1)
       [(left v) (left v)]
       [(right arg1)
        (case (parse-pre-type result)
          [(left v) (left v)]
          [(right result)
           (right (fun-pre-type (empty) (cons arg1 (empty)) result))])])]
    [(node (cons arg1 (cons arg2 (cons (symbol-sexp #"->") (cons result (empty))))))
     (case (parse-pre-type arg1)
       [(left v) (left v)]
       [(right arg1)
        (case (parse-pre-type arg2)
          [(left v) (left v)]
          [(right arg2)
           (case (parse-pre-type result)
             [(left v) (left v)]
             [(right result)
              (right (fun-pre-type (empty) (cons arg1 (cons arg2 (empty))) result))])])])]
    [(node (cons arg1 (cons arg2 (cons arg3 (cons (symbol-sexp #"->") (cons result (empty)))))))
     (case (parse-pre-type arg1)
       [(left v) (left v)]
       [(right arg1)
        (case (parse-pre-type arg2)
          [(left v) (left v)]
          [(right arg2)
           (case (parse-pre-type arg3)
             [(left v) (left v)]
             [(right arg3)
              (case (parse-pre-type result)
                [(left v) (left v)]
                [(right result)
                 (right (fun-pre-type (empty) (cons arg1 (cons arg2 (cons arg3 (empty)))) result))])])])])]
    [(node (cons (symbol-sexp constructor) args))
     (case (extract-rights (map parse-pre-type args))
       [(left v) (left v)]
       [(right args)
        (right (type-app-pre-type constructor args))])]
    [_ (left #"Not a valid Type")]))

(define (parse-function-definition [sexp : Sexp]) : (Either Bytes FunctionDefinition)
  (case sexp
    [(node (cons (symbol-sexp #"define")
                 (cons (node type-vars)
                       (cons (node (cons (symbol-sexp function-name) args))
                             (cons (symbol-sexp #":")
                                   (cons result-type body))))))
     (case (extract-rights (map parse-arg args))
       [(left v) (left v)]
       [(right parsed-args)
        (case (extract-rights (map parse-type-var-symbol type-vars))
          [(left v) (left v)]
          [(right type-vars)
           (case (parse-pre-type result-type)
             [(left v) (left v)]
             [(right result-type)
              (case (parse-block #t body)
                [(left v) (left v)]
                [(right body)
                 (right
                   (function-definition
                     function-name
                     type-vars
                     parsed-args
                     result-type
                     body))])])])])]
    [(node (cons (symbol-sexp #"define")
                 (cons (node (cons (symbol-sexp function-name) args))
                       (cons (symbol-sexp #":")
                             (cons result-type body)))))
     (case (extract-rights (map parse-arg args))
       [(left v) (left v)]
       [(right parsed-args)
        (case (parse-pre-type result-type)
          [(left v) (left v)]
          [(right result-type)
           (case (parse-block #t body)
             [(left v) (left v)]
             [(right body)
              (right
                (function-definition
                  function-name
                  (empty)
                  parsed-args
                  result-type
                  body))])])])]
    [_ (left #"Not a valid function definition")]))

(define (parse-arg [sexp : Sexp]) : (Either Bytes (Tuple2 Bytes PreType))
  (case sexp
    [(bracket-node (cons (symbol-sexp name) (cons (symbol-sexp #":") (cons type (empty)))))
     (case (parse-pre-type type)
       [(left v) (left v)]
       [(right pre-type)
        (right (tuple2 name pre-type))])]
    [_ (left #"Not a valid argument")]))

(define (parse-block [tail-position : Boolean] [sexps : (List Sexp)]) : (Either Bytes Block)
  (parse-block* tail-position sexps (empty)))

(define (parse-block* [tail-position : Boolean] [sexps : (List Sexp)] [rev-defs : (List BlockDefinition)])
  : (Either Bytes Block)
  (case sexps
    [(empty) (left #"Block must have at least one form")]
    [(cons expr (empty))
     (case (parse-expression tail-position expr)
       [(left v) (left v)]
       [(right expr)
        (right (block (reverse rev-defs) expr))])]
    [(cons def sexps)
     (case (parse-block-definition def)
       [(left v) (left v)]
       [(right def)
        (parse-block* tail-position sexps (cons def rev-defs))])]))

(define (parse-block-definition [sexp : Sexp]) : (Either Bytes BlockDefinition)
  (case sexp
    [(node (cons (symbol-sexp #"match-define") match-sexps))
     (case match-sexps
       [(cons pattern-sexp (cons expr-sexp (empty)))
        (case (parse-pattern pattern-sexp)
          [(left v) (left v)]
          [(right pattern)
           (case (parse-expression #f expr-sexp)
             [(left v) (left v)]
             [(right expr)
              (right (match-def pattern (nothing) expr))])])]
       [(cons pattern-sexp (cons (symbol-sexp #":") (cons type-sexp (cons expr-sexp (empty)))))
        (case (parse-pattern pattern-sexp)
          [(left v) (left v)]
          [(right pattern)
           (case (parse-pre-type type-sexp)
             [(left v) (left v)]
             [(right type)
              (case (parse-expression #f expr-sexp)
                [(left v) (left v)]
                [(right expr)
                 (right (match-def pattern (just type) expr))])])])]
       [_
        (left #"Match-define: couldn't be parsed")])]
    [_ (left #"Not a valid block definition")]))

(define (parse-expression [tail-position : Boolean] [sexp : Sexp]) : (Either Bytes Expression)
  (case sexp
    [(number-sexp v) (right (int-literal v))]
    [(bytes-sexp v) (right (bytes-literal v))]
    [(boolean-sexp v) (right (boolean-literal v))]
    [(symbol-sexp v) (right (var-expr v))]
    [(node (cons (symbol-sexp #"if") exprs))
     (case exprs
       [(cons cond (cons true (cons false (empty))))
        (either-app3 if-expr
          (parse-expression #f cond)
          (parse-expression tail-position true)
          (parse-expression tail-position false))]
       [_
        (left #"If: requires exactly three expressions")])]
    [(node (cons (symbol-sexp #"if") (cons cond (cons true (cons false (empty))))))
     (either-app3 if-expr
       (parse-expression #f cond)
       (parse-expression tail-position true)
       (parse-expression tail-position false))]
    [(node (cons (symbol-sexp #"begin") exprs))
     (case (reverse exprs)
       [(empty)
        (left #"Begin requires at least one expression")]
       [(cons last-expr exprs)
        (either-app2 begin-expr
          (extract-rights (map (lambda ([s : Sexp]) (parse-expression #f s)) (reverse exprs)))
          (parse-expression tail-position last-expr))])]
    [(node (cons (symbol-sexp #"varargs") (cons op-expr exprs)))
     (case (parse-expression #f op-expr)
       [(left v) (left v)]
       [(right op-expr)
        (case (extract-rights (map (lambda ([s : Sexp]) (parse-expression #f s)) exprs))
          [(left v) (left v)]
          [(right exprs)
           (right (varargs-app-expr tail-position op-expr exprs))])])]
    [(node (cons (symbol-sexp #"let") other-sexps))
     (parse-let-sexps tail-position other-sexps)]
    [(node (cons (symbol-sexp #"case") (cons expr clauses)))
     (either-app2 case-expr
       (parse-expression #f expr)
       (extract-rights (map (lambda ([s : Sexp]) (parse-case-clause tail-position s))
                            clauses)))]
    [(node (cons (symbol-sexp #"lambda") lambda-sexps))
     (parse-lambda-sexps lambda-sexps)]

    [(node (cons (symbol-sexp #"ann")
                 (cons pre-type (cons expr (empty)))))
     (case (parse-pre-type pre-type)
       [(left v) (left v)]
       [(right pre-type)
        (case (parse-expression tail-position expr)
          [(left v) (left v)]
          [(right expr)
           (right (annotated-expr pre-type expr))])])]
    [(node (cons (symbol-sexp #"match-define") _))
     (left #"Definitions are not valid expressions")]
    [(node (cons op-expr arg-exprs))
     (case (parse-expression #f op-expr)
       [(left v) (left v)]
       [(right op-expr)
        (case (extract-rights (map (lambda ([s : Sexp]) (parse-expression #f s)) arg-exprs))
          [(left v) (left v)]
          [(right arg-exprs)
           (right (app-expr tail-position op-expr arg-exprs))])])]
    [(node (empty))
     (left #"Application needs an operator")]
    [(bracket-node _)
     (left #"Bracketed nodes are not valid expressions")]
    [(brace-node _)
     (left #"Braced nodes are not valid expressions")]
    [(keyword-sexp _)
     (left #"Keywords are not valid expressions")]))

(define (parse-let-sexps [tail-position : Boolean] [sexps : (List Sexp)]) : (Either Bytes Expression)
  (case sexps
    [(empty)
     (left #"Let: not enough subparts")]
    [(cons _ (empty))
     (left #"Let: not enough subparts")]
    [(cons _ (cons _ (cons _ _)))
     (left #"Let: too many subparts")]
    [(cons bindings body)
     (case bindings
       [(node bindings-list)
        (case bindings-list
          [(cons (bracket-node (cons (symbol-sexp name) (cons expr (empty)))) (empty))
           (either-app3 let-expr
             (right/bytes name) (parse-expression #f expr) (parse-block tail-position body))]
          [_
           (left #"Let bindings: couldn't be parsed")])]
       [_
        (left #"Let bindings: couldn't be parsed")])]))

(define (parse-lambda-sexps [sexps : (List Sexp)]) : (Either Bytes Expression)
  (case sexps
    [(cons (node arg+tys) (cons body-expr (empty)))
     (either-app3 lambda-expr
       (extract-rights (map parse-arg arg+tys))
       (right/bytes (nothing/pre-type))
       (parse-expression #t body-expr))]
    [(cons (node arg+tys)
           (cons (symbol-sexp #":")
                 (cons type-expr
                       (cons body-expr (empty)))))
     (case (parse-pre-type type-expr)
       [(left v) (left v)]
       [(right pre-type)
        (either-app3 lambda-expr
          (extract-rights (map parse-arg arg+tys))
          (right/bytes (just pre-type))
          (parse-expression #t body-expr))])]
    [_
     (left #"Lambda: couldn't be parsed")]))



(define (parse-case-clause [tail-position : Boolean] [sexp : Sexp]) : (Either Bytes CaseClause)
  (case sexp
    [(bracket-node (cons pattern body))
     (either-app2 case-clause (parse-pattern pattern) (parse-block tail-position body))]
    [_ (left #"Not a valid case clause")]))

(define (parse-pattern [sexp : Sexp]) : (Either Bytes Pattern)
  (case sexp
    [(symbol-sexp #"_") (right (ignore-pattern))]
    [(symbol-sexp sym) (right (variable-pattern sym))]
    [(bytes-sexp v) (right (bytes-pattern v))]
    [(number-sexp v) (right (int-pattern v))]
    [(node (cons (symbol-sexp name) patterns))
     (either-app2 abstraction-pattern
       (right/bytes name)
       (extract-rights (map parse-pattern patterns)))]
    [_ (left #"Not a valid pattern")]))


(define (parse-module [sexp : (List Sexp)]) : (Either Bytes Module)
  (case sexp
    [(cons (keyword-sexp #"module") bodies)
     (parse-module-inner bodies)]
    [_ (left #"Bad module form")]))

(define (parse-module-inner [bodies : (List Sexp)]) : (Either Bytes Module)
  (case bodies
    [(cons (node module-name-parts)
           (cons (keyword-sexp #"import")
                 (cons (brace-node import-sexps)
                       (cons exports
                             (cons types
                                   definitions)))))
     (case (parse-module-name module-name-parts)
       [(left v) (left v)]
       [(right module-name)
        (case (parse-imports import-sexps)
          [(left v) (left v)]
          [(right imports)
           (case (parse-exports/top exports)
             [(left v) (left v)]
             [(right exports)
              (case (parse-types/top types)
                [(left v) (left v)]
                [(right types)
                 (case (extract-rights (map parse-function-definition definitions))
                   [(left v) (left v)]
                   [(right defs)
                    (right (module module-name imports exports types defs))])])])])])]
    [_ (left #"Bad module form")]))

(define (parse-module-name [forms : (List Sexp)]) : (Either Bytes ModName)
  (case (extract-justs (map parse-symbol forms))
    [(just vs) (right (mod-name vs))]
    [(nothing) (left #"Bod module name")]))

(define (parse-symbol [form : Sexp]) : (Maybe Bytes)
  (case form
    [(symbol-sexp v) (just v)]
    [_ (nothing)]))
