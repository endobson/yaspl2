(module mach-o
  (import
    (prim
      #:types (Bytes Byte InputPort OutputPort Array Void)
      #:values (- < = array-length array-ref read-bytes make-bytes
                panic void bytes-ref)
      #:patterns ())
    (boolean not)
    (either
      #:types (Either)
      #:values (right left)
      #:patterns ())
    (io write-line write-all-bytes call-with-input-file)
    (numbers integer->hex-bytes integer->decimal-bytes)
    (bytes bytes-ref/quad-le make-null-terminated))
  (export
    #:types (MachOFile)
    #:values (read-mach-o read-section)
    #:patterns (mach-o-file))
  (types
    (define-type MachOFile
      (mach-o-file
        [raw-contents Bytes])))


  (define (read-section [input : InputPort] [stdout : OutputPort]) : Void
    (let ([standard-header (make-bytes 8)])
      (begin
        (if (= 8 (read-bytes standard-header input 0 8))
            (void)
            (panic #"Not enough bytes"))
        (write-all-bytes #"command:\n  0x" stdout)
        (write-line (integer->hex-bytes (bytes-ref/quad-le standard-header 0)) stdout)
        (write-all-bytes #"command size:\n  0x" stdout)
        (let ([command-size (bytes-ref/quad-le standard-header 4)])
          (begin
            (write-line (integer->hex-bytes command-size) stdout)
            (let ([command-buffer (make-bytes (- command-size 8))])
              (if (= (- command-size 8) (read-bytes command-buffer input 0 (- command-size 8)))
                  (void)
                  (panic #"Not enough bytes"))))))))

  (define (read-sections [num-sections : Byte] [input : InputPort] [stdout : OutputPort]) : Void
    (if (= num-sections 0)
        (void)
        (begin
          (read-section input stdout)
          (read-sections (- num-sections 1) input stdout))))

  (define (read-mach-o [input : InputPort]) : (Either Bytes MachOFile)
    (let ([header (make-bytes 32)])
      (if (not (= 32 (read-bytes header input 0 32)))
          (left #"Not enough bytes")
          (right (mach-o-file header)))))

  (define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Byte
    (if (< (array-length args) 2)
        (begin
          (write-line #"No input file name supplied" stderr)
          1)
        (call-with-input-file (array-ref args 1)
          (lambda ([input : InputPort])
            (let ([header (make-bytes 32)])
              (begin
                (if (= 32 (read-bytes header input 0 32))
                    (void)
                    (panic #"Not enough bytes"))
                (write-all-bytes #"magic:\n  0x" stdout)
                (write-line (integer->hex-bytes (bytes-ref/quad-le header 0)) stdout)
                (write-all-bytes #"cpu-type:\n  0x" stdout)
                (write-line (integer->hex-bytes (bytes-ref/quad-le header 4)) stdout)
                (write-all-bytes #"cpu-subtype:\n  0x" stdout)
                (write-line (integer->hex-bytes (bytes-ref/quad-le header 8)) stdout)
                (write-all-bytes #"filetype:\n  0x" stdout)
                (write-line (integer->hex-bytes (bytes-ref/quad-le header 12)) stdout)
                (write-all-bytes #"number of commands:\n  0x" stdout)
                (write-line (integer->hex-bytes (bytes-ref/quad-le header 16)) stdout)
                (write-all-bytes #"size of commands:\n  0x" stdout)
                (write-line (integer->hex-bytes (bytes-ref/quad-le header 20)) stdout)
                (write-all-bytes #"flags:\n  0x" stdout)
                (write-line (integer->hex-bytes (bytes-ref/quad-le header 24)) stdout)
                (write-all-bytes #"reserved:\n  0x" stdout)
                (write-line (integer->hex-bytes (bytes-ref/quad-le header 28)) stdout)
                (read-sections 7 input stdout)
                0)))))))
