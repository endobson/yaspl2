(module mach-o
  (import
    (prim
      #:types (Bytes InputPort U32 U8 Int)
      #:values (- * + < = >= read-bytes make-bytes panic bytes-ref bytes-length or bitwise-and
                u8 u32 u32->s64)
      #:patterns ())
    (boolean not)
    (list
      #:types (List)
      #:values (cons empty list)
      #:patterns ())
    (either
      #:types (Either)
      #:values (left right)
      #:patterns (left right))
    (io read-all-bytes)
    (numbers integer->hex-bytes)
    (bytes
      #:types (EightBytesLe)
      #:values (subbytes bytes-ref/quad-le bytes-ref/eight-bytes-le
                eight-bytes-le->int bytes-append)
      #:patterns ()))
  (export
    #:types (MachOFile MachOLoadCommand SymbolTableEntry RelocationEntry SymbolTable
             Section64)
    #:values (read-mach-o mach-o-file read-symbol-table/strings read-symbol-table/symbols
              mach-o-header-commands-size symbol-table-entry-name symbol-table-entry
              read-relocation-entry symbol-table-entry-value)
    #:patterns (mach-o-file mach-o-header lc-segment64 lc-symtab lc-version-min-macosx
                lc-data-in-code symbol-table-entry relocation-entry))
  (types
    (define-type MachOFile
      (mach-o-file
        [header : MachOHeader]
        [commands : (List MachOLoadCommand)]
        [raw-content : Bytes]))
    (define-type MachOHeader
      (mach-o-header
        [magic : U32]
        [cpu-type : U32]
        [cpu-subtype : U32]
        [file-type : U32]
        [number-commands : U32]
        [commands-size : U32]
        [flags : U32]
        [reserved : U32]))
    (define-type MachOLoadCommand
      (lc-segment64 [v : LoadSegment64])
      (lc-symtab [v : SymbolTable])
      (lc-version-min-macosx [v : VersionMin])
      (lc-data-in-code [v : LinkeditData]))

    (define-type LoadSegment64
      (load-segment64
        [name : Bytes]
        [vm-addr : EightBytesLe]
        [vm-size : EightBytesLe]
        [file-offset : EightBytesLe]
        [file-size : EightBytesLe]
        [max-protection : U32]
        [init-protection : U32]
        [flags : U32]
        [sections : (List Section64)]))

    (define-type Section64
      (section64
        [name : Bytes]
        [segment-name : Bytes]
        [addr : EightBytesLe]
        [size : EightBytesLe]
        [offset : Int]
        [relocation-offset : Int]
        [num-relocations : Int]
        [flags : U32]))

    (define-type VersionMin
      (version-min
        [version-major : U8] ;; TODO this should be a u16
        [version-minor : U8]
        [version-patch : U8]
        [sdk-major : U8] ;; TODO this should be a u16
        [sdk-minor : U8]
        [sdk-patch : U8]))

    (define-type SymbolTable
      (symbol-table
        [offset : Int]
        [number : Int]
        [string-offset : Int]
        [string-size : Int]))

    (define-type LinkeditData
      (linkedit-data
        [offset : U32]
        [size : U32]))

    (define-type RelocationEntry
      (relocation-entry
        [address : Int]
        [symbol-num : Int]
        [type : U8]))

    (define-type SymbolTableEntry
      (symbol-table-entry
        [name : Bytes]
        [type : U8]
        [section : U8]
        [description : U8] ;; TODO make this U16
        [value : Int])))


  (define (read-load-command [input : InputPort]) : (Either Bytes MachOLoadCommand)
    (let ([standard-header (make-bytes 8)])
      (if (not (= 8 (read-bytes standard-header input 0 8)))
          (left #"Not enough bytes")
          (let ([number (bytes-ref/quad-le standard-header 0)])
            (let ([command-size (bytes-ref/quad-le standard-header 4)])
              (let ([command-buffer (make-bytes (- command-size 8))])
                (if (= (- command-size 8) (read-bytes command-buffer input 0 (- command-size 8)))
                    (case number
                      [#x02 (parse-lc-symtab command-buffer)]
                      [#x19 (parse-lc-segment64 command-buffer)]
                      [#x24 (parse-lc-version-min-macosx command-buffer)]
                      [#x29 (parse-lc-data-in-code command-buffer)]
                      [x (left (bytes-append
                                 (varargs list #"Unknown load command: #x"
                                               (integer->hex-bytes x))))])
                    (left #"Not enough bytes"))))))))

  (define (parse-lc-segment64 [bytes : Bytes]) : (Either Bytes MachOLoadCommand)
    (if (< (bytes-length bytes) #x40)
        (left #"Too short lc-segment64")
        (let ([num-sections (bytes-ref/quad-le bytes #x38)])
          (if (not (= (bytes-length bytes) (+ #x40 (* num-sections #x50))))
              (left #"Wrong length lc-segment64")
              (right
                (lc-segment64
                  (load-segment64
                    (read-16-byte-name bytes #x00 0)
                    (bytes-ref/eight-bytes-le bytes #x10)
                    (bytes-ref/eight-bytes-le bytes #x18)
                    (bytes-ref/eight-bytes-le bytes #x20)
                    (bytes-ref/eight-bytes-le bytes #x28)
                    (u32 (bytes-ref/quad-le bytes #x30))
                    (u32 (bytes-ref/quad-le bytes #x34))
                    (u32 (bytes-ref/quad-le bytes #x3c))
                    (parse-section64s num-sections #x40 bytes))))))))

  (define (parse-section64s [amount : Int] [offset : Int] [bytes : Bytes]) : (List Section64)
    (if (= amount 0)
        (empty)
        (cons
          (parse-section64 offset bytes)
          (parse-section64s (- amount 1) (+ offset #x50) bytes))))

  (define (parse-section64 [offset : Int] [bytes : Bytes]) : Section64
    (section64
      (read-16-byte-name bytes (+ offset #x00) 0)
      (read-16-byte-name bytes (+ offset #x10) 0)
      (bytes-ref/eight-bytes-le bytes (+ offset #x20))
      (bytes-ref/eight-bytes-le bytes (+ offset #x28))
      (bytes-ref/quad-le bytes (+ offset #x30))
      ;; TODO Check that this is 0
      (bytes-ref/quad-le bytes (+ offset #x38))
      (bytes-ref/quad-le bytes (+ offset #x3c))
      (u32 (bytes-ref/quad-le bytes (+ offset #x40)))
      ;; TODO Check that this is 0
      ;; TODO Check that this is 0
      ;; TODO Check that this is 0
      ))


  (define (read-16-byte-name [bytes : Bytes] [init-offset : Int] [num-chars : Int]) : Bytes
    (if (= num-chars 16)
        (subbytes bytes init-offset (+ init-offset num-chars))
        (if (= (bytes-ref bytes (+ init-offset num-chars)) 0)
            (subbytes bytes init-offset (+ init-offset num-chars))
            (read-16-byte-name bytes init-offset (+ 1 num-chars)))))

  (define (parse-lc-symtab [bytes : Bytes]) : (Either Bytes MachOLoadCommand)
    (if (not (= (bytes-length bytes) #x10))
        (left #"Wrong length lc-symtab")
        (right
          (lc-symtab
            (symbol-table
              (bytes-ref/quad-le bytes #x00)
              (bytes-ref/quad-le bytes #x04)
              (bytes-ref/quad-le bytes #x08)
              (bytes-ref/quad-le bytes #x0c))))))

  (define (parse-lc-data-in-code [bytes : Bytes]) : (Either Bytes MachOLoadCommand)
    (if (not (= (bytes-length bytes) #x08))
        (left #"Wrong length lc-data-in-code")
        (right
          (lc-data-in-code
            (linkedit-data
              (u32 (bytes-ref/quad-le bytes #x00))
              (u32 (bytes-ref/quad-le bytes #x04)))))))

  (define (parse-lc-version-min-macosx [bytes : Bytes]) : (Either Bytes MachOLoadCommand)
    (if (not (= (bytes-length bytes) #x08))
        (left #"Wrong length lc-version-min-macosx")
        (if (or (not (= (bytes-ref bytes 3) 0))
                (not (= (bytes-ref bytes 7) 0)))
            (left #"Not yet supported version min")
            (right
            (lc-version-min-macosx
              (version-min
                (u8 (bytes-ref bytes #x02))
                (u8 (bytes-ref bytes #x01))
                (u8 (bytes-ref bytes #x00))
                (u8 (bytes-ref bytes #x06))
                (u8 (bytes-ref bytes #x05))
                (u8 (bytes-ref bytes #x04))))))))


  (define (read-load-commands [amount : Int] [input : InputPort])
    : (Either Bytes (List MachOLoadCommand))
    (if (= amount 0)
        (right (empty))
        (case (read-load-command input)
          [(left v) (left v)]
          [(right cmd)
           (case (read-load-commands (- amount 1) input)
             [(left v) (left v)]
             [(right cmds)
              (right (cons cmd cmds))])])))

  (define (read-symbol-table/symbols
            [offset : Int]
            [entries : Bytes]
            [strings : Bytes]) : (List SymbolTableEntry)
    (if (>= offset (bytes-length entries))
        (empty)
        (cons
          (read-symbol-table/symbol offset entries strings)
          (read-symbol-table/symbols (+ offset 16) entries strings))))

  (define (read-symbol-table/symbol
            [offset : Int]
            [entries : Bytes]
            [strings : Bytes]) : SymbolTableEntry
    (let ([string-offset (bytes-ref/quad-le entries offset)])
      (let ([string (read-null-terminated-string strings string-offset string-offset)])
        (symbol-table-entry
          string
          (u8 (bytes-ref entries (+ offset 4)))
          (u8 (bytes-ref entries (+ offset 5)))
          (u8 0) ;;(bytes-ref/double-le entries (+ offset 6))
          (eight-bytes-le->int
            (bytes-ref/eight-bytes-le entries (+ offset 8)))))))


  (define (read-symbol-table/strings [bytes : Bytes] [offset : Int]) : (List Bytes)
    (if (>= offset (bytes-length bytes))
        (empty)
        (let ([symbol (read-null-terminated-string bytes offset offset)])
          (if (= (bytes-length symbol) 0)
              (empty)
              (cons
                symbol
                (read-symbol-table/strings bytes (+ offset (+ 1 (bytes-length symbol)))))))))

  (define (read-null-terminated-string [bytes : Bytes] [init : Int] [end : Int]) : Bytes
    (if (>= end (bytes-length bytes))
        (panic #"Bad null terminated string")
        (case (bytes-ref bytes end)
          [0 (subbytes bytes init end)]
          [_ (read-null-terminated-string bytes init (+ 1 end))])))

  (define (read-relocation-entry [offset : Int] [bytes : Bytes]) : RelocationEntry
    (relocation-entry
      (bytes-ref/quad-le bytes offset)
      (bitwise-and #xFFFFFF (bytes-ref/quad-le bytes (+ offset 4)))
      (u8 (bytes-ref bytes (+ offset 7)))))

  (define (read-mach-o [input : InputPort]) : (Either Bytes MachOFile)
    (let ([header-bytes (make-bytes 32)])
      (if (not (= 32 (read-bytes header-bytes input 0 32)))
          (left #"Not enough bytes")
          (let ([header
                 (mach-o-header
                   (u32 (bytes-ref/quad-le header-bytes 0))
                   (u32 (bytes-ref/quad-le header-bytes 4))
                   (u32 (bytes-ref/quad-le header-bytes 8))
                   (u32 (bytes-ref/quad-le header-bytes 12))
                   (u32 (bytes-ref/quad-le header-bytes 16))
                   (u32 (bytes-ref/quad-le header-bytes 20))
                   (u32 (bytes-ref/quad-le header-bytes 24))
                   (u32 (bytes-ref/quad-le header-bytes 28)))])
            (case (read-load-commands (u32->s64 (mach-o-header-number-commands header)) input)
              [(left v) (left v)]
              [(right commands)
               (right (mach-o-file header commands (read-all-bytes input)))]))))))
