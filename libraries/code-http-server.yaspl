(module code-http-server
  (import
    (prim
      #:types (Array Bytes InputPort OutputPort OutputPort Void)
      #:values (socket sendto bind shutdown listen accept make-bytes bytes-set! write-bytes quotient
                close-output-port panic
                remainder < = void connect bytes-length + * bytes-ref array-length array-ref)
      #:patterns ())
    (io write-line read-all-bytes write-all-bytes newline)
    (buffered-port
      #:types (BufferedPort)
      #:values (make-buffered-port read-crlf-line)
      #:patterns (line-result))
    (numbers decimal-bytes->integer integer->decimal-bytes)
    (either
      #:types (Either)
      #:values ()
      #:patterns (left right))
    (maybe
      #:types (Maybe)
      #:values (just nothing)
      #:patterns (just nothing))
    (bytes bytes-copy! bytes-append bytes=? subbytes)
    (join-list
      #:types (JoinList)
      #:values (append-jl single-jl snoc-jl cons-jl jl->list empty-jl append-jl* join-list)
      #:patterns ())
    (regexp
      #:types (Regexp)
      #:values (any-regexp group-regexp rep-regexp regexp-match epsilon-regexp seq-regexp lit-regexp
                non-greedy-rep-regexp)
      #:patterns ())
    (stack-machine
      #:types (TopLevelObject)
      #:values ()
      #:patterns (stack-function function-tlo trivial-closure-tlo))
    (list
      #:types (List)
      #:values (cons empty length reverse map list foldl)
      #:patterns (cons empty))
    (mach spawn)
    (tuples
      #:types (Tuple2)
      #:values (tuple2)
      #:patterns (tuple2))
    (tcp tcp-address tcp-socket-bind tcp-socket-accept tcp-socket-set-reuse-address)
    (print-stack-function extract-top-level-objects function->bytes)
    (http-server 
      #:types (Ipv4Address)
      #:values (run-http-server http-response)
      #:patterns (http-request http-request-header))
    (ip
      #:types (Ipv4Address)
      #:values (bytes->ipv4-address)
      #:patterns ()))
  (export)
  (types
    (define-type HtmlElement
      (html-element [head Node] [body Node]))

    (define-type Node
      (element-node [tag-name Bytes] [attributes (Listof Attribute)] [children (Listof Node)])
      (text-node [contents (JoinList Bytes)]))
    (define-type Attribute
      (attribute [name (JoinList Bytes)] [value (JoinList Bytes)])))

  (define (double-quote-bytes) : Bytes
    (let ([bytes (make-bytes 1)])
      (begin
        (bytes-set! bytes 0 34)
        bytes)))

  (define (html-document->xml-bytes [e : HtmlElement]) : Bytes
    (bytes-append
      (jl->list
        (cons-jl #"<?xml version="
          (cons-jl (double-quote-bytes)
            (cons-jl #"1.0"
              (cons-jl (double-quote-bytes) 
                (cons-jl #" encoding="
                  (cons-jl (double-quote-bytes) 
                    (cons-jl #"UTF-8"
                      (cons-jl (double-quote-bytes) 
                        (cons-jl #"?>" (html-element->xml-bytes e)))))))))))))


  (define (html-element->xml-bytes [e : HtmlElement]) : (JoinList Bytes)
    (case e
      [(html-element head body)
       (cons-jl #"<html xmlns="
         (cons-jl (double-quote-bytes) 
           (cons-jl #"http://www.w3.org/1999/xhtml"
             (cons-jl (double-quote-bytes) (cons-jl #">"
               (snoc-jl
                 (append-jl (node->xml-bytes head)
                            (node->xml-bytes body))
                 #"</html>"))))))]))


  (define (node->xml-bytes [v : Node]) : (JoinList Bytes)
    (case v
      [(element-node tag attributes child-nodes)
       (varargs append-jl*
          (varargs join-list #"<" tag)
          (foldl append-jl (map attribute->xml-bytes attributes) (empty-jl))
          (single-jl #">")
          (foldl append-jl (map node->xml-bytes child-nodes) (empty-jl))
          (varargs join-list #"</" tag #">"))]
      [(text-node contents)
       contents]))

  ;; TODO move the space somewhere else
  (define (attribute->xml-bytes [v : Attribute]) : (JoinList Bytes)
    (case v
      [(attribute name value)
       (varargs append-jl*
         (single-jl #" ")
         name
         (single-jl #"=")
         (single-jl (double-quote-bytes))
         value
         (single-jl (double-quote-bytes)))]))


  (define (pre [child : Node]) : Node
    (element-node #"pre" (empty) (cons child (empty))))
  (define (code [child : Node]) : Node
    (element-node #"code" (empty) (cons child (empty))))
  (define (div [child : Node]) : Node
    (element-node #"div" (empty) (cons child (empty))))
  (define (link [uri : (JoinList Bytes)] [contents : Node]) : Node
    (element-node #"a"
      (cons (attribute (single-jl #"href") uri) (empty))
      (cons contents (empty))))
  (define (body [children : (List Node)]) : Node
    (element-node #"body" (empty) children))
  (define (head) : Node
    (element-node #"head" (empty) (empty)))

  (define (top-level-object->node [object : TopLevelObject]) : Bytes
    (case object
      [(function-tlo (stack-function name _)) 
       (div (link (single-jl name) (text-node (single-jl name))))]
      [(trivial-closure-tlo name _)
       (div (link (single-jl name) (text-node (single-jl name))))]))

  (define (find-function [name : Bytes] [objects : (List TopLevelObject)]) : (Maybe StackFunction)
    (case objects
      [(empty) (nothing)]
      [(cons (function-tlo func) objects)
       (case func
         [(stack-function func-name _)
          (if (bytes=? name func-name)
              (just func)
              (find-function name objects))])]
      [(cons (trivial-closure-tlo _ _) objects)
       (find-function name objects)]))
       

  (define (make-request-handler [objects : (List TopLevelObject)]) : HttpResponse
    (lambda ([request : HttpRequest])
      (case request
        [(http-request resource headers)
         (case resource
           [#"/"
            (http-response
              200
              #"OK"
              #"application/xhtml+xml"
              (html-document->xml-bytes
                (html-element
                  (head)
                  (body (map top-level-object->node objects)))))]
           [path
            (let ([name (subbytes path 1 (bytes-length path))])
              (case (find-function name objects)
                [(nothing)
                 (http-response
                   404
                   #"Not Found"
                   #"text/plain"
                   #"Not Found")]
                [(just function)
                 (http-response
                   200
                   #"OK"
                   #"application/xhtml+xml"
                   (html-document->xml-bytes
                     (html-element
                       (head)
                       (body
                         (cons
                           (pre (code (text-node (function->bytes function))))
                           (empty))))))]))])])))

  (define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Byte
    (if (< (array-length args) 3)
        (begin
          (write-line #"Wrong number of arguments" stderr)
          1)
        (case (bytes->ipv4-address (array-ref args 1))
          [(just ip-addr)
           (let ([address (tcp-address ip-addr (decimal-bytes->integer (array-ref args 2)))])
             (case (extract-top-level-objects 3 args stderr)
               [(left v)
                (begin
                  (write-line v stderr)
                  1)]
               [(right objects)
                (run-http-server address (make-request-handler objects))]))]
          [(nothing)
           (begin
             (write-line #"Unparsable ip address" stderr)
             1)]))))
