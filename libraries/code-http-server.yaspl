#:module (code-http-server)
#:import {
  (bytes)
  (compiler)
  (depth-first-search)
  (dict)
  (either)
  (formats html)
  (formats svg)
  (formats xml)
  (http-server)
  (io)
  (ip)
  (join-list)
  (list)
  (maybe)
  (numbers)
  (prim)
  (print-register-language)
  (register-language) {
    #:types
      [BasicBlock r:BasicBlock]
      FunctionDefinition
      Terminal
    #:values
      [basic-block-terminal r:basic-block-terminal]
    #:patterns
      [basic-block r:basic-block]
      [cond-jump r:cond-jump]
      function-definition
      [halt r:halt]
      [jump r:jump]
      [return r:return]
      [tail-call r:tail-call]
  }
  (tcp)
  (tuples)
  (yaspl top-level-objects)
  (yaspl top-level-objects-to-x86-64)
  (yaspl x86-64-assembly)
  (yaspl x86-64-assembly-printer)
}
(export
  #:types ()
  #:values ()
  #:patterns ())
(types
  (define-type GraphicBlock
    (graphic-block [width : Int] [height : Int] [content : Node])))

(define (top-level-object->node [object : TopLevelObject]) : (Maybe Node)
  (case object
    [(register-function-tlo (function-definition name _ _ _ _))
     (just (div (link (single-jl name) (text-node/escape (single-jl name)))))]
    [(bytes-tlo name _)
     (nothing)]
    [(trivial-variant-tlo name _)
     (nothing)]
    [(trivial-closure-tlo name _)
     (nothing)]))

(define (text-fragment->node [fragment : TextFragment]) : Node
  (case fragment
    [(function-fragment name _)
     (div (link (single-jl name) (text-node/escape (single-jl name))))]))

(define (const-fragment->node [fragment : ConstFragment]) : Node
  (case fragment
    [(address-fragment name _)
     (div (link (single-jl name) (text-node/escape (single-jl name))))]
    [(bytes-fragment name _)
     (div (link (single-jl name) (text-node/escape (single-jl name))))]))

(define (find-function [name : Bytes] [objects : (List TopLevelObject)])
  : (Maybe FunctionDefinition)
  (case objects
    [(empty) (nothing)]
    [(cons (register-function-tlo func) objects)
     (case func
       [(function-definition func-name _ _ _ _)
        (if (bytes=? name func-name)
            (just func)
            (find-function name objects))])]
    [(cons _ objects)
     (find-function name objects)]))

(define (find-fragment [name : Bytes] [fragments : AssemblyFragments])
  : (Maybe (Either TextFragment ConstFragment))
  (case fragments
    [(assembly-fragments text const)
     (case (find-text-fragment name text)
       [(just v) (just (left v))]
       [(nothing)
        (case (find-const-fragment name const)
          [(just v) (just (right v))]
          [(nothing) (nothing)])])]))

(define (find-text-fragment [name : Bytes] [fragments : (List TextFragment)]) : (Maybe TextFragment)
  (findf
    (lambda ([frag : TextFragment])
      (case frag
        [(function-fragment name2 _)
         (bytes=? name name2)]))
    fragments))

(define (find-const-fragment [name : Bytes] [fragments : (List ConstFragment)]) : (Maybe ConstFragment)
  (findf
    (lambda ([frag : ConstFragment])
      (case frag
        [(address-fragment name2 _)
         (bytes=? name name2)]
        [(bytes-fragment name2 _)
         (bytes=? name name2)]))
    fragments))

(define (not-found) : HttpResponse
  (http-response 404 #"Not Found" #"text/plain" #"Not Found"))

(define (xhtml-ok-response [node : Node]) : HttpResponse
  (http-response 200 #"OK" #"application/xhtml+xml" (document->xml-bytes node)))
(define (svg-ok-response [node : Node]) : HttpResponse
  (http-response 200 #"OK" #"image/svg+xml" (document->xml-bytes node)))

(define (serve-assembly-response
          [fragments : AssemblyFragments]
          [name : Bytes]) : HttpResponse
  (if (= (bytes-length name) 0)
      (xhtml-ok-response
        (html
          (head (empty))
          (body
            (case fragments
              [(assembly-fragments text const)
               (append
                 (map text-fragment->node text)
                 (map const-fragment->node const))]))))
      (case (find-fragment name fragments)
        [(nothing) (not-found)]
        [(just fragment)
         (xhtml-ok-response
           (html
             (head (empty))
             (body
               (cons
                 (pre (code (text-node/escape
                              (assembly-commands->bytes
                                (jl->list
                                  (case fragment
                                    [(left text) (text-fragment->commands text)]
                                    [(right const) (const-fragment->commands const)]))))))
                 (empty)))))])))

(define (serve-register-response
          [objects : (List TopLevelObject)]
          [name : Bytes]) : HttpResponse
  (if (= (bytes-length name) 0)
      (xhtml-ok-response
        (html
          (head (empty))
          (body (filter-map top-level-object->node objects))))
      (case (find-function name objects)
        [(nothing) (not-found)]
        [(just function)
         (xhtml-ok-response
           (html
             (head (empty))
             (body
               (cons
                 (pre (code (text-node/escape (single-jl (print-function function)))))
                 (empty)))))])))

(define (terminal->successors [term : Terminal]) : (List Int)
  (case term
    [(r:return _) (empty)]
    [(r:halt) (empty)]
    [(r:cond-jump cond t t-args f f-args)
     (varargs list t f)]
    [(r:tail-call _ _) (empty)]
    [(r:jump i args) (varargs list i)]))

(define (panic/int-list [bytes : Bytes]) : (List Int)
  (panic bytes))
(define (panic/int [bytes : Bytes]) : Int
  (panic bytes))
(define (panic/basic-block-list [bytes : Bytes]) : (List r:BasicBlock)
  (panic bytes))
(define (panic/dict-int-basic-block-list [bytes : Bytes]) : (Dict Int (List r:BasicBlock))
  (panic bytes))
(define (empty/basic-block-list) : (List r:BasicBlock)
  (empty))
(define (make-dict/int-basic-block-list) : (Dict Int (List r:BasicBlock))
  (make-dict int-cmp))

(define (make-blocks-by-depth
          [depths : (Dict Int Int)]
          [blocks : (Dict Int r:BasicBlock)])
  : (Dict Int (List r:BasicBlock))
  (foldl
    (lambda ([entry : (Tuple2 Int Int)] [acc : (Dict Int (List r:BasicBlock))])
      (case entry
        [(tuple2 index depth)
         (case (dict-ref blocks index)
           [(nothing) (panic/dict-int-basic-block-list #"Bad index")]
           [(just block)
            (dict-update
              acc
              depth
              (lambda ([blocks : (List r:BasicBlock)]) (cons block blocks))
              (empty/basic-block-list))])]))
    (dict-map depths (lambda ([key : Int] [value : Int]) (tuple2 key value)))
    (make-dict/int-basic-block-list)))

(define (layer-blocks [blocks : (Dict Int r:BasicBlock)]) : (List (List r:BasicBlock))
  (let ([succ
          (lambda ([index : Int])
            (case (dict-ref blocks index)
              [(nothing) (panic/int-list #"Bad index")]
              [(just block) (terminal->successors (r:basic-block-terminal block))]))])
    (let ([ordered-indices (depth-first-search succ (varargs list 0) int-cmp)])
      (let ([depths (compute-depths succ ordered-indices (dict-add (make-dict int-cmp) 0 0))])
        (let ([max-depth (max* 0 (dict-values depths))])
          (let ([blocks-by-depth (make-blocks-by-depth depths blocks)])
            (let ([ref (lambda ([depth : Int])
                         (case (dict-ref blocks-by-depth depth)
                           [(nothing) (panic/basic-block-list #"Bad index")]
                           [(just blocks) blocks]))])
              (build-list (+ max-depth 1) ref))))))))


(define (compute-depths [succ : (Int -> (List Int))] [vs : (List Int)]
                        [acc : (Dict Int Int)]) : (Dict Int Int)
  (case vs
    [(empty) acc]
    [(cons v vs)
     (let ([cur-height
            (case (dict-ref acc v)
              [(nothing) (panic/int #"Bad index")]
              [(just v) v])])
       (compute-depths
         succ
         vs
         (foldl (lambda ([v : Int] [acc : (Dict Int Int)])
                  (dict-update acc v
                               (lambda ([old-height : Int])
                                 (max old-height (+ 1 cur-height)))
                               0))
                (succ v)
                acc)))]))

(define (layout-blocks [blocks : (List (List r:BasicBlock))]) : (List Node)
  (case
    (foldl
      (lambda ([blocks : (List r:BasicBlock)] [acc : (Tuple2 Int (List Node))])
        (case acc
          [(tuple2 y-offset nodes)
           (case
             (foldl
               (lambda ([block : r:BasicBlock] [acc : (Tuple3 Int Int (List Node))])
                 (case acc
                   [(tuple3 x-offset max-height nodes)
                    (case (block->graphic-block block)
                      [(graphic-block width height html)
                       (tuple3
                         (+ (+ x-offset width) 20)
                         (max max-height height)
                         (cons
                           (rect x-offset y-offset width height
                                 (varargs list (fill #"none") (stroke #"black")))
                           (cons
                             (foreign-object x-offset y-offset width height (empty) (varargs list html))
                             nodes)))])]))
               blocks
               (tuple3 10 0 nodes))
             [(tuple3 _ height nodes)
              (tuple2 (+ y-offset (+ height 20)) nodes)])]))
      blocks
      (tuple2 10 (empty/node)))
    [(tuple2 _ nodes) nodes]))


(define (block->graphic-block [block : r:BasicBlock]) : GraphicBlock
  (graphic-block
    (+ 15 (* 8 (basic-block-width block)))
    (+ 2 (* 15 (basic-block-size block)))
    (html-body (varargs list (block->node block)))))

(define (empty/node) : (List Node)
  (empty))

(define (serve-register-graphic-response
          [objects : (List TopLevelObject)]
          [name : Bytes]) : HttpResponse
  (if (= (bytes-length name) 0)
      (xhtml-ok-response
        (html
          (head (empty))
          (body (filter-map top-level-object->node objects))))
      (case (find-function name objects)
        [(nothing) (not-found)]
        [(just (function-definition _ _ basic-blocks _ _))
         (svg-ok-response
           (svg (layout-blocks (layer-blocks basic-blocks))))])))

(define (block->node [block : r:BasicBlock]) : Node
  (pre*
    (varargs list
      (attribute/escape #"style" (single-jl #"margin: 0px 0px")))
    (code (text-node/escape
            ;; TODO use real block number
            (print-basic-block 0 block)))))

(define (basic-block-size [block : r:BasicBlock]) : Int
  (case block
    [(r:basic-block _ instructions _)
     (+ 2 (length instructions))]))

(define (basic-block-width [block : r:BasicBlock]) : Int
  ;; TODO make this a better estimate
  50)


(define (serve-index-response) : HttpResponse
  (xhtml-ok-response
    (html
      (head (empty))
      (body
        (varargs list
           (div (link (single-jl #"/register/") (text-node/escape (single-jl #"register"))))
           (div (link (single-jl #"/register-graphic/") (text-node/escape (single-jl #"register-graphic"))))
           (div (link (single-jl #"/assembly/") (text-node/escape (single-jl #"assembly")))))))))

(define (make-request-handler
          [objects : (List TopLevelObject)]
          [fragments : AssemblyFragments]) : (HttpRequest -> HttpResponse)
  (lambda ([request : HttpRequest])
    (case request
      [(http-request path headers)
       (if (bytes=? path #"/")
           (serve-index-response)
           (if (starts-with? path #"/assembly/")
               (let ([name (subbytes path 10 (bytes-length path))])
                 (serve-assembly-response fragments name))
               (if (starts-with? path #"/register/")
                   (let ([name (subbytes path 10 (bytes-length path))])
                     (serve-register-response objects name))
                   (if (starts-with? path #"/register-graphic/")
                       (let ([name (subbytes path 18 (bytes-length path))])
                         (serve-register-graphic-response objects name))
                       (not-found)))))])))

(define (extract-top-level-objects [module-files : (List Bytes)])
  : (Either Bytes (List TopLevelObject))
  (case (parse-module-files module-files)
    [(left v)
     (left v)]
    [(right modules)
     (compile-modules modules)]))

(define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Int
  (case (array->list args)
    [(empty)
     (begin
       (write-line #"No executable specified???" stderr)
       1)]
    [(cons _ (empty))
     (begin
       (write-line #"No ip address supplied." stderr)
       1)]
    [(cons _ (cons _ (empty)))
     (begin
       (write-line #"No port supplied" stderr)
       1)]
    [(cons _ (cons ip-addr (cons port module-names)))
     (case (bytes->ipv4-address ip-addr)
       [(just ip-addr)
        (case (decimal-bytes->integer port)
          [(just port)
           (let ([address (tcp-address ip-addr port)])
             (case (extract-top-level-objects module-names)
               [(left v)
                (begin
                  (write-line v stderr)
                  1)]
               [(right objects)
                (begin
                  (run-http-server address (make-request-handler objects (convert-objects objects)))
                  (write-line #"Http server stopped running." stderr)
                  1)]))]
          [(nothing)
           (begin
             (write-line #"Unparsable port number" stderr)
             1)])]
       [(nothing)
        (begin
          (write-line #"Unparsable ip address" stderr)
          1)])]))
