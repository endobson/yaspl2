(module code-http-server
  (import
    (prim
      #:types (Array Bytes InputPort OutputPort Int)
      #:values (bytes-length)
      #:patterns ())
    (io write-line)
    (numbers decimal-bytes->integer)
    (either
      #:types ()
      #:values ()
      #:patterns (left right))
    (maybe
      #:types (Maybe)
      #:values (just nothing)
      #:patterns (just nothing))
    (bytes bytes=? subbytes starts-with?)
    (join-list
      #:types (JoinList)
      #:values (single-jl jl->list)
      #:patterns ())
    (stack-machine
      #:types (TopLevelObject StackFunction)
      #:values ()
      #:patterns (stack-function function-tlo trivial-closure-tlo bytes-tlo))
    (list
      #:types (List)
      #:values (cons empty map list array->list)
      #:patterns (cons empty))
    (tcp tcp-address)
    (print-stack-function extract-top-level-objects function->bytes)
    (http-server
      #:types (HttpResponse HttpRequest)
      #:values (run-http-server http-response)
      #:patterns (http-request))
    (x86-64-stack-machine
      #:types (AssemblyFragment)
      #:values (convert-objects assembly-commands->bytes fragment->commands)
      #:patterns (function-fragment address-fragment bytes-fragment ))
    (ip
      #:types ()
      #:values (bytes->ipv4-address)
      #:patterns ())
    (xml
      #:types (Node)
      #:values (text-node element-node attribute document->xml-bytes)
      #:patterns ()))
  (export
    #:types ()
    #:values ()
    #:patterns ())
  (types)

  (define (html [head : Node] [body : Node]) : Node
    (element-node
      #"html"
      (cons (attribute #"xmlns" (single-jl #"http://www.w3.org/1999/xhtml")) (empty))
      (cons head (cons body (empty)))))
  (define (head) : Node
    (element-node #"head" (empty) (empty)))
  (define (body [children : (List Node)]) : Node
    (element-node #"body" (empty) children))

  (define (pre [child : Node]) : Node
    (element-node #"pre" (empty) (cons child (empty))))
  (define (code [child : Node]) : Node
    (element-node #"code" (empty) (cons child (empty))))
  (define (div [child : Node]) : Node
    (element-node #"div" (empty) (cons child (empty))))
  (define (link [uri : (JoinList Bytes)] [contents : Node]) : Node
    (element-node #"a"
      (cons (attribute #"href" uri) (empty))
      (cons contents (empty))))

  (define (top-level-object->node [object : TopLevelObject]) : (Maybe Node)
    (case object
      [(function-tlo (stack-function name _ _))
       (just (div (link (single-jl name) (text-node (single-jl name)))))]
      [(bytes-tlo name _)
       (nothing)]
      [(trivial-closure-tlo name _)
       (nothing)]))

  (define (fragment->node [fragment : AssemblyFragment]) : Node
    (case fragment
      [(function-fragment name _)
       (div (link (single-jl name) (text-node (single-jl name))))]
      [(address-fragment name _)
       (div (link (single-jl name) (text-node (single-jl name))))]
      [(bytes-fragment name _)
       (div (link (single-jl name) (text-node (single-jl name))))]))


  (define (find-function [name : Bytes] [objects : (List TopLevelObject)]) : (Maybe StackFunction)
    (case objects
      [(empty) (nothing)]
      [(cons (function-tlo func) objects)
       (case func
         [(stack-function func-name _ _)
          (if (bytes=? name func-name)
              (just func)
              (find-function name objects))])]
      [(cons _ objects)
       (find-function name objects)]))


  (define (find-fragment [name : Bytes] [fragments : (List AssemblyFragment)]) : (Maybe AssemblyFragment)
    (case fragments
      [(empty) (nothing)]
      [(cons frag fragments)
       (case frag
         [(function-fragment name2 _)
          (if (bytes=? name name2)
              (just frag)
              (find-fragment name fragments))]
         [(address-fragment name2 _)
          (if (bytes=? name name2)
              (just frag)
              (find-fragment name fragments))]
         [(bytes-fragment name2 _)
          (if (bytes=? name name2)
              (just frag)
              (find-fragment name fragments))])]))

  (define (A B) (map/maybe [f : (A -> (Maybe B))] [l : (List A)]) : (List B)
    (case l
      [(empty) (empty)]
      [(cons e l)
       (case (f e)
         [(nothing) (map/maybe f l)]
         [(just e) (cons e (map/maybe f l))])]))


  (define (make-request-handler
            [objects : (List TopLevelObject)]
            [fragments : (List AssemblyFragment)]) : (HttpRequest -> HttpResponse)
    (lambda ([request : HttpRequest])
      (case request
        [(http-request resource headers)
         (case resource
           [#"/"
            (http-response
              200
              #"OK"
              #"application/xhtml+xml"
              (document->xml-bytes
                (html
                  (head)
                  (body
                    (varargs list
                       (div (link (single-jl #"/stack/") (text-node (single-jl #"stack"))))
                       (div (link (single-jl #"/assembly/") (text-node (single-jl #"assembly")))))))))]
           [#"/assembly/"
            (http-response
              200
              #"OK"
              #"application/xhtml+xml"
              (document->xml-bytes
                (html
                  (head)
                  (body (map fragment->node fragments)))))]
           [#"/stack/"
            (http-response
              200
              #"OK"
              #"application/xhtml+xml"
              (document->xml-bytes
                (html
                  (head)
                  (body (map/maybe top-level-object->node objects)))))]
           [path
             (if (starts-with? path #"/assembly/")
                 (let ([name (subbytes path 10 (bytes-length path))])
                   (case (find-fragment name fragments)
                     [(nothing)
                      (http-response
                        404
                        #"Not Found"
                        #"text/plain"
                        #"Not Found")]
                     [(just fragment)
                      (http-response
                        200
                        #"OK"
                        #"application/xhtml+xml"
                        (document->xml-bytes
                          (html
                            (head)
                            (body
                              (cons
                                (pre (code (text-node (assembly-commands->bytes
                                                        (jl->list (fragment->commands fragment))))))
                                (empty))))))]))
                 (if (starts-with? path #"/stack/")
                     (let ([name (subbytes path 7 (bytes-length path))])
                       (case (find-function name objects)
                         [(nothing)
                          (http-response
                            404
                            #"Not Found"
                            #"text/plain"
                            #"Not Found")]
                         [(just function)
                          (http-response
                            200
                            #"OK"
                            #"application/xhtml+xml"
                            (document->xml-bytes
                              (html
                                (head)
                                (body
                                  (cons
                                    (pre (code (text-node (function->bytes function))))
                                    (empty))))))]))
                     (http-response
                       404
                       #"Not Found"
                       #"text/plain"
                       #"Not Found")))])])))

  (define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Int
    (case (array->list args)
      [(empty)
       (begin
         (write-line #"No executable specified???" stderr)
         1)]
      [(cons _ (empty))
       (begin
         (write-line #"No ip address supplied." stderr)
         1)]
      [(cons _ (cons _ (empty)))
       (begin
         (write-line #"No port supplied" stderr)
         1)]
      [(cons _ (cons ip-addr (cons port module-names)))
       (case (bytes->ipv4-address ip-addr)
         [(just ip-addr)
          (let ([address (tcp-address ip-addr (decimal-bytes->integer port))])
            (case (extract-top-level-objects module-names)
              [(left v)
               (begin
                 (write-line v stderr)
                 1)]
              [(right objects)
               (begin
                 (run-http-server address (make-request-handler objects (convert-objects objects)))
                 (write-line #"Http server stopped running." stderr)
                 1)]))]
         [(nothing)
          (begin
            (write-line #"Unparsable ip address" stderr)
            1)])])))
