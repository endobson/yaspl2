(module code-http-server
  (import
    (prim
      #:types (Array Bytes InputPort OutputPort Byte)
      #:values (< bytes-length array-length array-ref)
      #:patterns ())
    (io write-line)
    (numbers decimal-bytes->integer)
    (either
      #:types ()
      #:values ()
      #:patterns (left right))
    (maybe
      #:types (Maybe)
      #:values (just nothing)
      #:patterns (just nothing))
    (bytes bytes-append bytes=? subbytes starts-with?)
    (join-list
      #:types (JoinList)
      #:values (append-jl single-jl cons-jl jl->list empty-jl append-jl* join-list)
      #:patterns ())
    (stack-machine
      #:types (TopLevelObject StackFunction)
      #:values ()
      #:patterns (stack-function function-tlo trivial-closure-tlo bytes-tlo))
    (list
      #:types (List)
      #:values (cons empty map list)
      #:patterns (cons empty))
    (tcp tcp-address)
    (print-stack-function extract-top-level-objects function->bytes)
    (http-server
      #:types (HttpResponse HttpRequest)
      #:values (run-http-server http-response)
      #:patterns (http-request))
    (x86-64-stack-machine
      #:types (AssemblyFragment)
      #:values (convert-objects assembly-commands->bytes fragment->commands)
      #:patterns (function-fragment address-fragment bytes-fragment ))
    (ip
      #:types ()
      #:values (bytes->ipv4-address)
      #:patterns ()))
  (export
    #:types ()
    #:values ()
    #:patterns ())
  (types
    (define-type Node
      (element-node [tag-name Bytes] [attributes (List Attribute)] [children (List Node)])
      (text-node [contents (JoinList Bytes)]))
    (define-type Attribute
      (attribute [name (JoinList Bytes)] [value (JoinList Bytes)])))

  (define (document->xml-bytes [node : Node]) : Bytes
    (bytes-append
      (jl->list
        (cons-jl
          #"<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
          (node->xml-bytes node)))))


  (define (a) (concat-jl [l : (List (JoinList a))]) : (JoinList a)
    (case l
      [(empty) (empty-jl)]
      [(cons e l) (append-jl e (concat-jl l))]))


  (define (node->xml-bytes [v : Node]) : (JoinList Bytes)
    (case v
      [(element-node tag attributes child-nodes)
       (varargs append-jl*
          (varargs join-list #"<" tag)
          (concat-jl (map attribute->xml-bytes attributes))
          (single-jl #">")
          (concat-jl (map node->xml-bytes child-nodes))
          (varargs join-list #"</" tag #">"))]
      [(text-node contents)
       contents]))

  ;; TODO move the space somewhere else
  (define (attribute->xml-bytes [v : Attribute]) : (JoinList Bytes)
    (case v
      [(attribute name value)
       (varargs append-jl*
         (single-jl #" ")
         name
         (single-jl #"=\"")
         value
         (single-jl #"\""))]))


  (define (html [head : Node] [body : Node]) : (JoinList Bytes)
    (element-node
      #"html"
      (cons (attribute (single-jl #"xmlns") (single-jl #"http://www.w3.org/1999/xhtml")) (empty))
      (cons head (cons body (empty)))))
  (define (head) : Node
    (element-node #"head" (empty) (empty)))
  (define (body [children : (List Node)]) : Node
    (element-node #"body" (empty) children))

  (define (pre [child : Node]) : Node
    (element-node #"pre" (empty) (cons child (empty))))
  (define (code [child : Node]) : Node
    (element-node #"code" (empty) (cons child (empty))))
  (define (div [child : Node]) : Node
    (element-node #"div" (empty) (cons child (empty))))
  (define (link [uri : (JoinList Bytes)] [contents : Node]) : Node
    (element-node #"a"
      (cons (attribute (single-jl #"href") uri) (empty))
      (cons contents (empty))))

  (define (top-level-object->node [object : TopLevelObject]) : Node
    (case object
      [(function-tlo (stack-function name _ _)) 
       (div (link (single-jl name) (text-node (single-jl name))))]
      [(bytes-tlo name _)
       (div (link (single-jl name) (text-node (single-jl name))))]
      [(trivial-closure-tlo name _)
       (div (link (single-jl name) (text-node (single-jl name))))]))

  (define (fragment->node [fragment : AssemblyFragment]) : Node
    (case fragment
      [(function-fragment name _) 
       (div (link (single-jl name) (text-node (single-jl name))))]
      [(address-fragment name _)
       (div (link (single-jl name) (text-node (single-jl name))))]
      [(bytes-fragment name _)
       (div (link (single-jl name) (text-node (single-jl name))))]))


  (define (find-function [name : Bytes] [objects : (List TopLevelObject)]) : (Maybe StackFunction)
    (case objects
      [(empty) (nothing)]
      [(cons (function-tlo func) objects)
       (case func
         [(stack-function func-name _ _)
          (if (bytes=? name func-name)
              (just func)
              (find-function name objects))])]
      [(cons _ objects)
       (find-function name objects)]))


  (define (find-fragment [name : Bytes] [fragments : (List AssemblyFragment)]) : (Maybe AssemblyFragment)
    (case fragments
      [(empty) (nothing)]
      [(cons frag fragments)
       (case frag
         [(function-fragment name2 _)
          (if (bytes=? name name2)
              (just frag)
              (find-fragment name fragments))]
         [(address-fragment name2 _)
          (if (bytes=? name name2)
              (just frag)
              (find-fragment name fragments))]
         [(bytes-fragment name2 _)
          (if (bytes=? name name2)
              (just frag)
              (find-fragment name fragments))])]))

  (define (make-request-handler
            [objects : (List TopLevelObject)]
            [fragments : (List AssemblyFragment)]) : HttpResponse
    (lambda ([request : HttpRequest])
      (case request
        [(http-request resource headers)
         (case resource
           [#"/"
            (http-response
              200
              #"OK"
              #"application/xhtml+xml"
              (document->xml-bytes
                (html
                  (head)
                  (body
                    (varargs list
                       (div (link (single-jl #"/stack/") (text-node (single-jl #"stack"))))
                       (div (link (single-jl #"/assembly/") (text-node (single-jl #"assembly")))))))))]
           [#"/assembly/"
            (http-response
              200
              #"OK"
              #"application/xhtml+xml"
              (document->xml-bytes
                (html
                  (head)
                  (body (map fragment->node fragments)))))]
           [#"/stack/"
            (http-response
              200
              #"OK"
              #"application/xhtml+xml"
              (document->xml-bytes
                (html
                  (head)
                  (body (map top-level-object->node objects)))))]
           [path
             (if (starts-with? path #"/assembly/")
                 (let ([name (subbytes path 10 (bytes-length path))])
                   (case (find-fragment name fragments)
                     [(nothing)
                      (http-response
                        404
                        #"Not Found"
                        #"text/plain"
                        #"Not Found")]
                     [(just fragment)
                      (http-response
                        200
                        #"OK"
                        #"application/xhtml+xml"
                        (document->xml-bytes
                          (html
                            (head)
                            (body
                              (cons
                                (pre (code (text-node (assembly-commands->bytes
                                                        (jl->list (fragment->commands fragment))))))
                                (empty))))))]))
                 (if (starts-with? path #"/stack/")
                     (let ([name (subbytes path 7 (bytes-length path))])
                       (case (find-function name objects)
                         [(nothing)
                          (http-response
                            404
                            #"Not Found"
                            #"text/plain"
                            #"Not Found")]
                         [(just function)
                          (http-response
                            200
                            #"OK"
                            #"application/xhtml+xml"
                            (document->xml-bytes
                              (html
                                (head)
                                (body
                                  (cons
                                    (pre (code (text-node (function->bytes function))))
                                    (empty))))))]))
                     (http-response
                       404
                       #"Not Found"
                       #"text/plain"
                       #"Not Found")))])])))

  (define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Byte
    (if (< (array-length args) 3)
        (begin
          (write-line #"Wrong number of arguments" stderr)
          1)
        (case (bytes->ipv4-address (array-ref args 1))
          [(just ip-addr)
           (let ([address (tcp-address ip-addr (decimal-bytes->integer (array-ref args 2)))])
             (case (extract-top-level-objects 3 args stderr)
               [(left v)
                (begin
                  (write-line v stderr)
                  1)]
               [(right objects)
                (run-http-server address (make-request-handler objects (convert-objects objects)))]))]
          [(nothing)
           (begin
             (write-line #"Unparsable ip address" stderr)
             1)]))))
