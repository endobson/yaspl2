#:module (intermediate-to-stack)
#:import {
  (bytes) {
    #:values
      bytes-append
      bytes=?
  }
  (dict) {
    #:types
      Dict
    #:values
      dict-add
      dict-value-map
      make-dict
      merge-dicts
  }
  (environment) {
    #:types
      Environment
      VarReference
      VariantInfo
    #:values
      environment
      environment-tag-ref
      environment-value-ref
      environment-value-set
      free-var
      global-value
      local-var
      variant-info
    #:patterns
      free-var
      global-value
      local-var
  }
  (intermediate-language) {
    #:types
      BytesConstant
      CaseClause
      ClosureConstant
      Expression
      [FunctionDefinition i:FunctionDefinition]
      [Module i:Module]
      Pattern
      TypeDefinition
      VariantDefinition
      VariantField
    #:values
      bytes-constant-name
      closure-constant-name
      [function-definition-name i:function-definition-name]
      [module-bytes i:module-bytes]
      [module-closures i:module-closures]
      [module-definitions i:module-definitions]
      [module-imports i:module-imports]
      [module-name i:module-name]
      [module-types i:module-types]
    #:patterns
      abstraction-pattern
      begin-expr
      boolean-literal
      bytes-constant
      bytes-pattern
      call-closure-expr
      case-clause
      case-expr
      closure-constant
      create-closure-expr
      [function-definition i:function-definition]
      if-expr
      ignore-pattern
      int-literal
      int-pattern
      let-expr
      type-definition
      var-expr
      varargs-call-closure-expr
      variable-pattern
      variant-definition
      variant-field
  }
  (intermediate-to-module-signature) {
    #:values
      module->module-signature
  }
  (join-list) {
    #:values
      append-jl
      empty-jl
      jl->list
      snoc-jl
  }
  (list) {
    #:types
      List
    #:values
      append
      cons
      empty
      foldl
      interleave
      length
      list
      map
      reverse
    #:patterns
      cons
      empty
  }
  (maybe) {
    #:patterns
      just
      nothing
  }
  (module-name) {
    #:types
      ModName
    #:values
      mod-name-parts
  }
  (module-signature) {
    #:types
      ModuleSignature
      PatternSignature
      ValueSignature
    #:values
      value-signature-symbol
    #:patterns
      pattern-signature
  }
  (prim) {
    #:types
      Boolean
      Bytes
      Int
    #:values
      *
      +
      -
      =
      >
      bytes-length
      bytes-ref
      bytes-set!
      make-bytes
      or
      panic
      u8
  }
  (resolved-imports-language) {
    #:patterns
      [imports r:imports]
  }
  (stack-machine) {
    #:types
      GenState
      StackCmd
      TopLevelObject
    #:values
      add-boolean-literal
      add-bytes-cmp
      add-int-cmp
      add-int-literal
      alloc-variant-cmd
      boolean-jmp
      boolean-lit-cmd
      bytes-tlo
      call-function
      catch-all-case
      create-closure
      dup-cmd
      dup-temporary
      function-tlo
      gen-state
      ignore-value
      initial-variables
      load-free-var
      load-global
      make-varargs-array
      name-temporary
      no-catch-all-case
      pop-cmd
      remove-temporaries
      return
      stack-basic-block
      stack-function
      swap-cmd
      tmp-slot
      trivial-closure-tlo
      uncond-jmp
      unscope-variable
      var-slot
      variable-ref
      variant-case
      variant-ref
      variant-ref-cmd
      variant-switch
    #:patterns
      gen-state
      tmp-slot
      trivial-closure-tlo
      var-slot
  }
  (tuples) {
    #:types
      Tuple2
    #:values
      tuple2
    #:patterns
      tuple2
  }
}
(export
  #:types (CompiledModule)
  #:values (compile-module)
  #:patterns (compiled-module))
(types
  (define-type CompiledModule
    (compiled-module
      [code : (List TopLevelObject)]
      [sig : ModuleSignature])))

(define (compile-module [imod : i:Module]) : CompiledModule
  (match-define env (make-global-env imod))
  (let ([tlos
          (append
            (compile-type-definitions imod)
            (append
              (compile-function-definitions imod env)
              (append
                (compile-closures imod)
                (compile-byte-constants imod))))])
    (compiled-module
      tlos
      (module->module-signature imod env
        (add-known-functions tlos (make-dict bytes=?))))))

(define (add-known-functions [tlos : (List TopLevelObject)]
                             [dict : (Dict Bytes Bytes)]) : (Dict Bytes Bytes)
  (case tlos
    [(empty) dict]
    [(cons (trivial-closure-tlo name fun-name) tlos)
     (add-known-functions tlos (dict-add dict name fun-name))]
    [(cons _ tlos)
     (add-known-functions tlos dict)]))


(define (make-global-env [imod : i:Module]) : Environment
  (environment
    (setup-value-environment imod)
    (add-all-imported-patterns
      (add-type-definitions-variant-infos/top
        (make-dict bytes=?) imod)
      imod)))

(define (setup-value-environment [imod : i:Module]) : (Dict Bytes VarReference)
  (add-all-imported-functions
    (add-type-definitions-functions/top
      (add-locally-defined-functions
        (add-locally-defined-closures
          (add-locally-defined-bytes
            (make-dict bytes=?)
            imod)
          imod)
        imod)
      imod)
    imod))

(define (add-all-imported-patterns [env : (Dict Bytes VariantInfo)] [imod : i:Module])
  : (Dict Bytes VariantInfo)
  (match-define (r:imports _ _ patterns) (i:module-imports imod))
  (merge-dicts
    (dict-value-map
      patterns
      (lambda ([p : PatternSignature])
        (case p
          [(pattern-signature _ tag _ _ _ _)
           (variant-info tag)])))
    env))

(define (add-all-imported-functions [env : (Dict Bytes VarReference)] [imod : i:Module])
  : (Dict Bytes VarReference)
  (match-define (r:imports _ values _) (i:module-imports imod))
  (merge-dicts
    (dict-value-map values
      (lambda ([v : ValueSignature])
        (global-value (value-signature-symbol v))))
    env))

(define (add-locally-defined-functions [env : (Dict Bytes VarReference)] [imod : i:Module])
  : (Dict Bytes VarReference)
  (let ([var-names (map i:function-definition-name (i:module-definitions imod))])
    (let ([mangled-names (get-mangled-names (i:module-name imod) (i:module-definitions imod))])
      (add-all-globals env var-names mangled-names))))

(define (get-mangled-names [mod-name : ModName] [funs : (List i:FunctionDefinition)]) : (List Bytes)
  (case funs
    [(empty) (empty)]
    [(cons (i:function-definition name _ _ _ _) funs)
     (cons
       (mangle-name (bytes-append (varargs list (mangled-mod-name mod-name) #"_" name)))
       (get-mangled-names mod-name funs))]))

(define (i-get-mangled-names [mod-name : ModName] [names : (List Bytes)]) : (List Bytes)
  (case names
    [(empty) (empty)]
    [(cons name names)
     (cons
       (mangle-name (bytes-append (varargs list (mangled-mod-name mod-name) #"_" name)))
       (i-get-mangled-names mod-name names))]))

(define (add-locally-defined-closures [env : (Dict Bytes VarReference)] [imod : i:Module])
  : (Dict Bytes VarReference)
  (let ([var-names (map closure-constant-name (i:module-closures imod))])
    (let ([mangled-names (i-get-mangled-names (i:module-name imod) var-names)])
      (add-all-globals env var-names mangled-names))))

(define (add-locally-defined-bytes [env : (Dict Bytes VarReference)] [imod : i:Module])
  : (Dict Bytes VarReference)
  (let ([var-names (map bytes-constant-name (i:module-bytes imod))])
    (let ([mangled-names (i-get-mangled-names (i:module-name imod) var-names)])
      (add-all-globals env var-names mangled-names))))


(define (add-all-globals [env : (Dict Bytes VarReference)]
                         [var-names : (List Bytes)]
                         [mangled-names : (List Bytes)])
  : (Dict Bytes VarReference)
  (case var-names
    [(empty) env]
    [(cons var-name var-names)
     (case mangled-names
       [(empty) (panic #"var-names not the same length as mangled-names")]
       [(cons mangled-name mangled-names)
        (add-all-globals
          (dict-add env var-name (global-value mangled-name)) var-names mangled-names)])]))

(define (add-type-definitions-functions/top [env : (Dict Bytes VarReference)] [imod : i:Module])
  : (Dict Bytes VarReference)
  (let ([mod-name (i:module-name imod)])
    (foldl
      (lambda ([def : TypeDefinition] [env : (Dict Bytes VarReference)])
        (case def
          [(type-definition name _ _ _ (cons variant (empty)))
           (case variant
             [(variant-definition variant-name _ fields)
              (add-variant-definition-accessors
                (add-variant-definition-constructor env mod-name name variant)
                mod-name name variant-name fields)])]
          [(type-definition name _ _ _ variants)
           (add-variant-definitions-constructors env mod-name name variants)]))
      (i:module-types imod)
      env)))


(define (add-variant-definitions-constructors
          [env : (Dict Bytes VarReference)]
          [mod-name : ModName]
          [type-name : Bytes]
          [defs : (List VariantDefinition)]) : (Dict Bytes VarReference)
  (case defs
    [(empty) env]
    [(cons def defs)
     (add-variant-definitions-constructors
       (add-variant-definition-constructor env mod-name type-name def)
       mod-name
       type-name
       defs)]))

(define (add-variant-definition-constructor
          [env : (Dict Bytes VarReference)]
          [mod-name : ModName]
          [type-name : Bytes]
          [def : VariantDefinition]) : (Dict Bytes VarReference)
  (case def
    [(variant-definition name _ _)
     (dict-add
       env
       name
       (global-value
         (mangle-name
           (bytes-append
             (varargs list (mangled-mod-name mod-name) #"_" type-name #"_" name #"_closure")))))]))

(define (add-variant-definition-accessors
          [env : (Dict Bytes VarReference)]
          [mod-name : ModName]
          [type-name : Bytes]
          [variant-name : Bytes]
          [fields : (List VariantField)]) : (Dict Bytes VarReference)
  (case fields
    [(empty) env]
    [(cons (variant-field name _) fields)
     (add-variant-definition-accessors
       (dict-add
         env
         (bytes-append (cons variant-name (cons #"-" (cons name (empty)))))
         (global-value
           (mangle-name
             (bytes-append
               (varargs list (mangled-mod-name mod-name) #"_" type-name #"_" variant-name #"_" name #"_closure")))))
       mod-name
       type-name
       variant-name
       fields)]))

(define (add-type-definitions-variant-infos/top [env : (Dict Bytes VariantInfo)] [imod : i:Module])
  : (Dict Bytes VariantInfo)
  (add-type-definitions-variant-infos env (i:module-types imod)))

(define (add-type-definitions-variant-infos
          [env : (Dict Bytes VariantInfo)]
          [defs : (List TypeDefinition)])
  : (Dict Bytes VariantInfo)
  (case defs
    [(empty) env]
    [(cons (type-definition _ _ _ _ variants) defs)
     (add-type-definitions-variant-infos
       (add-variant-definitions-variant-infos env variants)
       defs)]))

(define (add-variant-definitions-variant-infos
          [env : (Dict Bytes VariantInfo)]
          [defs : (List VariantDefinition)])
  : (Dict Bytes VariantInfo)
  (case defs
    [(empty) env]
    [(cons (variant-definition name tag _) defs)
     (add-variant-definitions-variant-infos
       (dict-add env name (variant-info tag))
       defs)]))

(define (add-all-locals [env : Environment] [names : (List Bytes)])
  : Environment
  (case names
    [(empty) env]
    [(cons name names) (add-all-locals (environment-value-set env name (local-var)) names)]))

(define (add-all-free-vars [env : Environment] [names : (List Bytes)] [index : Int])
  : Environment
  (case names
    [(empty) env]
    [(cons name names)
     (add-all-free-vars (environment-value-set env name (free-var index)) names (+ 1 index))]))


(define (compile-type-definitions [imod : i:Module]) : (List TopLevelObject)
  (compile-type-definitions/list (i:module-name imod) (i:module-types imod) (empty)))

(define (compile-type-definitions/list
          [mod-name : ModName]
          [defs : (List TypeDefinition)]
          [acc : (List TopLevelObject)]) : (List TopLevelObject)
  (case defs
    [(empty) acc]
    [(cons def defs)
     (compile-type-definitions/list
       mod-name
       defs
       (compile-type-definition mod-name def acc))]))

(define (compile-type-definition
          [mod-name : ModName]
          [def : TypeDefinition]
          [acc : (List TopLevelObject)]) : (List TopLevelObject)
  (case def
    [(type-definition name _ _ _ (cons variant (empty)))
     (compile-variant-definition mod-name name variant #t acc)]
    [(type-definition name _ _ _ variants)
     (compile-type-definition/variants mod-name name variants acc)]))

(define (compile-type-definition/variants
          [mod-name : ModName]
          [type-name : Bytes]
          [variants : (List VariantDefinition)]
          [acc : (List TopLevelObject)]) : (List TopLevelObject)
  (case variants
    [(empty) acc]
    [(cons variant variants)
     (compile-type-definition/variants
       mod-name
       type-name
       variants
       (compile-variant-definition mod-name type-name variant #f acc))]))

(define (compile-variant-definition
          [mod-name : ModName]
          [type-name : Bytes]
          [def : VariantDefinition]
          [generate-accessors : Boolean]
          [acc : (List TopLevelObject)]) : (List TopLevelObject)
  (case def
    [(variant-definition name variant-tag fields)
     (let ([mangled-name
            (mangle-name (bytes-append (varargs list (mangled-mod-name mod-name) #"_" type-name #"_" name)))])
       (cons
         (function-tlo
           (stack-function
             mangled-name
             (length fields)
             (cons
               (stack-basic-block
                 (add-reversed-args
                   0
                   (length fields)
                   (cons
                     (alloc-variant-cmd variant-tag (length fields))
                     (empty)))
                 (return (length fields)))
               (empty))))
         (cons
           (trivial-closure-tlo
             (bytes-append (varargs list mangled-name #"_closure"))
             mangled-name)
           (if generate-accessors
               (compile-variant-definition/accessors
                 mod-name
                 type-name
                 name
                 variant-tag
                 0
                 fields
                 acc)
               acc))))]))

(define (compile-variant-definition/accessors
          [mod-name : ModName]
          [type-name : Bytes]
          [variant-name : Bytes]
          [variant-tag : Int]
          [field-index : Int]
          [fields : (List VariantField)]
          [acc : (List TopLevelObject)]) : (List TopLevelObject)
  (case fields
    [(empty) acc]
    [(cons (variant-field name _) fields)
     (compile-variant-definition/accessors
       mod-name
       type-name
       variant-name
       variant-tag
       (+ field-index 1)
       fields
       (let ([mangled-name
              (mangle-name
                (bytes-append (varargs list (mangled-mod-name mod-name) #"_" type-name #"_" variant-name #"_" name)))])
         (cons
           (function-tlo
             (stack-function
               mangled-name
               1
               (cons
                 (stack-basic-block
                   (add-reversed-args 0 1 (cons (variant-ref-cmd variant-tag field-index) (empty)))
                   (return 1))
                 (empty))))
           (cons
             (trivial-closure-tlo
               (bytes-append (varargs list mangled-name #"_closure"))
               mangled-name)
             acc))))]))

(define (add-reversed-args [arg-number : Int] [args : Int] [cmds : (List StackCmd)]) : (List StackCmd)
  (if (= arg-number args)
      cmds
      (add-reversed-args
        (+ arg-number 1)
        args
        (cons (dup-cmd (- (* 2 args) (* 2 (+ arg-number 1)))) cmds))))


(define (compile-byte-constants [imod : i:Module]) : (List TopLevelObject)
  (map (let ([mod-name (i:module-name imod)])
         (lambda ([b : BytesConstant])
            (case b
              [(bytes-constant name value)
               (bytes-tlo
                 (mangle-name (bytes-append (varargs list (mangled-mod-name mod-name) #"_" name)))
                 value)])))
       (i:module-bytes imod)))

(define (compile-closures [imod : i:Module]) : (List TopLevelObject)
  (compile-closures/list (i:module-name imod) (i:module-closures imod)))

(define (compile-closures/list
          [mod-name : ModName]
          [pairs : (List ClosureConstant)])
  : (List TopLevelObject)
  (case pairs
    [(empty) (empty)]
    [(cons (closure-constant name fun-name) pairs)
     (cons
       (trivial-closure-tlo
         (mangle-name (bytes-append (varargs list (mangled-mod-name mod-name) #"_" name)))
         (mangle-name (bytes-append (varargs list (mangled-mod-name mod-name) #"_" fun-name))))
       (compile-closures/list mod-name pairs))]))

(define (compile-function-definitions [imod : i:Module] [env : Environment]) : (List TopLevelObject)
  (compile-function-definitions/list (i:module-name imod) (i:module-definitions imod) env))

(define (compile-function-definitions/list
          [mod-name : ModName]
          [funs : (List i:FunctionDefinition)]
          [env : Environment]) : (List TopLevelObject)
  (case funs
    [(empty) (empty)]
    [(cons fun funs)
     (cons (compile-function-definition mod-name fun env)
           (compile-function-definitions/list mod-name funs env))]))

(define (compile-function-definition
          [mod-name : ModName]
          [fun : i:FunctionDefinition]
          [env : Environment]) : TopLevelObject
  (case fun
    [(i:function-definition name pre-type arg-names free-vars body)
     (function-tlo
       (stack-function
         (mangle-name (bytes-append (varargs list (mangled-mod-name mod-name) #"_" name)))
         (length arg-names)
         ;; TODO validate the genstate has one temporary left in it, the return addr, and then the
         ;; variables.
         (case (compile-expression
                 body
                 (add-all-free-vars (add-all-locals env arg-names) free-vars 0)
                 (gen-state (initial-variables arg-names) (empty-jl) 0 (empty-jl)))
           [(gen-state _ cmds label blocks)
            (jl->list
              (snoc-jl
                blocks
                (stack-basic-block (jl->list cmds) (return (length arg-names)))))])))]))

(define (compile-expressions
          [exprs : (List Expression)]
          [env : Environment]
          [state : GenState]) : GenState
  (case exprs
    [(empty) state]
    [(cons expr exprs)
     (compile-expressions exprs env
       (compile-expression expr env state))]))

(define (compile-expression
          [expr : Expression]
          [env : Environment]
          [state : GenState]) : GenState
  (case expr
    [(int-literal v) (add-int-literal v state)]
    [(boolean-literal v) (add-boolean-literal v state)]
    [(let-expr name expr body)
     (unscope-variable name
       (compile-expression
         body
         (environment-value-set env name (local-var))
         (name-temporary name
           (compile-expression expr env state))))]
    [(var-expr v)
     (case (environment-value-ref env v)
       [(just (local-var)) (variable-ref v state)]
       [(just (free-var offset))
        (load-free-var offset state)]
       [(just (global-value n))
        (load-global n state)]
       [(nothing) (panic (bytes-append (cons #"Unbound variable: " (cons v (empty)))))])]
    ;; TODO compile the expressions in the right order
    [(create-closure-expr op args)
     (create-closure (length args)
       (compile-expression op env
         (compile-expressions (reverse args) env state)))]
    ;; TODO make effects of op go before arguments
    [(call-closure-expr op args)
     (call-function (length args)
       (compile-expression op env
         (compile-expressions args env state)))]
    ;; TODO make effects of op go before arguments
    ;; TODO compile the expressions in the right order
    [(varargs-call-closure-expr op args)
     (call-function 1
       (compile-expression op env
         (make-varargs-array (length args)
           (compile-expressions (reverse args) env state))))]
    [(if-expr c t f)
     (case (compile-expression c env state)
       [(gen-state stack cmds-c label-c-end blocks)
        (let ([stack-split (remove-temporaries 1 stack)])
          (let ([label-t-begin (+ label-c-end 1)])
            (case (compile-expression t env
                    (gen-state stack-split (empty-jl) label-t-begin (empty-jl)))
              [(gen-state stack-t cmds-t label-t-end blocks-t)
               (let ([label-f-begin (+ label-t-end 1)])
                 (case (compile-expression f env
                         (gen-state stack-split (empty-jl) label-f-begin (empty-jl)))
                   [(gen-state stack-f cmds-f label-f-end blocks-f)
                    (let ([new-label (+ label-f-end 1)])
                      (begin
                        ; (assert-stack-equal? stack-f stack-t)
                        ; (assert-stack-equal? stack-f (tmp-slot stack-split))
                        (gen-state
                          (tmp-slot stack-split)
                          (empty-jl)
                          new-label
                          (append-jl
                            (snoc-jl
                              blocks
                              (stack-basic-block (jl->list cmds-c) (boolean-jmp label-t-begin label-f-begin)))
                            (append-jl
                              (snoc-jl
                                blocks-t
                                (stack-basic-block (jl->list cmds-t) (uncond-jmp new-label)))
                              (snoc-jl
                                blocks-f
                                (stack-basic-block (jl->list cmds-f) (uncond-jmp new-label))))))))]))])))])]
    [(begin-expr expr exprs)
     (compile-begin-exprs exprs env (compile-expression expr env state))]
    [(case-expr expr clauses)
     (let ([state (compile-expression expr env state)])
       (compile-case-clauses clauses env state))]))

;; This should take a stack of A :: Rest to B :: Rest.
;; Where A is the type being cased on and B is the return type
(define (compile-case-clauses
          [clauses : (List CaseClause)]
          [env : Environment]
          [state : GenState]) : GenState
  (case clauses
    [(empty)
     (case state
       [(gen-state stack cmds label blocks)
        (gen-state
          (tmp-slot (remove-temporaries 1 stack))
          (empty-jl)
          (+ 1 label)
          (snoc-jl
            blocks
            (stack-basic-block
              (jl->list cmds)
              (variant-switch (no-catch-all-case)))))])]
    [(cons clause clauses)
     (compile-case-clause clause clauses env state)]))

(define (compile-case-clause
          [clause : CaseClause]
          [clauses : (List CaseClause)]
          [env : Environment]
          [state : GenState]) : GenState
  (case clause
    [(case-clause pattern expr)
     (case (compile-pattern/match pattern env (dup-temporary state))
       [(gen-state match-stack match-cmds match-end-label match-blocks)
        (let ([stack-split (remove-temporaries 1 match-stack)])
          (let ([extract-start-label (+ 1 match-end-label)])
            (case (compile-pattern/extract pattern expr env
                    (gen-state stack-split
                               (empty-jl)
                               extract-start-label
                               (empty-jl)))
              [(gen-state extract-stack extract-cmds extract-end-label extract-blocks)
               (let ([other-start-label (+ 1 extract-end-label)])
                 (case (compile-case-clauses clauses env
                         (gen-state stack-split
                                    (empty-jl)
                                    other-start-label
                                    (empty-jl)))
                   [(gen-state other-stack other-cmds other-end-label other-blocks)
                    (let ([join-label (+ other-end-label 1)])
                      (begin
                        ; (assert-stack-equal? other-stack extract-stack)
                        ; (assert-stack-equal? extract-stack stack-split)
                        (gen-state
                          stack-split
                          (empty-jl)
                          join-label
                          (append-jl
                            (snoc-jl
                              match-blocks
                              (stack-basic-block
                                (jl->list match-cmds)
                                (boolean-jmp extract-start-label other-start-label)))
                            (append-jl
                              (snoc-jl
                                extract-blocks
                                (stack-basic-block
                                  (jl->list extract-cmds)
                                  (uncond-jmp join-label)))
                              (snoc-jl
                                other-blocks
                                (stack-basic-block
                                  (jl->list other-cmds)
                                  (uncond-jmp join-label))))))))]))])))])]))

;; Takes a stack of the form A :: Rest and turns it into the state Boolean :: Rest
;; where the top of the stack is true if the value matched the pattern.
(define (compile-pattern/match
          [pattern : Pattern]
          [env : Environment]
          [state : GenState]) : GenState
  (case pattern
    [(ignore-pattern) (add-boolean-literal #t (ignore-value state))]
    [(variable-pattern _) (add-boolean-literal #t (ignore-value state))]
    [(abstraction-pattern name patterns)
     (let ([tag (environment-tag-ref env name)])
       (case state
         [(gen-state stack cmds old-label blocks)
          (let ([non-matching-label (+ 1 old-label)])
            (let ([matching-label (+ 1 non-matching-label)])
              (case (compile-variant-patterns/match tag 0 patterns env
                      (gen-state stack (empty-jl) matching-label (empty-jl)))
                [(gen-state matching-stack matching-cmds matching-end-label matching-blocks)
                 (let ([join-label (+ 1 matching-end-label)])
                   (begin
                     ; (assert-stack-equal? matching-stack stack)
                     (gen-state
                       (tmp-slot (remove-temporaries 1 stack))
                       (empty-jl)
                       join-label
                       (append-jl
                         (snoc-jl
                           (snoc-jl
                             blocks
                             (stack-basic-block
                               (jl->list cmds)
                               (variant-switch
                                 (variant-case tag matching-label
                                   (catch-all-case non-matching-label)))))
                           (stack-basic-block
                             (cons (pop-cmd) (cons (boolean-lit-cmd #f) (empty)))
                             (uncond-jmp join-label)))
                         (snoc-jl
                           matching-blocks
                           (stack-basic-block
                             (jl->list matching-cmds)
                             (uncond-jmp join-label)))))))])))]))]
    [(bytes-pattern const-name)
     (case (environment-value-ref env const-name)
       [(just (global-value n))
        (add-bytes-cmp (load-global n state))]
       [_ (panic #"Bad bytes pattern")])]
    [(int-pattern lit)
     (add-int-cmp (add-int-literal lit state))]))

;; Takes a stack of the form A :: Rest and turns it into the state Boolean :: Rest
;; where the top of the stack is true if the value matched all the patterns
(define (compile-variant-patterns/match
          [tag : Int]
          [field : Int]
          [patterns : (List Pattern)]
          [env : Environment]
          [state : GenState]) : GenState
  (case patterns
    [(empty) (add-boolean-literal #t (ignore-value state))]
    [(cons pattern patterns)
     (let ([state (variant-ref tag field (dup-temporary state))])
       (case (compile-pattern/match pattern env state)
         [(gen-state stack cmds label blocks)
          (let ([non-matching-label (+ label 1)])
            (let ([matching-label (+ non-matching-label 1)])
              (case (compile-variant-patterns/match tag (+ field 1) patterns env
                      (gen-state (remove-temporaries 1 stack) (empty-jl) matching-label (empty-jl)))
                [(gen-state matching-stack matching-cmds matching-end-label matching-blocks)
                 (let ([join-label (+ matching-end-label 1)])
                   (begin
                     ; (assert-stack-equal? matching-stack (remove-temporaries 1 stack))
                     (gen-state
                       matching-stack
                       (empty-jl)
                       join-label
                       (append-jl
                         (snoc-jl
                           (snoc-jl
                             blocks
                             (stack-basic-block
                               (jl->list cmds)
                               (boolean-jmp matching-label non-matching-label)))
                           (stack-basic-block
                             (cons (pop-cmd) (cons (boolean-lit-cmd #f) (empty)))
                             (uncond-jmp join-label)))
                         (snoc-jl
                           matching-blocks
                           (stack-basic-block
                             (jl->list matching-cmds)
                             (uncond-jmp join-label)))))))])))]))]))

;; Takes a stack of the form A :: Rest and sets it up with some variables
;; on top of Rest before evaluating expr, and then cleans up all those variables.
(define (compile-pattern/extract
          [pattern : Pattern]
          [expr : Expression]
          [env : Environment]
          [state : GenState]) : GenState
  (let ([extractions (compute-extractions (cons (tuple2 pattern (empty)) (empty)) env (empty))])
    (cleanup-extractions/state
      (reverse extractions)
      (compile-expression
        expr
        (run-extractions/env extractions env)
        (run-extractions/state extractions state)))))

(define (run-extractions/state
          [extractions : (List (Tuple2 Bytes (List (Tuple2 Int Int))))]
          [state : GenState]) : GenState
  (case extractions
    [(empty) (ignore-value state)]
    [(cons (tuple2 name path) extractions)
     (run-extractions/state
       extractions
       (swap-var
         (name-temporary name
           (extract-path (reverse path) (dup-temporary state)))))]))

(define (cleanup-extractions/state
          [extractions : (List (Tuple2 Bytes (List (Tuple2 Int Int))))]
          [state : GenState]) : GenState
  (case extractions
    [(empty) state]
    [(cons (tuple2 name _) extractions)
     (cleanup-extractions/state
       extractions
       (unscope-variable name state))]))

(define (extract-path [path : (List (Tuple2 Int Int))] [state : GenState]) : GenState
  (case path
    [(empty) state]
    [(cons (tuple2 tag field) path)
     (extract-path
       path
       (variant-ref tag field state))]))

(define (swap-var [state : GenState]) : GenState
  (case state
    [(gen-state stack cmds label blocks)
     (case stack
       [(var-slot v (tmp-slot stack))
        (gen-state
          (tmp-slot (var-slot v stack))
          (snoc-jl cmds (swap-cmd))
          label
          blocks)]
       [_ (panic #"swap-var: Not a valid state")])]))

(define (run-extractions/env
          [extractions : (List (Tuple2 Bytes (List (Tuple2 Int Int))))]
          [env : Environment]) : Environment
  (case extractions
    [(empty) env]
    [(cons (tuple2 name _) extractions)
     (run-extractions/env
       extractions
       (environment-value-set env name (local-var)))]))

(define (compute-extractions
          [patterns : (List (Tuple2 Pattern (List (Tuple2 Int Int))))]
          [env : Environment]
          [acc-extractions : (List (Tuple2 Bytes (List (Tuple2 Int Int))))])
  : (List (Tuple2 Bytes (List (Tuple2 Int Int))))
  (case patterns
    [(empty) acc-extractions]
    [(cons (tuple2 pattern path) patterns)
     (case pattern
       [(ignore-pattern) (compute-extractions patterns env acc-extractions)]
       [(bytes-pattern _) (compute-extractions patterns env acc-extractions)]
       [(int-pattern _) (compute-extractions patterns env acc-extractions)]
       [(variable-pattern v)
        (compute-extractions patterns env (cons (tuple2 v path) acc-extractions))]
       [(abstraction-pattern name inner-patterns)
        (let ([tag (environment-tag-ref env name)])
          (compute-extractions
            (compute-extraction-paths inner-patterns path tag 0 patterns)
            env
            acc-extractions))])]))

(define (compute-extraction-paths
          [patterns : (List Pattern)]
          [path : (List (Tuple2 Int Int))]
          [tag : Int]
          [field : Int]
          [acc : (List (Tuple2 Pattern (List (Tuple2 Int Int))))])
  : (List (Tuple2 Pattern (List (Tuple2 Int Int))))
  (case patterns
    [(empty) acc]
    [(cons pattern patterns)
     (compute-extraction-paths
       patterns
       path
       tag
       (+ field 1)
       (cons (tuple2 pattern (cons (tuple2 tag field) path)) acc))]))


(define (compile-begin-exprs
          [exprs : (List Expression)]
          [env : Environment]
          [state : GenState]) : GenState
  (case exprs
    [(empty) state]
    [(cons expr exprs)
     (compile-begin-exprs exprs env (compile-expression expr env (ignore-value state)))]))


;; TODO remove initial y once starting with an 'l' is not an issue
(define (mangle-name [name : Bytes]) : Bytes
  (let ([len (bytes-length name)])
    (bytes-append (varargs list
                           #"y"
                           (mangle-name/helper name (make-bytes len) (- len 1))))))

;; TODO Figure out how to avoid overlap in generated mangled names
(define (mangle-name/helper [orig-name : Bytes] [buf : Bytes] [index : Int]) : Bytes
  (if (> 0 index)
      buf
      (let ([byte (bytes-ref orig-name index)])
        (let ([new-byte
               (if (or (= byte 45)
                       (or (= byte 42)
                           (or (= byte 62)
                               (or (= byte 47)
                                   (or (= byte 61)
                                       (or (= byte 63)
                                           (or (= byte 60)
                                               (= byte 33))))))))
                   95
                   byte)])
          (begin
            (bytes-set! buf index (u8 new-byte))
            (mangle-name/helper orig-name buf (- index 1)))))))

;; TODO merge this with the rest of mangling
(define (mangled-mod-name [m : ModName]) : Bytes
  (bytes-append (interleave (mod-name-parts m) #"_")))
