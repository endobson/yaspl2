(module intermediate-to-stack
  (import
    (bytes bytes=? bytes-append)
    (dict
      #:types (Dict)
      #:values (dict-add dict-ref make-dict)
      #:patterns ())
    (either
      #:types (Either)
      #:values (left right)
      #:patterns (left right))
    (environment
      #:types (Environment VarReference VariantInfo)
      #:values (environment environment-tag-ref environment-value-ref environment-value-set free-var
                global-value local-var variant-info)
      #:patterns (free-var global-value local-var))
    (intermediate-language
      #:types (BytesConstant CaseClause ClosureConstant Expression
               (FunctionDefinition i:FunctionDefinition) (Module i:Module) Pattern TypeDefinition
               VariantDefinition VariantField)
      #:values (bytes-constant-name
                closure-constant-name
                (function-definition-name i:function-definition-name)
                (module-bytes i:module-bytes)
                (module-closures i:module-closures)
                (module-definitions i:module-definitions)
                (module-imports i:module-imports)
                (module-name i:module-name)
                (module-types i:module-types))
      #:patterns (abstraction-pattern begin-expr boolean-literal bytes-constant bytes-pattern
                  call-closure-expr case-clause case-expr closure-constant create-closure-expr
                  (function-definition i:function-definition) global-var-expr if-expr ignore-pattern
                  int-literal int-pattern let-expr local-var-expr type-definition
                  varargs-call-closure-expr variable-pattern variant-definition variant-field))
    (intermediate-to-module-signature module->module-signature)
    (join-list
      #:types ()
      #:values (append-jl empty-jl jl->list snoc-jl)
      #:patterns ())
    (list
      #:types (List)
      #:values (append append* cons empty foldl length list map reverse)
      #:patterns (cons empty))
    (maybe
      #:types ()
      #:values ()
      #:patterns (just nothing))
    (module-signature
      #:types (ModuleSignature)
      #:values (module-signature-name module-signature-pattern-exports module-signature-type-bindings
                module-signature-value-exports)
      #:patterns (pattern-signature))
    (prim
      #:types (Boolean Bytes Int)
      #:values (* + - = > bytes-length bytes-ref bytes-set! make-bytes or panic u8)
      #:patterns ())
    (source-language
      #:types (Import Imports)
      #:values ()
      #:patterns (import imports))
    (stack-machine
      #:types (GenState StackCmd TopLevelObject)
      #:values (add-boolean-literal add-bytes-cmp add-int-cmp add-int-literal alloc-variant-cmd
                boolean-jmp boolean-lit-cmd bytes-tlo call-function catch-all-case create-closure
                dup-cmd dup-temporary function-tlo gen-state ignore-value initial-variables
                load-free-var load-global make-varargs-array name-temporary no-catch-all-case pop-cmd
                remove-temporaries return stack-basic-block stack-function swap-cmd tmp-slot
                trivial-closure-tlo uncond-jmp unscope-variable var-slot variable-ref variant-case
                variant-ref variant-ref-cmd variant-switch)
      #:patterns (gen-state tmp-slot trivial-closure-tlo var-slot))
    (tuples
      #:types (Tuple2)
      #:values (tuple2)
      #:patterns (tuple2))
    (types
      #:types (Type)
      #:values ()
      #:patterns ()))
  (export
    #:types (CompiledModule)
    #:values (compile-module)
    #:patterns (compiled-module))
  (types
    (define-type CompiledModule
      (compiled-module
        [code : (List TopLevelObject)]
        [sig : ModuleSignature])))

  (define (compile-module [imod : i:Module] [sigs : (List ModuleSignature)]) :
    (Either Bytes CompiledModule)
    (case (make-global-env imod sigs)
      [(left v) (left v)]
      [(right env)
       (let ([tlos
               (append
                 (compile-type-definitions imod)
                 (append
                   (compile-function-definitions imod env)
                   (append
                     (compile-closures imod)
                     (compile-byte-constants imod))))])
         (right
           (compiled-module
             tlos
             (module->module-signature imod env
               (add-known-functions tlos (make-dict bytes=?))))))]))

  (define (add-known-functions [tlos : (List TopLevelObject)]
                               [dict : (Dict Bytes Bytes)]) : (Dict Bytes Bytes)
    (case tlos
      [(empty) dict]
      [(cons (trivial-closure-tlo name fun-name) tlos)
       (add-known-functions tlos (dict-add dict name fun-name))]
      [(cons _ tlos)
       (add-known-functions tlos dict)]))


  (define (make-global-env [imod : i:Module] [sigs : (List ModuleSignature)])
    : (Either Bytes Environment)
    (case (add-all-imported-patterns
            (add-type-definitions-variant-infos/top
              (initial-variant-bindings) imod)
            imod sigs)
      [(left v) (left v)]
      [(right pattern-env)
       (case (setup-value-environment imod sigs)
         [(left v) (left v)]
         [(right value-env)
          (case (setup-type-environment imod sigs)
            [(left v) (left v)]
            [(right type-env)
             (right
               (environment
                 value-env
                 pattern-env
                 type-env))])])]))

  (define (setup-type-environment [imod : i:Module] [sigs : (List ModuleSignature)])
    : (Either Bytes (Dict Bytes Type))
    (right
      (add-imported-types/importss (i:module-imports imod) sigs
        (add-type-definitions (i:module-types imod) (make-dict bytes=?)))))

  (define (add-imported-types/importss
            [importss : (List Imports)]
            [sigs : (List ModuleSignature)]
            [env : (Dict Bytes Type)])
    : (Dict Bytes Type)
    (case importss
      [(empty) env]
      [(cons (imports module-name types _ _) importss)
       (add-imported-types/importss
         importss
         sigs
         (add-imported-types module-name types
           (module-signature-type-bindings (lookup-signature module-name sigs)) env))]))

  (define (lookup-signature [name : Bytes] [sigs : (List ModuleSignature)])
    : ModuleSignature
    (case sigs
      [(empty) (panic #"No such signature")]
      [(cons sig sigs)
       (if (bytes=? (module-signature-name sig) name)
           sig
           (lookup-signature name sigs))]))


  (define (add-imported-types
            [module-name : Bytes]
            [types : (List Import)]
            [external-types : (Dict Bytes Type)]
            [env : (Dict Bytes Type)])
    : (Dict Bytes Type)
    (case types
      [(empty) env]
      [(cons (import external-name local-name) types)
       (add-imported-types
         module-name
         types
         external-types
         (dict-add env local-name
            (case (dict-ref external-types external-name)
              [(nothing) (panic (bytes-append (varargs list #"No type " external-name #" exported by "
                                                       module-name)))]
              [(just type) type])))]))


  (define (add-type-definitions [types : (List TypeDefinition)] [env : (Dict Bytes Type)])
    : (Dict Bytes Type)
    (case types
      [(empty) env]
      [(cons (type-definition name type-binding _ _ _) types)
       (add-type-definitions
         types
         (dict-add env name type-binding))]))

  (define (setup-value-environment [imod : i:Module] [sigs : (List ModuleSignature)])
    : (Either Bytes (Dict Bytes VarReference))
    (add-all-imported-functions
      (add-type-definitions-functions/top
        (add-locally-defined-functions
          (add-locally-defined-closures
            (add-locally-defined-bytes
              (initial-value-bindings)
              imod)
            imod)
          imod)
        imod)
      imod sigs))


  (define (initial-value-bindings) : (Dict Bytes VarReference)
    (make-dict bytes=?))

  (define (initial-variant-bindings) : (Dict Bytes VariantInfo)
    (make-dict bytes=?))


  (define (add-all-imported-patterns
            [env : (Dict Bytes VariantInfo)]
            [imod : i:Module]
            [sigs : (List ModuleSignature)]) : (Either Bytes (Dict Bytes VariantInfo))
    (add-all-imports/patterns env (i:module-imports imod) sigs))

  (define (add-all-imports/patterns
            [env : (Dict Bytes VariantInfo)]
            [imports : (List Imports)]
            [sigs : (List ModuleSignature)]) : (Either Bytes (Dict Bytes VariantInfo))
    (case imports
      [(empty) (right env)]
      [(cons (imports mod-name _ _ patterns) imports)
       (case (lookup-module-signature mod-name sigs)
         [(left v) (left v)]
         [(right sig)
          (case (add-imports/patterns env patterns sig)
            [(left v) (left v)]
            [(right env)
             (add-all-imports/patterns env imports sigs)])])]))

  (define (add-imports/patterns
            [env : (Dict Bytes VariantInfo)]
            [imports : (List Import)]
            [sig : ModuleSignature]) : (Either Bytes (Dict Bytes VariantInfo))
    (case imports
      [(empty) (right env)]
      [(cons (import exported-name local-name) imports)
       (case (dict-ref (module-signature-pattern-exports sig) exported-name)
         [(nothing)
          (left
            (bytes-append
              (cons #"No corresponding export for pattern import of "
                (cons exported-name (empty)))))]
         [(just (pattern-signature tag _ _ _))
          (add-imports/patterns
            (dict-add env local-name (variant-info tag))
            imports
            sig)])]))

  (define (add-all-imported-functions
            [env : (Dict Bytes VarReference)]
            [imod : i:Module]
            [sigs : (List ModuleSignature)]) : (Either Bytes (Dict Bytes VarReference))
    (add-all-imports env (i:module-imports imod)sigs))

  (define (add-all-imports
            [env : (Dict Bytes VarReference)]
            [imps : (List Imports)]
            [sigs : (List ModuleSignature)]) : (Either Bytes (Dict Bytes VarReference))
    (case imps
      [(empty) (right env)]
      [(cons (imports mod-name _ values _) imps)
       (case (lookup-module-signature mod-name sigs)
         [(left v) (panic v)]
         [(right sig)
          (case (add-imports env values sig)
            [(left v) (left v)]
            [(right env) (add-all-imports env imps sigs)])])]))

  (define (add-imports
            [env : (Dict Bytes VarReference)]
            [imps : (List Import)]
            [sig : ModuleSignature]) : (Either Bytes (Dict Bytes VarReference))
    (case (add-imports* (empty) env imps sig)
      [(tuple2 (empty) env)
       (right env)]
      [(tuple2 missing-exports _)
       (left
         (bytes-append
           (cons #"No corresponding export for import of:"
             (append*
               (map (lambda ([e : Bytes]) (varargs list #"\n  " e)) missing-exports)))))]))

  (define (add-imports*
            [missing-exports : (List Bytes)]
            [env : (Dict Bytes VarReference)]
            [imps : (List Import)]
            [sig : ModuleSignature]) : (Tuple2 (List Bytes) (Dict Bytes VarReference))
    (case imps
      [(empty) (tuple2 missing-exports env)]
      [(cons (import exported-name local-name) imps)
       (case (dict-ref (module-signature-value-exports sig) exported-name)
         [(nothing)
          (add-imports*
            (cons exported-name missing-exports)
            env
            imps
            sig)]
         [(just global-name)
          (add-imports*
            missing-exports
            (dict-add env local-name (global-value global-name))
            imps
            sig)])]))


  (define (lookup-module-signature [mod-name : Bytes] [sigs : (List ModuleSignature)])
    : (Either Bytes ModuleSignature)
    (case sigs
      [(empty) (left (bytes-append (cons #"No module found for import: " (cons mod-name (empty)))))]
      [(cons sig sigs)
       (if (bytes=? (module-signature-name sig) mod-name)
           (right sig)
           (lookup-module-signature mod-name sigs))]))

  (define (add-locally-defined-functions [env : (Dict Bytes VarReference)] [imod : i:Module])
    : (Dict Bytes VarReference)
    (let ([var-names (map i:function-definition-name (i:module-definitions imod))])
      (let ([mangled-names (get-mangled-names (i:module-name imod) (i:module-definitions imod))])
        (add-all-globals env var-names mangled-names))))

  (define (get-mangled-names [mod-name : Bytes] [funs : (List i:FunctionDefinition)]) : (List Bytes)
    (case funs
      [(empty) (empty)]
      [(cons (i:function-definition name _ _ _ _) funs)
       (cons
         (mangle-name (bytes-append (varargs list mod-name #"_" name)))
         (get-mangled-names mod-name funs))]))

  (define (i-get-mangled-names [mod-name : Bytes] [names : (List Bytes)]) : (List Bytes)
    (case names
      [(empty) (empty)]
      [(cons name names)
       (cons
         (mangle-name (bytes-append (varargs list mod-name #"_" name)))
         (i-get-mangled-names mod-name names))]))

  (define (add-locally-defined-closures [env : (Dict Bytes VarReference)] [imod : i:Module])
    : (Dict Bytes VarReference)
    (let ([var-names (map closure-constant-name (i:module-closures imod))])
      (let ([mangled-names (i-get-mangled-names (i:module-name imod) var-names)])
        (add-all-globals env var-names mangled-names))))

  (define (add-locally-defined-bytes [env : (Dict Bytes VarReference)] [imod : i:Module])
    : (Dict Bytes VarReference)
    (let ([var-names (map bytes-constant-name (i:module-bytes imod))])
      (let ([mangled-names (i-get-mangled-names (i:module-name imod) var-names)])
        (add-all-globals env var-names mangled-names))))


  (define (add-all-globals [env : (Dict Bytes VarReference)]
                           [var-names : (List Bytes)]
                           [mangled-names : (List Bytes)])
    : (Dict Bytes VarReference)
    (case var-names
      [(empty) env]
      [(cons var-name var-names)
       (case mangled-names
         [(empty) (panic #"var-names not the same length as mangled-names")]
         [(cons mangled-name mangled-names)
          (add-all-globals
            (dict-add env var-name (global-value mangled-name)) var-names mangled-names)])]))

  (define (add-type-definitions-functions/top [env : (Dict Bytes VarReference)] [imod : i:Module])
    : (Dict Bytes VarReference)
    (let ([mod-name (i:module-name imod)])
      (foldl
        (lambda ([def : TypeDefinition] [env : (Dict Bytes VarReference)])
          (case def
            [(type-definition name _ _ _ (cons variant (empty)))
             (case variant
               [(variant-definition variant-name _ fields)
                (add-variant-definition-accessors
                  (add-variant-definition-constructor env mod-name name variant)
                  mod-name name variant-name fields)])]
            [(type-definition name _ _ _ variants)
             (add-variant-definitions-constructors env mod-name name variants)]))
        (i:module-types imod)
        env)))


  (define (add-variant-definitions-constructors
            [env : (Dict Bytes VarReference)]
            [mod-name : Bytes]
            [type-name : Bytes]
            [defs : (List VariantDefinition)]) : (Dict Bytes VarReference)
    (case defs
      [(empty) env]
      [(cons def defs)
       (add-variant-definitions-constructors
         (add-variant-definition-constructor env mod-name type-name def)
         mod-name
         type-name
         defs)]))

  (define (add-variant-definition-constructor
            [env : (Dict Bytes VarReference)]
            [mod-name : Bytes]
            [type-name : Bytes]
            [def : VariantDefinition]) : (Dict Bytes VarReference)
    (case def
      [(variant-definition name _ _)
       (dict-add
         env
         name
         (global-value
           (mangle-name
             (bytes-append
               (varargs list mod-name #"_" type-name #"_" name #"_closure")))))]))

  (define (add-variant-definition-accessors
            [env : (Dict Bytes VarReference)]
            [mod-name : Bytes]
            [type-name : Bytes]
            [variant-name : Bytes]
            [fields : (List VariantField)]) : (Dict Bytes VarReference)
    (case fields
      [(empty) env]
      [(cons (variant-field name _) fields)
       (add-variant-definition-accessors
         (dict-add
           env
           (bytes-append (cons variant-name (cons #"-" (cons name (empty)))))
           (global-value
             (mangle-name
               (bytes-append
                 (varargs list mod-name #"_" type-name #"_" variant-name #"_" name #"_closure")))))
         mod-name
         type-name
         variant-name
         fields)]))

  (define (add-type-definitions-variant-infos/top [env : (Dict Bytes VariantInfo)] [imod : i:Module])
    : (Dict Bytes VariantInfo)
    (add-type-definitions-variant-infos env (i:module-types imod)))

  (define (add-type-definitions-variant-infos
            [env : (Dict Bytes VariantInfo)]
            [defs : (List TypeDefinition)])
    : (Dict Bytes VariantInfo)
    (case defs
      [(empty) env]
      [(cons (type-definition _ _ _ _ variants) defs)
       (add-type-definitions-variant-infos
         (add-variant-definitions-variant-infos env variants)
         defs)]))

  (define (add-variant-definitions-variant-infos
            [env : (Dict Bytes VariantInfo)]
            [defs : (List VariantDefinition)])
    : (Dict Bytes VariantInfo)
    (case defs
      [(empty) env]
      [(cons (variant-definition name tag _) defs)
       (add-variant-definitions-variant-infos
         (dict-add env name (variant-info tag))
         defs)]))

  (define (add-all-locals [env : Environment] [names : (List Bytes)])
    : Environment
    (case names
      [(empty) env]
      [(cons name names) (add-all-locals (environment-value-set env name (local-var)) names)]))

  (define (add-all-free-vars [env : Environment] [names : (List Bytes)] [index : Int])
    : Environment
    (case names
      [(empty) env]
      [(cons name names)
       (add-all-free-vars (environment-value-set env name (free-var index)) names (+ 1 index))]))


  (define (compile-type-definitions [imod : i:Module]) : (List TopLevelObject)
    (compile-type-definitions/list (i:module-name imod) (i:module-types imod) (empty)))

  (define (compile-type-definitions/list
            [mod-name : Bytes]
            [defs : (List TypeDefinition)]
            [acc : (List TopLevelObject)]) : (List TopLevelObject)
    (case defs
      [(empty) acc]
      [(cons def defs)
       (compile-type-definitions/list
         mod-name
         defs
         (compile-type-definition mod-name def acc))]))

  (define (compile-type-definition
            [mod-name : Bytes]
            [def : TypeDefinition]
            [acc : (List TopLevelObject)]) : (List TopLevelObject)
    (case def
      [(type-definition name _ _ _ (cons variant (empty)))
       (compile-variant-definition mod-name name variant #t acc)]
      [(type-definition name _ _ _ variants)
       (compile-type-definition/variants mod-name name variants acc)]))

  (define (compile-type-definition/variants
            [mod-name : Bytes]
            [type-name : Bytes]
            [variants : (List VariantDefinition)]
            [acc : (List TopLevelObject)]) : (List TopLevelObject)
    (case variants
      [(empty) acc]
      [(cons variant variants)
       (compile-type-definition/variants
         mod-name
         type-name
         variants
         (compile-variant-definition mod-name type-name variant #f acc))]))

  (define (compile-variant-definition
            [mod-name : Bytes]
            [type-name : Bytes]
            [def : VariantDefinition]
            [generate-accessors : Boolean]
            [acc : (List TopLevelObject)]) : (List TopLevelObject)
    (case def
      [(variant-definition name variant-tag fields)
       (let ([mangled-name
              (mangle-name (bytes-append (varargs list mod-name #"_" type-name #"_" name)))])
         (cons
           (function-tlo
             (stack-function
               mangled-name
               (length fields)
               (cons
                 (stack-basic-block
                   (add-reversed-args
                     0
                     (length fields)
                     (cons
                       (alloc-variant-cmd variant-tag (length fields))
                       (empty)))
                   (return (length fields)))
                 (empty))))
           (cons
             (trivial-closure-tlo
               (bytes-append (varargs list mangled-name #"_closure"))
               mangled-name)
             (if generate-accessors
                 (compile-variant-definition/accessors
                   mod-name
                   type-name
                   name
                   variant-tag
                   0
                   fields
                   acc)
                 acc))))]))

  (define (compile-variant-definition/accessors
            [mod-name : Bytes]
            [type-name : Bytes]
            [variant-name : Bytes]
            [variant-tag : Int]
            [field-index : Int]
            [fields : (List VariantField)]
            [acc : (List TopLevelObject)]) : (List TopLevelObject)
    (case fields
      [(empty) acc]
      [(cons (variant-field name _) fields)
       (compile-variant-definition/accessors
         mod-name
         type-name
         variant-name
         variant-tag
         (+ field-index 1)
         fields
         (let ([mangled-name
                (mangle-name
                  (bytes-append (varargs list mod-name #"_" type-name #"_" variant-name #"_" name)))])
           (cons
             (function-tlo
               (stack-function
                 mangled-name
                 1
                 (cons
                   (stack-basic-block
                     (add-reversed-args 0 1 (cons (variant-ref-cmd variant-tag field-index) (empty)))
                     (return 1))
                   (empty))))
             (cons
               (trivial-closure-tlo
                 (bytes-append (varargs list mangled-name #"_closure"))
                 mangled-name)
               acc))))]))

  (define (add-reversed-args [arg-number : Int] [args : Int] [cmds : (List StackCmd)]) : (List StackCmd)
    (if (= arg-number args)
        cmds
        (add-reversed-args
          (+ arg-number 1)
          args
          (cons (dup-cmd (- (* 2 args) (* 2 (+ arg-number 1)))) cmds))))


  (define (compile-byte-constants [imod : i:Module]) : (List TopLevelObject)
    (map (let ([mod-name (i:module-name imod)])
           (lambda ([b : BytesConstant])
              (case b
                [(bytes-constant name value)
                 (bytes-tlo
                   (mangle-name (bytes-append (varargs list mod-name #"_" name)))
                   value)])))
         (i:module-bytes imod)))

  (define (compile-closures [imod : i:Module]) : (List TopLevelObject)
    (compile-closures/list (i:module-name imod) (i:module-closures imod)))

  (define (compile-closures/list
            [mod-name : Bytes]
            [pairs : (List ClosureConstant)])
    : (List TopLevelObject)
    (case pairs
      [(empty) (empty)]
      [(cons (closure-constant name fun-name) pairs)
       (cons
         (trivial-closure-tlo
           (mangle-name (bytes-append (varargs list mod-name #"_" name)))
           (mangle-name (bytes-append (varargs list mod-name #"_" fun-name))))
         (compile-closures/list mod-name pairs))]))

  (define (compile-function-definitions [imod : i:Module] [env : Environment]) : (List TopLevelObject)
    (compile-function-definitions/list (i:module-name imod) (i:module-definitions imod) env))

  (define (compile-function-definitions/list
            [mod-name : Bytes]
            [funs : (List i:FunctionDefinition)]
            [env : Environment]) : (List TopLevelObject)
    (case funs
      [(empty) (empty)]
      [(cons fun funs)
       (cons (compile-function-definition mod-name fun env)
             (compile-function-definitions/list mod-name funs env))]))

  (define (compile-function-definition
            [mod-name : Bytes]
            [fun : i:FunctionDefinition]
            [env : Environment]) : TopLevelObject
    (case fun
      [(i:function-definition name pre-type arg-names free-vars body)
       (function-tlo
         (stack-function
           (mangle-name (bytes-append (varargs list mod-name #"_" name)))
           (length arg-names)
           ;; TODO validate the genstate has one temporary left in it, the return addr, and then the
           ;; variables.
           (case (compile-expression
                   body
                   (add-all-free-vars (add-all-locals env arg-names) free-vars 0)
                   (gen-state (initial-variables arg-names) (empty-jl) 0 (empty-jl)))
             [(gen-state _ cmds label blocks)
              (jl->list
                (snoc-jl
                  blocks
                  (stack-basic-block (jl->list cmds) (return (length arg-names)))))])))]))

  (define (compile-expressions
            [exprs : (List Expression)]
            [env : Environment]
            [state : GenState]) : GenState
    (case exprs
      [(empty) state]
      [(cons expr exprs)
       (compile-expressions exprs env
         (compile-expression expr env state))]))

  (define (compile-expression
            [expr : Expression]
            [env : Environment]
            [state : GenState]) : GenState
    (case expr
      [(int-literal v) (add-int-literal v state)]
      [(boolean-literal v) (add-boolean-literal v state)]
      [(let-expr name expr body)
       (unscope-variable name
         (compile-expression
           body
           (environment-value-set env name (local-var))
           (name-temporary name
             (compile-expression expr env state))))]
      [(local-var-expr v)
       (case (environment-value-ref env v)
         [(just (local-var)) (variable-ref v state)]
         [(just (free-var offset))
          (load-free-var offset state)]
         [(just (global-value n))
          (load-global n state)]
         [(nothing) (panic (bytes-append (cons #"Unbound variable: " (cons v (empty)))))])]
      [(global-var-expr v)
       (panic #"global-var: NYI")]
      ;; TODO compile the expressions in the right order
      [(create-closure-expr op args)
       (create-closure (length args)
         (compile-expression op env
           (compile-expressions (reverse args) env state)))]
      ;; TODO make effects of op go before arguments
      [(call-closure-expr op args)
       (call-function (length args)
         (compile-expression op env
           (compile-expressions args env state)))]
      ;; TODO make effects of op go before arguments
      ;; TODO compile the expressions in the right order
      [(varargs-call-closure-expr op args)
       (call-function 1
         (compile-expression op env
           (make-varargs-array (length args)
             (compile-expressions (reverse args) env state))))]
      [(if-expr c t f)
       (case (compile-expression c env state)
         [(gen-state stack cmds-c label-c-end blocks)
          (let ([stack-split (remove-temporaries 1 stack)])
            (let ([label-t-begin (+ label-c-end 1)])
              (case (compile-expression t env
                      (gen-state stack-split (empty-jl) label-t-begin (empty-jl)))
                [(gen-state stack-t cmds-t label-t-end blocks-t)
                 (let ([label-f-begin (+ label-t-end 1)])
                   (case (compile-expression f env
                           (gen-state stack-split (empty-jl) label-f-begin (empty-jl)))
                     [(gen-state stack-f cmds-f label-f-end blocks-f)
                      (let ([new-label (+ label-f-end 1)])
                        (begin
                          ; (assert-stack-equal? stack-f stack-t)
                          ; (assert-stack-equal? stack-f (tmp-slot stack-split))
                          (gen-state
                            (tmp-slot stack-split)
                            (empty-jl)
                            new-label
                            (append-jl
                              (snoc-jl
                                blocks
                                (stack-basic-block (jl->list cmds-c) (boolean-jmp label-t-begin label-f-begin)))
                              (append-jl
                                (snoc-jl
                                  blocks-t
                                  (stack-basic-block (jl->list cmds-t) (uncond-jmp new-label)))
                                (snoc-jl
                                  blocks-f
                                  (stack-basic-block (jl->list cmds-f) (uncond-jmp new-label))))))))]))])))])]
      [(begin-expr expr exprs)
       (compile-begin-exprs exprs env (compile-expression expr env state))]
      [(case-expr expr clauses)
       (let ([state (compile-expression expr env state)])
         (compile-case-clauses clauses env state))]))

  ;; This should take a stack of A :: Rest to B :: Rest.
  ;; Where A is the type being cased on and B is the return type
  (define (compile-case-clauses
            [clauses : (List CaseClause)]
            [env : Environment]
            [state : GenState]) : GenState
    (case clauses
      [(empty)
       (case state
         [(gen-state stack cmds label blocks)
          (gen-state
            (tmp-slot (remove-temporaries 1 stack))
            (empty-jl)
            (+ 1 label)
            (snoc-jl
              blocks
              (stack-basic-block
                (jl->list cmds)
                (variant-switch (no-catch-all-case)))))])]
      [(cons clause clauses)
       (compile-case-clause clause clauses env state)]))

  (define (compile-case-clause
            [clause : CaseClause]
            [clauses : (List CaseClause)]
            [env : Environment]
            [state : GenState]) : GenState
    (case clause
      [(case-clause pattern expr)
       (case (compile-pattern/match pattern env (dup-temporary state))
         [(gen-state match-stack match-cmds match-end-label match-blocks)
          (let ([stack-split (remove-temporaries 1 match-stack)])
            (let ([extract-start-label (+ 1 match-end-label)])
              (case (compile-pattern/extract pattern expr env
                      (gen-state stack-split
                                 (empty-jl)
                                 extract-start-label
                                 (empty-jl)))
                [(gen-state extract-stack extract-cmds extract-end-label extract-blocks)
                 (let ([other-start-label (+ 1 extract-end-label)])
                   (case (compile-case-clauses clauses env
                           (gen-state stack-split
                                      (empty-jl)
                                      other-start-label
                                      (empty-jl)))
                     [(gen-state other-stack other-cmds other-end-label other-blocks)
                      (let ([join-label (+ other-end-label 1)])
                        (begin
                          ; (assert-stack-equal? other-stack extract-stack)
                          ; (assert-stack-equal? extract-stack stack-split)
                          (gen-state
                            stack-split
                            (empty-jl)
                            join-label
                            (append-jl
                              (snoc-jl
                                match-blocks
                                (stack-basic-block
                                  (jl->list match-cmds)
                                  (boolean-jmp extract-start-label other-start-label)))
                              (append-jl
                                (snoc-jl
                                  extract-blocks
                                  (stack-basic-block
                                    (jl->list extract-cmds)
                                    (uncond-jmp join-label)))
                                (snoc-jl
                                  other-blocks
                                  (stack-basic-block
                                    (jl->list other-cmds)
                                    (uncond-jmp join-label))))))))]))])))])]))

  ;; Takes a stack of the form A :: Rest and turns it into the state Boolean :: Rest
  ;; where the top of the stack is true if the value matched the pattern.
  (define (compile-pattern/match
            [pattern : Pattern]
            [env : Environment]
            [state : GenState]) : GenState
    (case pattern
      [(ignore-pattern) (add-boolean-literal #t (ignore-value state))]
      [(variable-pattern _) (add-boolean-literal #t (ignore-value state))]
      [(abstraction-pattern name patterns)
       (let ([tag (environment-tag-ref env name)])
         (case state
           [(gen-state stack cmds old-label blocks)
            (let ([non-matching-label (+ 1 old-label)])
              (let ([matching-label (+ 1 non-matching-label)])
                (case (compile-variant-patterns/match tag 0 patterns env
                        (gen-state stack (empty-jl) matching-label (empty-jl)))
                  [(gen-state matching-stack matching-cmds matching-end-label matching-blocks)
                   (let ([join-label (+ 1 matching-end-label)])
                     (begin
                       ; (assert-stack-equal? matching-stack stack)
                       (gen-state
                         (tmp-slot (remove-temporaries 1 stack))
                         (empty-jl)
                         join-label
                         (append-jl
                           (snoc-jl
                             (snoc-jl
                               blocks
                               (stack-basic-block
                                 (jl->list cmds)
                                 (variant-switch
                                   (variant-case tag matching-label
                                     (catch-all-case non-matching-label)))))
                             (stack-basic-block
                               (cons (pop-cmd) (cons (boolean-lit-cmd #f) (empty)))
                               (uncond-jmp join-label)))
                           (snoc-jl
                             matching-blocks
                             (stack-basic-block
                               (jl->list matching-cmds)
                               (uncond-jmp join-label)))))))])))]))]
      [(bytes-pattern const-name)
       (case (environment-value-ref env const-name)
         [(just (global-value n))
          (add-bytes-cmp (load-global n state))]
         [_ (panic #"Bad bytes pattern")])]
      [(int-pattern lit)
       (add-int-cmp (add-int-literal lit state))]))

  ;; Takes a stack of the form A :: Rest and turns it into the state Boolean :: Rest
  ;; where the top of the stack is true if the value matched all the patterns
  (define (compile-variant-patterns/match
            [tag : Int]
            [field : Int]
            [patterns : (List Pattern)]
            [env : Environment]
            [state : GenState]) : GenState
    (case patterns
      [(empty) (add-boolean-literal #t (ignore-value state))]
      [(cons pattern patterns)
       (let ([state (variant-ref tag field (dup-temporary state))])
         (case (compile-pattern/match pattern env state)
           [(gen-state stack cmds label blocks)
            (let ([non-matching-label (+ label 1)])
              (let ([matching-label (+ non-matching-label 1)])
                (case (compile-variant-patterns/match tag (+ field 1) patterns env
                        (gen-state (remove-temporaries 1 stack) (empty-jl) matching-label (empty-jl)))
                  [(gen-state matching-stack matching-cmds matching-end-label matching-blocks)
                   (let ([join-label (+ matching-end-label 1)])
                     (begin
                       ; (assert-stack-equal? matching-stack (remove-temporaries 1 stack))
                       (gen-state
                         matching-stack
                         (empty-jl)
                         join-label
                         (append-jl
                           (snoc-jl
                             (snoc-jl
                               blocks
                               (stack-basic-block
                                 (jl->list cmds)
                                 (boolean-jmp matching-label non-matching-label)))
                             (stack-basic-block
                               (cons (pop-cmd) (cons (boolean-lit-cmd #f) (empty)))
                               (uncond-jmp join-label)))
                           (snoc-jl
                             matching-blocks
                             (stack-basic-block
                               (jl->list matching-cmds)
                               (uncond-jmp join-label)))))))])))]))]))

  ;; Takes a stack of the form A :: Rest and sets it up with some variables
  ;; on top of Rest before evaluating expr, and then cleans up all those variables.
  (define (compile-pattern/extract
            [pattern : Pattern]
            [expr : Expression]
            [env : Environment]
            [state : GenState]) : GenState
    (let ([extractions (compute-extractions (cons (tuple2 pattern (empty)) (empty)) env (empty))])
      (cleanup-extractions/state
        (reverse extractions)
        (compile-expression
          expr
          (run-extractions/env extractions env)
          (run-extractions/state extractions state)))))

  (define (run-extractions/state
            [extractions : (List (Tuple2 Bytes (List (Tuple2 Int Int))))]
            [state : GenState]) : GenState
    (case extractions
      [(empty) (ignore-value state)]
      [(cons (tuple2 name path) extractions)
       (run-extractions/state
         extractions
         (swap-var
           (name-temporary name
             (extract-path (reverse path) (dup-temporary state)))))]))

  (define (cleanup-extractions/state
            [extractions : (List (Tuple2 Bytes (List (Tuple2 Int Int))))]
            [state : GenState]) : GenState
    (case extractions
      [(empty) state]
      [(cons (tuple2 name _) extractions)
       (cleanup-extractions/state
         extractions
         (unscope-variable name state))]))

  (define (extract-path [path : (List (Tuple2 Int Int))] [state : GenState]) : GenState
    (case path
      [(empty) state]
      [(cons (tuple2 tag field) path)
       (extract-path
         path
         (variant-ref tag field state))]))

  (define (swap-var [state : GenState]) : GenState
    (case state
      [(gen-state stack cmds label blocks)
       (case stack
         [(var-slot v (tmp-slot stack))
          (gen-state
            (tmp-slot (var-slot v stack))
            (snoc-jl cmds (swap-cmd))
            label
            blocks)]
         [_ (panic #"swap-var: Not a valid state")])]))

  (define (run-extractions/env
            [extractions : (List (Tuple2 Bytes (List (Tuple2 Int Int))))]
            [env : Environment]) : Environment
    (case extractions
      [(empty) env]
      [(cons (tuple2 name _) extractions)
       (run-extractions/env
         extractions
         (environment-value-set env name (local-var)))]))

  (define (compute-extractions
            [patterns : (List (Tuple2 Pattern (List (Tuple2 Int Int))))]
            [env : Environment]
            [acc-extractions : (List (Tuple2 Bytes (List (Tuple2 Int Int))))])
    : (List (Tuple2 Bytes (List (Tuple2 Int Int))))
    (case patterns
      [(empty) acc-extractions]
      [(cons (tuple2 pattern path) patterns)
       (case pattern
         [(ignore-pattern) (compute-extractions patterns env acc-extractions)]
         [(bytes-pattern _) (compute-extractions patterns env acc-extractions)]
         [(int-pattern _) (compute-extractions patterns env acc-extractions)]
         [(variable-pattern v)
          (compute-extractions patterns env (cons (tuple2 v path) acc-extractions))]
         [(abstraction-pattern name inner-patterns)
          (let ([tag (environment-tag-ref env name)])
            (compute-extractions
              (compute-extraction-paths inner-patterns path tag 0 patterns)
              env
              acc-extractions))])]))

  (define (compute-extraction-paths
            [patterns : (List Pattern)]
            [path : (List (Tuple2 Int Int))]
            [tag : Int]
            [field : Int]
            [acc : (List (Tuple2 Pattern (List (Tuple2 Int Int))))])
    : (List (Tuple2 Pattern (List (Tuple2 Int Int))))
    (case patterns
      [(empty) acc]
      [(cons pattern patterns)
       (compute-extraction-paths
         patterns
         path
         tag
         (+ field 1)
         (cons (tuple2 pattern (cons (tuple2 tag field) path)) acc))]))


  (define (compile-begin-exprs
            [exprs : (List Expression)]
            [env : Environment]
            [state : GenState]) : GenState
    (case exprs
      [(empty) state]
      [(cons expr exprs)
       (compile-begin-exprs exprs env (compile-expression expr env (ignore-value state)))]))


  ;; TODO remove initial y once starting with an 'l' is not an issue
  (define (mangle-name [name : Bytes]) : Bytes
    (let ([len (bytes-length name)])
      (bytes-append (varargs list
                             #"y"
                             (mangle-name/helper name (make-bytes len) (- len 1))))))

  ;; TODO Figure out how to avoid overlap in generated mangled names
  (define (mangle-name/helper [orig-name : Bytes] [buf : Bytes] [index : Int]) : Bytes
    (if (> 0 index)
        buf
        (let ([byte (bytes-ref orig-name index)])
          (let ([new-byte
                 (if (or (= byte 45)
                         (or (= byte 42)
                             (or (= byte 62)
                                 (or (= byte 47)
                                     (or (= byte 61)
                                         (or (= byte 63)
                                             (or (= byte 60)
                                                 (= byte 33))))))))
                     95
                     byte)])
            (begin
              (bytes-set! buf index (u8 new-byte))
              (mangle-name/helper orig-name buf (- index 1))))))))
