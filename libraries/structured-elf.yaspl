#:module (structured-elf)
#:import {
  (aligned-bytes)
  (either)
  (maybe)
  (tuples)
  (bytes)
  (formats elf)
  (list)
  (prim)
  (structured-native-code)
}
(export
  (#:types ElfRelocationKind)
  (#:values
     elf-pc32-relocation
     abstract-relocation->elf-relocation
     parse-elf parsed-elf-text-section)
  (#:patterns elf-pc32-relocation))
(types
  (define-type ParsedElf
    (parsed-elf
      [text-section : (ProgramSection ElfRelocationKind)]))
  (define-type ElfRelocationKind
    (elf-pc32-relocation)))

(define (abstract-relocation->elf-relocation [r : AbstractRelocationKind])
  : ElfRelocationKind
  (case r
    [(branch-relocation) (elf-pc32-relocation)]
    [(call-relocation) (elf-pc32-relocation)]
    [(load-relocation) (elf-pc32-relocation)]
    [(address-relocation) (elf-pc32-relocation)]))

(define (parse-elf [elf : ElfFile]) : (Either Bytes ParsedElf)
  (case (elf-file->text-contents elf)
    [(left v) (left v)]
    [(right text-contents)
     (case (elf-file->symbols elf)
       [(left v) (left v)]
       [(right (tuple2 local-symbols global-symbols))
        (right
          (parsed-elf
            (program-section
              (aligned-bytes text-contents 1)
              (empty)
              global-symbols
              local-symbols)))])]))

(define (elf-file->text-contents [e : ElfFile]) : (Either Bytes Bytes)
  (match-define raw-contents (elf-file-raw-contents e))
  (case (find-named-section-header e #".text")
    [(left v) (left v)]
    [(right text-section-header)
     (right
       (subbytes raw-contents
                 (section-header-section-offset text-section-header)
                 (+ (section-header-section-offset text-section-header)
                    (section-header-section-size text-section-header))))]))


(define (elf-file->symbols [e : ElfFile])
  : (Either Bytes (Tuple2 (List DefinedSymbol) (List DefinedSymbol)))
  (case (find-named-section-header e #".symtab")
    [(left v) (left v)]
    [(right symtab-section-header)
     (case (find-named-section-header e #".strtab")
       [(left v) (left v)]
        [(right strtab-section-header)
         (match-define raw-contents (elf-file-raw-contents e))
         (right (tuple2 (empty) (empty)))])]))

(define (find-named-section-header [e : ElfFile] [name : Bytes]) : (Either Bytes SectionHeader)
  (match-define (elf-file sections section-name-index raw-contents) e)
  (case (list-ref sections section-name-index)
    [(nothing) (left #"Not enough sections for section name index")]
    [(just (section-header _ _ _ _ name-section-offset _ _ _ _ _))
     (case (findf
             (lambda ([v : SectionHeader])
               (let ([start (+ name-section-offset (section-header-name-offset v))])
                 (bytes=?
                   (subbytes raw-contents start (+ start (bytes-length name)))
                   name)))
             sections)
       [(nothing)
        (left (bytes-append (varargs list #"No section for name: " name)))]
       [(just v)
        (right v)])]))
