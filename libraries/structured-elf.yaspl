#:module (structured-elf)
#:import {
  (aligned-bytes)
  (bytes)
  (either)
  (formats elf)
  (list)
  (maybe)
  (numbers)
  (prim)
  (structured-native-code)
  (tuples)
}
(export
  (#:types ElfRelocationKind ParsedElf)
  (#:values
     elf-pc32-relocation elf-64-relocation
     abstract-relocation->elf-relocation
     parse-elf parsed-elf-text-section)
  (#:patterns elf-pc32-relocation elf-64-relocation))
(types
  (define-type ParsedElf
    (parsed-elf
      [text-section : (ProgramSection ElfRelocationKind)]))
  (define-type ElfRelocationKind
    (elf-pc32-relocation)
    (elf-64-relocation))
  (define-type ParsedSymbolTableEntry
    (section-symbol-entry [name : Bytes])
    (undefined-symbol-entry [name : Bytes])
    (text-symbol-entry [name : Bytes] [address : Int])
    (const-symbol-entry [name : Bytes] [address : Int])))

(define (abstract-relocation->elf-relocation [r : AbstractRelocationKind])
  : ElfRelocationKind
  (case r
    [(branch-relocation) (elf-pc32-relocation)]
    [(call-relocation) (elf-pc32-relocation)]
    [(load-relocation) (elf-pc32-relocation)]
    [(address-relocation) (elf-64-relocation)]))

(define (parse-elf [elf : ElfFile]) : (Either Bytes ParsedElf)
  (case (elf-file->text-contents elf)
    [(left v) (left v)]
    [(right text-contents)
     (case (elf-file->all-symbols elf)
       [(left v) (left v)]
       [(right all-symbols)
        (case (all-symbols->defined-symbols elf all-symbols)
          [(left v) (left v)]
          [(right (tuple2 local-symbols global-symbols))
           (case (elf-file->relocations elf all-symbols)
             [(left v) (left v)]
             [(right relocations)
              (right
                (parsed-elf
                  (program-section
                    (aligned-bytes text-contents 1)
                    relocations
                    global-symbols
                    local-symbols)))])])])]))

(define (elf-file->text-contents [e : ElfFile]) : (Either Bytes Bytes)
  (match-define raw-contents (elf-file-raw-contents e))
  (case (find-named-section-header e #".text")
    [(left v) (left v)]
    [(right text-section-header)
     (right
       (subbytes raw-contents
                 (section-header-section-offset text-section-header)
                 (+ (section-header-section-offset text-section-header)
                    (section-header-section-size text-section-header))))]))


(define (elf-file->all-symbols [e : ElfFile])
  : (Either Bytes (List ParsedSymbolTableEntry))
  (case (find-named-section-header e #".symtab")
    [(left v) (left v)]
    [(right symtab-section-header)
     (case (find-named-section-header e #".strtab")
       [(left v) (left v)]
       [(right strtab-section-header)
        (match-define raw-contents (elf-file-raw-contents e))
        (case (parse-elf-symbol-table symtab-section-header raw-contents)
          [(left v) (left v)]
          [(right symbols)
           (extract-rights
             (map
               (lambda ([v : SymbolTableEntry]) : (Either Bytes ParsedSymbolTableEntry)
                 (case v
                   [(symbol-table-entry name-offset binding-info section-index value size)
                    (let ([name (read-null-terminated-bytes
                                  raw-contents
                                  (+ (section-header-section-offset strtab-section-header)
                                     name-offset))])
                      (if (= binding-info 3)
                          (right (section-symbol-entry name))
                          (if (= section-index 0)
                              (right (undefined-symbol-entry name))
                              ;; TODO handle const symbols correctly
                              (right (text-symbol-entry name value)))))]))
               symbols))])])]))


(define (all-symbols->defined-symbols [e : ElfFile] [all-symbols : (List ParsedSymbolTableEntry)])
  : (Either Bytes (Tuple2 (List DefinedSymbol) (List DefinedSymbol)))
  (case (find-named-section-header e #".symtab")
    [(left v) (left v)]
    [(right symtab-section-header)
     (match-define num-local-symbols (section-header-section-info symtab-section-header))
     (match-define local-symbols (take num-local-symbols all-symbols))
     (match-define global-symbols (drop num-local-symbols all-symbols))
     (match-define text-filter
       (lambda ([s : ParsedSymbolTableEntry]) : (Maybe DefinedSymbol)
         (case s
           [(text-symbol-entry name value)
            (just (defined-symbol name value))]
           [_ (nothing)])))
     (right (tuple2 (filter-map text-filter local-symbols)
                    (filter-map text-filter global-symbols)))]))


(define (elf-file->relocations [e : ElfFile] [symbols : (List ParsedSymbolTableEntry)])
  : (Either Bytes (List (Relocation ElfRelocationKind)))
  (case (find-named-section-header e #".rela.text")
    [(left #"No section for name: .rela.text")
     (right (empty))]
    [(left v) (left v)]
    [(right rela-section-header)
     (case (find-named-section-header e #".strtab")
       [(left v) (left v)]
        [(right strtab-section-header)
         (match-define raw-contents (elf-file-raw-contents e))
         (case (parse-elf-relocations rela-section-header raw-contents)
           [(left v) (left v)]
           [(right relocations)
            (extract-rights
              (map
                (lambda ([relocation-entry : RelocationEntry])
                  : (Either Bytes (Relocation ElfRelocationKind))
                  (case relocation-entry
                    [(relocation-entry offset type symbol-index value)
                     (if (not (= type 2))
                         (left #"Unknown relocation entry type")
                     (if (not (= value (- 0 4)))
                         (left (bytes-append
                                 (varargs list
                                   #"Bad relocation value for pc32 relocation: "
                                   (integer->decimal-bytes value))))
                     (case (list-ref symbols symbol-index)
                       [(nothing)
                        (left (bytes-append (varargs list
                          #"Bad symbol index: "
                          (integer->decimal-bytes symbol-index)
                          #", list size: "
                          (integer->decimal-bytes (length symbols)))))]
                       [(just parsed-entry)
                        (match-define name
                          (case parsed-entry
                            [(section-symbol-entry name) name]
                            [(undefined-symbol-entry name) name]
                            [(text-symbol-entry name _) name]
                            [(const-symbol-entry name _) name]))
                        (right (relocation (elf-pc32-relocation) offset name))])))]))
                relocations))])])]))



(define (find-named-section-header [e : ElfFile] [name : Bytes]) : (Either Bytes SectionHeader)
  (match-define (elf-file sections section-name-index raw-contents) e)
  (case (list-ref sections section-name-index)
    [(nothing) (left #"Not enough sections for section name index")]
    [(just (section-header _ _ _ _ name-section-offset _ _ _ _ _))
     (case (findf
             (lambda ([v : SectionHeader])
               (let ([start (+ name-section-offset (section-header-name-offset v))])
                 (bytes=?
                   (subbytes raw-contents start (+ start (bytes-length name)))
                   name)))
             sections)
       [(nothing)
        (left (bytes-append (varargs list #"No section for name: " name)))]
       [(just v)
        (right v)])]))
