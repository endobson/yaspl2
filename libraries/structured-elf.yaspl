#:module (structured-elf)
#:import {
  (aligned-bytes)
  (bytes)
  (either)
  (formats elf)
  (list)
  (maybe)
  (numbers)
  (prim)
  (structured-native-code)
  (tuples)
}
(export
  (#:types ElfRelocationKind)
  (#:values
     elf-pc32-relocation
     abstract-relocation->elf-relocation
     parse-elf parsed-elf-text-section)
  (#:patterns elf-pc32-relocation))
(types
  (define-type ParsedElf
    (parsed-elf
      [text-section : (ProgramSection ElfRelocationKind)]))
  (define-type ElfRelocationKind
    (elf-pc32-relocation)))

(define (abstract-relocation->elf-relocation [r : AbstractRelocationKind])
  : ElfRelocationKind
  (case r
    [(branch-relocation) (elf-pc32-relocation)]
    [(call-relocation) (elf-pc32-relocation)]
    [(load-relocation) (elf-pc32-relocation)]
    [(address-relocation) (elf-pc32-relocation)]))

(define (parse-elf [elf : ElfFile]) : (Either Bytes ParsedElf)
  (case (elf-file->text-contents elf)
    [(left v) (left v)]
    [(right text-contents)
     (case (elf-file->symbols elf)
       [(left v) (left v)]
       [(right (tuple2 local-symbols global-symbols))
        (case (elf-file->relocations elf)
          [(left v) (left v)]
          [(right relocations)
           (right
             (parsed-elf
               (program-section
                 (aligned-bytes text-contents 1)
                 relocations
                 global-symbols
                 local-symbols)))])])]))

(define (elf-file->text-contents [e : ElfFile]) : (Either Bytes Bytes)
  (match-define raw-contents (elf-file-raw-contents e))
  (case (find-named-section-header e #".text")
    [(left v) (left v)]
    [(right text-section-header)
     (right
       (subbytes raw-contents
                 (section-header-section-offset text-section-header)
                 (+ (section-header-section-offset text-section-header)
                    (section-header-section-size text-section-header))))]))


(define (elf-file->symbols [e : ElfFile])
  : (Either Bytes (Tuple2 (List DefinedSymbol) (List DefinedSymbol)))
  (case (find-named-section-header e #".symtab")
    [(left v) (left v)]
    [(right symtab-section-header)
     (case (find-named-section-header e #".strtab")
       [(left v) (left v)]
        [(right strtab-section-header)
         (match-define raw-contents (elf-file-raw-contents e))
         (case (parse-elf-symbol-table symtab-section-header raw-contents)
           [(left v) (left v)]
           [(right symbol-table-entries)
            ;; TODO actually figure out what the right symbols are
            (match-define text-symbols (drop 4 symbol-table-entries))
            (match-define defined-text-symbols
              (map
                (lambda ([s : SymbolTableEntry])
                  (case s
                    [(symbol-table-entry name-offset value size)
                     (defined-symbol
                       (read-null-terminated-bytes
                         raw-contents
                         (+ (section-header-section-offset strtab-section-header)
                            name-offset))
                       value)]))
                text-symbols))
            (match-define num-local-symbols (- (section-header-section-info symtab-section-header) 4))
            (right (tuple2 (take num-local-symbols defined-text-symbols)
                           (drop num-local-symbols defined-text-symbols)))])])]))

(define (elf-file->relocations [e : ElfFile])
  : (Either Bytes (List (Relocation ElfRelocationKind)))
  (case (find-named-section-header e #".rela.text")
    [(left v) (left v)]
    [(right rela-section-header)
     (case (find-named-section-header e #".strtab")
       [(left v) (left v)]
        [(right strtab-section-header)
         (match-define raw-contents (elf-file-raw-contents e))
         (case (parse-elf-relocations rela-section-header raw-contents)
           [(left v) (left v)]
           [(right relocations)
            (extract-rights
              (map
                (lambda ([relocation-entry : RelocationEntry])
                  : (Either Bytes (Relocation ElfRelocationKind))
                  (case relocation-entry
                    [(relocation-entry offset type symbol-offset value)
                     (if (not (= type 2))
                         (left #"Unknown relocation entry type")
                     (if (not (= value (- 0 4)))
                         (left (bytes-append
                                 (varargs list
                                   #"Bad relocation value for pc32 relocation: "
                                   (integer->decimal-bytes value))))
                     (right
                       (relocation
                         (elf-pc32-relocation)
                         offset
                         (read-null-terminated-bytes
                            raw-contents
                            (+ (section-header-section-offset strtab-section-header)
                               symbol-offset))))))]))
                relocations))])])]))



(define (find-named-section-header [e : ElfFile] [name : Bytes]) : (Either Bytes SectionHeader)
  (match-define (elf-file sections section-name-index raw-contents) e)
  (case (list-ref sections section-name-index)
    [(nothing) (left #"Not enough sections for section name index")]
    [(just (section-header _ _ _ _ name-section-offset _ _ _ _ _))
     (case (findf
             (lambda ([v : SectionHeader])
               (let ([start (+ name-section-offset (section-header-name-offset v))])
                 (bytes=?
                   (subbytes raw-contents start (+ start (bytes-length name)))
                   name)))
             sections)
       [(nothing)
        (left (bytes-append (varargs list #"No section for name: " name)))]
       [(just v)
        (right v)])]))
