(module mach-o-writer2
  (import
    (prim
      #:types (Bytes S64 InputPort OutputPort Array Void)
      #:values (= + close-output-port array-length array-ref open-output-file < void open-input-file
                bytes-length - remainder *)
      #:patterns ())
    (io write-line write-all-bytes read-all-bytes)
    (bytes bytes make-null-terminated bytes-append bytes=? sum)
    (join-list jl->list empty-jl list->jl map-jl concat-map-jl single-jl)
    (list
      #:types (List)
      #:values (empty cons map reverse list)
      #:patterns (cons empty))
    (x86-64-stack-machine
      #:types (AssemblyFragment BasicBlock Instruction)
      #:values (write-fragments convert-objects instruction->mc-command)
      #:patterns (function-fragment bytes-fragment address-fragment basic-block mc-bytes mc-jump
                  mcj-jb mcj-je mcj-jne mcj-jnz mc-leaq/rel))
    (library-compiler add-known-functions extract-modules compile-main-module)
    (dict
      #:types (Dict)
      #:values (make-dict)
      #:patterns ())
    (prim-implementation prim-static-signature prim-signature prim-implementation)
    (mach-o-writer write-mach-o-header2 mach-o-header lc-load-segment64 load-segment64 section64
                   lc-version-min-macosx version-min symbol-table lc-symbol-table
                   lc-dynamic-symbol-table dynamic-symbol-table)
    (source-language
      #:types ()
      #:values (parse-module)
      #:patterns ())
    (sexp-parser
      #:types ()
      #:values (parse-sexps)
      #:patterns ())
    (either
      #:types (Either)
      #:values (left right)
      #:patterns (left right)))
  (export
    #:types ()
    #:values (write-mach-o)
    #:patterns ())
  (types)

  (define (a) (array->list [offset : S64] [arr : (Array a)]) : (List a)
    (if (= offset (array-length arr))
        (empty)
        (cons (array-ref arr offset) (array->list (+ 1 offset) arr))))

  (define (read-module-files [modules : (List Bytes)]) : (List Bytes)
    (case modules
      [(empty) (empty)]
      [(cons mod modules)
       (cons (read-all-bytes (open-input-file (make-null-terminated mod)))
             (read-module-files modules))]))

  (define (assemble-text-segment [fragments : (List AssemblyFragment)]) : Bytes
    (bytes-append
      (jl->list
        (concat-map-jl
          (lambda ([fragment : AssemblyFragment])
            (case fragment
              [(function-fragment name blocks)
               (concat-map-jl
                 (lambda ([bb : BasicBlock])
                   (case bb
                     [(basic-block block-name instructions)
                      (map-jl
                        (lambda ([inst : Instruction])
                          (case (instruction->mc-command inst)
                            [(mc-bytes bytes) bytes]
                            [(mc-jump (mcj-jb) _) (varargs bytes #x0F #x82 0 0 0 0)]
                            [(mc-jump (mcj-je) _) (varargs bytes #x0F #x84 0 0 0 0)]
                            [(mc-jump (mcj-jne) _) (varargs bytes #x0F #x85 0 0 0 0)]
                            [(mc-jump (mcj-jnz) _) (varargs bytes #x0F #x85 0 0 0 0)]
                            [_ #""]))
                        instructions)]))
                 (list->jl blocks))]
              [_ (empty-jl)]))
          (list->jl fragments)))))

  (define (count-text-segment-relocations [fragments : (List AssemblyFragment)]) : S64
    (sum
      (map
        (lambda ([fragment : AssemblyFragment])
          (case fragment
            [(function-fragment name blocks)
             (sum
               (map
                 (lambda ([bb : BasicBlock])
                   (case bb
                     [(basic-block block-name instructions)
                      (sum
                        (jl->list
                          (map-jl
                            (lambda ([inst : Instruction])
                              (case (instruction->mc-command inst)
                                [(mc-bytes bytes) 0]
                                [(mc-jump _ _) 1]
                                [(mc-leaq/rel _ _ _) 1]))
                            instructions)))]))
                 blocks))]
            [_ 0]))
        fragments)))


  (define (assemble-const-segment [fragments : (List AssemblyFragment)]) : Bytes
    (bytes-append
      (jl->list
        (concat-map-jl
          (lambda ([fragment : AssemblyFragment])
            (case fragment
              [(address-fragment name value)
               (single-jl (varargs bytes 0 0 0 0 0 0 0 0))]
              [(bytes-fragment name value)
               ;; TODO Make the bytes actual value go here
               (empty-jl)]
              [_ (empty-jl)]))
          (list->jl fragments)))))

  (define (count-const-segment-relocations [fragments : (List AssemblyFragment)]) : S64
    (sum
      (map
        (lambda ([fragment : AssemblyFragment])
          (case fragment
            [(address-fragment name value) 1]
            [(bytes-fragment name value) 0]
            [(function-fragment _ _) 0]))
        fragments)))


  (define (round-up [v : S64] [mod : S64]) : S64
    (let ([rem (remainder v mod)])
      (if (= 0 rem)
          v
          (+ (- v rem) mod))))




  (define (write-mach-o [output-file-name : Bytes] [input-file-names : Bytes]) : (Either Bytes Void)
    (case (parse-sexps (bytes-append (read-module-files input-file-names)))
          [(left v) (left v)]
          [(right sexps)
           (case (extract-modules (map parse-module sexps))
             [(left v) (left v)]
             [(right modules)
              (case (reverse modules)
                [(empty) (left #"No provided modules")]
                [(cons main-module other-modules)
                 (case (compile-main-module
                         main-module
                         (reverse other-modules)
                         (cons (prim-static-signature) (empty))
                         (cons (prim-signature) (empty))
                         (add-known-functions (prim-implementation) (make-dict bytes=?)))
                   [(left v) (left v)]
                   [(right objects)
                    (let ([fragments (convert-objects objects)])
                      (let ([text-segment-bytes (assemble-text-segment fragments)])
                        (let ([text-segment-num-relocations (count-text-segment-relocations fragments)])
                          (let ([const-segment-bytes (assemble-const-segment fragments)])
                            (let ([const-segment-num-relocations (count-const-segment-relocations fragments)])
                              (let ([segment-size (+ (bytes-length text-segment-bytes)
                                                     (bytes-length const-segment-bytes))])
                                (let ([reloc-base (+ 384 (round-up segment-size 4))])
                                  (let ([output (open-output-file (make-null-terminated output-file-name))])
                                    (begin
                                      (write-mach-o-header2
                                        (mach-o-header
                                          (varargs list
                                            (lc-load-segment64
                                              (load-segment64 #""
                                                #x0000000000000000
                                                segment-size
                                                384
                                                segment-size
                                                #x07
                                                #x07
                                                0
                                                (varargs list
                                                  (section64 #"__TEXT" #"__text"
                                                             #x00
                                                             (bytes-length text-segment-bytes)
                                                             384
                                                             reloc-base
                                                             text-segment-num-relocations
                                                             #x80000400)
                                                  (section64 #"__TEXT" #"__const"
                                                             (bytes-length text-segment-bytes)
                                                             (bytes-length const-segment-bytes)
                                                             (+ 384 (bytes-length text-segment-bytes))
                                                             (+ reloc-base
                                                                (* 8 text-segment-num-relocations))
                                                             const-segment-num-relocations
                                                             0))))
                                            (lc-version-min-macosx
                                              (version-min 10 11 0 0 0 0))
                                            (lc-symbol-table
                                              (symbol-table
                                                560
                                                10
                                                720
                                                220))
                                            (lc-dynamic-symbol-table
                                              (dynamic-symbol-table 0 9 9 1))))
                                        output)
                                      (write-all-bytes text-segment-bytes output)
                                      (write-all-bytes const-segment-bytes output)
                                      (close-output-port output)
                                      (right (void)))))))))))])])])]))

  (define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : S64
    (if (< (array-length args) 2)
        (begin
          (write-line #"No output file name supplied" stderr)
          1)
        (case (write-mach-o (array-ref args 1) (array->list 2 args))
          [(left v)
           (begin
             (write-line v stderr)
             1)]
          [(right _)
           0]))))
