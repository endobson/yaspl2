(module mach-o-writer2
  (import
    (prim
      #:types (Bytes S64 InputPort OutputPort Array Void U32 Boolean)
      #:values (= + close-output-port array-length array-ref open-output-file < void open-input-file
                bytes-length - remainder * make-bytes u32 bitwise-ior panic)
      #:patterns ())
    (io write-line write-all-bytes read-all-bytes)
    (bytes bytes make-null-terminated bytes-append bytes=? sum bytes<
           bytes-set!/quad-le
           bytes-set!/octo-le)
    (set make-set set-add-all set->list set-remove-all)
    (join-list jl->list cons-jl empty-jl list->jl map-jl concat-map-jl single-jl join-list)
    (list
      #:types (List)
      #:values (empty cons map reverse list length sort find-index append)
      #:patterns (cons empty))
    (x86-64-stack-machine
      #:types (AssemblyFragment BasicBlock Instruction)
      #:values (write-fragments convert-objects instruction->mc-command)
      #:patterns (function-fragment bytes-fragment address-fragment basic-block mc-bytes mc-jump
                  mcj-jb mcj-je mcj-jne mcj-jnz mcj-jmp mcj-call mc-leaq/rel))
    (library-compiler add-known-functions extract-modules compile-main-module)
    (dict
      #:types (Dict)
      #:values (make-dict)
      #:patterns ())
    (prim-implementation prim-static-signature prim-signature prim-implementation)
    (mach-o-writer write-mach-o-header2 mach-o-header lc-load-segment64 load-segment64 section64
                   lc-version-min-macosx version-min symbol-table lc-symbol-table
                   lc-dynamic-symbol-table dynamic-symbol-table lc-data-in-code linkedit-data)
    (source-language
      #:types ()
      #:values (parse-module)
      #:patterns ())
    (sexp-parser
      #:types ()
      #:values (parse-sexps)
      #:patterns ())
    (maybe
      #:types (Maybe)
      #:values (just nothing)
      #:patterns (just nothing))
    (tuples
      #:types (Tuple2)
      #:values (tuple2)
      #:patterns (tuple2))
    (either
      #:types (Either)
      #:values (left right)
      #:patterns (left right)))
  (export
    #:types ()
    #:values (write-mach-o)
    #:patterns ())
  (types
    (define-type TextSegmentRelocation
      (text-segment-relocation [offset S64] [symbol Bytes])
      (text-segment-relocation/2 [offset S64] [symbol Bytes]))
    (define-type ConstSegmentRelocation
      (const-segment-relocation [offset S64] [symbol Bytes] [value Bytes]))
    (define-type Symbol
      (defined-symbol [sym DefinedSymbol])
      (undefined-symbol [name Bytes]))
    (define-type DefinedSymbol
      (text-symbol [name Bytes] [offset Bytes])
      (const-symbol [name Bytes] [offset Bytes])))

  (define (symbol-name [v : Symbol]) : Bytes
    (case v
      [(defined-symbol sym) (defined-symbol-name sym)]
      [(undefined-symbol name) name]))

  (define (defined-symbol-name [v : DefinedSymbol]) : Bytes
    (case v
      [(text-symbol name offset) name]
      [(const-symbol name offset) name]))

  (define (a) (array->list [offset : S64] [arr : (Array a)]) : (List a)
    (if (= offset (array-length arr))
        (empty)
        (cons (array-ref arr offset) (array->list (+ 1 offset) arr))))

  (define (read-module-files [modules : (List Bytes)]) : (List Bytes)
    (case modules
      [(empty) (empty)]
      [(cons mod modules)
       (cons (read-all-bytes (open-input-file (make-null-terminated mod)))
             (read-module-files modules))]))

  (define (assemble-text-segment [fragments : (List AssemblyFragment)]) : Bytes
    (bytes-append
      (jl->list
        (concat-map-jl
          (lambda ([fragment : AssemblyFragment])
            (case fragment
              [(function-fragment name blocks)
               (concat-map-jl
                 (lambda ([bb : BasicBlock])
                   (case bb
                     [(basic-block block-name instructions)
                      (map-jl
                        (lambda ([inst : Instruction])
                          (case (instruction->mc-command inst)
                            [(mc-bytes bytes) bytes]
                            [(mc-jump (mcj-jb) _) (varargs bytes #x0F #x82 0 0 0 0)]
                            [(mc-jump (mcj-je) _) (varargs bytes #x0F #x84 0 0 0 0)]
                            [(mc-jump (mcj-jne) _) (varargs bytes #x0F #x85 0 0 0 0)]
                            [(mc-jump (mcj-jnz) _) (varargs bytes #x0F #x85 0 0 0 0)]
                            [(mc-jump (mcj-jmp) _) (varargs bytes #xE9 0 0 0 0)]
                            [(mc-jump (mcj-call) _) (varargs bytes #xE8 0 0 0 0)]
                            [(mc-leaq/rel _ _ _) (varargs bytes #x48 #x8D #x05 0 0 0 0)]))
                        instructions)]))
                 (list->jl blocks))]
              [_ (empty-jl)]))
          (list->jl fragments)))))

  (define (compute-text-segment-relocations [fragments : (List AssemblyFragment)] [offset : S64])
    : (List TextSegmentRelocation)
    (case fragments
      [(empty) (empty)]
      [(cons (function-fragment _ blocks) fragments)
       (compute-text-segment-relocations/blocks blocks fragments offset)]
      [(cons _ fragments)
       (compute-text-segment-relocations fragments offset)]))

  (define (compute-text-segment-relocations/blocks
            [blocks : (List BasicBlock)]
            [fragments : (List AssemblyFragment)] [offset : S64]) : (List TextSegmentRelocation)
    (case blocks
      [(empty) (compute-text-segment-relocations fragments offset)]
      [(cons (basic-block _ instructions) blocks)
       (compute-text-segment-relocations/instructions
         (jl->list instructions) blocks (empty) fragments offset)]))

  (define (compute-text-segment-relocations/instructions
            [instructions : (List Instruction)]
            [blocks : (List BasicBlock)]
            [acc : (List TextSegmentRelocation)]
            [fragments : (List AssemblyFragment)] [offset : S64]) : (List TextSegmentRelocation)
    (case instructions
      [(empty) (append acc (compute-text-segment-relocations/blocks blocks fragments offset))]
      [(cons inst instructions)
       (case (instruction->mc-command inst)
         [(mc-bytes bytes)
          (compute-text-segment-relocations/instructions
            instructions blocks acc fragments (+ (bytes-length bytes) offset))]
         [(mc-jump (mcj-jmp) name)
          (compute-text-segment-relocations/instructions
            instructions blocks (cons (text-segment-relocation (+ 1 offset) name) acc) fragments (+ 5 offset))]
         [(mc-jump (mcj-call) name)
          (compute-text-segment-relocations/instructions
            instructions blocks (cons (text-segment-relocation (+ 1 offset) name) acc) fragments (+ 5 offset))]
         [(mc-jump _ name)
          (compute-text-segment-relocations/instructions
            instructions blocks (cons (text-segment-relocation (+ 2 offset) name) acc) fragments (+ 6 offset))]
         ;; TODO actually implement this
         [(mc-leaq/rel name _ _)
          (compute-text-segment-relocations/instructions
            instructions blocks (cons (text-segment-relocation/2 (+ 3 offset) name) acc) fragments
            (+ 7 offset))])]))


  (define (instruction-length [inst : Instruction]) : S64
    (case (instruction->mc-command inst)
      [(mc-bytes bytes) (bytes-length bytes)]
      [(mc-jump (mcj-jmp) name) 5]
      [(mc-jump (mcj-call) name) 5]
      [(mc-jump _ name) 6]
      [(mc-leaq/rel name _ _) 7]))

  (define (compute-const-segment-relocations [fragments : (List AssemblyFragment)])
    : (List ConstSegmentRelocation)
    (compute-const-segment-relocations-helper
      0
      (jl->list
        (concat-map-jl
          (lambda ([fragment : AssemblyFragment])
            (case fragment
              [(address-fragment name value)
               (varargs join-list (right (tuple2 name value)) (left 8))]
              [_ (empty-jl)]))
          (list->jl fragments)))))

  (define (compute-const-segment-relocations-helper [offset : S64]
                                                    [pieces : (List (Either S64 (Tuple2 Bytes Bytes)))])
    : (List ConstSegmentRelocation)
    (case pieces
      [(empty) (empty)]
      [(cons (left v) pieces)
       (compute-const-segment-relocations-helper (+ v offset) pieces)]
      [(cons (right (tuple2 name value)) pieces)
       (cons (const-segment-relocation offset name value)
             (compute-const-segment-relocations-helper offset pieces))]))

  (define (assemble-const-segment [fragments : (List AssemblyFragment)]) : Bytes
    (bytes-append
      (jl->list
        (concat-map-jl
          (lambda ([fragment : AssemblyFragment])
            (case fragment
              [(address-fragment name value)
               (single-jl (varargs bytes 0 0 0 0 0 0 0 0))]
              [(bytes-fragment name value)
               ;; TODO Make the bytes actual value go here
               (empty-jl)]
              [_ (empty-jl)]))
          (list->jl fragments)))))

  (define (collect-defined-symbols
            [fragments : (List AssemblyFragment)]
            [text-offset : S64]
            [const-offset : S64]
            [acc : (List DefinedSymbol)])
    : (List DefinedSymbol)
    (case fragments
      [(empty) (reverse acc)]
      [(cons fragment fragments)
       (case fragment
         [(function-fragment name blocks)
          (collect-defined-symbols/blocks blocks fragments text-offset const-offset acc)]
         [(address-fragment name value)
          (collect-defined-symbols fragments text-offset (+ const-offset 8)
                                   (cons (const-symbol name const-offset) acc))]
         [(bytes-fragment name value)
          (collect-defined-symbols fragments text-offset (+ const-offset (bytes-length value))
                                   (cons (const-symbol name const-offset) acc))])]))

  (define (collect-defined-symbols/blocks
            [blocks : (List BasicBlock)]
            [fragments : (List AssemblyFragment)]
            [text-offset : S64]
            [const-offset : S64]
            [acc : (List DefinedSymbol)])
    : (List DefinedSymbol)
    (case blocks
      [(empty)
       (collect-defined-symbols fragments text-offset const-offset acc)]
      [(cons (basic-block block-name instructions) blocks)
       (collect-defined-symbols/blocks
         blocks fragments
         (+ text-offset (sum (map instruction-length (jl->list instructions))))
         const-offset
         (cons (text-symbol block-name text-offset) acc))]))


  (define (collect-instruction-symbols [fragments : (List AssemblyFragment)]) : (List Bytes)
    (jl->list
      (concat-map-jl
        (lambda ([fragment : AssemblyFragment])
          (case fragment
            [(function-fragment name blocks)
             (concat-map-jl
               (lambda ([bb : BasicBlock])
                 (case bb
                   [(basic-block block-name instructions)
                    (concat-map-jl
                      (lambda ([inst : Instruction])
                        (case (instruction->mc-command inst)
                          [(mc-bytes bytes) (empty-jl)]
                          [(mc-jump _ label) (single-jl label)]
                          [(mc-leaq/rel label _ _) (single-jl label)]))
                      instructions)]))
               (list->jl blocks))]
            [(address-fragment name value)
             (empty-jl)]
            [(bytes-fragment name value)
             (empty-jl)]))
        (list->jl fragments))))

  ;; TODO simplify this now that just the sorted symbols are needed
  (define (collect-symbols [fragments : (List AssemblyFragment)] [text-size : S64]) : (List Bytes)
    (let ([defined-symbols (collect-defined-symbols fragments 0 text-size (empty))])
      (let ([undefined-symbols
              (map undefined-symbol
                   (sort
                     (set->list
                       (set-remove-all
                         (set-add-all
                           (make-set bytes=?)
                           (collect-instruction-symbols fragments))
                         (map defined-symbol-name defined-symbols)))
                     bytes<))])
        (append
          (map
            defined-symbol
            (sort
              defined-symbols
              (lambda ([x : DefinedSymbol] [y : DefinedSymbol])
                (bytes< (defined-symbol-name x) (defined-symbol-name y)))))
          undefined-symbols))))


  (define (round-up [v : S64] [mod : S64]) : S64
    (let ([rem (remainder v mod)])
      (if (= 0 rem)
          v
          (+ (- v rem) mod))))

  (define (write-quad-le [v : U32] [output : OutputPort]) : Void
    (let ([bytes (make-bytes 4)])
      (begin
        (bytes-set!/quad-le bytes 0 v)
        (write-all-bytes bytes output))))

  (define (write-octo-le [v : S64] [output : OutputPort]) : Void
    (let ([bytes (make-bytes 8)])
      (begin
        (bytes-set!/octo-le bytes 0 v)
        (write-all-bytes bytes output))))



  (define (write-all-symbols [symbols : (List Bytes)] [output : OutputPort]) : Void
    (case symbols
      [(empty) (void)]
      [(cons symbol symbols)
       (begin
         (write-all-bytes symbol output)
         (write-all-bytes (make-bytes 1) output)
         (write-all-symbols symbols output))]))

  (define (write-text-segment-relocations
            [relocations : (List TextSegmentRelocation)]
            [symbols : (List Bytes)]
            [output : OutputPort]) : Void
    (case relocations
      [(empty) (void)]
      [(cons (text-segment-relocation offset symbol) relocations)
       (begin
         (write-quad-le offset output)
         (case (find-index (lambda ([x : Bytes]) (bytes=? symbol x))
                           symbols)
           [(nothing)
            (panic #"Bad symbol")]
           [(just index)
            (write-quad-le (bitwise-ior index #x2D000000) output)])
         (write-text-segment-relocations relocations symbols output))]
      [(cons (text-segment-relocation/2 offset symbol) relocations)
       (begin
         (write-quad-le offset output)
         (case (find-index (lambda ([x : Bytes]) (bytes=? symbol x))
                           symbols)
           [(nothing)
            (panic #"Bad symbol")]
           [(just index)
            (write-quad-le (bitwise-ior index #x1D000000) output)])
         (write-text-segment-relocations relocations symbols output))]))

  (define (write-const-segment-relocations
            [relocations : (List ConstSegmentRelocation)]
            [symbols : (List Bytes)]
            [output : OutputPort]) : Void
    (case relocations
      [(empty) (void)]
      [(cons (const-segment-relocation offset symbol value) relocations)
       (begin
         (write-quad-le offset output)
         (case (find-index (lambda ([x : Bytes]) (bytes=? value x))
                           symbols)
           [(nothing)
            (panic #"Bad symbol")]
           [(just index)
            (write-quad-le (bitwise-ior index #x0e000000) output)])
         (write-const-segment-relocations relocations symbols output))]))

  (define (write-symbol-table
            [symbols : (List Symbol)]
            [sym-offset : S64]
            [output : OutputPort]) : Void
    (case symbols
      [(empty) (void)]
      [(cons symbol symbols)
       (begin
         (write-quad-le sym-offset output)
         (case symbol
           [(undefined-symbol _)
            (begin
              (write-quad-le #x00000001 output)
              (write-octo-le #x0000000000000000 output))]
           [(defined-symbol (text-symbol _ offset))
            (begin
              (write-quad-le #x0020010f output)
              (write-octo-le offset output))]
           [(defined-symbol (const-symbol _ offset))
            (begin
              (write-quad-le #x0020020f output)
              (write-octo-le offset output))])
         (write-symbol-table symbols (+ (+ (bytes-length (symbol-name symbol)) 1) sym-offset) output))]))



  (define (write-mach-o [output-file-name : Bytes] [input-file-names : Bytes]) : (Either Bytes Void)
    (case (parse-sexps (bytes-append (read-module-files input-file-names)))
          [(left v) (left v)]
          [(right sexps)
           (case (extract-modules (map parse-module sexps))
             [(left v) (left v)]
             [(right modules)
              (case (reverse modules)
                [(empty) (left #"No provided modules")]
                [(cons main-module other-modules)
                 (case (compile-main-module
                         main-module
                         (reverse other-modules)
                         (cons (prim-static-signature) (empty))
                         (cons (prim-signature) (empty))
                         (add-known-functions (prim-implementation) (make-dict bytes=?)))
                   [(left v) (left v)]
                   [(right objects)
                    (let ([fragments (convert-objects objects)])
                      (let ([text-segment-bytes (assemble-text-segment fragments)])
                        (let ([text-segment-relocations (compute-text-segment-relocations fragments 0)])
                          (let ([text-segment-num-relocations (length text-segment-relocations)])
                            (let ([const-segment-bytes (assemble-const-segment fragments)])
                              (let ([const-segment-relocations
                                      (compute-const-segment-relocations fragments)])
                                (let ([const-segment-num-relocations (length const-segment-relocations)])
                                  (let ([segment-size (+ (bytes-length text-segment-bytes)
                                                         (bytes-length const-segment-bytes))])
                                    (let ([reloc-base (+ 352 (round-up segment-size 8))])
                                      (let ([symbols (collect-symbols fragments (bytes-length
                                                                                  text-segment-bytes))])
                                        (let ([output (open-output-file (make-null-terminated output-file-name))])
                                          (begin
                                            (write-mach-o-header2
                                              (mach-o-header
                                                (varargs list
                                                  (lc-load-segment64
                                                    (load-segment64 #""
                                                      #x0000000000000000
                                                      segment-size
                                                      352
                                                      segment-size
                                                      #x07
                                                      #x07
                                                      0
                                                      (varargs list
                                                        (section64 #"__TEXT" #"__text"
                                                                   #x00
                                                                   (bytes-length text-segment-bytes)
                                                                   352
                                                                   reloc-base
                                                                   text-segment-num-relocations
                                                                   #x80000400)
                                                        (section64 #"__TEXT" #"__const"
                                                                   (bytes-length text-segment-bytes)
                                                                   (bytes-length const-segment-bytes)
                                                                   (+ 352 (bytes-length text-segment-bytes))
                                                                   (+ reloc-base
                                                                      (* 8 text-segment-num-relocations))
                                                                   const-segment-num-relocations
                                                                   0))))
                                                  (lc-symbol-table
                                                    (symbol-table
                                                      (+ reloc-base
                                                         (* 8 (+ text-segment-num-relocations
                                                                 const-segment-num-relocations)))
                                                      (length symbols)
                                                      (+ (+ reloc-base
                                                            (* 8 (+ text-segment-num-relocations
                                                                    const-segment-num-relocations)))
                                                         (* (length symbols) #x10))
                                                      (round-up
                                                        (+ (+ 2 (length symbols))
                                                           (sum (map bytes-length
                                                                     (map symbol-name symbols))))
                                                        8)))
                                                  (lc-version-min-macosx
                                                    (version-min 10 11 0 10 11 0))
                                                  (lc-data-in-code
                                                    (linkedit-data
                                                      (+ reloc-base
                                                         (* 8 (+ text-segment-num-relocations
                                                                 const-segment-num-relocations)))
                                                      0))))
                                              output)
                                            (write-all-bytes (make-bytes 32) output)
                                            (write-all-bytes text-segment-bytes output)
                                            (write-all-bytes const-segment-bytes output)
                                            (write-all-bytes
                                              (make-bytes
                                                (-
                                                  (round-up (+ (bytes-length text-segment-bytes)
                                                               (bytes-length const-segment-bytes))
                                                            8)
                                                  (+ (bytes-length text-segment-bytes)
                                                     (bytes-length const-segment-bytes)))) output)
                                            (write-text-segment-relocations
                                              text-segment-relocations (map symbol-name symbols) output)
                                            (write-const-segment-relocations
                                              const-segment-relocations (map symbol-name symbols) output)
                                            (write-symbol-table symbols 2 output)
                                            (write-all-bytes (varargs bytes 32 0) output)
                                            (write-all-symbols (map symbol-name symbols) output)
                                            (write-all-bytes
                                              (make-bytes
                                                (-
                                                  (round-up
                                                    (+ (+ 2 (length symbols))
                                                       (sum (map bytes-length
                                                                 (map symbol-name symbols))))
                                                    8)
                                                  (+ (+ 2 (length symbols))
                                                     (sum (map bytes-length
                                                               (map symbol-name symbols))))))
                                              output)
                                            (close-output-port output)
                                            (right (void))))))))))))))])])])]))

  (define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : S64
    (if (< (array-length args) 2)
        (begin
          (write-line #"No output file name supplied" stderr)
          1)
        (case (write-mach-o (array-ref args 1) (array->list 2 args))
          [(left v)
           (begin
             (write-line v stderr)
             1)]
          [(right _)
           0]))))
