(module intermediate-language
  (import
    (prim
      #:types (Bytes Byte Boolean Array)
      #:values ()
      #:patterns ())
    (list
      #:types (List)
      #:values ()
      #:patterns ())
    (source-language
      #:types (Pattern Imports TypeDefinition PreType)
      #:values ()
      #:patterns ()))
  (export Module imodule)
  (types
    ;; TODO support importing patterns correctly
    (define-type Module
      (imodule [name Bytes]
               [imports (List Imports)]
               [types (List TypeDefinition)]
               [definitions (List FunctionDefinition)]))
    (define-type FunctionDefinition
      (function-definition
        [name Bytes] [type PreType] [args (List Bytes)] [free-vars (List Bytes)] [body Expression]))
    (define-type Expression
      (byte-literal [v Byte])
      (bytes-literal [v Bytes])
      (boolean-literal [v Boolean])
      (var-expr [v Bytes])
      (if-expr [cond Expression] [true Expression] [false Expression])
      (begin-expr [first-expr Expression] [exprs (List Expression)])
      (create-closure-expr [op Expression] [args (List Expression)])
      (call-closure-expr [op Expression] [args (List Expression)])
      (varargs-call-closure-expr [op Expression] [args (List Expression)])
      (let-expr [name Bytes] [expr Expression] [body Expression])
      (case-expr [expr Expression] [clauses (List CaseClause)]))

    (define-type CaseClause
      (case-clause [pattern Pattern] [expr Expression]))

    (define-type Pattern
      (bytes-pattern [v Bytes])
      (byte-pattern [v Byte])
      (variable-pattern [v Bytes])
      (ignore-pattern)
      (abstraction-pattern [name Bytes] [patterns (List Pattern)]))))
