#:module (core-language lexer)
#:import {
  (byte-escapes)
  (bytes)
  (data source-location)
  (either)
  (lexer)
  (list)
  (numbers)
  (prim)
}
(export
  (#:types Token Result Lexer)
  (#:values make-core-lexer run-lexer)
  (#:patterns end-of-input bad-input lex-result
              symbol-token decimal-number-token hexadecimal-number-token
              left-paren-token right-paren-token
              left-brace-token right-brace-token
              left-bracket-token right-bracket-token comment-token
              bytes-token
              keyword-token))
(types
  (define-type Token
    (left-paren-token)
    (right-paren-token)
    (left-bracket-token)
    (right-bracket-token)
    (left-brace-token)
    (right-brace-token)

    (less-than-token)
    (less-than-equal-token)
    (greater-than-token)
    (greater-than-equal-token)
    (equal-equal-token)
    (not-equal-token)

    (assignment-token)
    (pointer-assignment-token)

    (logical-and-token)
    (logical-or-token)
    (plus-token)
    (minus-token)
    (division-token)
    (multiplication-token)

    (comma-token)
    (bang-token)

    (pointer-field-access-token)
    (pointer-offset-token)

    (comment-token)
    (symbol-token [v : Bytes])
    (bytes-token [v : Bytes])
    (keyword-token [v : Bytes])
    (decimal-number-token [v : Bytes])
    (hexadecimal-number-token [v : Bytes])))


(define (token* [ctx : LexerContext] [start : Int] [end : Int] [t : Token])
  : (InnerResult Token)
  (lex-result/inner
    (source-span-annotated t (lexer-context-get-span ctx start end))
    end))

(define (symbol-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end
    (symbol-token (subbytes (lexer-context-bytes ctx) start end))))

(define (comment-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end (comment-token)))

;; Need to adjust for #: at begining
(define (keyword-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx (- start 2) end
    (keyword-token (subbytes (lexer-context-bytes ctx) start end))))

;; Need to adjust for #" at begining.
(define (bytes-token* [ctx : LexerContext] [v : Bytes] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx (- start 2) end (bytes-token v)))

(define (decimal-number-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end
    (decimal-number-token (subbytes (lexer-context-bytes ctx) start end))))

;; Need to adjust for #x at the begining
(define (hexadecimal-number-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx (- start 2) end
    (hexadecimal-number-token (subbytes (lexer-context-bytes ctx) start end))))

(define (left-paren-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end (left-paren-token)))

(define (right-paren-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end (right-paren-token)))

(define (left-bracket-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end (left-bracket-token)))

(define (right-bracket-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end (right-bracket-token)))

(define (left-brace-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end (left-brace-token)))

(define (right-brace-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end (right-brace-token)))

(define (less-than-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end (less-than-token)))

(define (less-than-equal-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end (less-than-equal-token)))

(define (greater-than-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end (greater-than-token)))

(define (greater-than-equal-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end (greater-than-equal-token)))

(define (equal-equal-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end (equal-equal-token)))

(define (not-equal-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end (not-equal-token)))

(define (plus-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end (plus-token)))

(define (minus-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end (plus-token)))

(define (multiplication-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end (multiplication-token)))

(define (division-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end (division-token)))

(define (comma-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end (comma-token)))

(define (bang-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end (bang-token)))

(define (assignment-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end (assignment-token)))

(define (logical-and-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end (logical-and-token)))

(define (pointer-field-access-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end (pointer-field-access-token)))

(define (pointer-offset-token* [ctx : LexerContext] [start : Int] [end : Int])
  : (InnerResult Token)
  (token* ctx start end (pointer-offset-token)))

;; Make this saner
(define (symbol-start-byte? [v : U8]) : Boolean
  (let ([valid #"                                                                 ABCDEFGHIJKLMNOPQRSTUVWXYZ      abcdefghijklmnopqrstuvwxyz     "])
    (let ([index (u8->s64 v)])
      (and (<= index 127)
           (not (= (u8->s64 (bytes-ref valid index)) 32))))))

;; Make this saner
(define (symbol-continue-byte? [v : U8]) : Boolean
  (let ([valid #"                                                0123456789       ABCDEFGHIJKLMNOPQRSTUVWXYZ    _ abcdefghijklmnopqrstuvwxyz     "])
    (let ([index (u8->s64 v)])
      (and (<= index 127)
           (not (= (u8->s64 (bytes-ref valid index)) 32))))))

(define (keyword-continue-byte? [v : U8]) : Boolean
  (or (letter? v)
      (underscore? v)))

(define (bytes-continue-byte? [v : U8]) : Boolean
  (let ([int (u8->s64 v)])
    (and (and (<= 32 int) (< int 127))
         (not (double-quote? v)))))

(define (decimal-start-byte? [v : U8]) : Boolean
  (digit? v))
(define (decimal-continue-byte? [v : U8]) : Boolean
  (digit? v))

(define (hexadecimal-byte? [v : U8]) : Boolean
  (or (digit? v)
      (let ([v (u8->s64 v)])
        (or (and (<= 65 v) (<= v 70))
            (and (<= 97 v) (<= v 102))))))

(define (letter? [v : U8]) : Boolean
  (let ([v (u8->s64 v)])
    (or (and (<= 97 v) (< v 123))
        (and (<= 65 v) (< v 91)))))

(define (newline? [v : U8]) : Boolean
  (= (u8->s64 v) 10))

(define (space? [v : U8]) : Boolean
  (= (u8->s64 v) 32))

(define (bang? [v : U8]) : Boolean
  (= (u8->s64 v) 33))

(define (double-quote? [v : U8]) : Boolean
  (= (u8->s64 v) 34))

(define (hash? [v : U8]) : Boolean
  (= (u8->s64 v) 35))

(define (ampersand? [v : U8]) : Boolean
  (= (u8->s64 v) 38))

(define (left-paren? [v : U8]) : Boolean
  (= (u8->s64 v) 40))

(define (right-paren? [v : U8]) : Boolean
  (= (u8->s64 v) 41))

(define (multiplication-sign? [v : U8]) : Boolean
  (= (u8->s64 v) 42))

(define (plus-sign? [v : U8]) : Boolean
  (= (u8->s64 v) 43))

(define (comma? [v : U8]) : Boolean
  (= (u8->s64 v) 44))

(define (minus-sign? [v : U8]) : Boolean
  (= (u8->s64 v) 45))

(define (period? [v : U8]) : Boolean
  (= (u8->s64 v) 46))

(define (forward-slash? [v : U8]) : Boolean
  (= (u8->s64 v) 47))

(define (colon? [v : U8]) : Boolean
  (= (u8->s64 v) 58))

(define (semi-colon? [v : U8]) : Boolean
  (= (u8->s64 v) 59))

(define (less-than? [v : U8]) : Boolean
  (= (u8->s64 v) 60))

(define (equals-sign? [v : U8]) : Boolean
  (= (u8->s64 v) 61))

(define (greater-than? [v : U8]) : Boolean
  (= (u8->s64 v) 62))

(define (left-bracket? [v : U8]) : Boolean
  (= (u8->s64 v) 91))

(define (back-slash? [v : U8]) : Boolean
  (= (u8->s64 v) 92))

(define (right-bracket? [v : U8]) : Boolean
  (= (u8->s64 v) 93))

(define (underscore? [v : U8]) : Boolean
  (= (u8->s64 v) 95))

(define (left-brace? [v : U8]) : Boolean
  (= (u8->s64 v) 123))

(define (right-brace? [v : U8]) : Boolean
  (= (u8->s64 v) 125))




(define (lex-symbol [ctx : LexerContext] [start : Int] [cur : Int]) : (InnerResult Token)
  (match-define bytes (lexer-context-bytes ctx))
  (cond
    [(= (bytes-length bytes) cur)
     (symbol-token* ctx start cur)]
    [(symbol-continue-byte? (bytes-ref bytes cur))
     (lex-symbol ctx start (+ 1 cur))]
    [else
     (symbol-token* ctx start cur)]))

(define (lex-after-hash [ctx : LexerContext] [pos : Int]) : (InnerResult Token)
  (match-define bytes (lexer-context-bytes ctx))
  (cond
    [(= (bytes-length bytes) pos)
     (bad-input/inner #"Input ended with hash" (lexer-context-get-span ctx (- pos 1) pos))]
    [else
     (match-define byte (bytes-ref bytes pos))
     (match-define next-pos (+ 1 pos))
     (cond
      [(colon? byte)
       (lex-keyword ctx next-pos next-pos)]
      [(double-quote? byte)
       (lex-bytes ctx next-pos next-pos)]
      [(= (u8->s64 byte) 120)
       (lex-hexadecimal ctx next-pos next-pos)]
      [else
       (bad-input/inner
         #"Unsupported character after hash"
         (lexer-context-get-span ctx (- pos 1) next-pos))])]))

(define (lex-after-equal [ctx : LexerContext] [start : Int] [pos : Int]) : (InnerResult Token)
  (match-define bytes (lexer-context-bytes ctx))
  (cond
    [(= (bytes-length bytes) pos)
     (bad-input/inner #"Input ended with equal" (lexer-context-get-span ctx start pos))]
    [else
     (match-define byte (bytes-ref bytes pos))
     (match-define next-pos (+ 1 pos))
     (cond
      [(equals-sign? byte)
       (equal-equal-token* ctx start next-pos)]
      [else
       (bad-input/inner
         (bytes-append
           (varargs list
             #"Unsupported character after equal: #x" 
             (integer->hex-bytes (u8->s64 byte))))
         (lexer-context-get-span ctx start next-pos))])]))

(define (lex-after-less-than [ctx : LexerContext] [start : Int] [pos : Int]) : (InnerResult Token)
  (match-define bytes (lexer-context-bytes ctx))
  (cond
    [(= (bytes-length bytes) pos)
     (less-than-token* ctx start pos)]
    [else
     (match-define byte (bytes-ref bytes pos))
     (match-define next-pos (+ 1 pos))
     (cond
      [(equals-sign? byte)
       (less-than-equal-token* ctx start next-pos)]
      [else
       (less-than-token* ctx start pos)])]))

(define (lex-after-greater-than [ctx : LexerContext] [start : Int] [pos : Int]) : (InnerResult Token)
  (match-define bytes (lexer-context-bytes ctx))
  (cond
    [(= (bytes-length bytes) pos)
     (greater-than-token* ctx start pos)]
    [else
     (match-define byte (bytes-ref bytes pos))
     (match-define next-pos (+ 1 pos))
     (cond
      [(equals-sign? byte)
       (greater-than-equal-token* ctx start next-pos)]
      [else
       (greater-than-token* ctx start pos)])]))

(define (lex-after-colon [ctx : LexerContext] [start : Int] [pos : Int]) : (InnerResult Token)
  (match-define bytes (lexer-context-bytes ctx))
  (cond
    [(= (bytes-length bytes) pos)
     (bad-input/inner #"Input ended with colon" (lexer-context-get-span ctx start pos))]
    [else
     (match-define byte (bytes-ref bytes pos))
     (match-define next-pos (+ 1 pos))
     (cond
      [(equals-sign? byte)
       (assignment-token* ctx start next-pos)]
      [else
       (bad-input/inner
         (bytes-append
           (varargs list
             #"Unsupported character after colon: #x" 
             (integer->hex-bytes (u8->s64 byte))))
         (lexer-context-get-span ctx start next-pos))])]))


(define (lex-after-bang [ctx : LexerContext] [start : Int] [pos : Int]) : (InnerResult Token)
  (match-define bytes (lexer-context-bytes ctx))
  (cond
    [(= (bytes-length bytes) pos)
     (bang-token* ctx start pos)]
    [else
     (match-define byte (bytes-ref bytes pos))
     (match-define next-pos (+ 1 pos))
     (cond
      [(equals-sign? byte)
       (not-equal-token* ctx start next-pos)]
      [else
       (bang-token* ctx start pos)])]))

(define (lex-after-ampersand [ctx : LexerContext] [start : Int] [pos : Int]) : (InnerResult Token)
  (match-define bytes (lexer-context-bytes ctx))
  (cond
    [(= (bytes-length bytes) pos)
     (bad-input/inner #"Input ended with ampersand" (lexer-context-get-span ctx start pos))]
    [else
     (match-define byte (bytes-ref bytes pos))
     (match-define next-pos (+ 1 pos))
     (cond
      [(ampersand? byte)
       (logical-and-token* ctx start next-pos)]
      [else
       (bad-input/inner
         (bytes-append
           (varargs list
             #"Unsupported character after ampersand: #x" 
             (integer->hex-bytes (u8->s64 byte))))
         (lexer-context-get-span ctx start next-pos))])]))

(define (lex-after-minus [ctx : LexerContext] [start : Int] [pos : Int]) : (InnerResult Token)
  (match-define bytes (lexer-context-bytes ctx))
  (cond
    [(= (bytes-length bytes) pos)
     (minus-token* ctx start pos)]
    [else
     (match-define byte (bytes-ref bytes pos))
     (match-define next-pos (+ 1 pos))
     (cond
      [(greater-than? byte)
       (lex-after-minus-greater-than ctx start next-pos)]
      [else
       (minus-token* ctx start pos)])]))

(define (lex-after-minus-greater-than [ctx : LexerContext] [start : Int] [pos : Int])
  : (InnerResult Token)
  (match-define bytes (lexer-context-bytes ctx))
  (cond
    [(= (bytes-length bytes) pos)
     (pointer-field-access-token* ctx start pos)]
    [else
     (match-define byte (bytes-ref bytes pos))
     (match-define next-pos (+ 1 pos))
     (cond
      [(ampersand? byte)
       (pointer-offset-token* ctx start next-pos)]
      [else
       (pointer-field-access-token* ctx start pos)])]))


(define (lex-keyword [ctx : LexerContext] [start : Int] [cur : Int]) : (InnerResult Token)
  (match-define bytes (lexer-context-bytes ctx))
  (cond
    [(= (bytes-length bytes) cur)
     (keyword-token* ctx start cur)]
    [(keyword-continue-byte? (bytes-ref bytes cur))
     (lex-keyword ctx start (+ 1 cur))]
    [else
     (keyword-token* ctx start cur)]))

(define (lex-bytes [ctx : LexerContext] [start : Int] [cur : Int]) : (InnerResult Token)
  (match-define bytes (lexer-context-bytes ctx))
  (cond
    [(= (bytes-length bytes) cur)
     (bad-input/inner #"Input ended in the middle of bytes literal"
                      (lexer-context-get-span ctx (- start 2) cur))]
    [else
     (match-define byte (bytes-ref bytes cur))
     (cond
       [(back-slash? byte)
        (cond
          [(= (bytes-length bytes) (+ 1 cur))
           (bad-input/inner #"Input ended with backslash"
                            (lexer-context-get-span ctx (- start 2) (+ 1 cur)))]
          [else
            (match-define cur (+ 1 cur))
            (match-define byte (bytes-ref bytes cur))
            (if (or (or (double-quote? byte)
                        (back-slash? byte))
                    (or (= (u8->s64 byte) 110) ;; n
                        (or (= (u8->s64 byte) 114) ;; r
                            (= (u8->s64 byte) 120)))) ;; x
                (lex-bytes ctx start (+ 1 cur))
                (bad-input/inner #"Unknown character after backslash"
                                 (lexer-context-get-span ctx (- cur 1) (+ cur 1))))])]
       [(bytes-continue-byte? byte)
        (lex-bytes ctx start (+ 1 cur))]
       [(double-quote? byte)
        (case (unescape-bytes (subbytes bytes start cur))
          [(left _) (bad-input/inner #"Bytes literal couldn't be unescaped"
                                     (lexer-context-get-span ctx (- start 2) (+ cur 1)))]
          [(right v)
           (bytes-token* ctx v start (+ 1 cur))])]
       [else
        (bad-input/inner
          (bytes-append (varargs list #"Unsupported character in bytes literal: #x"
                                      (integer->hex-bytes (u8->s64 byte))))
          (lexer-context-get-span ctx cur (+ cur 1)))])]))

(define (lex-decimal [ctx : LexerContext] [start : Int] [cur : Int]) : (InnerResult Token)
  (match-define bytes (lexer-context-bytes ctx))
  (cond
    [(= (bytes-length bytes) cur)
     (decimal-number-token* ctx start cur)]
    [(decimal-continue-byte? (bytes-ref bytes cur))
     (lex-decimal ctx start (+ 1 cur))]
    [else
     (decimal-number-token* ctx start cur)]))

(define (lex-hexadecimal [ctx : LexerContext] [start : Int] [cur : Int]) : (InnerResult Token)
  (match-define bytes (lexer-context-bytes ctx))
  (cond
    [(= (bytes-length bytes) cur)
     (hexadecimal-number-token* ctx start cur)]
    [(hexadecimal-byte? (bytes-ref bytes cur))
     (lex-hexadecimal ctx start (+ 1 cur))]
    [else
     (hexadecimal-number-token* ctx start cur)]))

(define (lex-line-comment [ctx : LexerContext] [start : Int] [pos : Int]) : (InnerResult Token)
  (match-define bytes (lexer-context-bytes ctx))
  (cond
    [(= (bytes-length bytes) pos)
     (comment-token* ctx start pos)]
    [(newline? (bytes-ref bytes pos))
     (comment-token* ctx start pos)]
    [else
     (lex-line-comment ctx start (+ 1 pos))]))

(define (make-core-lexer [sbytes : SourcedBytes]) : (Lexer Token)
  (make-lexer sbytes sexp-lexer/impl))

(define (sexp-lexer/impl [ctx : LexerContext] [pos : Int]) : (InnerResult Token)
  (match-define bytes (lexer-context-bytes ctx))
  (cond
    [(= pos (bytes-length bytes))
     (end-of-input/inner (lexer-context-get-span ctx pos pos))]
    [else
      (match-define byte (bytes-ref bytes pos))
      (match-define next-pos (+ pos 1))
      (cond
       [(left-paren? byte)
        (left-paren-token* ctx pos next-pos)]
       [(right-paren? byte)
        (right-paren-token* ctx pos next-pos)]
       [(left-bracket? byte)
        (left-bracket-token* ctx pos next-pos)]
       [(right-bracket? byte)
        (right-bracket-token* ctx pos next-pos)]
       [(left-brace? byte)
        (left-brace-token* ctx pos next-pos)]
       [(right-brace? byte)
        (right-brace-token* ctx pos next-pos)]
       [(less-than? byte)
        (lex-after-less-than ctx pos next-pos)]
       [(greater-than? byte)
        (lex-after-greater-than ctx pos next-pos)]
       [(equals-sign? byte)
        (lex-after-equal ctx pos next-pos)]
       [(plus-sign? byte)
        (plus-token* ctx pos next-pos)]
       [(minus-sign? byte)
        (lex-after-minus ctx pos next-pos)]
       [(multiplication-sign? byte)
        (multiplication-token* ctx pos next-pos)]
       [(forward-slash? byte)
        (division-token* ctx pos next-pos)]
       [(comma? byte)
        (comma-token* ctx pos next-pos)]
       [(ampersand? byte)
        (lex-after-ampersand ctx pos next-pos)]
       [(bang? byte)
        (lex-after-bang ctx pos next-pos)]
       [(colon? byte)
        (lex-after-colon ctx pos next-pos)]
       [(or (newline? byte) (space? byte))
        (sexp-lexer/impl ctx next-pos)]
       [(symbol-start-byte? byte)
        (lex-symbol ctx pos next-pos)]
       [(decimal-start-byte? byte)
        (lex-decimal ctx pos next-pos)]
       [(hash? byte)
        (lex-after-hash ctx next-pos)]
       [(semi-colon? byte)
        (lex-line-comment ctx pos next-pos)]
       [(double-quote? byte)
        (bad-input/inner
          #"String literals not supported"
          (lexer-context-get-span ctx pos next-pos))]
       [else
        (bad-input/inner
          (bytes-append
            (varargs list
              #"Unsupported character at start of lexeme: #x"
              (integer->hex-bytes (u8->s64 byte))))
          (lexer-context-get-span ctx pos next-pos))])]))
