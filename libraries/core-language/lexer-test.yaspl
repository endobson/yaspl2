#:module (core-language lexer-test)
#:import {
  (bytes)
  (data source-location)
  (list)
  (maybe)
  (prim)
  (core-language lexer)
  (tuples)
  (yunit)
}
(export
  (#:values main))
(types)

(define (lex-all [bytes : Bytes]) : (Maybe (List (SourceSpanAnnotated Lexeme)))
  (lex-all/run (make-sexp-lexer (sourced-bytes (unnamed-source) bytes)) (empty)))
(define (lex-all/run [lexer : (Lexer Lexeme)] [lexemes : (List (SourceSpanAnnotated Lexeme))])
  : (Maybe (List (SourceSpanAnnotated Lexeme)))
  (case (run-lexer lexer)
    [(lex-result v lexer) (lex-all/run lexer (cons v lexemes))]
    [(end-of-input _) (just (reverse lexemes))]
    [(bad-input _ _) (nothing)]))

(define (count-lexemes [bytes : Bytes] [expected-count : Int]) : (-> Boolean)
  (lambda ()
    (case (lex-all bytes)
      [(nothing) #f]
      [(just lexemes) (= (length lexemes) expected-count)])))

(define (main [args : Bytes] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Int
  (yunit/main stderr
    (varargs list
      (test-case #"left parens" (count-lexemes #"((((" 4))
      )))
