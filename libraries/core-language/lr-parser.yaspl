#:module (core-language lr-parser)
#:import {
  (bytes)
  {(core-language lexer)
    {#:types
      [Lexer l:Lexer]
      [Token l:Token]
    }
    {#:values
      [run-lexer l:run-lexer]
    }
    {#:patterns
      [bad-input l:bad-input]
      [end-of-input l:end-of-input]
      [left-paren-token l:left-paren-token]
      [lex-result l:lex-result]
      [multiplication-token l:multiplication-token]
      [plus-token l:plus-token]
      [right-paren-token l:right-paren-token]
      [symbol-token l:symbol-token]
    }
  }
  (data ordering)
  (data source-location)
  (dict)
  (either)
  (list)
  (maybe)
  (numbers)
  {(prim)
    {#:types
      Boolean
      Bytes
      Int
    }
    {#:values
      +
      -
      =
      and
      panic
    }
  }
  (set)
  (tuples)
  (unique-dict)
}
(export
  (#:types TestNonTerm TestTerm Item StateId Action LiftedTerm)
  (#:values run-parser lex-all

   closure
   production-rules-dict
   test-production-rules
   item
   start-symbol
   lifted-non-term
   non-term/E
   item-set
   item-cmp
   test-non-term-cmp
   test-term-cmp

   term/plus
   term/times
   term/left-paren
   term/right-paren
   term/id
   canonical-item-sets
   build-parser
   parser-action
   state-id-v
   build-empty-table
   build-first-table
   build-follow-table


   )
  (#:patterns non-term/T non-term/F non-term/E
   term/id term/plus term/times term/left-paren term/right-paren
   lifted-term end-of-terminals
   accept reduce shift
   state-id))
(types
  (define-type (ParserState Token)
    (parser-state
      [stack : (List StateId)]
      [nodes : (List (ParseTree Token))]
      [input : (List Token)]))

  (define-type (Parser NonTerm Term)
    (parser
      [action : (Dict StateId (Dict (LiftedTerm Term) (Action NonTerm)))]
      [goto : (Dict StateId (Dict NonTerm StateId))]))
  (define-type (Action NonTerm)
    (shift [new-state : StateId])
    (reduce [non-term : NonTerm] [index : Int] [num-symbols : Int])
    (accept))
  (define-type StateId
    (state-id [v : Int]))
  (define-type (LiftedTerm Term)
    (end-of-terminals)
    (lifted-term [t : Term]))
  (define-type (LiftedNonTerm NonTerm)
    (start-symbol)
    (lifted-non-term [n : NonTerm]))

  (define-type (ParseTree Token)
    (non-terminal-node [index : Int]
                       [children : (List (ParseTree Token))])
    (terminal-node [t : Token]))

  (define-type (ProductionRule NonTerm Term)
    (production-rule
      [non-term : NonTerm]
      [rule-number : Int]
      [entries : (List (Symbol NonTerm Term))]))

  (define-type (ProductionRHS NonTerm Term)
    (production-rhs
      [rule-number : Int]
      [entries : (List (Symbol NonTerm Term))]))

  (define-type (Item NonTerm Term)
    (item
      [non-term : (LiftedNonTerm NonTerm)]
      [rule : Int]
      [left-entries : (List (Symbol NonTerm Term))]
      [right-entries : (List (Symbol NonTerm Term))]))
  ;; This only contains the kernel items
  (define-type (ItemSet NonTerm Term)
    (item-set [items : (Set (Item NonTerm Term))]))

  (define-type (Symbol NonTerm Term)
    (symbol/non-term [nt : NonTerm])
    (symbol/term [t : Term]))

  (define-type TestNonTerm
    (non-term/E)
    (non-term/F)
    (non-term/T))
  (define-type TestTerm
    (term/plus)
    (term/times)
    (term/left-paren)
    (term/right-paren)
    (term/id)))

(define (state-id-cmp [a : StateId] [b : StateId]) : Ordering
  (match-define (state-id a-v) a)
  (match-define (state-id b-v) b)
  (int-cmp a-v b-v))

(define [NonTerm Term] (item-set-cmp
                         [non-term-cmp : (NonTerm NonTerm -> Ordering)]
                         [term-cmp : (Term Term -> Ordering)])
  : ((ItemSet NonTerm Term) (ItemSet NonTerm Term) -> Ordering)
  (lambda ([a : (ItemSet NonTerm Term)] [b : (ItemSet NonTerm Term)]) : Ordering
    (match-define (item-set as) a)
    (match-define (item-set bs) b)
    ((list-cmp (item-cmp non-term-cmp term-cmp))
     (set->list as) (set->list bs))))

(define [Term] (lifted-term-cmp [term-cmp : (Term Term -> Ordering)])
  : ((LiftedTerm Term) (LiftedTerm Term) -> Ordering)
  (lambda ([a : (LiftedTerm Term)] [b : (LiftedTerm Term)]) : Ordering
    (case (tuple2 a b)
      [(tuple2 (end-of-terminals) (end-of-terminals)) (equal-to)]
      [(tuple2 (lifted-term _) (end-of-terminals)) (less-than)]
      [(tuple2 (end-of-terminals) (lifted-term _)) (greater-than)]
      [(tuple2 (lifted-term a) (lifted-term b)) (term-cmp a b)])))

(define [NonTerm] (lifted-non-term-cmp [non-term-cmp : (NonTerm NonTerm -> Ordering)])
  : ((LiftedNonTerm NonTerm) (LiftedNonTerm NonTerm) -> Ordering)
  (lambda ([a : (LiftedNonTerm NonTerm)] [b : (LiftedNonTerm NonTerm)]) : Ordering
    (case (tuple2 a b)
      [(tuple2 (start-symbol) (start-symbol)) (equal-to)]
      [(tuple2 (lifted-non-term _) (start-symbol)) (greater-than)]
      [(tuple2 (start-symbol) (lifted-non-term _)) (less-than)]
      [(tuple2 (lifted-non-term a) (lifted-non-term b)) (non-term-cmp a b)])))

(define [NonTerm Term] (symbol-cmp [non-term-cmp : (NonTerm NonTerm -> Ordering)]
                                   [term-cmp : (Term Term -> Ordering)])
  : ((Symbol NonTerm Term) (Symbol NonTerm Term) -> Ordering)
  (lambda ([v1 : (Symbol NonTerm Term)] [v2 : (Symbol NonTerm Term)])
    (case (tuple2 v1 v2)
      [(tuple2 (symbol/non-term _) (symbol/term _))
       (less-than)]
      [(tuple2 (symbol/term _) (symbol/non-term _))
       (greater-than)]
      [(tuple2 (symbol/non-term nt1) (symbol/non-term nt2))
       (non-term-cmp nt1 nt2)]
      [(tuple2 (symbol/term t1) (symbol/term t2))
       (term-cmp t1 t2)])))

(define [NonTerm Term] (symbol=? [non-term=? : (NonTerm NonTerm -> Boolean)]
                                 [term=? : (Term Term -> Boolean)])
  : ((Symbol NonTerm Term) (Symbol NonTerm Term) -> Boolean)
  (lambda ([v1 : (Symbol NonTerm Term)] [v2 : (Symbol NonTerm Term)])
    (case (tuple2 v1 v2)
      [(tuple2 (symbol/non-term nt1) (symbol/non-term nt2))
       (non-term=? nt1 nt2)]
      [(tuple2 (symbol/term t1) (symbol/term t2))
       (term=? t1 t2)]
      [_ #f])))

(define [NonTerm] (action=? [non-term=? : (NonTerm NonTerm -> Boolean)])
  : ((Action NonTerm) (Action NonTerm) -> Boolean)
  (lambda ([a1 : (Action NonTerm)] [a2 : (Action NonTerm)])
    (case (tuple2 a1 a2)
      [(tuple2 (shift (state-id s1)) (shift (state-id s2)))
       (= s1 s2)]
      [(tuple2 (reduce nt1 rule1 num-symbols1)
               (reduce nt2 rule2 num-symbols2))
       (and
         (non-term=? nt1 nt2)
         (and (= rule1 rule2) (= num-symbols1 num-symbols2)))]
      [(tuple2 (accept) (accept)) #t]
      [_ #f])))


(define [NonTerm Term] (item-cmp [non-term-cmp : (NonTerm NonTerm -> Ordering)]
                                 [term-cmp : (Term Term -> Ordering)])
  : ((Item NonTerm Term) (Item NonTerm Term) -> Ordering)
  (lambda ([a : (Item NonTerm Term)] [b : (Item NonTerm Term)]) : Ordering
    (match-define (item nt-a rule-a l-a r-a) a)
    (match-define (item nt-b rule-b l-b r-b) b)
    (case ((lifted-non-term-cmp non-term-cmp) nt-a nt-b)
      [(equal-to)
       (case (int-cmp rule-a rule-b)
        [(equal-to)
         (match-define entries-cmp (list-cmp (symbol-cmp non-term-cmp term-cmp)))
         (case (entries-cmp l-a l-b)
           [(equal-to)
            (entries-cmp r-a r-b)]
           [v v])]
        [v v])]
      [v v])))

(define [NonTerm Term] (kernel-item? [item : (Item NonTerm Term)]) : Boolean
  (case item
    [(item _ _ (cons _ _) _) #t]
    [(item (start-symbol) _ (empty) _) #t]
    [_ #f]))



(define (test-term=? [a : TestTerm] [b : TestTerm]) : Boolean
  (match-define convert
    (lambda ([v : TestTerm])
      (case v
        [(term/plus) 0]
        [(term/times) 1]
        [(term/left-paren) 2]
        [(term/right-paren) 3]
        [(term/id) 4])))
  (= (convert a) (convert b)))


(define (test-term-cmp [a : TestTerm] [b : TestTerm]) : Ordering
  (match-define convert
    (lambda ([v : TestTerm])
      (case v
        [(term/plus) 0]
        [(term/times) 1]
        [(term/left-paren) 2]
        [(term/right-paren) 3]
        [(term/id) 4])))
  (int-cmp (convert a) (convert b)))

(define (test-non-term=? [a : TestNonTerm] [b : TestNonTerm]) : Boolean
  (match-define convert
    (lambda ([v : TestNonTerm])
      (case v
        [(non-term/E) 0]
        [(non-term/F) 1]
        [(non-term/T) 2])))
  (= (convert a) (convert b)))

(define (test-non-term-cmp [a : TestNonTerm] [b : TestNonTerm]) : Ordering
  (match-define convert
    (lambda ([v : TestNonTerm])
      (case v
        [(non-term/E) 0]
        [(non-term/F) 1]
        [(non-term/T) 2])))
  (int-cmp (convert a) (convert b)))

(define (test-production-rules) : (List (ProductionRule TestNonTerm TestTerm))
  (match-define E* (non-term/E))
  (match-define F* (non-term/F))
  (match-define T* (non-term/T))

  (match-define E : (Symbol TestNonTerm TestTerm) (symbol/non-term (non-term/E)))
  (match-define F : (Symbol TestNonTerm TestTerm) (symbol/non-term (non-term/F)))
  (match-define T : (Symbol TestNonTerm TestTerm) (symbol/non-term (non-term/T)))
  (match-define + : (Symbol TestNonTerm TestTerm) (symbol/term (term/plus)))
  (match-define * : (Symbol TestNonTerm TestTerm) (symbol/term (term/times)))
  (match-define < : (Symbol TestNonTerm TestTerm) (symbol/term (term/left-paren)))
  (match-define > : (Symbol TestNonTerm TestTerm) (symbol/term (term/right-paren)))
  (match-define id : (Symbol TestNonTerm TestTerm) (symbol/term (term/id)))


  (varargs list
    (production-rule E* 1 (varargs list E + T))
    (production-rule E* 2 (varargs list T))
    (production-rule T* 3 (varargs list T * F))
    (production-rule T* 4 (varargs list F))
    (production-rule F* 5 (varargs list < E >))
    (production-rule F* 6 (varargs list id))))



(define (production-rules-dict [rules : (List (ProductionRule TestNonTerm TestTerm))])
  : (Dict TestNonTerm (List (ProductionRHS TestNonTerm TestTerm)))
  (foldl
    (lambda ([pr : (ProductionRule TestNonTerm TestTerm)]
             [acc : (Dict TestNonTerm (List (ProductionRHS TestNonTerm TestTerm)))])
      : (Dict TestNonTerm (List (ProductionRHS TestNonTerm TestTerm)))
      (match-define (production-rule nt rule symbols) pr)
      (dict-update
        acc
        nt
        (lambda ([rhss : (List (ProductionRHS TestNonTerm TestTerm))])
          (cons (production-rhs rule symbols) rhss))
        (empty)))
    rules
    (ann (Dict TestNonTerm (List (ProductionRHS TestNonTerm TestTerm)))
      (make-dict test-non-term-cmp))))

(define (build-empty-table [rules : (Dict TestNonTerm (List (ProductionRHS TestNonTerm TestTerm)))])
  : (Set TestNonTerm)
  ;; Drop all the rules that have a terminal in them as they cannot be empty
  (match-define filtered-rules
    (dict-value-map rules
      (lambda ([rhss : (List (ProductionRHS TestNonTerm TestTerm))])
        (filter-map
          (lambda ([rhs : (ProductionRHS TestNonTerm TestTerm)]) : (Maybe (List TestNonTerm))
            (case (partition-symbols (production-rhs-entries rhs))
              [(tuple2 nonterms (empty))
               (just nonterms)]
              [_ (nothing)]))
          rhss))))

  (build-empty-table* (make-set test-non-term-cmp) filtered-rules))


(define (partition-symbols [symbols : (List (Symbol TestNonTerm TestTerm))])
  : (Tuple2 (List TestNonTerm) (List TestTerm))
  (partition-symbols* symbols (empty) (empty)))

(define (partition-symbols* [symbols : (List (Symbol TestNonTerm TestTerm))]
                            [non-terms : (List TestNonTerm)] [terms : (List TestTerm)])
  : (Tuple2 (List TestNonTerm) (List TestTerm))
  (case symbols
    [(empty) (tuple2 (reverse non-terms) (reverse terms))]
    [(cons (symbol/non-term non-term) symbols)
     (partition-symbols* symbols (cons non-term non-terms) terms)]
    [(cons (symbol/term term) symbols)
     (partition-symbols* symbols non-terms (cons term terms))]))


(define (build-empty-table*
          [current-table : (Set TestNonTerm)]
          [rules : (Dict TestNonTerm (List (List TestNonTerm)))])
  : (Set TestNonTerm)
  (match-define new-entries
    (dict-fold
      rules
      (lambda ([nt : TestNonTerm] [rhss : (List (List TestNonTerm))] [acc : (Set TestNonTerm)])
        (cond
          [(set-member? current-table nt)
           acc]
          [(ormap
             (lambda ([rhs : (List TestNonTerm)])
               (andmap (lambda ([rhs-nt : TestNonTerm]) (set-member? current-table rhs-nt)) rhs))
             rhss)
           (set-add acc nt)]
          [else
           acc]))
      (make-set test-non-term-cmp)))
  (if (set-empty? new-entries)
      current-table
      (build-empty-table* (set-union current-table new-entries) rules)))

(define (build-first-table
          [rules : (Dict TestNonTerm (List (ProductionRHS TestNonTerm TestTerm)))]
          [empty-table : (Set TestNonTerm)]) : (Dict TestNonTerm (Set TestTerm))
  (match-define initial-table
    (dict-value-map rules
      (lambda ([rhss : (List (ProductionRHS TestNonTerm TestTerm))])
        (set-add-all
          (make-set test-term-cmp)
          (filter-map
            (lambda ([rhs : (ProductionRHS TestNonTerm TestTerm)])
              (initial-terminal (production-rhs-entries rhs) empty-table))
            rhss)))))

  ;; Convert the rules to the set of relevant non terminals which can contribute to the
  ;; first value for the the non terminal.
  (match-define filtered-rules
    (dict-value-map rules
      (lambda ([rhss : (List (ProductionRHS TestNonTerm TestTerm))])
        (set->list
          (set-union*
            (make-set test-non-term-cmp)
            (map
              (lambda ([rhs : (ProductionRHS TestNonTerm TestTerm)])
                (first-relevant-non-terminals (production-rhs-entries rhs) empty-table))
              rhss))))))

  (build-first-table* initial-table filtered-rules))

(define (initial-terminal [rhs : (List (Symbol TestNonTerm TestTerm))]
                          [empty-table : (Set TestNonTerm)]) : (Maybe TestTerm)
  (case rhs
    [(empty) (nothing)]
    [(cons (symbol/term t) _) (just t)]
    [(cons (symbol/non-term nt) rest-rhs)
     (if (set-member? empty-table nt)
         (initial-terminal rest-rhs empty-table)
         (nothing))]))

(define (first-relevant-non-terminals
          [rhs : (List (Symbol TestNonTerm TestTerm))]
          [empty-table : (Set TestNonTerm)]) : (Set TestNonTerm)
  (case rhs
    [(empty) (make-set test-non-term-cmp)]
    [(cons (symbol/term _) _) (make-set test-non-term-cmp)]
    [(cons (symbol/non-term nt) rest-rhs)
     (set-add
       (if (set-member? empty-table nt)
           (first-relevant-non-terminals rest-rhs empty-table)
           (make-set test-non-term-cmp))
       nt)]))

(define (build-first-table*
          [current-table : (Dict TestNonTerm (Set TestTerm))]
          [rules : (Dict TestNonTerm (List TestNonTerm))]) : (Dict TestNonTerm (Set TestTerm))
  (match-define all-updates
    (dict-filter-map
      rules
      (lambda ([nt : TestNonTerm] [others : (List TestNonTerm)]) : (Maybe (Set TestTerm))
        (match-define new-elems
          (set-union*
            (make-set test-term-cmp)
            (map (lambda ([other-nt : TestNonTerm])
                   (dict-ref/panic current-table other-nt))
                 others)))
        (match-define delta
          (set-difference new-elems (dict-ref/panic current-table nt)))
        (if (set-empty? delta)
            (nothing)
            (just new-elems)))))
  (if (dict-empty? all-updates)
      current-table
      (build-first-table*
        (dict-entry-map
          current-table
          (lambda ([nt : TestNonTerm] [old-elems : (Set TestTerm)])
            (case (dict-ref all-updates nt)
              [(just new-elems) new-elems]
              [(nothing) old-elems])))
        rules)))

(define (build-follow-table
          [rules : (Dict TestNonTerm (List (ProductionRHS TestNonTerm TestTerm)))]
          [empty-table : (Set TestNonTerm)]
          [first-table : (Dict TestNonTerm (Set TestTerm))])
  : (Dict TestNonTerm (Set (LiftedTerm TestTerm)))
  (match-define initial-table
    (dict-value-map
      rules
      (lambda ([_rhss : (List (ProductionRHS TestNonTerm TestTerm))])
        (make-set (lifted-term-cmp test-term-cmp)))))
  (match-define initial-table : (Dict TestNonTerm (Set (LiftedTerm TestTerm)))
    (dict-set
      initial-table
      (non-term/E)
      (set-add
        (make-set (lifted-term-cmp test-term-cmp))
        (end-of-terminals))))
  (match-define initial-table
    (dict-fold
      rules
      (lambda ([_nt : TestNonTerm]
               [rhss : (List (ProductionRHS TestNonTerm TestTerm))]
               [acc : (Dict TestNonTerm (Set (LiftedTerm TestTerm)))])
        (foldl
          (lambda ([rhs : (ProductionRHS TestNonTerm TestTerm)]
                   [acc : (Dict TestNonTerm (Set (LiftedTerm TestTerm)))])
            (add-initial-follows (production-rhs-entries rhs) empty-table first-table acc))
          rhss
          acc))
      initial-table))

  ;; Convert the rules to the set of relevant non terminals which can contribute to the
  ;; follow value for the the non terminal.
  (match-define non-terminal-map
    (dict-value-map
      rules
      (lambda ([_rhss : (List (ProductionRHS TestNonTerm TestTerm))])
        (make-set test-non-term-cmp))))

  (match-define non-terminal-map
    (dict-fold
      rules
      (lambda ([nt : TestNonTerm]
               [rhss : (List (ProductionRHS TestNonTerm TestTerm))]
               [acc : (Dict TestNonTerm (Set TestNonTerm))])
        (foldl
          (lambda ([rhs : (ProductionRHS TestNonTerm TestTerm)]
                   [acc : (Dict TestNonTerm (Set TestNonTerm))])
            (add-non-term-follows nt (production-rhs-entries rhs) empty-table first-table acc))
          rhss
          acc))
      non-terminal-map))
  (match-define non-terminal-map
    (dict-value-map non-terminal-map
      (lambda ([s : (Set TestNonTerm)]) (set->list s))))

  (build-follow-table* initial-table non-terminal-map))

(define (build-follow-table*
          [current-table : (Dict TestNonTerm (Set (LiftedTerm TestTerm)))]
          [non-terminal-map : (Dict TestNonTerm (List TestNonTerm))])
  : (Dict TestNonTerm (Set (LiftedTerm TestTerm)))
  (match-define all-updates
    (dict-filter-map
      non-terminal-map
      (lambda ([nt : TestNonTerm] [others : (List TestNonTerm)]) 
        : (Maybe (Set (LiftedTerm TestTerm)))
        (match-define new-elems
          (set-union*
            (dict-ref/panic current-table nt)
            (map (lambda ([other-nt : TestNonTerm])
                   (dict-ref/panic current-table other-nt))
                 others)))
        (match-define delta
          (set-difference new-elems (dict-ref/panic current-table nt)))
        (if (set-empty? delta)
            (nothing)
            (just new-elems)))))
  (if (dict-empty? all-updates)
      current-table
      (build-follow-table*
        (dict-entry-map
          current-table
          (lambda ([nt : TestNonTerm] [old-elems : (Set (LiftedTerm TestTerm))])
            (case (dict-ref all-updates nt)
              [(just new-elems) new-elems]
              [(nothing) old-elems])))
        non-terminal-map)))


(define (add-initial-follows
          [rhs : (List (Symbol TestNonTerm TestTerm))]
          [empty-table : (Set TestNonTerm)]
          [first-table : (Dict TestNonTerm (Set TestTerm))]
          [acc : (Dict TestNonTerm (Set (LiftedTerm TestTerm)))])
  : (Dict TestNonTerm (Set (LiftedTerm TestTerm)))
  (case rhs
    [(empty) acc]
    [(cons (symbol/term _) rhs)
     (add-initial-follows rhs empty-table first-table acc)]
    [(cons (symbol/non-term nt) rhs)
     (add-initial-follows
       rhs empty-table first-table
       (dict-update-existing
         acc
         nt
         (lambda ([acc-set : (Set (LiftedTerm TestTerm))])
           (set-add-all acc-set
             (map (lambda ([t : TestTerm]) (lifted-term t))
                  (set->list (first/string rhs empty-table first-table)))))))]))

(define (first/string
          [str : (List (Symbol TestNonTerm TestTerm))]
          [empty-table : (Set TestNonTerm)]
          [first-table : (Dict TestNonTerm (Set TestTerm))])
  : (Set TestTerm)
  (case str
    [(empty) (make-set test-term-cmp)]
    [(cons (symbol/term t) _) (set-add (make-set test-term-cmp) t)]
    [(cons (symbol/non-term nt) str)
     (set-union
       (if (set-member? empty-table nt)
           (first/string str empty-table first-table)
           (make-set test-term-cmp))
       (dict-ref/panic first-table nt))]))

(define (add-non-term-follows
          [nt : TestNonTerm]
          [rhs : (List (Symbol TestNonTerm TestTerm))]
          [empty-table : (Set TestNonTerm)]
          [first-table : (Dict TestNonTerm (Set TestTerm))]
          [acc : (Dict TestNonTerm (Set TestNonTerm))])
  : (Dict TestNonTerm (Set TestNonTerm))
  (case rhs
    [(empty) acc]
    [(cons (symbol/term _) rhs)
     (add-non-term-follows nt rhs empty-table first-table acc)]
    [(cons (symbol/non-term other-nt) rhs)
     (match-define acc
       (if (empty/string rhs empty-table)
           (dict-update-existing
             acc
             other-nt
             (lambda ([nt-set : (Set TestNonTerm)])
               (set-add nt-set nt)))
           acc))
     (add-non-term-follows nt rhs empty-table first-table acc)]))

(define (empty/string
          [str : (List (Symbol TestNonTerm TestTerm))]
          [empty-table : (Set TestNonTerm)])
  : Boolean
  (case str
    [(empty) #t]
    [(cons (symbol/term _t) _str) #f]
    [(cons (symbol/non-term nt) str)
     (if (set-member? empty-table nt)
         (empty/string str empty-table)
         #f)]))

(define (closure
          [is : (ItemSet TestNonTerm TestTerm)]
          [rules : (Dict TestNonTerm (List (ProductionRHS TestNonTerm TestTerm)))])
  : (Set (Item TestNonTerm TestTerm))
  (match-define (item-set items) is)

  (closure* (set->list items)
            (make-set (item-cmp test-non-term-cmp test-term-cmp))
            rules))

(define (closure*
          [items : (List (Item TestNonTerm TestTerm))]
          [acc : (Set (Item TestNonTerm TestTerm))]
          [rules : (Dict TestNonTerm (List (ProductionRHS TestNonTerm TestTerm)))])
  : (Set (Item TestNonTerm TestTerm))
  (case items
    [(empty) acc]
    [(cons i items)
     (if (set-member? acc i)
         (closure* items acc rules)
         (closure*
           (case i
             [(item nt _ _ (cons (symbol/non-term other-nt) _))
              (append
                (map
                  (lambda ([rhs : (ProductionRHS TestNonTerm TestTerm)])
                    : (Item TestNonTerm TestTerm)
                    (match-define (production-rhs rule entries) rhs)
                    (item (lifted-non-term other-nt) rule (empty) entries))
                  (dict-ref/panic rules other-nt))
                items)]
             [_ items])
           (set-add acc i)
           rules))]))

(define (goto [items : (Set (Item TestNonTerm TestTerm))]
              [symbol : (Symbol TestNonTerm TestTerm)])
  : (Maybe (ItemSet TestNonTerm TestTerm))
  (match-define new-items
    (filter-map
      (lambda ([i : (Item TestNonTerm TestTerm)]) : (Maybe (Item TestNonTerm TestTerm))
        (case i
          [(item nt rule lhs (cons other-symbol rhs))
           (if ((symbol=? test-non-term=? test-term=?) symbol other-symbol)
               (just (item nt rule (cons other-symbol lhs) rhs))
               (nothing))]
          [_ (nothing)]))
      (set->list items)))
  (case new-items
    [(empty) (nothing)]
    [_
     (just
       (item-set
         (set-add-all
           (make-set (item-cmp test-non-term-cmp test-term-cmp))
           new-items)))]))

(define (canonical-item-sets
          [start : TestNonTerm]
          [rules : (Dict TestNonTerm (List (ProductionRHS TestNonTerm TestTerm)))])
  : (UniqueDict (ItemSet TestNonTerm TestTerm) StateId)
  (match-define init-item : (Item TestNonTerm TestTerm)
    (item (start-symbol) 0 (empty) (varargs list (symbol/non-term start))))

  (match-define terms
    (set->list
      (set-add-all
        (make-set test-term-cmp)
        (append*
          (map
            (lambda ([rhs : (ProductionRHS TestNonTerm TestTerm)])
              (filter-map
                (lambda ([s : (Symbol TestNonTerm TestTerm)]) : (Maybe TestTerm)
                  (case s
                    [(symbol/non-term _) (nothing)]
                    [(symbol/term t) (just t)]))
                (production-rhs-entries rhs)))
            (append* (dict-values rules)))))))



  (canonical-item-sets*
    (varargs list (item-set (set-add (make-set (item-cmp test-non-term-cmp test-term-cmp))
                                     init-item)))
    (make-unique-dict (item-set-cmp test-non-term-cmp test-term-cmp) state-id-cmp)
    0
    (append
      (map
        (lambda ([nt : TestNonTerm]) : (Symbol TestNonTerm TestTerm) (symbol/non-term nt))
        (set->list (dict-keys rules)))
      (map
        (lambda ([t : TestTerm]) : (Symbol TestNonTerm TestTerm) (symbol/term t))
        terms))
    rules))

(define (canonical-item-sets*
          [unprocessed-item-sets : (List (ItemSet TestNonTerm TestTerm))]
          [item-sets : (UniqueDict (ItemSet TestNonTerm TestTerm) StateId)]
          [next-state-id : Int]
          [symbols : (List (Symbol TestNonTerm TestTerm))]
          [rules : (Dict TestNonTerm (List (ProductionRHS TestNonTerm TestTerm)))])
  : (UniqueDict (ItemSet TestNonTerm TestTerm) StateId)
  (case unprocessed-item-sets
    [(empty) item-sets]
    [(cons is unprocessed-item-sets)
     (case (unique-dict-ref item-sets is)
       [(just _)
        (canonical-item-sets* unprocessed-item-sets item-sets next-state-id symbols rules)]
       [else
         (match-define full-items (closure is rules))
         (match-define next-sets
           (filter-map
             (lambda ([symbol : (Symbol TestNonTerm TestTerm)])
               (goto full-items symbol))
             symbols))
         (canonical-item-sets*
           (append next-sets unprocessed-item-sets)
           (unique-dict-add item-sets is (state-id next-state-id))
           (+ 1 next-state-id)
           symbols
           rules)])]))


(define (build-parser [rules : (List (ProductionRule TestNonTerm TestTerm))])
  : (Either Bytes (Parser TestNonTerm TestTerm))


  (match-define rules-dict (production-rules-dict rules))
  (match-define item-sets (canonical-item-sets (non-term/E) rules-dict))

  (match-define empty-table (build-empty-table rules-dict))
  (match-define first-table (build-first-table rules-dict empty-table))
  (match-define follow-table (build-follow-table rules-dict empty-table first-table))

  (match-define action-map-entries
    (unique-dict-map
      item-sets
      (lambda ([is : (ItemSet TestNonTerm TestTerm)]
               [s : StateId])
        : (Either Bytes (Tuple2 StateId (Dict (LiftedTerm TestTerm) (Action TestNonTerm))))
        (match-define full-set (closure is rules-dict))

        (match-define action-tuples
          (append*
            (map
              (lambda ([item : (Item TestNonTerm TestTerm)])
                : (List (Tuple2 (LiftedTerm TestTerm) (Action TestNonTerm)))
                (case item
                  [(item nt _ _ (cons (symbol/term term) _))
                   (case (goto full-set (symbol/term term))
                     [(nothing) (panic #"Bad goto")]
                     [(just next-is)
                      (case (unique-dict-ref item-sets next-is)
                        [(nothing) (panic #"Bad item set")]
                        [(just next-state)
                         (varargs list (tuple2 (lifted-term term) (shift next-state)))])])]
                  [(item nt _ _ (cons (symbol/non-term other-nt) _))
                   (empty)]
                  [(item (start-symbol) _ _ (empty))
                   (varargs list (tuple2 (end-of-terminals) (accept)))]
                  [(item (lifted-non-term nt) rule lhs (empty))
                   (map
                     (lambda ([term : (LiftedTerm TestTerm)])
                       : (Tuple2 (LiftedTerm TestTerm) (Action TestNonTerm))
                       (tuple2 term (reduce nt rule (length lhs))))
                     (set->list (dict-ref/panic follow-table nt)))]))
              (set->list full-set))))


        (match-define action-dict
          (foldl
            (lambda ([at : (Tuple2 (LiftedTerm TestTerm) (Action TestNonTerm))]
                     [acc : (Either Bytes (Dict (LiftedTerm TestTerm) (Action TestNonTerm)))])
              : (Either Bytes (Dict (LiftedTerm TestTerm) (Action TestNonTerm)))
              (case acc
                [(left v) (left v)]
                [(right dict)
                 (match-define (tuple2 term action) at)
                 (case (dict-ref dict term)
                   [(nothing) (right (dict-add dict term action))]
                   [(just existing-action)
                    (if ((action=? test-non-term=?) action existing-action)
                        acc
                        (left #"action conflict"))])]))
            action-tuples
            (ann
              (Either Bytes (Dict (LiftedTerm TestTerm) (Action TestNonTerm)))
              (right (make-dict (lifted-term-cmp test-term-cmp))))))
        (case action-dict
          [(left v) (left v)]
          [(right dict)
           (right (tuple2 s dict))]))))


  (match-define non-terminals (set->list (dict-keys rules-dict)))

  (match-define goto-table : (Dict StateId (Dict TestNonTerm StateId))
    (dict-add-all
      (make-dict state-id-cmp)
      (unique-dict-map
        item-sets
        (lambda ([is : (ItemSet TestNonTerm TestTerm)]
                 [s : StateId]) : (Tuple2 StateId (Dict TestNonTerm StateId))
          (match-define full-items (closure is rules-dict))
          (tuple2
            s
            (dict-add-all
              (make-dict test-non-term-cmp)
              (filter-map
                (lambda ([nt : TestNonTerm]) : (Maybe (Tuple2 TestNonTerm StateId))
                  (case (goto full-items (symbol/non-term nt))
                    [(nothing) (nothing)]
                    [(just next-state)
                     (case (unique-dict-ref item-sets next-state)
                       [(nothing) (panic #"Bad item set")]
                       [(just next-s)
                        (just (tuple2 nt next-s))])]))
                non-terminals)))))))

  (case (extract-rights action-map-entries)
    [(left v) (left v)]
    [(right action-map-entries)
     (match-define action-map : (Dict StateId (Dict (LiftedTerm TestTerm) (Action TestNonTerm)))
       (dict-add-all (make-dict state-id-cmp) action-map-entries))

     (right (parser action-map goto-table))]))


(define (test-kernel-items) : (Dict StateId (List (Item TestNonTerm TestTerm)))
  (match-define S* : (LiftedNonTerm TestNonTerm) (start-symbol))
  (match-define E* (lifted-non-term (non-term/E)))
  (match-define F* (lifted-non-term (non-term/F)))
  (match-define T* (lifted-non-term (non-term/T)))

  (match-define E : (Symbol TestNonTerm TestTerm) (symbol/non-term (non-term/E)))
  (match-define F : (Symbol TestNonTerm TestTerm) (symbol/non-term (non-term/F)))
  (match-define T : (Symbol TestNonTerm TestTerm) (symbol/non-term (non-term/T)))
  (match-define + : (Symbol TestNonTerm TestTerm) (symbol/term (term/plus)))
  (match-define * : (Symbol TestNonTerm TestTerm) (symbol/term (term/times)))
  (match-define < : (Symbol TestNonTerm TestTerm) (symbol/term (term/left-paren)))
  (match-define > : (Symbol TestNonTerm TestTerm) (symbol/term (term/right-paren)))
  (match-define id : (Symbol TestNonTerm TestTerm) (symbol/term (term/id)))

  (dict-add-all
    (make-dict state-id-cmp)
    (varargs list
      (tuple2 (state-id 0)
        (varargs list
          (item S* 0 (empty) (varargs list E))))
      (tuple2 (state-id 1)
        (varargs list
          (item S* 0 (varargs list E) (empty))
          (item E* 1 (varargs list E) (varargs list + T))))
      (tuple2 (state-id 2)
        (varargs list
          (item E* 2 (varargs list T) (empty))
          (item T* 3 (varargs list T) (varargs list * F))))
      (tuple2 (state-id 3)
        (varargs list
          (item T* 4 (varargs list F) (empty))))
      (tuple2 (state-id 4)
        (varargs list
          (item F* 5 (varargs list <) (varargs list E >))))
      (tuple2 (state-id 5)
        (varargs list
          (item F* 6 (varargs list id) (empty))))
      (tuple2 (state-id 6)
        (varargs list
          (item E* 1 (varargs list E +) (varargs list T))))
      (tuple2 (state-id 7)
        (varargs list
          (item T* 3 (varargs list T *) (varargs list F))))
      (tuple2 (state-id 8)
        (varargs list
          (item E* 1 (varargs list E) (varargs list + T))
          (item F* 5 (varargs list < E) (varargs list >))))
      (tuple2 (state-id 9)
        (varargs list
          (item E* 1 (varargs list E + T) (empty))
          (item T* 3 (varargs list T) (varargs list * F))))
      (tuple2 (state-id 10)
        (varargs list
          (item T* 3 (varargs list T * F) (empty))))
      (tuple2 (state-id 11)
        (varargs list
          (item F* 5 (varargs list < E >) (empty)))))))


(define (make-test-parser) : (Parser TestNonTerm TestTerm)
  (case (build-parser (test-production-rules))
    [(left v) (panic v)]
    [(right v) v]))


;(define (make-test-parser) : (Parser TestNonTerm TestTerm)
;  (match-define E (non-term/E))
;  (match-define F (non-term/F))
;  (match-define T (non-term/T))
;
;  (match-define + (lifted-term (term/plus)))
;  (match-define * (lifted-term (term/times)))
;  (match-define < (lifted-term (term/left-paren)))
;  (match-define > (lifted-term (term/right-paren)))
;  (match-define id (lifted-term (term/id)))
;  (match-define $ : (LiftedTerm TestTerm) (end-of-terminals))
;
;  (match-define r1 : (Action TestNonTerm) (reduce E 1 3))
;  (match-define r2 : (Action TestNonTerm) (reduce E 2 1))
;  (match-define r3 : (Action TestNonTerm) (reduce T 3 3))
;  (match-define r4 : (Action TestNonTerm) (reduce T 4 1))
;  (match-define r5 : (Action TestNonTerm) (reduce F 5 3))
;  (match-define r6 : (Action TestNonTerm) (reduce F 6 1))
;
;  (match-define action-state-entry
;    (lambda ([s : StateId]
;             [action-entries : (List (Tuple2 (LiftedTerm TestTerm) (Action TestNonTerm)))])
;      : (Tuple2 StateId (Dict (LiftedTerm TestTerm) (Action TestNonTerm)))
;      (tuple2
;        s
;        (dict-add-all (make-dict (lifted-term-cmp test-term-cmp)) action-entries))))
;
;  (match-define actions
;    : (Dict StateId (Dict (LiftedTerm TestTerm) (Action TestNonTerm)))
;    (dict-add-all
;      (make-dict state-id-cmp)
;      (varargs list
;        (action-state-entry (state-id 0)
;          (varargs list
;            (tuple2 id (shift (state-id 5)))
;            (tuple2 < (shift (state-id 4)))))
;        (action-state-entry (state-id 1)
;          (varargs list
;            (tuple2 + (shift (state-id 6)))
;            (tuple2 $ (accept))))
;        (action-state-entry (state-id 2)
;          (varargs list
;            (tuple2 + r2)
;            (tuple2 * (shift (state-id 7)))
;            (tuple2 > r2)
;            (tuple2 $ r2)))
;        (action-state-entry (state-id 3)
;          (varargs list
;            (tuple2 + r4)
;            (tuple2 * r4)
;            (tuple2 > r4)
;            (tuple2 $ r4)))
;        (action-state-entry (state-id 4)
;          (varargs list
;            (tuple2 id (shift (state-id 5)))
;            (tuple2 < (shift (state-id 4)))))
;        (action-state-entry (state-id 5)
;          (varargs list
;            (tuple2 + r6)
;            (tuple2 * r6)
;            (tuple2 > r6)
;            (tuple2 $ r6)))
;        (action-state-entry (state-id 6)
;          (varargs list
;            (tuple2 id (shift (state-id 5)))
;            (tuple2 < (shift (state-id 4)))))
;        (action-state-entry (state-id 7)
;          (varargs list
;            (tuple2 id (shift (state-id 5)))
;            (tuple2 < (shift (state-id 4)))))
;        (action-state-entry (state-id 8)
;          (varargs list
;            (tuple2 + (shift (state-id 6)))
;            (tuple2 > (shift (state-id 11)))))
;        (action-state-entry (state-id 9)
;          (varargs list
;            (tuple2 + r1)
;            (tuple2 * (shift (state-id 7)))
;            (tuple2 > r1)
;            (tuple2 $ r1)))
;        (action-state-entry (state-id 10)
;          (varargs list
;            (tuple2 + r3)
;            (tuple2 * r3)
;            (tuple2 > r3)
;            (tuple2 $ r3)))
;        (action-state-entry (state-id 11)
;          (varargs list
;            (tuple2 + r5)
;            (tuple2 * r5)
;            (tuple2 > r5)
;            (tuple2 $ r5))))))
;
;  (match-define goto-state-entry
;    (lambda ([s : StateId]
;             [goto-entries : (List (Tuple2 TestNonTerm StateId))])
;      : (Tuple2 StateId (Dict TestNonTerm StateId))
;      (tuple2
;        s
;        (dict-add-all (make-dict test-non-term-cmp) goto-entries))))
;
;  (match-define gotos
;    : (Dict StateId (Dict TestNonTerm StateId))
;    (dict-add-all
;      (make-dict state-id-cmp)
;      (varargs list
;        (goto-state-entry (state-id 0)
;          (varargs list
;            (tuple2 E (state-id 1))
;            (tuple2 T (state-id 2))
;            (tuple2 F (state-id 3))))
;        (goto-state-entry (state-id 4)
;          (varargs list
;            (tuple2 E (state-id 8))
;            (tuple2 T (state-id 2))
;            (tuple2 F (state-id 3))))
;        (goto-state-entry (state-id 6)
;          (varargs list
;            (tuple2 T (state-id 9))
;            (tuple2 F (state-id 3))))
;        (goto-state-entry (state-id 7)
;          (varargs list
;            (tuple2 F (state-id 10)))))))
;
;
;  (parser actions gotos))


(define (run-parser [lexer : (l:Lexer l:Token)]) : (Either Bytes (ParseTree l:Token))
  (case (lex-all lexer)
    [(left v) (left v)]
    [(right tokens)
     (match-define initial-state : (ParserState l:Token)
       (parser-state (varargs list (state-id 0)) (empty) tokens))
     (run-parser* initial-state (make-test-parser))]))

(define (run-parser* [state : (ParserState l:Token)] [parser : (Parser TestNonTerm TestTerm)])
  : (Either Bytes (ParseTree l:Token))
  (case (step-parser-state state parser)
    [(left v) (left v)]
    [(right (left next-state))
     (run-parser* next-state parser)]
    [(right (right tree))
     (right tree)]))


(define (step-parser-state [s : (ParserState l:Token)] [p : (Parser TestNonTerm TestTerm)])
  : (Either Bytes (Either (ParserState l:Token) (ParseTree l:Token)))
  (match-define (parser actions goto) p)
  (match-define (parser-state state-stack node-stack tokens) s)
  (match-define current-state : StateId
    (case state-stack
      [(cons s _) s]
      [(empty) (panic #"Cannot have empty state stack")]))
  (match-define term-type : (LiftedTerm TestTerm)
    (case tokens
      [(empty) (end-of-terminals)]
      [(cons (l:left-paren-token) _) (lifted-term (term/left-paren))]
      [(cons (l:right-paren-token) _) (lifted-term (term/right-paren))]
      [(cons (l:symbol-token _) _) (lifted-term (term/id))]
      [(cons (l:plus-token) _) (lifted-term (term/plus))]
      [(cons (l:multiplication-token) _) (lifted-term (term/times))]
      [_ (panic #"Bad token type")]))
  (case (dict-ref actions current-state)
    [(nothing) (left #"Found state with no actions")]
    [(just state-actions)
     (case (dict-ref state-actions term-type)
       [(nothing)
        (left (bytes-append (varargs list
          #"In state "
          (integer->decimal-bytes (state-id-v current-state))
          #", no action for "
          (case term-type
            [(end-of-terminals) #"$"]
            [(lifted-term (term/plus)) #"+"]
            [(lifted-term (term/times)) #"*"]
            [(lifted-term (term/left-paren)) #"("]
            [(lifted-term (term/right-paren)) #")"]
            [(lifted-term (term/id)) #"id"]))))]
       [(just (shift next-state))
        (case tokens
          [(empty) (left #"Cannot shift when at end of terminals.")]
          [(cons token tokens)
           (right
             (left
               (parser-state
                 (cons next-state state-stack)
                 (cons (terminal-node token) node-stack)
                 tokens)))])]
       [(just (accept))
        (case node-stack
          [(empty) (left #"Cannot have empty node stack at accept")]
          [(cons _ (cons _ _)) (left #"Cannot have long node stack at accept")]
          [(cons node (empty))
           (right (right node))])]
       [(just (reduce non-term rule num-symbols))
        (match-define (tuple2 sub-trees shortened-node-stack) (pop-n num-symbols node-stack))
        (match-define shortened-state-stack (drop num-symbols state-stack))
        (match-define top-state : StateId
          (case shortened-state-stack
            [(cons s _) s]
            [(empty) (panic #"Cannot have empty state stack")]))
        (case (dict-ref goto top-state)
          [(nothing) (left #"Found state with no goto")]
          [(just state-goto)
           (case (dict-ref state-goto non-term)
             [(nothing) (left #"No goto found for non-term")]
             [(just next-state)
              (right
                (left
                  (parser-state
                    (cons next-state shortened-state-stack)
                    (cons (non-terminal-node rule sub-trees) shortened-node-stack)
                    tokens)))])])])]))


(define (lex-all [lexer : (l:Lexer l:Token)]) : (Either Bytes (List l:Token))
  (lex-all* lexer (empty)))

(define (lex-all* [lexer : (l:Lexer l:Token)] [acc : (List l:Token)])
  : (Either Bytes (List l:Token))
  (case (l:run-lexer lexer)
    [(l:end-of-input _) (right (reverse acc))]
    [(l:bad-input msg src)
     (left (bytes-append
             (varargs list
               (source-span->start-location-bytes src)
               #": " msg)))]
    [(l:lex-result (source-span-annotated t _) lexer) (lex-all* lexer (cons t acc))]))

;; Like split-at, but reverses the taken elements
(define [A] (pop-n [num : Int] [l : (List A)]) : (Tuple2 (List A) (List A))
  (pop-n* num l (empty)))

(define [A] (pop-n* [num : Int] [l : (List A)] [acc : (List A)]) : (Tuple2 (List A) (List A))
  (if (= num 0)
      (tuple2 acc l)
      (case l
        [(empty) (panic #"Cannot pop from empty list")]
        [(cons e l) (pop-n* (- num 1) l (cons e acc))])))

