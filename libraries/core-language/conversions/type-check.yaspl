#:module (core-language conversions type-check)
#:import {
  (bytes)
  {(core-language languages resolved-types-language)
    {#:types
      [Expression rt:Expression]
      [FunctionDefinition rt:FunctionDefinition]
      [Module rt:Module]
      [Statement rt:Statement]
    }
    {#:values
      [function-definition-name rt:function-definition-name]
      import-external-type
    }
    {#:patterns
      [array-index-expr rt:array-index-expr]
      [assignment-statement rt:assignment-statement]
      [bin-op-expr rt:bin-op-expr]
      [bytes-expr rt:bytes-expr]
      [call-expr rt:call-expr]
      [cast-expr rt:cast-expr]
      [define-local-variable-statement rt:define-local-variable-statement]
      [deref-expr rt:deref-expr]
      [effect-statement rt:effect-statement]
      [function-definition rt:function-definition]
      [if-statement rt:if-statement]
      [int-expr rt:int-expr]
      [module rt:module]
      [pointer-assignment-statement rt:pointer-assignment-statement]
      [return-statement rt:return-statement]
      [struct-field-expr rt:struct-field-expr]
      [var-expr rt:var-expr]
      [while-statement rt:while-statement]
    }
  }
  (core-language languages type-checked-language)
  (dict)
  (either)
  (list)
  (maybe)
  (prim)
  (prim-types)
  (set)
  (sexp-printer)
  (tuples)
  (types)
  (yaspl math-operations)
}
(export
  (#:types)
  (#:values type-check)
  (#:patterns))
(types
  (define-type GlobalEnvironment
    (global-environment
      [var-types : (Dict Bytes Type)]))
  (define-type Environment
    (environment
      [return-type : Type]
      [var-types : (Dict Bytes Type)])))

(define (type-check [mod : rt:Module]) : (Either Bytes Module)
  (match-define (rt:module name imports functions) mod)

  (match-define function-names
    (set-add-all (make-set bytes-cmp) (map rt:function-definition-name functions)))


  (if (not (= (set-count function-names) (length functions)))
      (left #"Duplicate function name")
      (let ([local-function-types
             (ann (Dict Bytes Type)
               (dict-add-all
                 (make-dict bytes-cmp)
                 (map
                   (lambda ([f : rt:FunctionDefinition])
                     (match-define (rt:function-definition name parameters return-type _) f)
                     (tuple2
                       name
                       (fun-type
                         (empty)
                         (map parameter-type parameters)
                         return-type)))
                   functions)))])
        (match-define imported-function-types
          (dict-value-map
            imports
            import-external-type))
        (match-define env
          (global-environment (merge-dicts imported-function-types
                                           local-function-types)))
        (case (map/failure/env type-check/function functions env)
          [(left v) (left v)]
          [(right functions)
           (right (module name imports functions))]))))



(define (type-check/function [f : rt:FunctionDefinition] [env : GlobalEnvironment])
  : (Either Bytes FunctionDefinition)
  (match-define (rt:function-definition name parameters return-type body) f)

  (match-define initial-var-types : (Dict Bytes Type)
    (dict-add-all
      (global-environment-var-types env)
      (map
        (lambda ([p : Parameter])
          (match-define (parameter name type) p)
          (tuple2 name type))
        parameters)))

  (match-define env (environment return-type initial-var-types))

  (case (type-check/statements body env)
    [(left v) (left v)]
    [(right body)
     (right (function-definition name parameters return-type body))]))


(define (type-check/statements [ss : (List rt:Statement)] [env : Environment])
  : (Either Bytes (List Statement))
  (case ss
    [(empty) (right (empty))]
    [(cons s ss)
     (case (type-check/statement s env)
       [(left v) (left v)]
       [(right (tuple2 s env))
        (case (type-check/statements ss env)
          [(left v) (left v)]
          [(right ss)
           (right (cons s ss))])])]))

(define (type-check/statement [s : rt:Statement] [env : Environment])
  : (Either Bytes (Tuple2 Statement Environment))
  (case s
    [(rt:return-statement e)
     (case (type-check/expression e (environment-return-type env) env)
       [(left v) (left v)]
       [(right e)
        (right (tuple2 (return-statement e) env))])]
    [(rt:define-local-variable-statement v type e)
     (case (type-check/expression e type env)
       [(left v) (left v)]
       [(right e)
        (match-define env (environment-add-local env v type))
        (right (tuple2 (define-local-variable-statement v type e) env))])]
    [(rt:assignment-statement v e)
     (case (dict-ref (environment-var-types env) v)
       [(nothing)
        (left #"Cannot assign to unbound variable.")]
       [(just ty)
        (case (type-check/expression e ty env)
          [(left v) (left v)]
          [(right e)
           (right (tuple2 (assignment-statement v e) env))])])]
    [(rt:effect-statement e)
     (case (type-infer/expression e env)
       [(left v) (left v)]
       [(right (tuple2 e _))
        (right (tuple2 (effect-statement e) env))])]
    [(rt:pointer-assignment-statement p e)
     (case (type-infer/expression p env)
       [(left v) (left v)]
       [(right (tuple2 p p-ty))
        (case (pointer-type->element-type p-ty)
          [(nothing)
           (left (bytes-append
                   (varargs list
                     #"Expected Pointer Type, got: "
                     (print-sexp (type->sexp p-ty)))))]
          [(just e-ty)
           (case (type-check/expression e e-ty env)
             [(left v) (left v)]
             [(right e)
              (right (tuple2 (pointer-assignment-statement p e) env))])])])]
    [(rt:while-statement e body)
     (case (type-check/expression e (boolean-type) env)
       [(left v) (left v)]
       [(right e)
        (case (type-check/statements body env)
          [(left v) (left v)]
          [(right body)
           (right (tuple2 (while-statement e body) env))])])]
    [(rt:if-statement c t f)
     (case (type-check/expression c (boolean-type) env)
       [(left v) (left v)]
       [(right c)
        (case (type-check/statements t env)
          [(left v) (left v)]
          [(right t)
           (case (type-check/statements f env)
             [(left v) (left v)]
             [(right f)
              (right (tuple2 (if-statement c t f) env))])])])]))

(define (type-check/expression [e : rt:Expression] [expected-type : Type] [env : Environment])
  : (Either Bytes Expression)
  (case (type-infer/expression e env)
    [(left v) (left v)]
    [(right (tuple2 e actual-type))
     (if (type=? actual-type expected-type)
         (right e)
         (left
           (bytes-append
             (varargs list
               #"Types don't match:\nGot: "
               (print-sexp (type->sexp actual-type))
               #"\nExpected: "
               (print-sexp (type->sexp expected-type))))))]))

(define (type-infer/expression [e : rt:Expression] [env : Environment])
  : (Either Bytes (Tuple2 Expression Type))
  (case e
    [(rt:int-expr i)
     (right (tuple2 (int-expr i) (u64-type)))]
    [(rt:bytes-expr b)
     (right (tuple2 (bytes-expr b) (bytes-type)))]
    [(rt:cast-expr t e)
     (case (type-infer/expression e env)
       [(left v) (left v)]
       [(right (tuple2 e _))
        (right (tuple2 e t))])]
    [(rt:array-index-expr a i)
     (case (type-infer/expression a env)
       [(left v) (left v)]
       [(right (tuple2 a pa-ty))
        (case (pointer-type->element-type pa-ty)
          [(nothing)
           (left (bytes-append
                   (varargs list
                     #"Expected Pointer Type, got: "
                     (print-sexp (type->sexp pa-ty)))))]
          [(just a-ty)
           (case (array-type->element-type a-ty)
             [(nothing)
              (left (bytes-append
                      (varargs list
                        #"Expected Array Type, got: "
                        (print-sexp (type->sexp a-ty)))))]
             [(just elem-ty)
              (case (type-check/expression i (u64-type) env)
                [(left v) (left v)]
                [(right i)
                 (right (tuple2 (array-index-expr a elem-ty i) (pointer-type elem-ty)))])])])])]
    [(rt:struct-field-expr e _f)
     ;; TODO actually resolve the field access
     (type-infer/expression e env)]
    [(rt:var-expr v)
     (case (dict-ref (environment-var-types env) v)
       [(nothing)
        (left (bytes-append (varargs list #"Unbound variable: " v)))]
       [(just ty)
        (right (tuple2 (var-expr v) ty))])]
    [(rt:bin-op-expr (numeric-bin-op op) l r)
     (case (type-check/expression l (u64-type) env)
       [(left v) (left v)]
       [(right l)
        (case (type-check/expression r (u64-type) env)
          [(left v) (left v)]
          [(right r)
           (right (tuple2 (bin-op-expr (numeric-bin-op op) l r) (u64-type)))])])]
    [(rt:bin-op-expr (comparison-bin-op op) l r)
     (case (type-check/expression l (u64-type) env)
       [(left v) (left v)]
       [(right l)
        (case (type-check/expression r (u64-type) env)
          [(left v) (left v)]
          [(right r)
           (right (tuple2 (bin-op-expr (comparison-bin-op op) l r) (boolean-type)))])])]
    [(rt:bin-op-expr (logical-bin-op op) l r)
     (case (type-check/expression l (boolean-type) env)
       [(left v) (left v)]
       [(right l)
        (case (type-check/expression r (boolean-type) env)
          [(left v) (left v)]
          [(right r)
           (right (tuple2 (bin-op-expr (logical-bin-op op) l r) (boolean-type)))])])]
    [(rt:deref-expr e)
     (case (type-infer/expression e env)
       [(left v) (left v)]
       [(right (tuple2 e e-ty))
        (case (pointer-type->element-type e-ty)
          [(nothing)
           (left (bytes-append
                   (varargs list
                     #"Expected Pointer Type, got: "
                     (print-sexp (type->sexp e-ty)))))]
          [(just elem-ty)
           (right (tuple2 (deref-expr e) elem-ty))])])]
    [(rt:call-expr f args)
     (case (type-infer/expression f env)
       [(left v) (left v)]
       [(right (tuple2 f f-type))
        (case f-type
          [(fun-type (empty) arg-types return-type)
           (case (zip args arg-types)
             [(nothing)
              (left #"Function must be called with right number of arguments.")]
             [(just arg-tuples)
              (case (extract-rights (map (lambda ([arg-ty : (Tuple2 rt:Expression Type)])
                                           (match-define (tuple2 arg ty) arg-ty)
                                           (type-check/expression arg ty env)) arg-tuples))
                [(left v) (left v)]
                [(right args)
                 (right (tuple2 (call-expr f args) return-type))])])]
          [(fun-type _ _ _)
           (left #"Cannot call polymorphic function")]
          [_
           (left #"Cannot call non function")])])]))

(define (environment-add-local [env : Environment] [v : Bytes] [ty : Type])
  : Environment
  (match-define (environment return-type vars) env)
  (environment return-type (dict-set vars v ty)))
