#:module (core-language source-to-register)
#:import {
  (block-number)
  (bytes)
  (core-language source-language)
  (data indexed-set)
  (dict)
  (list)
  (maybe)
  (module-signature)
  (prim)
  (prim-language register-language-builder)
  (prim-types)
  {(register-language)
    {#:types
      [FunctionDefinition r:FunctionDefinition]
    }
    {#:values
      basic-block-number
      bin-op-inst
      block-call
      closure-call
      cond-jump
      eight-byte-mem-op
      fixed-pointer-offset
      [function-definition r:function-definition]
      halt
      int-literal
      jump
      jump-target
      negated-var-condition
      plain-function-convention
      pointer-ref-inst
      pointer-set!-inst
      [return r:return]
      symbol-address-inst
    }
  }
  (set)
  (top-level-name)
  (tuples)
  (types)
  {(yaspl intermediate-to-register)
    {#:values
      mangle-top-level-name
    }
  }
  (yaspl math-operations)
  (yaspl top-level-objects)
  (yaspl var)
}
(export
  (#:types)
  (#:values
     module-to-top-level-objects
     module->module-signature)
  (#:patterns))
(types
  (define-type Environment
    (environment
      [vars : (Dict Bytes Var)]
      [globals : (Dict Bytes Global)]))
  (define-type Global
    (global/top-level [v : TopLevelName])
    (global/external [v : Bytes])))



(define (module-to-top-level-objects [mod : Module]) : (List TopLevelObject)
  (match-define (module mod-name definitions) mod)

  (match-define globals : (Dict Bytes Global)
    (dict-add-all
      (make-dict bytes-cmp)
      (map
        (lambda ([def : Definition]) : (Tuple2 Bytes Global)
          (case def
            [(function-definition name _params _statements)
             (match-define tl-closure-name
               (top-level-name mod-name (bytes-append (varargs list name #"_closure"))))
             (tuple2 name (global/top-level tl-closure-name))]
            [(external-definition name)
             (tuple2 name (global/external name))]))
        definitions)))

  (append*
    (map
      (lambda ([def : Definition]) : (List TopLevelObject)
        (case def
          [(function-definition name _params _statements)
           (match-define tl-name (top-level-name mod-name name))
           (match-define tl-closure-name
             (top-level-name mod-name (bytes-append (varargs list name #"_closure"))))
           (varargs list
             (register-function-tlo
               (mangle-top-level-name tl-name)
               (convert-function def globals))
             (trivial-closure-tlo
               (mangle-top-level-name tl-closure-name)
               (mangle-top-level-name tl-name)))]
          [(external-definition _)
           (empty)]))
      definitions)))

(define (module->module-signature [mod : Module]) : ModuleSignature
  (match-define (module mod-name definitions) mod)

  (match-define values : (Dict Bytes ValueSignature)
    (dict-add-all
      (make-dict bytes-cmp)
      (filter-map
        (lambda ([def : Definition]) : (Maybe (Tuple2 Bytes ValueSignature))
          (case def
            [(function-definition name params _statements)
             (match-define tl-closure-name
               (top-level-name mod-name (bytes-append (varargs list name #"_closure"))))
             (match-define arg-types
               (map
                 (lambda ([p : Parameter])
                   (case p
                     [(parameter _name (pointer-pre-type _))
                      (bytes-type)]
                     [(parameter _name (array-pre-type _))
                      (u64-type)]
                     [(parameter _name (var-pre-type _))
                      (u64-type)]))
                 params))
             (just
               (tuple2
                 name
                 (value-signature
                   (fun-type (empty) arg-types (u64-type))
                   tl-closure-name)))]
            [(external-definition _)
             (nothing)]))
        definitions)))


  (module-signature
    mod-name
    values
    (make-dict bytes-cmp) ;; Patterns
    (make-dict bytes-cmp) ;; Types
    (make-dict bytes-cmp) ;; Static Bindings
    (make-dict top-level-name-cmp) ;; Static Info
    ))


(define (convert-function [f : Definition] [globals : (Dict Bytes Global)])
  : r:FunctionDefinition
  (case f
    [(function-definition _name args statements)
     (match-define acc (block-accumulator (initial-var-number) (initial-block-number)
                                          (make-indexed-set basic-block-number block-number-cmp)))
     (match-define (tuple2 freshened-args acc)
       (map/state fresh-name* (map parameter-name args) acc))
     (match-define env
       (add-all-args freshened-args (environment (make-dict bytes-cmp) globals)))

     (match-define (tuple2 start-block-num acc) (fresh-block-number* acc))
     (match-define acc (start-block start-block-num (map new-arg freshened-args) acc))

     (match-define (tuple2 acc _env)
       (convert-statements statements acc env))
     (match-define (block-accumulator next-var next-block blocks) (add-terminal acc (halt)))

     (r:function-definition
       (plain-function-convention (length args) start-block-num)
       blocks next-var next-block)]
    [(external-definition _)
     (panic #"Cannot convert external definition")]))


(define (convert-statements
          [statements : (List Statement)]
          [acc : Accumulator]
          [env : Environment])
  : (Tuple2 Accumulator Environment)
  (case statements
    [(empty) (tuple2 acc env)]
    [(cons statement statements)
     (case (convert-statement statement acc env)
       [(tuple2 acc env)
        (convert-statements statements acc env)])]))

(define (convert-statement
          [statement : Statement]
          [acc : Accumulator]
          [env : Environment])
  : (Tuple2 Accumulator Environment)
  (case statement
    [(return-statement expr)
     (match-define (tuple2 temp acc)
       (convert-expr #"ret" expr acc env))
     (match-define (tuple2 block-num acc) (fresh-block-number acc))
     (tuple2
       (start-block block-num (empty) (add-terminal acc (r:return temp)))
       env)]
    [(define-local-variable-statement var _type expr)
     (match-define (tuple2 val acc)
       (convert-expr var expr acc env))
     (tuple2 acc (env-add env var val))]
    [(assignment-statement var expr)
     (match-define (tuple2 val acc)
       (convert-expr var expr acc env))
     (tuple2 acc (env-replace env var val))]
    [(pointer-assignment-statement pointer expr)
     (match-define (tuple2 p acc)
       (convert-expr #"ptr" pointer acc env))
     (match-define (tuple2 e acc)
       (convert-expr #"val" expr acc env))
     (tuple2
       (add-instruction acc (pointer-set!-inst (eight-byte-mem-op) p (fixed-pointer-offset 0) e))
       env)]
    [(if-statement cond t-statements f-statements)

     (match-define (tuple2 branch-var acc)
       (convert-expr #"cond" cond acc env))
     (match-define (tuple2 t-block-num acc) (fresh-block-number acc))
     (match-define (tuple2 f-block-num acc) (fresh-block-number acc))
     (match-define acc
       (add-terminal acc (cond-jump (negated-var-condition branch-var)
                                    (jump-target f-block-num (empty))
                                    (jump-target t-block-num (empty)))))

     ;; Get the two pending basic blocks without their final terminators
     (match-define (tuple2 acc t-env)
       (convert-statements t-statements (start-block t-block-num (empty) acc) env))
     (match-define (tuple2 t-block acc) (split-accumulator acc))
     (match-define (tuple2 acc f-env)
       (convert-statements f-statements (start-block f-block-num (empty) acc) env))
     (match-define (tuple2 f-block acc) (split-accumulator acc))

     ;; Figure out the differing variables so that they can be joined.
     (match-define mut-vars (get-differing-vars env t-env f-env))
     (match-define t-mut-vars (env-ref* t-env mut-vars))
     (match-define f-mut-vars (env-ref* f-env mut-vars))

     (match-define (tuple2 c-block-num acc) (fresh-block-number* acc))

     (match-define acc
       (add-terminal* acc t-block (jump (jump-target c-block-num t-mut-vars))))
     (match-define acc
       (add-terminal* acc f-block (jump (jump-target c-block-num f-mut-vars))))

     (match-define (tuple2 fresh-mut-args acc)
       (map/state fresh-name* mut-vars acc))

     (tuple2
       (start-block c-block-num (map new-arg fresh-mut-args) acc)
       (replace-all-args fresh-mut-args env))]
    [(while-statement cond body)

     (match-define (tuple2 header-block-num acc) (fresh-block-number acc))
     (match-define mut-vars (set->list (mutated-vars/statements body)))
     (match-define acc
       (add-terminal acc (jump (jump-target header-block-num (env-ref* env mut-vars)))))

     (match-define (tuple2 fresh-mut-args acc)
       (map/state fresh-name* mut-vars acc))

     (match-define acc (start-block header-block-num (map new-arg fresh-mut-args) acc))
     (match-define header-env (replace-all-args fresh-mut-args env))

     (match-define (tuple2 branch-var acc)
       (convert-expr #"cond" cond acc header-env))
     (match-define (tuple2 header-block acc) (split-accumulator acc))

     (match-define (tuple2 body-block-num acc) (fresh-block-number* acc))
     (match-define (tuple2 acc body-env)
       (convert-statements
         body
         (start-block body-block-num (empty) acc)
         header-env))
     (match-define (tuple2 body-block acc) (split-accumulator acc))

     (match-define (tuple2 after-block-num acc) (fresh-block-number* acc))

     (match-define acc
       (add-terminal*
         (add-terminal* acc header-block (cond-jump (negated-var-condition branch-var)
                                                    (jump-target after-block-num (empty))
                                                    (jump-target body-block-num (empty))))
         body-block (jump (jump-target header-block-num (env-ref* body-env mut-vars)))))

     (tuple2
       (start-block after-block-num (empty) acc)
       header-env)]))


(define (convert-exprs
          [base-name : Bytes]
          [exprs : (List Expression)]
          [acc : Accumulator]
          [env : Environment])
  : (Tuple2 (List Var) Accumulator)
  (case exprs
    [(empty) (tuple2 (empty) acc)]
    [(cons expr exprs)
     (case (convert-expr base-name expr acc env)
       [(tuple2 var acc)
        (case (convert-exprs base-name exprs acc env)
          [(tuple2 vars acc)
           (tuple2 (cons var vars) acc)])])]))

(define (convert-expr
          [base-name : Bytes]
          [expr : Expression]
          [acc : Accumulator]
          [env : Environment])
  : (Tuple2 Var Accumulator)
  (case expr
    [(var-expr name)
     (case (maybe-env-ref env name)
       [(just v) (tuple2 v acc)]
       [(nothing)
        (case (global-env-ref env name)
          [(just (global/top-level top-level-name))
           (match-define sym (mangle-top-level-name top-level-name))
           (match-define (top-level-name _mod-name local) top-level-name)
           (match-define (tuple2 (tuple2 _ var) acc) (fresh-name local acc))
           (tuple2 var (add-instruction acc (symbol-address-inst var sym)))]
          [(just (global/external sym))
           (match-define (tuple2 (tuple2 _ var) acc) (fresh-name base-name acc))
           (tuple2 var (add-instruction acc (symbol-address-inst var sym)))]
          [(nothing)
           (panic #"Unbound variable")])])]
    [(int-expr v)
     (match-define (tuple2 (tuple2 _ name) acc) (fresh-name base-name acc))
     (tuple2
       name
       (add-instruction acc (int-literal name v)))]
    [(bin-op-expr op l r)
     (match-define (tuple2 left-res acc) (convert-expr #"tmp" l acc env))
     (match-define (tuple2 right-res acc) (convert-expr #"tmp" r acc env))
     (match-define (tuple2 (tuple2 _ name) acc) (fresh-name base-name acc))
     (tuple2
       name
       (add-instruction acc (bin-op-inst name op left-res right-res)))]
    [(cast-expr _t e)
     (convert-expr base-name e acc env)]
    [(deref-expr e)
     (match-define (tuple2 p acc) (convert-expr #"ptr" e acc env))
     (match-define (tuple2 (tuple2 _ name) acc) (fresh-name base-name acc))
     (tuple2 name (add-instruction acc (pointer-ref-inst name (eight-byte-mem-op) p
                                                              (fixed-pointer-offset 0))))]
    [(array-index-expr ptr offset)
     (match-define (tuple2 ptr acc) (convert-expr #"ptr" ptr acc env))
     (match-define (tuple2 offset acc) (convert-expr #"off" offset acc env))
     (match-define (tuple2 (tuple2 _ size-name) acc) (fresh-name #"size" acc))
     (match-define (tuple2 (tuple2 _ offset-mul-name) acc) (fresh-name #"offset-mul" acc))
     (match-define (tuple2 (tuple2 _ name) acc) (fresh-name base-name acc))


     (tuple2 name
             (add-instruction
               (add-instruction
                 (add-instruction
                   acc
                   (int-literal size-name 8))
                 (bin-op-inst offset-mul-name (numeric-bin-op (mult-op)) offset size-name))
               (bin-op-inst name (numeric-bin-op (add-op)) ptr offset-mul-name)))]
    [(call-expr f args)
     (match-define (tuple2 fun acc) (convert-expr #"fun" f acc env))
     (match-define (tuple2 vars acc) (convert-exprs #"arg" args acc env))
     (match-define (tuple2 (tuple2 _ name) acc) (fresh-name base-name acc))
     (match-define (tuple2 block-num acc) (fresh-block-number acc))
     (match-define acc (add-terminal acc (block-call (closure-call fun) vars block-num)))
     (match-define acc (start-block block-num (varargs list name) acc))
     (tuple2 name acc)]
    ))


(define (mutated-vars/statements [ss : (List Statement)]) : (Set Bytes)
  (foldl mutated-vars* ss (make-set bytes-cmp)))

(define (mutated-vars* [s : Statement] [acc : (Set Bytes)]) : (Set Bytes)
  (case s
    [(return-statement _) acc]
    [(define-local-variable-statement _ _ _)  acc]
    [(pointer-assignment-statement _ _) acc]
    [(assignment-statement v _) (set-add acc v)]
    [(while-statement _ body) (foldl mutated-vars* body acc)]
    [(if-statement _ then else)
     (foldl mutated-vars* else (foldl mutated-vars* then acc))]))

(define (add-all-args [args : (List (Tuple2 Bytes Var))] [env : Environment]) : Environment
  (case env
    [(environment vars globals)
     (environment (dict-add-all vars args) globals)]))

(define (replace-all-args [args : (List (Tuple2 Bytes Var))] [env : Environment]) : Environment
  (case env
    [(environment vars globals)
     (environment (dict-replace-all vars args) globals)]))

(define (get-differing-vars [base-env : Environment] [env1 : Environment] [env2 : Environment])
  : (List Bytes)
  (match-define vars (environment-vars base-env))
  (filter
    (lambda ([name : Bytes]) : Boolean
      (not (var=? (env-ref env1 name) (env-ref env2 name))))
    (set->list (dict-keys vars))))

(define (env-ref [env : Environment] [name : Bytes]) : Var
  (dict-ref/panic (environment-vars env) name))

(define (maybe-env-ref [env : Environment] [name : Bytes]) : (Maybe Var)
  (dict-ref (environment-vars env) name))

(define (global-env-ref [env : Environment] [name : Bytes]) : (Maybe Global)
  (dict-ref (environment-globals env) name))


(define (env-ref* [env : Environment] [names : (List Bytes)]) : (List Var)
  (map (lambda ([name : Bytes]) (env-ref env name)) names))

(define (env-add [env : Environment] [name : Bytes] [var : Var]) : Environment
  (case env
    [(environment vars globals)
     (environment (dict-add vars name var) globals)]))

(define (env-replace [env : Environment] [name : Bytes] [var : Var]) : Environment
  (case env
    [(environment vars globals)
     (environment (dict-replace vars name var) globals)]))
