#:module (core-language core-parser)
#:import {
  (bytes)
  (core-language lexer)
  (core-language lr-parser)
  (data ordering)
  (either)
  (list)
  (numbers)
  {(prim)
    {#:types
      Bytes
      Int
    }
    {#:values
      panic
    }
  }
  (tuples)
}
(export
  (#:types)
  (#:values make-expr-parser)
  (#:patterns))
(types
  (define-type CoreNonTerm
    (non-term/E)
    (non-term/Module)
    (non-term/Definitions)
    (non-term/Definition)

    ;(non-term/F)
    ;(non-term/T)
    ;(non-term/Type)
    ;(non-term/Statement)
    ;(non-term/Statements)
    )
  (define-type CoreTerm
    (term/punctuation [p : Punctuation])
    (term/language-keyword [v : Bytes])
    (term/id)
    (term/number))

  (define-type Expr
    ;(bin-op-expr [op : BinOp] [l : Expr] [r : Expr])
    ;(var-expr [var : Bytes])
    (int-expr [v : Int]))

  (define-type Definition
    (function-definition [name : Bytes]))

  (define-type Form
    (form/module [name : Bytes])
    (form/definitions [ds : (List Definition)])
    (form/definition [d : Definition])

    ;(form/statement [s : Statement])
    ;(form/statements [ss : (List Statement)])
    (form/expr [e : Expr])
    ;(form/type [t : Type])
    (form/token [t : Token])))


(define (core-term-cmp [l : CoreTerm] [r : CoreTerm]) : Ordering
  (case (tuple2 l r)
    [(tuple2 (term/punctuation l) (term/punctuation r))
     (punctuation-cmp l r)]
    [(tuple2 (term/punctuation _) _)
     (less-than)]
    [(tuple2 _ (term/punctuation _))
     (greater-than)]
    [(tuple2 (term/language-keyword l) (term/language-keyword r))
     (bytes-cmp l r)]
    [(tuple2 (term/language-keyword _) _)
     (less-than)]
    [(tuple2 _ (term/language-keyword _))
     (greater-than)]
    [(tuple2 (term/id) (term/id))
     (equal-to)]
    [(tuple2 (term/id) _)
     (less-than)]
    [(tuple2 _ (term/id))
     (greater-than)]
    [(tuple2 (term/number) (term/number))
     (equal-to)]))

(define (core-non-term-cmp [a : CoreNonTerm] [b : CoreNonTerm]) : Ordering
  (match-define convert
    (lambda ([v : CoreNonTerm])
      (case v
        [(non-term/E) 0]
        [(non-term/Module) 1]
        [(non-term/Definitions) 2]
        [(non-term/Definition) 3]
        ;[(non-term/T) 2]
        ;[(non-term/Type) 3]
        ;[(non-term/Statement) 4]
        ;[(non-term/Statements) 5]
        )))
  (int-cmp (convert a) (convert b)))



(define (token->terminal [token : Token]) : (Either Bytes CoreTerm)
  (case token
    [(punctuation-token p) (right (term/punctuation p))]
    [(symbol-token _) (right (term/id))]
    [(decimal-number-token _) (right (term/number))]
    [(keyword-token k)
     (case k
       [#"module" (right (term/language-keyword k))]
       [#"define_function" (right (term/language-keyword k))]
       [_ (left #"Bad keyword token")])]
    [_ (left #"Bad token type")]))


(define (core-production-rules) : (List (ProductionRule CoreNonTerm CoreTerm Form))
  (match-define Module* (non-term/Module))
  (match-define Definitions* (non-term/Definitions))
  (match-define Definition* (non-term/Definition))
  ;(match-define E* (non-term/E))
  ;(match-define F* (non-term/F))
  ;(match-define T* (non-term/T))
  ;(match-define Type* (non-term/Type))
  ;(match-define S* (non-term/Statement))
  ;(match-define Ss* (non-term/Statements))

  (match-define symbol/term
    (lambda ([x : CoreTerm]) : (Symbol CoreNonTerm CoreTerm)
      (symbol/term x)))
  (match-define symbol/non-term
    (lambda ([x : CoreNonTerm]) : (Symbol CoreNonTerm CoreTerm)
      (symbol/non-term x)))

  ;(match-define E (symbol/non-term (non-term/E)))
  (match-define Definitions (symbol/non-term (non-term/Definitions)))
  (match-define Definition (symbol/non-term (non-term/Definition)))

  ;(match-define F (symbol/non-term (non-term/F)))
  ;(match-define T (symbol/non-term (non-term/T)))
  ;(match-define Type (symbol/non-term (non-term/Type)))
  ;(match-define S (symbol/non-term (non-term/Statement)))
  ;(match-define Ss (symbol/non-term (non-term/Statements)))
  ;(match-define + (symbol/term (term/punctuation (punct/plus))))
  ;(match-define - (symbol/term (term/punctuation (punct/minus))))
  ;(match-define * (symbol/term (term/punctuation (punct/multiplication))))
  ;(match-define / (symbol/term (term/punctuation (punct/division))))
  ;(match-define paren-< (symbol/term (term/punctuation (punct/left-paren))))
  ;(match-define >-paren (symbol/term (term/punctuation (punct/right-paren))))
  ;(match-define brace-< (symbol/term (term/punctuation (punct/left-brace))))
  ;(match-define >-brace (symbol/term (term/punctuation (punct/right-brace))))
  ;(match-define := (symbol/term (term/punctuation (punct/assignment))))
  ;(match-define !  (symbol/term (term/punctuation (punct/bang))))
  ;(match-define while (symbol/term (term/language-keyword #"while")))
  (match-define module-keyword (symbol/term (term/language-keyword #"module")))
  (match-define define-function-keyword (symbol/term (term/language-keyword #"define_function")))

  (match-define id (symbol/term (term/id)))
  ;(match-define num (symbol/term (term/number)))

  ;(match-define bin-op*
  ;  (lambda ([forms : (List Form)]) : Form
  ;    (case forms
  ;      [(cons (form/expr l) (cons (form/token t) (cons (form/expr r) (empty))))
  ;       (match-define op : BinOp
  ;         (case t
  ;           [(punctuation-token (punct/plus)) (op/plus)]
  ;           [(punctuation-token (punct/minus)) (op/minus)]
  ;           [(punctuation-token (punct/division)) (op/divide)]
  ;           [(punctuation-token (punct/multiplication)) (op/times)]
  ;           [_ (panic #"Bad bin op token")]))
  ;       (form/expr (bin-op-expr op l r))]
  ;      [_ (panic #"Bad forms for bin-op")])))

  ;(match-define identity*
  ;  (lambda ([forms : (List Form)]) : Form
  ;    (case forms
  ;      [(cons f (empty))
  ;       f]
  ;      [_ (panic #"Bad forms for identity")])))

  ;(match-define parens*
  ;  (lambda ([forms : (List Form)]) : Form
  ;    (case forms
  ;      [(cons _lparen (cons f (cons _rparen (empty))))
  ;       f]
  ;      [_ (panic #"Bad forms for parens")])))

  ;(match-define var*
  ;  (lambda ([forms : (List Form)]) : Form
  ;    (case forms
  ;      [(cons (form/token (symbol-token v)) (empty))
  ;       (form/expr (var-expr v))]
  ;      [_ (panic #"Bad forms for identifier")])))

  ;(match-define num*
  ;  (lambda ([forms : (List Form)]) : Form
  ;    (case forms
  ;      [(cons (form/token (decimal-number-token v)) (empty))
  ;       (case (decimal-bytes->integer v)
  ;         [(nothing) (panic #"Bad decimal number token")]
  ;         [(just (lifted-int v)) (form/expr (int-expr v))])]
  ;      [_ (panic #"Bad forms for identifier")])))

  (match-define module*
    (lambda ([forms : (List Form)]) : Form
      (case forms
        [(cons _keyword (cons (form/token (symbol-token name))
                              (cons (form/definitions _def)
                                    (empty))))
         (form/module name)]
        [_ (panic #"Bad forms for module")])))

  (match-define definitions*
    (lambda ([forms : (List Form)]) : Form
      (case forms
        [(empty)
         (form/definitions (empty))]
        [(cons (form/definition d) (cons (form/definitions ds) (empty)))
         (form/definitions (cons d ds))]
        [_ (panic #"Bad forms for definitions")])))


  (match-define function-definition*
    (lambda ([forms : (List Form)]) : Form
      (case forms
        [(cons _keyword (cons (form/token (symbol-token name)) (empty)))
         (form/definition (function-definition name))]
        [_ (panic #"Bad forms for module")])))


  ;(match-define assign*
  ;  (lambda ([forms : (List Form)]) : Form
  ;    (case forms
  ;      [(cons (form/token (symbol-token v)) (cons _:= (cons (form/expr e) (cons _! (empty)))))
  ;       (form/statement (assignment-statement v e))]
  ;      [_ (panic #"Bad forms for identifier")])))

  ;(match-define local-variable*
  ;  (lambda ([forms : (List Form)]) : Form
  ;    (case forms
  ;      [(cons (form/type ty)
  ;             (cons (form/token (symbol-token v))
  ;                   (cons _:= (cons (form/expr e) (cons _! (empty))))))
  ;       (form/statement (local-variable-statement ty v e))]
  ;      [_ (panic #"Bad forms for identifier")])))


  ;(match-define while*
  ;  (lambda ([forms : (List Form)]) : Form
  ;    (case forms
  ;      [(cons _while (cons _< (cons (form/expr e) (cons _>
  ;        (cons _< (cons (form/statements ss) (cons _> (empty))))))))
  ;       (form/statement (while-statement e ss))]
  ;      [_ (panic #"Bad forms for while statement")])))


  ;(match-define statements*
  ;  (lambda ([forms : (List Form)]) : Form
  ;    (case forms
  ;      [(empty)
  ;       (form/statements (empty))]
  ;      [(cons (form/statement s) (cons (form/statements ss) (empty)))
  ;       (form/statements (cons s ss))]
  ;      [_ (panic #"Bad forms for statements")])))

  ;(match-define var-type*
  ;  (lambda ([forms : (List Form)]) : Form
  ;    (case forms
  ;      [(cons (form/token (symbol-token v)) (empty))
  ;       (form/type (var-type v))]
  ;      [_ (panic #"Bad forms for variable type")])))

  (varargs list
    (production-rule Module* 1 (varargs list module-keyword id Definitions) module*)
    (production-rule Definitions* 2 (empty) definitions*)
    (production-rule Definitions* 3 (varargs list Definition Definitions) definitions*)
    (production-rule Definition* 4 (varargs list define-function-keyword id) function-definition*)

    ;(production-rule E* 1 (varargs list id) var*)
    ;(production-rule E* 1 (varargs list num) num*)

    ;(production-rule E* 1 (varargs list E + T) bin-op*)
    ;(production-rule E* 2 (varargs list E - T) bin-op*)
    ;(production-rule E* 3 (varargs list T) identity*)
    ;(production-rule T* 4 (varargs list T * F) bin-op*)
    ;(production-rule T* 5 (varargs list T / F) bin-op*)
    ;(production-rule T* 6 (varargs list F) identity*)
    ;(production-rule F* 7 (varargs list paren-< E >-paren) parens*)
    ;(production-rule F* 8 (varargs list id) var*)
    ;(production-rule F* 9 (varargs list num) num*)
    ;(production-rule S* 10 (varargs list id := E !) assign*)
    ;(production-rule S* 11 (varargs list Type id := E !) local-variable*)
    ;(production-rule S* 12 (varargs list while paren-< E >-paren brace-< Ss >-brace) while*)
    ;(production-rule Ss* 13 (empty) statements*)
    ;(production-rule Ss* 14 (varargs list S Ss) statements*)
    ;(production-rule Type* 15 (varargs list id) var-type*)

  ))


(define (make-expr-parser) : (Either Bytes (Parser CoreNonTerm CoreTerm Form))
  (build-parser (grammar (non-term/Module)
                         (core-production-rules)
                         core-non-term-cmp core-term-cmp)
                form/token
                token->terminal))
