#:module (core-language core-parser)
#:import {
  (bytes)
  (core-language lexer)
  (core-language lr-parser)
  (core-language source-language)
  (data lifted-primitives)
  (data ordering)
  (either)
  (list)
  (maybe)
  (module-name)
  (numbers)
  (prim)
  (tuples)
  (yaspl math-operations)
}
(export
  (#:types CoreNonTerm CoreTerm Form)
  (#:values
     make-module-grammar
     make-module-parser
     core-non-term->bytes
     core-term->bytes)
  (#:patterns form/module))
(types
  (define-type CoreNonTerm
    (non-term/Module)
    (non-term/ModName)
    (non-term/Definitions)
    (non-term/Definition)
    (non-term/SpaceType)
    (non-term/Type)
    (non-term/TypeArguments)
    (non-term/NonEmptyTypeArguments)
    (non-term/Parameters)
    (non-term/NonEmptyParameters)
    (non-term/Parameter)
    (non-term/Statements)
    (non-term/Statement)
    (non-term/IfStatement)
    (non-term/ElseChain)
    (non-term/Expression)
    (non-term/E1)
    (non-term/E2)
    (non-term/Arguments)
    (non-term/NonEmptyArguments)
    (non-term/StructFields)
    (non-term/StructField))
  (define-type CoreTerm
    (term/punctuation [p : Punctuation])
    (term/language-keyword [v : Bytes])
    (term/id)
    (term/number)
    (term/bytes))

  (define-type Form
    (form/module [m : Module])
    (form/definitions [ds : (List Definition)])
    (form/definition [d : Definition])
    (form/symbols [ss : (List Bytes)])
    (form/parameters [ps : (List Parameter)])
    (form/parameter [p : Parameter])
    (form/statements [ss : (List Statement)])
    (form/statement [s : Statement])
    (form/expression [e : Expression])
    (form/expressions [es : (List Expression)])
    (form/space-type [t : PreSpaceType])
    (form/type [t : PreType])
    (form/types [ts : (List PreType)])
    (form/struct-fields [fs : (List StructField)])
    (form/struct-field [f : StructField])

    (form/token [t : Token])))


(define (core-term-cmp [l : CoreTerm] [r : CoreTerm]) : Ordering
  (case (tuple2 l r)
    [(tuple2 (term/punctuation l) (term/punctuation r))
     (punctuation-cmp l r)]
    [(tuple2 (term/punctuation _) _)
     (less-than)]
    [(tuple2 _ (term/punctuation _))
     (greater-than)]
    [(tuple2 (term/language-keyword l) (term/language-keyword r))
     (bytes-cmp l r)]
    [(tuple2 (term/language-keyword _) _)
     (less-than)]
    [(tuple2 _ (term/language-keyword _))
     (greater-than)]
    [(tuple2 (term/id) (term/id))
     (equal-to)]
    [(tuple2 (term/id) _)
     (less-than)]
    [(tuple2 _ (term/id))
     (greater-than)]
    [(tuple2 (term/number) (term/number))
     (equal-to)]
    [(tuple2 (term/number) _)
     (less-than)]
    [(tuple2 _ (term/number))
     (greater-than)]
    [(tuple2 (term/bytes) (term/bytes))
     (equal-to)]))

(define (core-non-term-cmp [a : CoreNonTerm] [b : CoreNonTerm]) : Ordering
  (match-define convert
    (lambda ([v : CoreNonTerm])
      (case v
        [(non-term/Module) 1]
        [(non-term/ModName) 2]
        [(non-term/Definitions) 3]
        [(non-term/Definition) 4]
        [(non-term/Parameters) 5]
        [(non-term/NonEmptyParameters) 6]
        [(non-term/Parameter) 7]
        [(non-term/Statements) 8]
        [(non-term/Statement) 9]
        [(non-term/Expression) 10]
        [(non-term/Type) 11]
        [(non-term/IfStatement) 12]
        [(non-term/ElseChain) 13]
        [(non-term/E1) 14]
        [(non-term/E2) 15]
        [(non-term/Arguments) 16]
        [(non-term/NonEmptyArguments) 17]
        [(non-term/StructFields) 18]
        [(non-term/StructField) 19]
        [(non-term/TypeArguments) 20]
        [(non-term/NonEmptyTypeArguments) 21]
        [(non-term/SpaceType) 22]
        )))
  (int-cmp (convert a) (convert b)))

(define (core-non-term->bytes [nt : CoreNonTerm]) : Bytes
  (case nt
    [(non-term/Module) #"Module"]
    [(non-term/ModName) #"ModName"]
    [(non-term/Definitions) #"Definitions"]
    [(non-term/Definition) #"Definition"]
    [(non-term/Parameters) #"Parameters"]
    [(non-term/NonEmptyParameters) #"NonEmptyParameters"]
    [(non-term/Parameter) #"Parameter"]
    [(non-term/Statements) #"Statements"]
    [(non-term/Statement) #"Statement"]
    [(non-term/Expression) #"Expression"]
    [(non-term/SpaceType) #"SpaceType"]
    [(non-term/Type) #"Type"]
    [(non-term/TypeArguments) #"TypeArguments"]
    [(non-term/NonEmptyTypeArguments) #"NonEmptyTypeArguments"]
    [(non-term/IfStatement) #"IfStatement"]
    [(non-term/ElseChain) #"ElseChain"]
    [(non-term/E1) #"E1"]
    [(non-term/E2) #"E2"]
    [(non-term/Arguments) #"Arguments"]
    [(non-term/NonEmptyArguments) #"NonEmptyArguments"]
    [(non-term/StructFields) #"StructFields"]
    [(non-term/StructField) #"StructField"]
    ))

(define (core-term->bytes [t : CoreTerm]) : Bytes
  (case t
    [(term/punctuation p) (punctuation->bytes p)]
    [(term/language-keyword k) k]
    [(term/id) #"id"]
    [(term/number) #"number"]
    [(term/bytes) #"number"]))


(define (token->terminal [token : Token]) : (Either Bytes CoreTerm)
  (case token
    [(punctuation-token p) (right (term/punctuation p))]
    [(symbol-token s)
     (case s
       [#"if" (right (term/language-keyword s))]
       [#"else" (right (term/language-keyword s))]
       [#"return" (right (term/language-keyword s))]
       [#"as" (right (term/language-keyword s))]
       [#"while" (right (term/language-keyword s))]
       [_ (right (term/id))])]
    [(decimal-number-token _) (right (term/number))]
    [(hexadecimal-number-token _) (right (term/number))]
    [(bytes-token _) (right (term/bytes))]
    [(keyword-token k)
     (case k
       [#"module" (right (term/language-keyword k))]
       [#"define_function" (right (term/language-keyword k))]
       [#"define_struct" (right (term/language-keyword k))]
       [#"define_global" (right (term/language-keyword k))]
       [#"declare_external" (right (term/language-keyword k))]
       [_ (left #"Bad keyword token")])]))


(define (core-production-rules) : (List (InputProductionRule CoreNonTerm CoreTerm Form))
  (append*
    (varargs list
      (definition-production-rules)
      (type-production-rules)
      (statement-production-rules)
      (expression-production-rules))))

;; Refine the type for better inference
(define (symbol/term* [x : CoreTerm]) : (Symbol CoreNonTerm CoreTerm)
  (symbol/term x))
(define (symbol/non-term* [x : CoreNonTerm]) : (Symbol CoreNonTerm CoreTerm)
  (symbol/non-term x))

(define (identity* [forms : (List Form)]) : (Either Bytes Form)
  (case forms
    [(cons f (empty)) (right f)]
    [_ (left #"Bad forms for identity")]))

(define (definition-production-rules) : (List (InputProductionRule CoreNonTerm CoreTerm Form))
  (match-define ModName (symbol/non-term* (non-term/ModName)))
  (match-define Definitions (symbol/non-term* (non-term/Definitions)))
  (match-define Definition (symbol/non-term* (non-term/Definition)))
  (match-define Parameters (symbol/non-term* (non-term/Parameters)))
  (match-define NonEmptyParameters (symbol/non-term* (non-term/NonEmptyParameters)))
  (match-define Parameter (symbol/non-term* (non-term/Parameter)))
  (match-define Statements (symbol/non-term* (non-term/Statements)))
  (match-define StructFields (symbol/non-term* (non-term/StructFields)))
  (match-define StructField (symbol/non-term* (non-term/StructField)))
  (match-define SpaceType (symbol/non-term* (non-term/SpaceType)))
  (match-define Type (symbol/non-term* (non-term/Type)))

  (match-define paren-< (symbol/term* (term/punctuation (punct/left-paren))))
  (match-define >-paren (symbol/term* (term/punctuation (punct/right-paren))))
  (match-define brace-< (symbol/term* (term/punctuation (punct/left-brace))))
  (match-define >-brace (symbol/term* (term/punctuation (punct/right-brace))))
  (match-define comma (symbol/term* (term/punctuation (punct/comma))))
  (match-define semi-colon (symbol/term* (term/punctuation (punct/semi-colon))))
  (match-define module-keyword (symbol/term* (term/language-keyword #"module")))
  (match-define define-function-keyword (symbol/term* (term/language-keyword #"define_function")))
  (match-define define-global-keyword (symbol/term* (term/language-keyword #"define_global")))
  (match-define define-struct-keyword (symbol/term* (term/language-keyword #"define_struct")))
  (match-define declare-external-keyword
                (symbol/term* (term/language-keyword #"declare_external")))

  (match-define id (symbol/term* (term/id)))


  (match-define Module* (non-term/Module))
  (match-define ModName* (non-term/ModName))
  (match-define Definitions* (non-term/Definitions))
  (match-define Definition* (non-term/Definition))
  (match-define Parameters* (non-term/Parameters))
  (match-define NonEmptyParameters* (non-term/NonEmptyParameters))
  (match-define Parameter* (non-term/Parameter))
  (match-define StructFields* (non-term/StructFields))
  (match-define StructField* (non-term/StructField))

  (match-define module*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons _keyword
           (cons _<
             (cons (form/symbols symbols)
               (cons _>
                 (cons (form/definitions defs)
                   (empty))))))
         (right (form/module (module (mod-name symbols) defs)))]
        [_ (left #"Bad forms for module")])))

  (match-define mod-name*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(empty)
         (right (form/symbols (empty)))]
        [(cons (form/token (symbol-token s)) (cons (form/symbols ss) (empty)))
         (right (form/symbols (cons s ss)))]
        [_ (left #"Bad forms for mod-name")])))


  (match-define definitions*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(empty)
         (right (form/definitions (empty)))]
        [(cons (form/definition d) (cons (form/definitions ds) (empty)))
         (right (form/definitions (cons d ds)))]
        [_ (left #"Bad forms for definitions")])))


  (match-define external-function*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons _keyword
           (cons (form/token (symbol-token name))
             (cons (form/type ty)
               (empty))))
         (right (form/definition (external-definition name ty)))]
        [_ (left #"Bad forms for external function")])))

  (match-define global-definition*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons _keyword
           (cons (form/space-type ty)
             (cons (form/token (symbol-token name))
               (empty))))
         (right (form/definition (global-definition name ty)))]
        [_ (left #"Bad forms for global definition")])))

  (match-define struct-definition*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons _keyword
           (cons (form/token (symbol-token name))
             (cons _brace-<
               (cons (form/struct-fields fields)
                 (cons _>-brace
                       (empty))))))
         (right (form/definition (struct-definition name fields)))]
        [_ (left #"Bad forms for struct-definition")])))

  (match-define struct-fields*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(empty)
         (right (form/struct-fields (empty)))]
        [(cons (form/struct-field f) (cons (form/struct-fields fs) (empty)))
         (right (form/struct-fields (cons f fs)))]
        [_ (left #"Bad forms for struct-fields")])))

  (match-define struct-field*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/space-type type)
           (cons (form/token (symbol-token name))
             (cons _semi-colon
                   (empty))))
         (right (form/struct-field (struct-field name type)))]
        [_ (left #"Bad forms for struct-field")])))


  (match-define function-definition*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons _keyword
           (cons (form/type return-type)
             (cons (form/token (symbol-token name))
               (cons _paren-<
                 (cons (form/parameters params)
                   (cons _>-paren
                     (cons _brace-<
                       (cons (form/statements statements)
                         (cons _>-brace
                           (empty))))))))))
         (right (form/definition (function-definition name params return-type statements)))]
        [_ (left #"Bad forms for function-definition")])))

  (match-define parameters*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(empty)
         (right (form/parameters (empty)))]
        [(cons (form/parameters ps) (empty))
         (right (form/parameters ps))]
        [_ (left #"Bad forms for parameters")])))

  (match-define non-empty-parameters*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/parameter p) (empty))
         (right (form/parameters (varargs list p)))]
        [(cons (form/parameter p) (cons _comma (cons (form/parameters ps) (empty))))
         (right (form/parameters (cons p ps)))]
        [_ (left #"Bad forms for non-empty parameters")])))

  (match-define parameter*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/type t)
           (cons (form/token (symbol-token param))
             (empty)))
         (right (form/parameter (parameter param t)))]
        [_ (left #"Bad forms for parameter")])))

  (varargs list
    (input-production-rule Module* (varargs list module-keyword paren-< ModName >-paren Definitions) module*)
    (input-production-rule ModName* (empty) mod-name*)
    (input-production-rule ModName* (varargs list id ModName) mod-name*)

    (input-production-rule Definitions* (empty) definitions*)
    (input-production-rule Definitions* (varargs list Definition Definitions) definitions*)
    (input-production-rule Definition*
      (varargs list define-function-keyword Type id paren-< Parameters >-paren
                    brace-< Statements >-brace)
      function-definition*)
    (input-production-rule Definition*
      (varargs list declare-external-keyword id Type)
      external-function*)
    (input-production-rule Definition*
      (varargs list define-struct-keyword id brace-< StructFields >-brace)
      struct-definition*)
    (input-production-rule Definition*
      (varargs list define-global-keyword SpaceType id)
      global-definition*)

    (input-production-rule Parameters* (empty) parameters*)
    (input-production-rule Parameters* (varargs list NonEmptyParameters) parameters*)
    (input-production-rule NonEmptyParameters*
      (varargs list Parameter)
      non-empty-parameters*)
    (input-production-rule NonEmptyParameters*
      (varargs list Parameter comma NonEmptyParameters)
      non-empty-parameters*)
    (input-production-rule Parameter* (varargs list Type id) parameter*)

    ;; StructFields
    (input-production-rule StructFields*
      (varargs list StructField StructFields)
      struct-fields*)
    (input-production-rule StructFields*
      (empty)
      struct-fields*)
    (input-production-rule StructField*
      (varargs list SpaceType id semi-colon)
      struct-field*)))

(define (type-production-rules) : (List (InputProductionRule CoreNonTerm CoreTerm Form))
  (match-define Type (symbol/non-term* (non-term/Type)))
  (match-define TypeArguments (symbol/non-term* (non-term/TypeArguments)))
  (match-define NonEmptyTypeArguments (symbol/non-term* (non-term/NonEmptyTypeArguments)))

  (match-define * (symbol/term* (term/punctuation (punct/multiplication))))
  (match-define paren-< (symbol/term* (term/punctuation (punct/left-paren))))
  (match-define >-paren (symbol/term* (term/punctuation (punct/right-paren))))
  (match-define bracket-< (symbol/term* (term/punctuation (punct/left-bracket))))
  (match-define >-bracket (symbol/term* (term/punctuation (punct/right-bracket))))
  (match-define -> (symbol/term* (term/punctuation (punct/pointer-field-access))))
  (match-define comma (symbol/term* (term/punctuation (punct/comma))))

  (match-define number (symbol/term* (term/number)))
  (match-define id (symbol/term* (term/id)))

  (match-define SpaceType* (non-term/SpaceType))
  (match-define Type* (non-term/Type))
  (match-define TypeArguments* (non-term/TypeArguments))
  (match-define NonEmptyTypeArguments* (non-term/NonEmptyTypeArguments))

  (match-define var-type*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/token (symbol-token v)) (empty))
         (right (form/type (var-pre-type v)))]
        [_ (left #"Bad forms for var type")])))
  (match-define array-type*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/type t)
           (cons _<
             (cons _>
               (empty))))
         (right (form/type (array-pre-type t)))]
        [_ (left #"Bad forms for array type")])))
  (match-define pointer-type*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/type t)
           (cons _*
             (empty)))
         (right (form/type (pointer-pre-type t)))]
        [_ (left #"Bad forms for array type")])))
  (match-define function-type*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons _<
           (cons (form/types args)
             (cons _->
               (cons (form/type return-type)
                 (cons _>
                   (empty))))))
         (right (form/type (function-pre-type args return-type)))]
        [_ (left #"Bad forms for function type")])))
  (match-define type-arguments*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(empty)
         (right (form/types (empty)))]
        [(cons (form/types ts) (empty))
         (right (form/types ts))]
        [_ (left #"Bad forms for type arguments")])))
  (match-define non-empty-type-arguments*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/type t) (empty))
         (right (form/types (varargs list t)))]
        [(cons (form/type t) (cons _comma (cons (form/types ts) (empty))))
         (right (form/types (cons t ts)))]
        [_ (left #"Bad forms for non-empty type arguments")])))

  (match-define fixed-array-space-type*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/type t)
           (cons _<
             (cons (form/token (decimal-number-token v))
               (cons _>
                 (empty)))))
         (case (decimal-bytes->integer v)
           [(nothing) (left #"Bad decimal number token")]
           [(just (lifted-int v)) (right (form/space-type (fixed-array-pre-space-type t v)))])]
        [(cons (form/type t)
           (cons _<
             (cons (form/token (hexadecimal-number-token v))
               (cons _>
                 (empty)))))
         (case (hexadecimal-bytes->integer v)
           [(nothing) (left #"Bad hexadecimal number token")]
           [(just (lifted-int v)) (right (form/space-type (fixed-array-pre-space-type t v)))])]
        [_ (left #"Bad forms for fixed array type")])))

  (match-define raw-space-type*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/type t) (empty))
         (right (form/space-type (raw-pre-space-type t)))]
        [_ (left #"Bad forms for raw space type")])))


  (varargs list
    ;; Types
    (input-production-rule Type* (varargs list id) var-type*)
    (input-production-rule Type* (varargs list Type bracket-< >-bracket) array-type*)
    (input-production-rule Type* (varargs list Type *) pointer-type*)
    (input-production-rule Type* (varargs list paren-< TypeArguments -> Type >-paren) function-type*)

    (input-production-rule TypeArguments* (empty) type-arguments*)
    (input-production-rule TypeArguments* (varargs list NonEmptyTypeArguments) type-arguments*)
    (input-production-rule NonEmptyTypeArguments*
      (varargs list Type)
      non-empty-type-arguments*)
    (input-production-rule NonEmptyTypeArguments*
      (varargs list Type comma NonEmptyTypeArguments)
      non-empty-type-arguments*)

    ;; Space Types
    (input-production-rule SpaceType* (varargs list Type)
                           raw-space-type*)
    (input-production-rule SpaceType* (varargs list Type bracket-< number >-bracket)
                           fixed-array-space-type*)
    ))

(define (statement-production-rules) : (List (InputProductionRule CoreNonTerm CoreTerm Form))
  (match-define Statements (symbol/non-term* (non-term/Statements)))
  (match-define Statement (symbol/non-term* (non-term/Statement)))
  (match-define IfStatement (symbol/non-term* (non-term/IfStatement)))
  (match-define ElseChain (symbol/non-term* (non-term/ElseChain)))
  (match-define Expression (symbol/non-term* (non-term/Expression)))
  (match-define Type (symbol/non-term* (non-term/Type)))

  (match-define * (symbol/term* (term/punctuation (punct/multiplication))))
  (match-define paren-< (symbol/term* (term/punctuation (punct/left-paren))))
  (match-define >-paren (symbol/term* (term/punctuation (punct/right-paren))))
  (match-define brace-< (symbol/term* (term/punctuation (punct/left-brace))))
  (match-define >-brace (symbol/term* (term/punctuation (punct/right-brace))))
  (match-define := (symbol/term* (term/punctuation (punct/assignment))))
  (match-define <- (symbol/term* (term/punctuation (punct/pointer-assignment))))
  (match-define <> (symbol/term* (term/punctuation (punct/less-greater))))
  (match-define semi-colon (symbol/term* (term/punctuation (punct/semi-colon))))
  (match-define if (symbol/term* (term/language-keyword #"if")))
  (match-define else (symbol/term* (term/language-keyword #"else")))
  (match-define return (symbol/term* (term/language-keyword #"return")))
  (match-define while (symbol/term* (term/language-keyword #"while")))

  (match-define id (symbol/term* (term/id)))

  (match-define Statements* (non-term/Statements))
  (match-define Statement* (non-term/Statement))
  (match-define IfStatement* (non-term/IfStatement))
  (match-define ElseChain* (non-term/ElseChain))


  (match-define statements*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(empty)
         (right (form/statements (empty)))]
        [(cons (form/statement s) (cons (form/statements ss) (empty)))
         (right (form/statements (cons s ss)))]
        [_ (left #"Bad forms for statements")])))

  (match-define return*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/token (symbol-token #"return"))
           (cons (form/expression e)
             (cons _semi-colon
               (empty))))
         (right (form/statement (return-statement e)))]
        [_ (left #"Bad forms for return")])))
  (match-define local-variable*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/type ty)
           (cons (form/token (symbol-token v))
             (cons _:=
               (cons (form/expression e)
                 (cons _
                   (empty))))))
         (right (form/statement (define-local-variable-statement v ty e)))]
        [_ (left #"Bad forms for local-variable")])))
  (match-define assignment*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/token (symbol-token v))
           (cons _:=
             (cons (form/expression e)
               (cons _
                 (empty)))))
         (right (form/statement (assignment-statement v e)))]
        [_ (left #"Bad forms for assignment")])))
  (match-define pointer-assignment*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons _*
           (cons (form/expression e1)
             (cons _<-
               (cons (form/expression e2)
                 (cons _
                   (empty))))))
         (right (form/statement (pointer-assignment-statement e1 e2)))]
        [_ (left #"Bad forms for pointer assignment")])))
  (match-define effect*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons _<>
             (cons (form/expression e)
               (cons _
                 (empty))))
         (right (form/statement (effect-statement e)))]
        [_ (left #"Bad forms for effect")])))


  (match-define while*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/token (symbol-token #"while"))
           (cons _<
             (cons (form/expression e)
               (cons _>
                 (cons _<<
                   (cons (form/statements ss)
                     (cons _>>
                       (empty))))))))
         (right (form/statement (while-statement e ss)))]
        [_ (left #"Bad forms for while")])))


  (match-define if*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/token (symbol-token #"if"))
           (cons _<
             (cons (form/expression e)
               (cons _>
                 (cons _<<
                   (cons (form/statements t)
                     (cons _>>
                       (cons (form/statements f)
                         (empty)))))))))
         (right (form/statement (if-statement e t f)))]
        [_ (left #"Bad forms for if")])))

  (match-define else*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(empty)
         (right (form/statements (empty)))]
        [(cons (form/token (symbol-token #"else"))
           (cons _<<
             (cons (form/statements f)
               (cons _>>
                 (empty)))))
         (right (form/statements f))]
        [(cons (form/token (symbol-token #"else"))
           (cons (form/statement f)
             (empty)))
         (right (form/statements (cons f (empty))))]
        [_ (left #"Bad forms for else")])))

  (varargs list
    (input-production-rule Statements* (empty) statements*)
    (input-production-rule Statements* (varargs list Statement Statements) statements*)
    (input-production-rule Statement* (varargs list return Expression semi-colon) return*)
    (input-production-rule Statement* (varargs list Type id := Expression semi-colon) local-variable*)
    (input-production-rule Statement* (varargs list id := Expression semi-colon) assignment*)
    (input-production-rule Statement*
      (varargs list * Expression <- Expression semi-colon)
      pointer-assignment*)
    (input-production-rule Statement* (varargs list <> Expression semi-colon) effect*)
    (input-production-rule Statement*
      (varargs list while paren-< Expression >-paren brace-< Statements >-brace)
      while*)

    ;; If statements
    (input-production-rule Statement* (varargs list IfStatement) identity*)
    (input-production-rule IfStatement*
      (varargs list if paren-< Expression >-paren brace-< Statements >-brace ElseChain)
      if*)
    (input-production-rule ElseChain* (empty) else*)
    (input-production-rule ElseChain* (varargs list else brace-< Statements >-brace) else*)
    (input-production-rule ElseChain* (varargs list else IfStatement) else*)
    ))

(define (expression-production-rules) : (List (InputProductionRule CoreNonTerm CoreTerm Form))
  (match-define Expression (symbol/non-term* (non-term/Expression)))
  (match-define E1 (symbol/non-term* (non-term/E1)))
  (match-define E2 (symbol/non-term* (non-term/E2)))
  (match-define Arguments (symbol/non-term* (non-term/Arguments)))
  (match-define NonEmptyArguments (symbol/non-term* (non-term/NonEmptyArguments)))
  (match-define Type (symbol/non-term* (non-term/Type)))

  (match-define + (symbol/term* (term/punctuation (punct/plus))))
  (match-define - (symbol/term* (term/punctuation (punct/minus))))
  (match-define * (symbol/term* (term/punctuation (punct/multiplication))))
  (match-define / (symbol/term* (term/punctuation (punct/division))))
  (match-define % (symbol/term* (term/punctuation (punct/percent))))
  (match-define & (symbol/term* (term/punctuation (punct/bitwise-and))))
  (match-define && (symbol/term* (term/punctuation (punct/logical-and))))
  (match-define bar (symbol/term* (term/punctuation (punct/bitwise-or))))
  (match-define barbar (symbol/term* (term/punctuation (punct/logical-or))))
  (match-define ! (symbol/term* (term/punctuation (punct/bang))))
  (match-define paren-< (symbol/term* (term/punctuation (punct/left-paren))))
  (match-define >-paren (symbol/term* (term/punctuation (punct/right-paren))))
  (match-define bracket-< (symbol/term* (term/punctuation (punct/left-bracket))))
  (match-define >-bracket (symbol/term* (term/punctuation (punct/right-bracket))))
  (match-define < (symbol/term* (term/punctuation (punct/less-than))))
  (match-define > (symbol/term* (term/punctuation (punct/greater-than))))
  (match-define << (symbol/term* (term/punctuation (punct/less-less))))
  (match-define >> (symbol/term* (term/punctuation (punct/greater-greater))))
  (match-define != (symbol/term* (term/punctuation (punct/not-equal))))
  (match-define == (symbol/term* (term/punctuation (punct/equal-equal))))
  (match-define -> (symbol/term* (term/punctuation (punct/pointer-field-access))))
  (match-define ->& (symbol/term* (term/punctuation (punct/pointer-offset))))
  (match-define comma (symbol/term* (term/punctuation (punct/comma))))
  (match-define as (symbol/term* (term/language-keyword #"as")))

  (match-define id (symbol/term* (term/id)))
  (match-define number (symbol/term* (term/number)))
  (match-define bytes (symbol/term* (term/bytes)))


  (match-define Expression* (non-term/Expression))
  (match-define E1* (non-term/E1))
  (match-define E2* (non-term/E2))
  (match-define Arguments* (non-term/Arguments))
  (match-define NonEmptyArguments* (non-term/NonEmptyArguments))

  (match-define var-expr*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/token (symbol-token v)) (empty))
         (right (form/expression (var-expr v)))]
        [_ (left #"Bad forms for var expr")])))
  (match-define number-expr*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/token (decimal-number-token v)) (empty))
         (case (decimal-bytes->integer v)
           [(nothing) (left #"Bad decimal number token")]
           [(just (lifted-int v)) (right (form/expression (int-expr v)))])]
        [(cons (form/token (hexadecimal-number-token v)) (empty))
         (case (hexadecimal-bytes->integer v)
           [(nothing) (left #"Bad hexadecimal number token")]
           [(just (lifted-int v)) (right (form/expression (int-expr v)))])]
        [_ (left #"Bad forms for number")])))
  (match-define bytes-expr*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/token (bytes-token v)) (empty))
         (right (form/expression (bytes-expr v)))]
        [_ (left #"Bad forms for bytes")])))

  (match-define paren-expr*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons _<
           (cons (form/expression e)
             (cons _>
               (empty))))
         (right (form/expression e))]
        [_ (left #"Bad forms for paren expression")])))
  (match-define cast-expr*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons _as
           (cons _<
             (cons (form/type t)
              (cons _>
                (cons _<
                  (cons (form/expression e)
                    (cons _>
                      (empty))))))))
         (right (form/expression (cast-expr t e)))]
        [_ (left #"Bad forms for cast expression")])))

  (match-define unary-op-expr*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/token (punctuation-token p))
           (cons (form/expression e)
             (empty)))
         (case (ann (Either Bytes LogicalUnaryOp)
                    (case p
                      [(punct/bang) (right (not-op))]
                      [_ (left #"Bad op form for unary-op expr")]))
           [(left v) (left v)]
           [(right op)
            (right (form/expression (unary-op-expr op e)))])]
        [_ (left #"Bad forms for unary-op expr")])))

  (match-define bin-op-expr*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/expression l)
           (cons (form/token (punctuation-token p))
             (cons (form/expression r) (empty))))
         (case (ann (Either Bytes BinOp)
                    (case p
                      [(punct/less-than) (right (comparison-bin-op (less-than-op)))]
                      [(punct/greater-than) (right (comparison-bin-op (greater-than-op)))]
                      [(punct/equal-equal) (right (comparison-bin-op (equal-op)))]
                      [(punct/not-equal) (right (comparison-bin-op (not-equal-op)))]
                      [(punct/plus) (right (numeric-bin-op (add-op)))]
                      [(punct/minus) (right (numeric-bin-op (sub-op)))]
                      [(punct/multiplication) (right (numeric-bin-op (mult-op)))]
                      [(punct/division) (right (numeric-bin-op (quotient-op)))]
                      [(punct/percent) (right (numeric-bin-op (remainder-op)))]
                      [(punct/bitwise-and) (right (numeric-bin-op (bitwise-and-op)))]
                      [(punct/bitwise-or) (right (numeric-bin-op (bitwise-ior-op)))]
                      [(punct/logical-and) (right (logical-bin-op (and-op)))]
                      [(punct/logical-or) (right (logical-bin-op (ior-op)))]
                      [(punct/less-less) (right (numeric-bin-op (logical-shift-left-op)))]
                      [(punct/greater-greater) (right (numeric-bin-op (logical-shift-right-op)))]
                      [_ (left #"Bad op form for bin-op expr")]))
           [(left v) (left v)]
           [(right op)
            (right (form/expression (bin-op-expr op l r)))])]
        [_ (left #"Bad forms for bin-op expr")])))

  (match-define deref-expr*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons _* (cons (form/expression e) (empty)))
         (right (form/expression (deref-expr e)))]
        [_ (left #"Bad forms for deref expr")])))

  (match-define array-index-expr*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/expression e)
           (cons _->&
             (cons _<
               (cons (form/expression i)
                 (cons _>
                   (empty))))))
         (right (form/expression (array-index-expr e i)))]
        [_ (left #"Bad forms for array-index expr")])))

  (match-define array-deref-expr*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/expression e)
           (cons _->
             (cons _<
               (cons (form/expression i)
                 (cons _>
                   (empty))))))
         (right (form/expression (deref-expr (array-index-expr e i))))]
        [_ (left #"Bad forms for array-index expr")])))

  (match-define call-expr*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/expression f)
           (cons _<
             (cons (form/expressions es)
               (cons _>
                 (empty)))))
         (right (form/expression (call-expr f es)))]
        [_ (left #"Bad forms for call expr")])))

  (match-define struct-field-expr*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/expression e)
           (cons _->&
             (cons (form/token (symbol-token f))
               (empty))))
         (right (form/expression (struct-field-expr e f)))]
        [_ (left #"Bad forms for struct-field expr")])))

  (match-define struct-deref-expr*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/expression e)
           (cons _->
             (cons (form/token (symbol-token f))
               (empty))))
         (right (form/expression (deref-expr (struct-field-expr e f))))]
        [_ (left #"Bad forms for struct-deref expr")])))


  (match-define arguments*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(empty)
         (right (form/expressions (empty)))]
        [(cons (form/expressions ps) (empty))
         (right (form/expressions ps))]
        [_ (left #"Bad forms for arguments")])))

  (match-define non-empty-arguments*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/expression p) (empty))
         (right (form/expressions (varargs list p)))]
        [(cons (form/expression p) (cons _comma (cons (form/expressions ps) (empty))))
         (right (form/expressions (cons p ps)))]
        [_ (left #"Bad forms for non-empty arguments")])))

  (varargs list
    (input-production-rule Expression* (varargs list E1) identity*)
    (input-production-rule E1* (varargs list E2) identity*)
    (input-production-rule E1* (varargs list ! E1) unary-op-expr*)
    (input-production-rule E1* (varargs list E2 < E1) bin-op-expr*)
    (input-production-rule E1* (varargs list E2 > E1) bin-op-expr*)
    (input-production-rule E1* (varargs list E2 + E1) bin-op-expr*)
    (input-production-rule E1* (varargs list E2 - E1) bin-op-expr*)
    (input-production-rule E1* (varargs list E2 * E1) bin-op-expr*)
    (input-production-rule E1* (varargs list E2 / E1) bin-op-expr*)
    (input-production-rule E1* (varargs list E2 % E1) bin-op-expr*)
    (input-production-rule E1* (varargs list E2 & E1) bin-op-expr*)
    (input-production-rule E1* (varargs list E2 && E1) bin-op-expr*)
    (input-production-rule E1* (varargs list E2 == E1) bin-op-expr*)
    (input-production-rule E1* (varargs list E2 != E1) bin-op-expr*)
    (input-production-rule E1* (varargs list E2 bar E1) bin-op-expr*)
    (input-production-rule E1* (varargs list E2 barbar E1) bin-op-expr*)
    (input-production-rule E1* (varargs list E2 << E1) bin-op-expr*)
    (input-production-rule E1* (varargs list E2 >> E1) bin-op-expr*)


    (input-production-rule E1* (varargs list * E1) deref-expr*)
    (input-production-rule E1* (varargs list E2 ->& bracket-< E1 >-bracket ) array-index-expr*)
    (input-production-rule E1* (varargs list E2 -> bracket-< E1 >-bracket ) array-deref-expr*)
    (input-production-rule E1* (varargs list E2 paren-< Arguments >-paren ) call-expr*)
    (input-production-rule E1* (varargs list E2 ->& id) struct-field-expr*)
    (input-production-rule E1* (varargs list E2 -> id) struct-deref-expr*)

    (input-production-rule E2* (varargs list id) var-expr*)
    (input-production-rule E2* (varargs list number) number-expr*)
    (input-production-rule E2* (varargs list bytes) bytes-expr*)
    (input-production-rule E2* (varargs list paren-< E1 >-paren) paren-expr*)
    (input-production-rule E2* (varargs list as < Type > paren-< E1 >-paren) cast-expr*)

    (input-production-rule Arguments* (empty) arguments*)
    (input-production-rule Arguments* (varargs list NonEmptyArguments) arguments*)
    (input-production-rule NonEmptyArguments*
      (varargs list Expression)
      non-empty-arguments*)
    (input-production-rule NonEmptyArguments*
      (varargs list Expression comma NonEmptyArguments)
      non-empty-arguments*)))


(define (make-module-grammar) : (Grammar CoreNonTerm CoreTerm Form)
  (grammar (non-term/Module)
           (core-production-rules)
           core-non-term-cmp core-term-cmp))

(define (make-module-parser) : (Either Bytes (Parser CoreNonTerm CoreTerm Form))
  (build-parser (make-module-grammar)
                form/token
                token->terminal))
