#:module (core-language core-parser)
#:import {
  (bytes)
  (core-language lexer)
  (core-language lr-parser)
  (core-language source-language)
  (data ordering)
  (either)
  (list)
  (module-name)
  (numbers)
  (prim)
  (tuples)
}
(export
  (#:types)
  (#:values make-module-parser)
  (#:patterns form/module))
(types
  (define-type CoreNonTerm
    (non-term/Module)
    (non-term/ModName)
    (non-term/Definitions)
    (non-term/Definition)
    (non-term/Type)
    (non-term/Parameters)
    (non-term/NonEmptyParameters)
    (non-term/Parameter)
    (non-term/Statements)
    (non-term/Statement)
    (non-term/Expression)

    ;(non-term/F)
    ;(non-term/T)
    ;(non-term/Type)
    ;(non-term/Statement)
    ;(non-term/Statements)
    )
  (define-type CoreTerm
    (term/punctuation [p : Punctuation])
    (term/language-keyword [v : Bytes])
    (term/id)
    (term/number))

  (define-type Form
    (form/module [m : Module])
    (form/definitions [ds : (List Definition)])
    (form/definition [d : Definition])
    (form/symbols [ss : (List Bytes)])
    (form/parameters [ps : (List Parameter)])
    (form/parameter [p : Parameter])
    (form/statements [ss : (List Statement)])
    (form/statement [s : Statement])
    (form/expression [e : Expression])
    (form/type [t : PreType])

    ;(form/type [t : Type])
    (form/token [t : Token])))


(define (core-term-cmp [l : CoreTerm] [r : CoreTerm]) : Ordering
  (case (tuple2 l r)
    [(tuple2 (term/punctuation l) (term/punctuation r))
     (punctuation-cmp l r)]
    [(tuple2 (term/punctuation _) _)
     (less-than)]
    [(tuple2 _ (term/punctuation _))
     (greater-than)]
    [(tuple2 (term/language-keyword l) (term/language-keyword r))
     (bytes-cmp l r)]
    [(tuple2 (term/language-keyword _) _)
     (less-than)]
    [(tuple2 _ (term/language-keyword _))
     (greater-than)]
    [(tuple2 (term/id) (term/id))
     (equal-to)]
    [(tuple2 (term/id) _)
     (less-than)]
    [(tuple2 _ (term/id))
     (greater-than)]
    [(tuple2 (term/number) (term/number))
     (equal-to)]))

(define (core-non-term-cmp [a : CoreNonTerm] [b : CoreNonTerm]) : Ordering
  (match-define convert
    (lambda ([v : CoreNonTerm])
      (case v
        [(non-term/Module) 1]
        [(non-term/ModName) 2]
        [(non-term/Definitions) 3]
        [(non-term/Definition) 4]
        [(non-term/Parameters) 5]
        [(non-term/NonEmptyParameters) 6]
        [(non-term/Parameter) 7]
        [(non-term/Statements) 8]
        [(non-term/Statement) 9]
        [(non-term/Expression) 10]
        [(non-term/Type) 11]
        ;[(non-term/T) 2]
        ;[(non-term/Type) 3]
        ;[(non-term/Statement) 4]
        ;[(non-term/Statements) 5]
        )))
  (int-cmp (convert a) (convert b)))



(define (token->terminal [token : Token]) : (Either Bytes CoreTerm)
  (case token
    [(punctuation-token p) (right (term/punctuation p))]
    [(symbol-token s)
     (case s
       [#"return" (right (term/language-keyword s))]
       [_ (right (term/id))])]
    [(decimal-number-token _) (right (term/number))]
    [(keyword-token k)
     (case k
       [#"module" (right (term/language-keyword k))]
       [#"define_function" (right (term/language-keyword k))]
       [_ (left #"Bad keyword token")])]
    [_ (left #"Bad token type")]))


(define (core-production-rules) : (List (ProductionRule CoreNonTerm CoreTerm Form))
  (match-define Module* (non-term/Module))
  (match-define ModName* (non-term/ModName))
  (match-define Definitions* (non-term/Definitions))
  (match-define Definition* (non-term/Definition))
  (match-define Parameters* (non-term/Parameters))
  (match-define NonEmptyParameters* (non-term/NonEmptyParameters))
  (match-define Parameter* (non-term/Parameter))
  (match-define Statements* (non-term/Statements))
  (match-define Statement* (non-term/Statement))
  (match-define Expression* (non-term/Expression))
  (match-define Type* (non-term/Type))
  ;(match-define E* (non-term/E))
  ;(match-define F* (non-term/F))
  ;(match-define T* (non-term/T))
  ;(match-define Type* (non-term/Type))
  ;(match-define S* (non-term/Statement))
  ;(match-define Ss* (non-term/Statements))

  (match-define symbol/term
    (lambda ([x : CoreTerm]) : (Symbol CoreNonTerm CoreTerm)
      (symbol/term x)))
  (match-define symbol/non-term
    (lambda ([x : CoreNonTerm]) : (Symbol CoreNonTerm CoreTerm)
      (symbol/non-term x)))

  ;(match-define E (symbol/non-term (non-term/E)))
  (match-define ModName (symbol/non-term (non-term/ModName)))
  (match-define Definitions (symbol/non-term (non-term/Definitions)))
  (match-define Definition (symbol/non-term (non-term/Definition)))
  (match-define Parameters (symbol/non-term (non-term/Parameters)))
  (match-define NonEmptyParameters (symbol/non-term (non-term/NonEmptyParameters)))
  (match-define Parameter (symbol/non-term (non-term/Parameter)))
  (match-define Statements (symbol/non-term (non-term/Statements)))
  (match-define Statement (symbol/non-term (non-term/Statement)))
  (match-define Expression (symbol/non-term (non-term/Expression)))
  (match-define Type (symbol/non-term (non-term/Type)))

  ;(match-define F (symbol/non-term (non-term/F)))
  ;(match-define T (symbol/non-term (non-term/T)))
  ;(match-define S (symbol/non-term (non-term/Statement)))
  ;(match-define Ss (symbol/non-term (non-term/Statements)))
  ;(match-define + (symbol/term (term/punctuation (punct/plus))))
  ;(match-define - (symbol/term (term/punctuation (punct/minus))))
  ;(match-define * (symbol/term (term/punctuation (punct/multiplication))))
  ;(match-define / (symbol/term (term/punctuation (punct/division))))
  (match-define paren-< (symbol/term (term/punctuation (punct/left-paren))))
  (match-define >-paren (symbol/term (term/punctuation (punct/right-paren))))
  (match-define brace-< (symbol/term (term/punctuation (punct/left-brace))))
  (match-define >-brace (symbol/term (term/punctuation (punct/right-brace))))
  ;(match-define := (symbol/term (term/punctuation (punct/assignment))))
  ;(match-define !  (symbol/term (term/punctuation (punct/bang))))
  (match-define comma (symbol/term (term/punctuation (punct/comma))))
  (match-define semi-colon (symbol/term (term/punctuation (punct/semi-colon))))
  ;(match-define while (symbol/term (term/language-keyword #"while")))
  (match-define return (symbol/term (term/language-keyword #"return")))
  (match-define module-keyword (symbol/term (term/language-keyword #"module")))
  (match-define define-function-keyword (symbol/term (term/language-keyword #"define_function")))

  (match-define id (symbol/term (term/id)))
  ;(match-define num (symbol/term (term/number)))

  ;(match-define bin-op*
  ;  (lambda ([forms : (List Form)]) : Form
  ;    (case forms
  ;      [(cons (form/expr l) (cons (form/token t) (cons (form/expr r) (empty))))
  ;       (match-define op : BinOp
  ;         (case t
  ;           [(punctuation-token (punct/plus)) (op/plus)]
  ;           [(punctuation-token (punct/minus)) (op/minus)]
  ;           [(punctuation-token (punct/division)) (op/divide)]
  ;           [(punctuation-token (punct/multiplication)) (op/times)]
  ;           [_ (panic #"Bad bin op token")]))
  ;       (form/expr (bin-op-expr op l r))]
  ;      [_ (panic #"Bad forms for bin-op")])))

  ;(match-define identity*
  ;  (lambda ([forms : (List Form)]) : Form
  ;    (case forms
  ;      [(cons f (empty))
  ;       f]
  ;      [_ (panic #"Bad forms for identity")])))

  ;(match-define parens*
  ;  (lambda ([forms : (List Form)]) : Form
  ;    (case forms
  ;      [(cons _lparen (cons f (cons _rparen (empty))))
  ;       f]
  ;      [_ (panic #"Bad forms for parens")])))


  ;(match-define num*
  ;  (lambda ([forms : (List Form)]) : Form
  ;    (case forms
  ;      [(cons (form/token (decimal-number-token v)) (empty))
  ;       (case (decimal-bytes->integer v)
  ;         [(nothing) (panic #"Bad decimal number token")]
  ;         [(just (lifted-int v)) (form/expr (int-expr v))])]
  ;      [_ (panic #"Bad forms for identifier")])))

  (match-define module*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons _keyword
           (cons _<
             (cons (form/symbols symbols)
               (cons _>
                 (cons (form/definitions defs)
                   (empty))))))
         (right (form/module (module (mod-name symbols) defs)))]
        [_ (left #"Bad forms for module")])))

  (match-define mod-name*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(empty)
         (right (form/symbols (empty)))]
        [(cons (form/token (symbol-token s)) (cons (form/symbols ss) (empty)))
         (right (form/symbols (cons s ss)))]
        [_ (left #"Bad forms for mod-name")])))


  (match-define definitions*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(empty)
         (right (form/definitions (empty)))]
        [(cons (form/definition d) (cons (form/definitions ds) (empty)))
         (right (form/definitions (cons d ds)))]
        [_ (left #"Bad forms for definitions")])))


  (match-define function-definition*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons _keyword
           (cons (form/token (symbol-token name))
             (cons _paren-<
               (cons (form/parameters params)
                 (cons _>-paren
                   (cons _brace-<
                     (cons (form/statements statements)
                       (cons _>-brace
                         (empty)))))))))
         (right (form/definition (function-definition name params statements)))]
        [_ (left #"Bad forms for function-definition")])))

  (match-define parameters*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(empty)
         (right (form/parameters (empty)))]
        [(cons (form/parameters ps) (empty))
         (right (form/parameters ps))]
        [_ (left #"Bad forms for parameters")])))

  (match-define non-empty-parameters*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/parameter p) (empty))
         (right (form/parameters (varargs list p)))]
        [(cons (form/parameter p) (cons _comma (cons (form/parameters ps) (empty))))
         (right (form/parameters (cons p ps)))]
        [_ (left #"Bad forms for non-empty parameters")])))

  (match-define parameter*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/type t)
           (cons (form/token (symbol-token param))
             (empty)))
         (right (form/parameter (parameter param t)))]
        [_ (left #"Bad forms for parameter")])))


  ;(match-define assign*
  ;  (lambda ([forms : (List Form)]) : Form
  ;    (case forms
  ;      [(cons (form/token (symbol-token v)) (cons _:= (cons (form/expr e) (cons _! (empty)))))
  ;       (form/statement (assignment-statement v e))]
  ;      [_ (panic #"Bad forms for identifier")])))

  ;(match-define local-variable*
  ;  (lambda ([forms : (List Form)]) : Form
  ;    (case forms
  ;      [(cons (form/type ty)
  ;             (cons (form/token (symbol-token v))
  ;                   (cons _:= (cons (form/expr e) (cons _! (empty))))))
  ;       (form/statement (local-variable-statement ty v e))]
  ;      [_ (panic #"Bad forms for identifier")])))


  ;(match-define while*
  ;  (lambda ([forms : (List Form)]) : Form
  ;    (case forms
  ;      [(cons _while (cons _< (cons (form/expr e) (cons _>
  ;        (cons _< (cons (form/statements ss) (cons _> (empty))))))))
  ;       (form/statement (while-statement e ss))]
  ;      [_ (panic #"Bad forms for while statement")])))


  (match-define statements*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(empty)
         (right (form/statements (empty)))]
        [(cons (form/statement s) (cons (form/statements ss) (empty)))
         (right (form/statements (cons s ss)))]
        [_ (left #"Bad forms for statements")])))

  (match-define return*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/token (symbol-token #"return"))
           (cons (form/expression e)
             (cons _semi-colon
               (empty))))
         (right (form/statement (return-statement e)))]
        [_ (left #"Bad forms for return")])))

  (match-define var-expr*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/token (symbol-token v)) (empty))
         (right (form/expression (var-expr v)))]
        [_ (left #"Bad forms for var expr")])))

  (match-define var-type*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/token (symbol-token v)) (empty))
         (right (form/type (var-pre-type v)))]
        [_ (left #"Bad forms for var type")])))

  ;(match-define var-type*
  ;  (lambda ([forms : (List Form)]) : Form
  ;    (case forms
  ;      [(cons (form/token (symbol-token v)) (empty))
  ;       (form/type (var-type v))]
  ;      [_ (panic #"Bad forms for variable type")])))

  (varargs list
    (production-rule Module* 1 (varargs list module-keyword paren-< ModName >-paren Definitions) module*)
    (production-rule Definitions* 2 (empty) definitions*)
    (production-rule Definitions* 3 (varargs list Definition Definitions) definitions*)
    (production-rule Definition* 4
      (varargs list define-function-keyword id paren-< Parameters >-paren
                    brace-< Statements >-brace)
      function-definition*)
    (production-rule ModName* 5 (empty) mod-name*)
    (production-rule ModName* 6 (varargs list id ModName) mod-name*)
    (production-rule Parameters* 7 (empty) parameters*)
    (production-rule Parameters* 8 (varargs list NonEmptyParameters) parameters*)
    (production-rule NonEmptyParameters* 9
      (varargs list Parameter)
      non-empty-parameters*)
    (production-rule NonEmptyParameters* 10
      (varargs list Parameter comma NonEmptyParameters)
      non-empty-parameters*)
    (production-rule Parameter* 11 (varargs list Type id) parameter*)
    (production-rule Statements* 12 (empty) statements*)
    (production-rule Statements* 13 (varargs list Statement Statements) statements*)
    (production-rule Statement* 14 (varargs list return Expression semi-colon) return*)
    (production-rule Expression* 15 (varargs list id) var-expr*)

    (production-rule Type* 16 (varargs list id) var-type*)

    ;(production-rule E* 1 (varargs list id) var*)
    ;(production-rule E* 1 (varargs list num) num*)

    ;(production-rule E* 1 (varargs list E + T) bin-op*)
    ;(production-rule E* 2 (varargs list E - T) bin-op*)
    ;(production-rule E* 3 (varargs list T) identity*)
    ;(production-rule T* 4 (varargs list T * F) bin-op*)
    ;(production-rule T* 5 (varargs list T / F) bin-op*)
    ;(production-rule T* 6 (varargs list F) identity*)
    ;(production-rule F* 7 (varargs list paren-< E >-paren) parens*)
    ;(production-rule F* 8 (varargs list id) var*)
    ;(production-rule F* 9 (varargs list num) num*)
    ;(production-rule S* 10 (varargs list id := E !) assign*)
    ;(production-rule S* 11 (varargs list Type id := E !) local-variable*)
    ;(production-rule S* 12 (varargs list while paren-< E >-paren brace-< Ss >-brace) while*)
    ;(production-rule Ss* 13 (empty) statements*)
    ;(production-rule Ss* 14 (varargs list S Ss) statements*)
    ;(production-rule Type* 15 (varargs list id) var-type*)

  ))


(define (make-module-parser) : (Either Bytes (Parser CoreNonTerm CoreTerm Form))
  (build-parser (grammar (non-term/Module)
                         (core-production-rules)
                         core-non-term-cmp core-term-cmp)
                form/token
                token->terminal))
