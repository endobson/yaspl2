#:module (core-language core-parser)
#:import {
  (bytes)
  (core-language lexer)
  (core-language lr-parser)
  (core-language source-language)
  (data lifted-primitives)
  (data ordering)
  (either)
  (list)
  (maybe)
  (module-name)
  (numbers)
  (prim)
  (tuples)
  (yaspl math-operations)
}
(export
  (#:types CoreNonTerm CoreTerm Form)
  (#:values
     make-module-grammar
     make-module-parser
     core-non-term->bytes
     core-term->bytes)
  (#:patterns form/module))
(types
  (define-type CoreNonTerm
    (non-term/Module)
    (non-term/ModName)
    (non-term/Definitions)
    (non-term/Definition)
    (non-term/Type)
    (non-term/Parameters)
    (non-term/NonEmptyParameters)
    (non-term/Parameter)
    (non-term/Statements)
    (non-term/Statement)
    (non-term/IfStatement)
    (non-term/ElseChain)
    (non-term/Expression)
    (non-term/E1)
    (non-term/E2)

    ;(non-term/F)
    ;(non-term/T)
    ;(non-term/Type)
    ;(non-term/Statement)
    ;(non-term/Statements)
    )
  (define-type CoreTerm
    (term/punctuation [p : Punctuation])
    (term/language-keyword [v : Bytes])
    (term/id)
    (term/number))

  (define-type Form
    (form/module [m : Module])
    (form/definitions [ds : (List Definition)])
    (form/definition [d : Definition])
    (form/symbols [ss : (List Bytes)])
    (form/parameters [ps : (List Parameter)])
    (form/parameter [p : Parameter])
    (form/statements [ss : (List Statement)])
    (form/statement [s : Statement])
    (form/expression [e : Expression])
    (form/type [t : PreType])

    ;(form/type [t : Type])
    (form/token [t : Token])))


(define (core-term-cmp [l : CoreTerm] [r : CoreTerm]) : Ordering
  (case (tuple2 l r)
    [(tuple2 (term/punctuation l) (term/punctuation r))
     (punctuation-cmp l r)]
    [(tuple2 (term/punctuation _) _)
     (less-than)]
    [(tuple2 _ (term/punctuation _))
     (greater-than)]
    [(tuple2 (term/language-keyword l) (term/language-keyword r))
     (bytes-cmp l r)]
    [(tuple2 (term/language-keyword _) _)
     (less-than)]
    [(tuple2 _ (term/language-keyword _))
     (greater-than)]
    [(tuple2 (term/id) (term/id))
     (equal-to)]
    [(tuple2 (term/id) _)
     (less-than)]
    [(tuple2 _ (term/id))
     (greater-than)]
    [(tuple2 (term/number) (term/number))
     (equal-to)]))

(define (core-non-term-cmp [a : CoreNonTerm] [b : CoreNonTerm]) : Ordering
  (match-define convert
    (lambda ([v : CoreNonTerm])
      (case v
        [(non-term/Module) 1]
        [(non-term/ModName) 2]
        [(non-term/Definitions) 3]
        [(non-term/Definition) 4]
        [(non-term/Parameters) 5]
        [(non-term/NonEmptyParameters) 6]
        [(non-term/Parameter) 7]
        [(non-term/Statements) 8]
        [(non-term/Statement) 9]
        [(non-term/Expression) 10]
        [(non-term/Type) 11]
        [(non-term/IfStatement) 12]
        [(non-term/ElseChain) 13]
        [(non-term/E1) 14]
        [(non-term/E2) 15]
        )))
  (int-cmp (convert a) (convert b)))

(define (core-non-term->bytes [nt : CoreNonTerm]) : Bytes
  (case nt
    [(non-term/Module) #"Module"]
    [(non-term/ModName) #"ModName"]
    [(non-term/Definitions) #"Definitions"]
    [(non-term/Definition) #"Definition"]
    [(non-term/Parameters) #"Parameters"]
    [(non-term/NonEmptyParameters) #"NonEmptyParameters"]
    [(non-term/Parameter) #"Parameter"]
    [(non-term/Statements) #"Statements"]
    [(non-term/Statement) #"Statement"]
    [(non-term/Expression) #"Expression"]
    [(non-term/Type) #"Type"]
    [(non-term/IfStatement) #"IfStatement"]
    [(non-term/ElseChain) #"ElseChain"]
    [(non-term/E1) #"E1"]
    [(non-term/E2) #"E2"]
    ))

(define (core-term->bytes [t : CoreTerm]) : Bytes
  (case t
    [(term/punctuation p) (punctuation->bytes p)]
    [(term/language-keyword k) k]
    [(term/id) #"id"]
    [(term/number) #"number"]))


(define (token->terminal [token : Token]) : (Either Bytes CoreTerm)
  (case token
    [(punctuation-token p) (right (term/punctuation p))]
    [(symbol-token s)
     (case s
       [#"if" (right (term/language-keyword s))]
       [#"else" (right (term/language-keyword s))]
       [#"return" (right (term/language-keyword s))]
       [#"as" (right (term/language-keyword s))]
       [#"while" (right (term/language-keyword s))]
       [_ (right (term/id))])]
    [(decimal-number-token _) (right (term/number))]
    [(keyword-token k)
     (case k
       [#"module" (right (term/language-keyword k))]
       [#"define_function" (right (term/language-keyword k))]
       [_ (left #"Bad keyword token")])]
    [_ (left #"Bad token type")]))


(define (core-production-rules) : (List (InputProductionRule CoreNonTerm CoreTerm Form))
  (match-define Module* (non-term/Module))
  (match-define ModName* (non-term/ModName))
  (match-define Definitions* (non-term/Definitions))
  (match-define Definition* (non-term/Definition))
  (match-define Parameters* (non-term/Parameters))
  (match-define NonEmptyParameters* (non-term/NonEmptyParameters))
  (match-define Parameter* (non-term/Parameter))
  (match-define Statements* (non-term/Statements))
  (match-define Statement* (non-term/Statement))
  (match-define IfStatement* (non-term/IfStatement))
  (match-define ElseChain* (non-term/ElseChain))
  (match-define Expression* (non-term/Expression))
  (match-define E1* (non-term/E1))
  (match-define E2* (non-term/E2))
  (match-define Type* (non-term/Type))

  (match-define symbol/term
    (lambda ([x : CoreTerm]) : (Symbol CoreNonTerm CoreTerm)
      (symbol/term x)))
  (match-define symbol/non-term
    (lambda ([x : CoreNonTerm]) : (Symbol CoreNonTerm CoreTerm)
      (symbol/non-term x)))

  (match-define ModName (symbol/non-term (non-term/ModName)))
  (match-define Definitions (symbol/non-term (non-term/Definitions)))
  (match-define Definition (symbol/non-term (non-term/Definition)))
  (match-define Parameters (symbol/non-term (non-term/Parameters)))
  (match-define NonEmptyParameters (symbol/non-term (non-term/NonEmptyParameters)))
  (match-define Parameter (symbol/non-term (non-term/Parameter)))
  (match-define Statements (symbol/non-term (non-term/Statements)))
  (match-define Statement (symbol/non-term (non-term/Statement)))
  (match-define IfStatement (symbol/non-term (non-term/IfStatement)))
  (match-define ElseChain (symbol/non-term (non-term/ElseChain)))
  (match-define Expression (symbol/non-term (non-term/Expression)))
  (match-define E1 (symbol/non-term (non-term/E1)))
  (match-define E2 (symbol/non-term (non-term/E2)))
  (match-define Type (symbol/non-term (non-term/Type)))

  (match-define + (symbol/term (term/punctuation (punct/plus))))
  (match-define - (symbol/term (term/punctuation (punct/minus))))
  (match-define * (symbol/term (term/punctuation (punct/multiplication))))
  (match-define / (symbol/term (term/punctuation (punct/division))))
  (match-define & (symbol/term (term/punctuation (punct/bitwise-and))))
  (match-define && (symbol/term (term/punctuation (punct/logical-and))))
  (match-define bar (symbol/term (term/punctuation (punct/bitwise-or))))
  (match-define barbar (symbol/term (term/punctuation (punct/logical-or))))
  (match-define paren-< (symbol/term (term/punctuation (punct/left-paren))))
  (match-define >-paren (symbol/term (term/punctuation (punct/right-paren))))
  (match-define bracket-< (symbol/term (term/punctuation (punct/left-bracket))))
  (match-define >-bracket (symbol/term (term/punctuation (punct/right-bracket))))
  (match-define brace-< (symbol/term (term/punctuation (punct/left-brace))))
  (match-define >-brace (symbol/term (term/punctuation (punct/right-brace))))
  (match-define < (symbol/term (term/punctuation (punct/less-than))))
  (match-define > (symbol/term (term/punctuation (punct/greater-than))))
  (match-define != (symbol/term (term/punctuation (punct/not-equal))))
  (match-define := (symbol/term (term/punctuation (punct/assignment))))
  (match-define <- (symbol/term (term/punctuation (punct/pointer-assignment))))
  (match-define -> (symbol/term (term/punctuation (punct/pointer-field-access))))
  (match-define ->& (symbol/term (term/punctuation (punct/pointer-offset))))
  (match-define comma (symbol/term (term/punctuation (punct/comma))))
  (match-define semi-colon (symbol/term (term/punctuation (punct/semi-colon))))
  (match-define if (symbol/term (term/language-keyword #"if")))
  (match-define else (symbol/term (term/language-keyword #"else")))
  (match-define return (symbol/term (term/language-keyword #"return")))
  (match-define while (symbol/term (term/language-keyword #"while")))
  (match-define as (symbol/term (term/language-keyword #"as")))
  (match-define module-keyword (symbol/term (term/language-keyword #"module")))
  (match-define define-function-keyword (symbol/term (term/language-keyword #"define_function")))

  (match-define id (symbol/term (term/id)))
  (match-define number (symbol/term (term/number)))


  (match-define identity*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons f (empty)) (right f)]
        [_ (left #"Bad forms for identity")])))

  (match-define module*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons _keyword
           (cons _<
             (cons (form/symbols symbols)
               (cons _>
                 (cons (form/definitions defs)
                   (empty))))))
         (right (form/module (module (mod-name symbols) defs)))]
        [_ (left #"Bad forms for module")])))

  (match-define mod-name*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(empty)
         (right (form/symbols (empty)))]
        [(cons (form/token (symbol-token s)) (cons (form/symbols ss) (empty)))
         (right (form/symbols (cons s ss)))]
        [_ (left #"Bad forms for mod-name")])))


  (match-define definitions*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(empty)
         (right (form/definitions (empty)))]
        [(cons (form/definition d) (cons (form/definitions ds) (empty)))
         (right (form/definitions (cons d ds)))]
        [_ (left #"Bad forms for definitions")])))


  (match-define function-definition*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons _keyword
           (cons (form/token (symbol-token name))
             (cons _paren-<
               (cons (form/parameters params)
                 (cons _>-paren
                   (cons _brace-<
                     (cons (form/statements statements)
                       (cons _>-brace
                         (empty)))))))))
         (right (form/definition (function-definition name params statements)))]
        [_ (left #"Bad forms for function-definition")])))

  (match-define parameters*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(empty)
         (right (form/parameters (empty)))]
        [(cons (form/parameters ps) (empty))
         (right (form/parameters ps))]
        [_ (left #"Bad forms for parameters")])))

  (match-define non-empty-parameters*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/parameter p) (empty))
         (right (form/parameters (varargs list p)))]
        [(cons (form/parameter p) (cons _comma (cons (form/parameters ps) (empty))))
         (right (form/parameters (cons p ps)))]
        [_ (left #"Bad forms for non-empty parameters")])))

  (match-define parameter*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/type t)
           (cons (form/token (symbol-token param))
             (empty)))
         (right (form/parameter (parameter param t)))]
        [_ (left #"Bad forms for parameter")])))


  (match-define statements*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(empty)
         (right (form/statements (empty)))]
        [(cons (form/statement s) (cons (form/statements ss) (empty)))
         (right (form/statements (cons s ss)))]
        [_ (left #"Bad forms for statements")])))

  (match-define return*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/token (symbol-token #"return"))
           (cons (form/expression e)
             (cons _semi-colon
               (empty))))
         (right (form/statement (return-statement e)))]
        [_ (left #"Bad forms for return")])))
  (match-define local-variable*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/type ty)
           (cons (form/token (symbol-token v))
             (cons _:=
               (cons (form/expression e)
                 (cons _
                   (empty))))))
         (right (form/statement (define-local-variable-statement v ty e)))]
        [_ (left #"Bad forms for local-variable")])))
  (match-define assignment*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/token (symbol-token v))
           (cons _:=
             (cons (form/expression e)
               (cons _
                 (empty)))))
         (right (form/statement (assignment-statement v e)))]
        [_ (left #"Bad forms for assignment")])))
  (match-define pointer-assignment*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons _*
           (cons (form/expression e1)
             (cons _<-
               (cons (form/expression e2)
                 (cons _
                   (empty))))))
         (right (form/statement (pointer-assignment-statement e1 e2)))]
        [_ (left #"Bad forms for pointer assignment")])))
  (match-define while*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/token (symbol-token #"while"))
           (cons _<
             (cons (form/expression e)
               (cons _>
                 (cons _<<
                   (cons (form/statements ss)
                     (cons _>>
                       (empty))))))))
         (right (form/statement (while-statement e ss)))]
        [_ (left #"Bad forms for while")])))


  (match-define if*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/token (symbol-token #"if"))
           (cons _<
             (cons (form/expression e)
               (cons _>
                 (cons _<<
                   (cons (form/statements t)
                     (cons _>>
                       (cons (form/statements f)
                         (empty)))))))))
         (right (form/statement (if-statement e t f)))]
        [_ (left #"Bad forms for if")])))

  (match-define else*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(empty)
         (right (form/statements (empty)))]
        [(cons (form/token (symbol-token #"else"))
           (cons _<<
             (cons (form/statements f)
               (cons _>>
                 (empty)))))
         (right (form/statements f))]
        [(cons (form/token (symbol-token #"else"))
           (cons (form/statement f)
             (empty)))
         (right (form/statements (cons f (empty))))]
        [_ (left #"Bad forms for else")])))


  (match-define var-expr*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/token (symbol-token v)) (empty))
         (right (form/expression (var-expr v)))]
        [_ (left #"Bad forms for var expr")])))
  (match-define number-expr*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/token (decimal-number-token v)) (empty))
         (case (decimal-bytes->integer v)
           [(nothing) (left #"Bad decimal number token")]
           [(just (lifted-int v)) (right (form/expression (int-expr v)))])]
        [_ (left #"Bad forms for number")])))
  (match-define paren-expr*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons _<
           (cons (form/expression e)
             (cons _>
               (empty))))
         (right (form/expression e))]
        [_ (left #"Bad forms for paren expression")])))
  (match-define cast-expr*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons _as
           (cons _<
             (cons (form/type t)
              (cons _>
                (cons _<
                  (cons (form/expression e)
                    (cons _>
                      (empty))))))))
         (right (form/expression (cast-expr t e)))]
        [_ (left #"Bad forms for cast expression")])))

  (match-define bin-op-expr*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/expression l)
           (cons (form/token (punctuation-token p))
             (cons (form/expression r) (empty))))
         (case (ann (Either Bytes BinOp)
                    (case p
                      [(punct/less-than) (right (comparison-bin-op (less-than-op)))]
                      [(punct/greater-than) (right (comparison-bin-op (greater-than-op)))]
                      [(punct/not-equal) (right (comparison-bin-op (not-equal-op)))]
                      [(punct/plus) (right (numeric-bin-op (add-op)))]
                      [(punct/minus) (right (numeric-bin-op (sub-op)))]
                      [(punct/multiplication) (right (numeric-bin-op (mult-op)))]
                      [(punct/division) (right (numeric-bin-op (quotient-op)))]
                      [(punct/bitwise-and) (right (numeric-bin-op (bitwise-and-op)))]
                      [(punct/bitwise-or) (right (numeric-bin-op (bitwise-ior-op)))]
                      [(punct/logical-and) (right (logical-bin-op (and-op)))]
                      [(punct/logical-or) (right (logical-bin-op (ior-op)))]
                      [_ (left #"Bad op form for bin-op expr")]))
           [(left v) (left v)]
           [(right op)
            (right (form/expression (bin-op-expr op l r)))])]
        [_ (left #"Bad forms for bin-op expr")])))

  (match-define deref-expr*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons _* (cons (form/expression e) (empty)))
         (right (form/expression e))]
        [_ (left #"Bad forms for deref expr")])))

  (match-define array-index-expr*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/expression e)
           (cons _->&
             (cons _<
               (cons (form/expression i)
                 (cons _>
                   (empty))))))
         (right (form/expression (array-index-expr e i)))]
        [_ (left #"Bad forms for array-index expr")])))

  (match-define array-deref-expr*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/expression e)
           (cons _->&
             (cons _<
               (cons (form/expression i)
                 (cons _>
                   (empty))))))
         (right (form/expression (deref-expr (array-index-expr e i))))]
        [_ (left #"Bad forms for array-index expr")])))



  (match-define var-type*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/token (symbol-token v)) (empty))
         (right (form/type (var-pre-type v)))]
        [_ (left #"Bad forms for var type")])))
  (match-define array-type*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/type t)
           (cons _<
             (cons _>
               (empty))))
         (right (form/type (array-pre-type t)))]
        [_ (left #"Bad forms for array type")])))
  (match-define pointer-type*
    (lambda ([forms : (List Form)]) : (Either Bytes Form)
      (case forms
        [(cons (form/type t)
           (cons _*
             (empty)))
         (right (form/type (pointer-pre-type t)))]
        [_ (left #"Bad forms for array type")])))

  (varargs list
    (input-production-rule Module* (varargs list module-keyword paren-< ModName >-paren Definitions) module*)
    (input-production-rule Definitions* (empty) definitions*)
    (input-production-rule Definitions* (varargs list Definition Definitions) definitions*)
    (input-production-rule Definition*
      (varargs list define-function-keyword id paren-< Parameters >-paren
                    brace-< Statements >-brace)
      function-definition*)
    (input-production-rule ModName* (empty) mod-name*)
    (input-production-rule ModName* (varargs list id ModName) mod-name*)
    (input-production-rule Parameters* (empty) parameters*)
    (input-production-rule Parameters* (varargs list NonEmptyParameters) parameters*)
    (input-production-rule NonEmptyParameters*
      (varargs list Parameter)
      non-empty-parameters*)
    (input-production-rule NonEmptyParameters*
      (varargs list Parameter comma NonEmptyParameters)
      non-empty-parameters*)
    (input-production-rule Parameter* (varargs list Type id) parameter*)
    (input-production-rule Statements* (empty) statements*)
    (input-production-rule Statements* (varargs list Statement Statements) statements*)
    (input-production-rule Statement* (varargs list return Expression semi-colon) return*)
    (input-production-rule Statement* (varargs list Type id := Expression semi-colon) local-variable*)
    (input-production-rule Statement* (varargs list id := Expression semi-colon) assignment*)
    (input-production-rule Statement*
      (varargs list * Expression <- Expression semi-colon)
      pointer-assignment*)
    (input-production-rule Statement*
      (varargs list while paren-< Expression >-paren brace-< Statements >-brace)
      while*)

    ;; If statements
    (input-production-rule Statement* (varargs list IfStatement) identity*)
    (input-production-rule IfStatement*
      (varargs list if paren-< Expression >-paren brace-< Statements >-brace ElseChain)
      if*)
    (input-production-rule ElseChain* (empty) else*)
    (input-production-rule ElseChain* (varargs list else brace-< Statements >-brace) else*)
    (input-production-rule ElseChain* (varargs list else IfStatement) else*)

    ;; Expressions
    (input-production-rule Expression* (varargs list E1) identity*)
    (input-production-rule E1* (varargs list E2) identity*)
    (input-production-rule E1* (varargs list E2 < E1) bin-op-expr*)
    (input-production-rule E1* (varargs list E2 > E1) bin-op-expr*)
    (input-production-rule E1* (varargs list E2 + E1) bin-op-expr*)
    (input-production-rule E1* (varargs list E2 - E1) bin-op-expr*)
    (input-production-rule E1* (varargs list E2 * E1) bin-op-expr*)
    (input-production-rule E1* (varargs list E2 / E1) bin-op-expr*)
    (input-production-rule E1* (varargs list E2 & E1) bin-op-expr*)
    (input-production-rule E1* (varargs list E2 && E1) bin-op-expr*)
    (input-production-rule E1* (varargs list E2 != E1) bin-op-expr*)
    (input-production-rule E1* (varargs list E2 bar E1) bin-op-expr*)
    (input-production-rule E1* (varargs list E2 barbar E1) bin-op-expr*)

    (input-production-rule E1* (varargs list * E1) deref-expr*)
    (input-production-rule E1* (varargs list E2 ->& bracket-< E1 >-bracket ) array-index-expr*)
    (input-production-rule E1* (varargs list E2 -> bracket-< E1 >-bracket ) array-deref-expr*)


    (input-production-rule E2* (varargs list id) var-expr*)
    (input-production-rule E2* (varargs list number) number-expr*)
    (input-production-rule E2* (varargs list paren-< E1 >-paren) paren-expr*)
    (input-production-rule E2* (varargs list as < Type > paren-< E1 >-paren) cast-expr*)

    ;; Types
    (input-production-rule Type* (varargs list id) var-type*)
    (input-production-rule Type* (varargs list Type bracket-< >-bracket) array-type*)
    (input-production-rule Type* (varargs list Type *) pointer-type*)

    ;(input-production-rule E* (varargs list id) var*)
    ;(input-production-rule E* (varargs list num) num*)

    ;(input-production-rule E* (varargs list E + T) bin-op*)
    ;(input-production-rule E* (varargs list E - T) bin-op*)
    ;(input-production-rule E* (varargs list T) identity*)
    ;(input-production-rule T* (varargs list T * F) bin-op*)
    ;(input-production-rule T* (varargs list T / F) bin-op*)
    ;(input-production-rule T* (varargs list F) identity*)
    ;(input-production-rule F* (varargs list paren-< E >-paren) parens*)
    ;(input-production-rule F* (varargs list id) var*)
    ;(input-production-rule F* (varargs list num) num*)
    ;(input-production-rule S* (varargs list id := E !) assign*)
    ;(input-production-rule S* (varargs list Type id := E !) local-variable*)
    ;(input-production-rule S* (varargs list while paren-< E >-paren brace-< Ss >-brace) while*)
    ;(input-production-rule Ss* (empty) statements*)
    ;(input-production-rule Ss* (varargs list S Ss) statements*)
    ;(input-production-rule Type* (varargs list id) var-type*)

  ))

(define (make-module-grammar) : (Grammar CoreNonTerm CoreTerm Form)
  (grammar (non-term/Module)
           (core-production-rules)
           core-non-term-cmp core-term-cmp))

(define (make-module-parser) : (Either Bytes (Parser CoreNonTerm CoreTerm Form))
  (build-parser (make-module-grammar)
                form/token
                token->terminal))
