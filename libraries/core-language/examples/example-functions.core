#:module (core_language examples example_functions)

#:define_function
U64 fun_none() { }

#:define_function
U64 fun_only(U64 arg) {
  return arg;
}

#:define_function
U64 fun_first(U64 arg_a, U64 arg_b) {
  return arg_a;
}

#:define_function
U64 fun_greater(U64 arg1, U64 arg2) {
  if (arg1 > arg2) {
    return arg1;
  } else {
    return arg2;
  }
}

#:define_function
U64 fun_greater_local(U64 arg1, U64 arg2) {
  U64 max := arg1;
  if (arg2 > arg1) {
    max := arg2;
  }
  return max;
}

#:define_function
U64 fun_if(U64 arg1, U64 arg2) {
  if (arg1 < arg2) {
    return arg2;
  }
}

#:define_function
U64 fun_else(U64 arg1, U64 arg2) {
  if (arg1 != 0) {
    return arg2;
  } else {
    return arg1;
  }
}

#:define_function
U64 fun_elseif1(U64 arg1, U64 arg2) {
  if (arg1 != 0) {
    return arg2;
  } else if (arg2 != 0) {
    return arg2;
  }
}

#:define_function
U64 fun_elseif2(U64 arg1, U64 arg2) {
  if (arg1 != 0) {
    return arg2;
  } else if (arg1 != 0) {
    return arg1;
  } else if (arg1 != 0) {
    return arg1;
  } else {
    return arg1;
  }
}

#:define_function
U64 fun_untag(U64 tagged_descriptor) {
  return as<U64>((0 - 8) & tagged_descriptor);
}

#:define_function
U64 fun_triangle(U64 v) {
  U64 sum := 0;
  while (v != 0) {
    sum := sum + v;
    v := v - 1;
  }
  return sum;
}

#:define_function
U64 fun_bytes_size(Bytes bytes) {
  return as<U64[]*>(bytes)->[1];
}


#:define_function
U64 fun_fact(U64 i) {
  if (i == 0) {
    return 1;
  } else {
    return i * fun_fact(i - 1);
  }
}

#:define_function
U64 fun_bytes_const(U64 i) {
  Bytes b := #"A\x00\x00\x00\x00\x00\x00\x00";
  U64[]* v := as<U64[]*>(b);
  return (v->[1]) + v->[2];
}

#:define_function
U64 fun_bytes_const2() {
  Bytes b := #"12";
  U8[]* v := as<U8[]*>(as<U64>(b) + 16);
  return (as<U64>(v->[0]) + as<U64>(v->[1]));
}

#:define_function
U64 fun_mutate_bytes(Bytes b) {
  U8[]* v := as<U8[]*>(as<U64>(b) + 16);
  *v->&[0] <- v->[1];
  return 0;
}

#:define_struct Posn {
  U8 x;
  U8 y;
}

#:define_function
U64 fun_use_posn() {
  Posn* p := as<Posn*>(as<U64>(#"13") + 16);
  U8 vx := p->x;
  U8 vy := p->y;
  return as<U64>(vx) + as<U64>(vy);
}


#:define_function
U64 fun_seq_calls_helper(U64* p, U64 adj) {
  *p <- (*p) + adj;
  return 0;
}


#:define_function
U64 fun_seq_calls(Bytes b) {
  U64[]* v := as<U64[]*>(as<U64>(b) + 16);
  <> fun_seq_calls_helper(v->&[0], 2);
  <> fun_seq_calls_helper(v->&[0], 256);
  return 0;
}

#:define_struct Header {
  U8 version;
  U8 size;
}

#:define_struct Message {
  Header header;
  U8 value;
}

#:define_function
U8 fun_nested_struct() {
  Message* v := as<Message*>(as<U64>(#"012") + 16);
  return v->value;
}

#:define_struct Vector3 {
  U8 x;
  U8 y;
  U8 z;
}

#:define_struct Matrix33 {
  Vector3[3] vs;
}

#:define_function
U8 fun_matrix() {
  Matrix33* m := as<Matrix33*>(as<U64>(#"012345678") + 16);
  return ((m->&vs)->&[2])->x;
}
