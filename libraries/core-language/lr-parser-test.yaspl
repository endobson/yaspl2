#:module (core-language lr-parser-test)
#:import {
  (bytes)
  (core-language lexer)
  (core-language lr-parser)
  (data source-location)
  (dict)
  (either)
  (list)
  (maybe)
  (numbers)
  (prim)
  (set)
  (unique-dict)
  (data ordering)
  (yunit)
}
(export
  (#:values main))
(types
  (define-type TestNonTerm
    (non-term/E)
    (non-term/F)
    (non-term/T))
  (define-type TestTerm
    (term/plus)
    (term/minus)
    (term/times)
    (term/divide)
    (term/left-paren)
    (term/right-paren)
    (term/id))

  (define-type BinOp
    (op/plus)
    (op/minus)
    (op/times)
    (op/divide))

  (define-type Expr
    (bin-op-expr [op : BinOp] [l : Expr] [r : Expr])
    (var-expr [var : Bytes]))

  (define-type Form
    (form/expr [e : Expr])
    (form/token [t : Token])))

(define (test-term-cmp [a : TestTerm] [b : TestTerm]) : Ordering
  (match-define convert
    (lambda ([v : TestTerm])
      (case v
        [(term/plus) 0]
        [(term/minus) 1]
        [(term/times) 2]
        [(term/divide) 3]
        [(term/left-paren) 4]
        [(term/right-paren) 5]
        [(term/id) 6])))
  (int-cmp (convert a) (convert b)))

(define (test-non-term-cmp [a : TestNonTerm] [b : TestNonTerm]) : Ordering
  (match-define convert
    (lambda ([v : TestNonTerm])
      (case v
        [(non-term/E) 0]
        [(non-term/F) 1]
        [(non-term/T) 2])))
  (int-cmp (convert a) (convert b)))


(define (token->terminal [token : Token]) : TestTerm
  (case token
    [(left-paren-token) (term/left-paren)]
    [(right-paren-token) (term/right-paren)]
    [(symbol-token _) (term/id)]
    [(plus-token) (term/plus)]
    [(multiplication-token) (term/times)]
    [_ (panic #"Bad token type")]))

(define (test-production-rules) : (List (ProductionRule TestNonTerm TestTerm Form))
  (match-define E* (non-term/E))
  (match-define F* (non-term/F))
  (match-define T* (non-term/T))

  (match-define E : (Symbol TestNonTerm TestTerm) (symbol/non-term (non-term/E)))
  (match-define F : (Symbol TestNonTerm TestTerm) (symbol/non-term (non-term/F)))
  (match-define T : (Symbol TestNonTerm TestTerm) (symbol/non-term (non-term/T)))
  (match-define + : (Symbol TestNonTerm TestTerm) (symbol/term (term/plus)))
  (match-define - : (Symbol TestNonTerm TestTerm) (symbol/term (term/minus)))
  (match-define * : (Symbol TestNonTerm TestTerm) (symbol/term (term/times)))
  (match-define / : (Symbol TestNonTerm TestTerm) (symbol/term (term/divide)))
  (match-define < : (Symbol TestNonTerm TestTerm) (symbol/term (term/left-paren)))
  (match-define > : (Symbol TestNonTerm TestTerm) (symbol/term (term/right-paren)))
  (match-define id : (Symbol TestNonTerm TestTerm) (symbol/term (term/id)))

  (match-define bin-op*
    (lambda ([forms : (List Form)]) : Form
      (case forms
        [(cons (form/expr l) (cons _op (cons (form/expr r) (empty))))
         (form/expr (bin-op-expr (op/plus) l r))]
        [_ (panic #"Bad forms for bin-op")])))

  (match-define identity*
    (lambda ([forms : (List Form)]) : Form
      (case forms
        [(cons f (empty))
         f]
        [_ (panic #"Bad forms for identity")])))

  (match-define parens*
    (lambda ([forms : (List Form)]) : Form
      (case forms
        [(cons _lparen (cons f (cons _rparen (empty))))
         f]
        [_ (panic #"Bad forms for parens")])))

  (match-define var*
    (lambda ([forms : (List Form)]) : Form
      (case forms
        [(cons (form/token (symbol-token v)) (empty))
         (form/expr (var-expr v))]
        [_ (panic #"Bad forms for identifier")])))


  (varargs list
    (production-rule E* 1 (varargs list E + T) bin-op*)
    (production-rule E* 2 (varargs list E - T) bin-op*)
    (production-rule E* 3 (varargs list T) identity*)
    (production-rule T* 4 (varargs list T * F) bin-op*)
    (production-rule T* 5 (varargs list T / F) bin-op*)
    (production-rule T* 6 (varargs list F) identity*)
    (production-rule F* 7 (varargs list < E >) parens*)
    (production-rule F* 8 (varargs list id) var*)))

(define (make-test-parser) : (Parser TestNonTerm TestTerm Form)
  (case (build-parser (grammar (non-term/E) (test-production-rules)
                               test-non-term-cmp test-term-cmp)
                      form/token
                      token->terminal)
    [(left v) (panic v)]
    [(right v) v]))

(define (parses [input : Bytes]) : (-> (Maybe FailedAssertion))
  (lambda ()
    (match-define lexer (make-core-lexer (sourced-bytes (unnamed-source) input)))
    (case (run-parser (make-test-parser) lexer)
      [(left v) (just (failure v))]
      [(right _) (nothing)])))


(define (fails-parse [input : Bytes]) : (-> (Maybe FailedAssertion))
  (lambda ()
    (match-define lexer (make-core-lexer (sourced-bytes (unnamed-source) input)))
    (case (run-parser (make-test-parser) lexer)
      [(left v) (nothing)]
      [(right _) (just (failure #"Expected failed parse but parsing suceeded"))])))

(define (print-test-case) : (Maybe FailedAssertion)
  (case (build-parser (grammar (non-term/E) (test-production-rules)
                               test-non-term-cmp test-term-cmp)
                      form/token
                      token->terminal)
    [(left v) (just (failure v))]
    [(right parser)
     (match-define action-map (parser-action parser))
     (match-define output : (List Bytes)
       (interleave
         (dict-map
           action-map
           (lambda ([s : StateId] [d : (Dict (LiftedTerm TestTerm) (Action TestNonTerm))])
             (bytes-append
               (varargs list
                 (integer->decimal-bytes (state-id-v s))
                 #": "
                 (bytes-append
                   (interleave
                     (dict-map
                       d
                       (lambda ([t : (LiftedTerm TestTerm)]
                                [act : (Action TestNonTerm)])
                         (bytes-append
                           (varargs list
                             (print-lifted-term t)
                             (case act
                               [(accept) #":<accept>"]
                               [(reduce _ _ _) #":<reduce>"]
                               [(shift (state-id s))
                                (bytes-append
                                  (varargs list
                                    #":<s " (integer->decimal-bytes s) #">"))])))))
                     #" "))
                 ))))
         #"\n"))
     (just (failure (bytes-append (cons #"\n" output))))]))


(define (print-first-test-case) : (Maybe FailedAssertion)
  (match-define rules (test-production-rules))
  (match-define rules-dict (production-rules-dict rules test-non-term-cmp))
  (match-define empty-table (build-empty-table rules-dict test-non-term-cmp))
  (match-define first-table (build-first-table rules-dict empty-table test-non-term-cmp
                                               test-term-cmp))


  (match-define output
    (dict-map
      first-table
      (lambda ([v : TestNonTerm] [s : (Set TestTerm)])
        (bytes-append
          (varargs list
            (print-non-term v)
            #": "
            (bytes-append (interleave (map print-term (set->list s)) #" "))
            #"\n")))))

  (just (failure (bytes-append (cons #"\n" output)))))


(define (print-follow-test-case) : (Maybe FailedAssertion)
  (match-define rules (test-production-rules))
  (match-define rules-dict (production-rules-dict rules test-non-term-cmp))
  (match-define empty-table (build-empty-table rules-dict test-non-term-cmp))
  (match-define first-table (build-first-table rules-dict empty-table test-non-term-cmp test-term-cmp))
  (match-define follow-table (build-follow-table (non-term/E)
                                                 rules-dict empty-table first-table test-non-term-cmp
                                                 test-term-cmp))


  (match-define output
    (dict-map
      follow-table
      (lambda ([v : TestNonTerm] [s : (Set (LiftedTerm TestTerm))])
        (bytes-append
          (varargs list
            (print-non-term v)
            #": "
            (bytes-append (interleave (map print-lifted-term (set->list s)) #" "))
            #"\n")))))

  (just (failure (bytes-append (cons #"\n" output)))))


(define (print-non-term [nt : TestNonTerm]) : Bytes
  (case nt
    [(non-term/E) #"E"]
    [(non-term/F) #"F"]
    [(non-term/T) #"T"]))

(define (print-lifted-term [t : (LiftedTerm TestTerm)]) : Bytes
  (case t
    [(end-of-terminals) #"$"]
    [(lifted-term t) (print-term t)]))

(define (print-term [t : TestTerm]) : Bytes
  (case t
    [(term/plus) #"+"]
    [(term/minus) #"-"]
    [(term/times) #"*"]
    [(term/divide) #"/"]
    [(term/left-paren) #"("]
    [(term/right-paren) #")"]
    [(term/id) #"id"]))

(define (main [args : Bytes] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Int
  (yunit/main stderr
    (varargs list
      (test-case #"id" (parses #"x"))
      (test-case #"plus" (parses #"x+y"))
      (test-case #"plus-minus" (parses #"x+y-z+x"))
      (test-case #"plus-times" (parses #"x*y+z"))
      (test-case #"parens" (parses #"(x+y)*z"))
      (test-case #"extra plus" (fails-parse #"x+"))
      (test-case #"unbalanced parens 1" (fails-parse #"(x+y"))
      (test-case #"unbalanced parens 2" (fails-parse #"(x+y))"))
      )))

