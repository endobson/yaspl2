#:module (core-language lr-parser-test)
#:import {
  (core-language lexer)
  (core-language lr-parser)
  (data lifted-primitives)
  (data source-location)
  (either)
  (list)
  (maybe)
  (set)
  (prim)
  (unique-dict)
  (yunit)
}
(export
  (#:values main))
(types)

(define (parses [input : Bytes]) : (-> (Maybe FailedAssertion))
  (lambda ()
    (match-define lexer (make-core-lexer (sourced-bytes (unnamed-source) input)))
    (case (run-parser lexer)
      [(left v) (just (failure v))]
      [(right _) (nothing)])))


(define (fails-parse [input : Bytes]) : (-> (Maybe FailedAssertion))
  (lambda ()
    (match-define lexer (make-core-lexer (sourced-bytes (unnamed-source) input)))
    (case (run-parser lexer)
      [(left v) (nothing)]
      [(right _) (just (failure #"Expected failed parse but parsing suceeded"))])))

(define (closure-test-case) : (Maybe FailedAssertion)
  (match-define canonical-sets
    (canonical-item-sets
      (non-term/E)
      (varargs list
        (term/plus)
        (term/times)
        (term/left-paren)
        (term/right-paren)
        (term/id))
      (test-production-rules-dict)))

  (expect-equal/int (set-count (unique-dict-keys canonical-sets)) 12))


(define (main [args : Bytes] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Int
  (yunit/main stderr
    (varargs list
      (test-case #"id" (parses #"x"))
      (test-case #"plus" (parses #"x+y"))
      (test-case #"plus-times" (parses #"x*y+z"))
      (test-case #"extra plus" (fails-parse #"x+"))
      (test-case #"closure" closure-test-case)
      )))

