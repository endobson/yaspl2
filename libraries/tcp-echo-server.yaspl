(module tcp-echo-server
  (import
    (prim
      #:types (Array Bytes InputPort OutputPort OutputPort Void)
      #:values (socket sendto bind shutdown listen accept make-bytes bytes-set! write-bytes quotient
                close-output-port
                remainder = void connect bytes-length + * bytes-ref array-length array-ref)
      #:patterns ())
    (io write-line read-all-bytes write-all-bytes)
    (buffered-port
      #:types (BufferedPort)
      #:values (make-buffered-port read-crlf-line)
      #:patterns (line-result))
    (numbers decimal-bytes->integer)
    (maybe
      #:types (Maybe)
      #:values (just nothing)
      #:patterns (just nothing))
    (mach spawn)
    (tuples
      #:types (Tuple2)
      #:values (tuple2)
      #:patterns (tuple2))
    (tcp tcp-address tcp-socket-bind tcp-socket-accept tcp-socket-set-reuse-address)
    (ip
      #:types (Ipv4Address)
      #:values (bytes->ipv4-address)
      #:patterns ()))
  (export)
  (types)

  (define (write-crlf [out : OutputPort]) : Void
    (let ([bytes (make-bytes 2)])
      (begin
        (bytes-set! bytes 0 #x0D)
        (bytes-set! bytes 1 #x0A)
        (write-all-bytes bytes out))))


  (define (read-loop [buffered-port : BufferedPort] [sock : Socket] [stdout : OutputPort]) : Void
    (case (read-crlf-line buffered-port)
      [(line-result bytes eof buffered-port)
       (begin
         (write-line bytes stdout)
         (if (= (bytes-length bytes) 0)
             (begin
               (write-all-bytes #"HTTP/1.1 200 OK" sock)
               (write-crlf sock)
               (write-all-bytes #"Content-Type: text/plain" sock)
               (write-crlf sock)
               (write-all-bytes #"Connection: close" sock)
               (write-crlf sock)
               (write-crlf sock)
               (write-line #"foobar" sock)
               (close-output-port sock))
             (if eof
                 (close-output-port sock)
                 (read-loop buffered-port sock stdout))))]))

  (define (accept-loop [sock : Socket] [stdout : OutputPort]) : Void
    (case (tcp-socket-accept sock)
      [(tuple2 new-sock new-sock-addr)
       (begin
         (spawn
           (lambda ()
             (read-loop (make-buffered-port new-sock) new-sock stdout)))
         (accept-loop sock stdout))]))

  (define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Byte
    (if (= (array-length args) 3)
        (case (bytes->ipv4-address (array-ref args 1))
          [(just ip-addr)
           (let ([address (tcp-address ip-addr (decimal-bytes->integer (array-ref args 2)))])
             (let ([sock (socket 2 1 0)])
               (begin
                 (tcp-socket-set-reuse-address sock #t)
                 (tcp-socket-bind sock address)
                 (listen sock 5)
                 (accept-loop sock stdout))))]
          [(nothing)
           (begin
             (write-line #"Unparsable ip address" stderr)
             1)])
        (begin
          (write-line #"Wrong number of arguments" stderr)
          1))))
