(module types
  (import
    (prim
      #:types (Bytes Boolean)
      #:values ()
      #:patterns ())
    (bytes bytes=?)
    (list
      #:types (List)
      #:values (list=?)
      #:patterns ())
    (tuples
      #:types (Tuple2)
      #:values (tuple2)
      #:patterns (tuple2)))
  (export
    #:types (Type)
    #:values (star-kind fun-kind kind=?
              abstract-type var-type fun-type type-constructor type=?)
    #:patterns (type-constructor))
  (types
    (define-type Kind
      (star-kind)
      (fun-kind [args (List Kind)] [result Kind]))
    (define-type Type
      (fun-type [type-vars (List Bytes)] [args (List Type)] [result Type])
      (var-type [v Bytes])
      (abstract-type [module-name Bytes] [name Bytes] [args (List Type)])
      (type-constructor [module-name Bytes] [name Bytes] [args (List Kind)])))

  (define (kind=? [k1 : Kind] [k2 : Kind]) : Boolean
    (case (tuple2 k1 k2)
      [(tuple2 (star-kind) (star-kind)) #t]
      [(tuple2 (fun-kind args1 result1) (fun-kind args2 result2))
       (if (kind=? result1 result2)
           ((list=? kind=?) args1 args2)
           #f)]
      [_ #f]))

  (define (type=? [t1 : Type] [t2 : Type]) : Boolean
    (case (tuple2 t1 t2)
      [(tuple2 (var-type v1) (var-type v2))
       (bytes=? v1 v2)]
      [(tuple2
         (abstract-type mod1 name1 args1)
         (abstract-type mod2 name2 args2))
       (if (bytes=? mod1 mod2)
           (if (bytes=? name1 name2)
               ((list=? type=?) args1 args2)
               #f)
           #f)]
      [(tuple2
         (fun-type args1 result1)
         (fun-type args2 result2))
       (if (type=? result1 result2)
           ((list=? type=?) args1 args2)
           #f)]
      [(tuple2
         (type-constructor mod1 name1 args1)
         (type-constructor mod2 name2 args2))
       (if (bytes=? mod1 mod2)
           (if (bytes=? name1 name2)
               ((list=? kind=?) args1 args2)
               #f)
           #f)]
      [_ #f])))
