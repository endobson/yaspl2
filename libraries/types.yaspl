#:module (types)
#:import {
  (bytes)
  (data ordering)
  (list)
  (maybe)
  (module-name)
  (prim)
  (sexp-parser)
  (sexp-printer)
  (tuples)
}
(export
  #:types (Type Kind)
  #:values (star-kind fun-kind kind=? serialize-kind
            abstract-type var-type fun-type type-constructor type=? serialize-type
            kind->sexp sexp->kind type->sexp sexp->type type-cmp print-type)
  #:patterns (type-constructor fun-type abstract-type var-type))
(types
  (define-type Kind
    (star-kind)
    (fun-kind [args : (List Kind)] [result : Kind]))
  (define-type Type
    (fun-type [type-vars : (List Bytes)] [args : (List Type)] [result : Type])
    (var-type [v : Bytes])
    (abstract-type [module-name : ModName] [name : Bytes] [args : (List Type)])
    (type-constructor [module-name : ModName] [name : Bytes] [args : (List Kind)])))

(define (kind=? [k1 : Kind] [k2 : Kind]) : Boolean
  (case (tuple2 k1 k2)
    [(tuple2 (star-kind) (star-kind)) #t]
    [(tuple2 (fun-kind args1 result1) (fun-kind args2 result2))
     (if (kind=? result1 result2)
         ((list=? kind=?) args1 args2)
         #f)]
    [_ #f]))

(define (kind-cmp [k1 : Kind] [k2 : Kind]) : Ordering
  (case (tuple2 k1 k2)
    [(tuple2 (star-kind) (star-kind)) (equal-to)]
    [(tuple2 (star-kind) _) (less-than)]
    [(tuple2 _ (star-kind)) (greater-than)]
    [(tuple2 (fun-kind args1 result1) (fun-kind args2 result2))
     (case ((list-cmp kind-cmp) args1 args2)
       [(equal-to)
        (kind-cmp result1 result2)]
       [res res])]))


(define (type=? [t1 : Type] [t2 : Type]) : Boolean
  (case (tuple2 t1 t2)
    [(tuple2 (var-type v1) (var-type v2))
     (bytes=? v1 v2)]
    [(tuple2
       (abstract-type mod1 name1 args1)
       (abstract-type mod2 name2 args2))
     (if (mod-name=? mod1 mod2)
         (if (bytes=? name1 name2)
             ((list=? type=?) args1 args2)
             #f)
         #f)]
    [(tuple2
       (fun-type type-vars1 args1 result1)
       (fun-type type-vars2 args2 result2))
     (if (type=? result1 result2)
         (if ((list=? bytes=?) type-vars1 type-vars2)
             ((list=? type=?) args1 args2)
             #f)
         #f)]
    [(tuple2
       (type-constructor mod1 name1 args1)
       (type-constructor mod2 name2 args2))
     (if (mod-name=? mod1 mod2)
         (if (bytes=? name1 name2)
             ((list=? kind=?) args1 args2)
             #f)
         #f)]
    [_ #f]))


(define (type-cmp [t1 : Type] [t2 : Type]) : Ordering
  (case (tuple2 t1 t2)
    [(tuple2 (var-type v1) (var-type v2))
     (bytes-cmp v1 v2)]
    [(tuple2 (var-type _) _)
     (less-than)]
    [(tuple2 _ (var-type _))
     (greater-than)]
    [(tuple2
       (abstract-type mod1 name1 args1)
       (abstract-type mod2 name2 args2))
     (case (mod-name-cmp mod1 mod2)
       [(equal-to)
        (case (bytes-cmp name1 name2)
          [(equal-to)
           ((list-cmp type-cmp) args1 args2)]
          [res res])]
       [res res])]
    [(tuple2 (abstract-type _ _ _) _)
     (less-than)]
    [(tuple2 _ (abstract-type _ _ _))
     (greater-than)]
    [(tuple2
       (fun-type type-vars1 args1 result1)
       (fun-type type-vars2 args2 result2))
     (case ((list-cmp bytes-cmp) type-vars1 type-vars2)
       [(equal-to)
        (case ((list-cmp type-cmp) args1 args2)
          [(equal-to)
           (type-cmp result1 result2)]
          [res res])]
       [res res])]
    [(tuple2 (fun-type _ _ _) _)
     (less-than)]
    [(tuple2 _ (fun-type _ _ _))
     (greater-than)]
    [(tuple2
       (type-constructor mod1 name1 args1)
       (type-constructor mod2 name2 args2))
     (case (mod-name-cmp mod1 mod2)
       [(equal-to)
        (case (bytes-cmp name1 name2)
          [(equal-to)
           ((list-cmp kind-cmp) args1 args2)]
          [res res])]
       [res res])]))


(define (serialize-type [type : Type]) : Bytes
  (print-sexp (type->sexp type)))

(define (type->sexp [type : Type]) : Sexp
  (case type
    [(var-type v) (node (varargs list (symbol-sexp #"var") (bytes-sexp v)))]
    [(abstract-type mod name args)
     (node (cons (symbol-sexp #"abstract")
                 (cons (mod-name->sexp mod)
                       (cons (bytes-sexp name)
                             (map type->sexp args)))))]
    [(fun-type type-vars args result)
     (node (cons (symbol-sexp #"fun")
                 (cons (node (map bytes-sexp type-vars))
                       (append (map type->sexp args) (cons (type->sexp result) (empty))))))]
    [(type-constructor mod name args)
     (node (cons (symbol-sexp #"tcon")
                 (cons (mod-name->sexp mod)
                       (cons (bytes-sexp name)
                             (map kind->sexp args)))))]))

(define (extract-type-var [sexp : Sexp]) : (Maybe Bytes)
  (case sexp
    [(bytes-sexp tv) (just tv)]
    [_ (nothing)]))

(define (sexp->type [sexp : Sexp]) : (Maybe Type)
  (case sexp
    [(node (cons (symbol-sexp #"var") (cons (bytes-sexp v) (empty))))
     (just (var-type v))]
    [(node (cons (symbol-sexp #"fun") (cons (node type-vars) types)))
     (case (extract-justs (reverse (map sexp->type types)))
       [(nothing) (nothing)]
       [(just (empty)) (nothing)]
       [(just (cons result rev-arg-types))
        (case (extract-justs (map extract-type-var type-vars))
          [(nothing) (nothing)]
          [(just type-vars)
           (just (fun-type type-vars (reverse rev-arg-types) result))])])]
    [(node (cons (symbol-sexp #"abstract")
                 (cons mod
                       (cons (bytes-sexp name)
                             types))))
     (case (extract-justs (map sexp->type types))
       [(nothing) (nothing)]
       [(just types)
        (case (sexp->mod-name mod)
          [(nothing) (nothing)]
          [(just mod)
           (just (abstract-type mod name types))])])]
    [(node (cons (symbol-sexp #"tcon")
                 (cons mod
                       (cons (bytes-sexp name)
                             kinds))))
     (case (extract-justs (map sexp->kind kinds))
       [(nothing) (nothing)]
       [(just kinds)
        (case (sexp->mod-name mod)
          [(nothing) (nothing)]
          [(just mod)
           (just (type-constructor mod name kinds))])])]
    [_ (nothing)]))

(define (serialize-kind [kind : Kind]) : Bytes
  (print-sexp (kind->sexp kind)))

(define (kind->sexp [kind : Kind]) : Sexp
  (case kind
    [(star-kind) (symbol-sexp #"*")]
    [(fun-kind args result)
     (node (varargs list (node (map kind->sexp args))
                         (symbol-sexp #"->")
                         (kind->sexp result)))]))

(define (sexp->kind [sexp : Sexp]) : (Maybe Kind)
  (case sexp
    [(symbol-sexp #"*") (just (star-kind))]
    [(node (cons (node args) (cons (symbol-sexp #"->") (cons result (empty)))))
     (case (extract-justs (map sexp->kind args))
       [(nothing) (nothing)]
       [(just args)
        (case (sexp->kind result)
          [(nothing) (nothing)]
          [(just result)
           (just (fun-kind args result))])])]
    [_ (nothing)]))

(define (print-type [type : Type]) : Bytes
  (print-sexp (type->print-sexp type)))

(define (type->print-sexp [type : Type]) : Sexp
  (case type
    [(var-type v) (symbol-sexp v)]
    [(abstract-type mod name (empty))
     (symbol-sexp name)]
    [(abstract-type mod name args)
     (node (cons (symbol-sexp name) (map type->print-sexp args)))]
    [(fun-type type-vars args result)
     (node (append
             (case type-vars
               [(empty) (empty)]
               [type-vars (varargs list (node (map symbol-sexp type-vars)))])
             (append (map type->print-sexp args)
                     (cons (symbol-sexp #"->")
                           (cons (type->print-sexp result) (empty))))))]
    [(type-constructor mod name args)
     (node (cons (symbol-sexp #"tcon")
                 (cons (mod-name->sexp mod)
                       (cons (symbol-sexp name)
                             (map kind->sexp args)))))]))
