(module types
  (import
    (prim
      #:types (Bytes Boolean)
      #:values ()
      #:patterns ())
    (bytes bytes=?)
    (list
      #:types (List)
      #:values (list=? list cons empty append map extract-justs)
      #:patterns (cons empty))
    (maybe
      #:types (Maybe)
      #:values (just nothing)
      #:patterns (just nothing))
    (tuples
      #:types (Tuple2)
      #:values (tuple2)
      #:patterns (tuple2))
    (sexp-printer print-sexp)
    (sexp-parser
      #:types (Sexp)
      #:values (node bytes-sexp symbol-sexp)
      #:patterns (node symbol-sexp bytes-sexp)))
  (export
    #:types (Type)
    #:values (star-kind fun-kind kind=? serialize-kind
              abstract-type var-type fun-type type-constructor type=? serialize-type
              kind->sexp sexp->kind)
    #:patterns (type-constructor))
  (types
    (define-type Kind
      (star-kind)
      (fun-kind [args (List Kind)] [result Kind]))
    (define-type Type
      (fun-type [type-vars (List Bytes)] [args (List Type)] [result Type])
      (var-type [v Bytes])
      (abstract-type [module-name Bytes] [name Bytes] [args (List Type)])
      (type-constructor [module-name Bytes] [name Bytes] [args (List Kind)])))

  (define (kind=? [k1 : Kind] [k2 : Kind]) : Boolean
    (case (tuple2 k1 k2)
      [(tuple2 (star-kind) (star-kind)) #t]
      [(tuple2 (fun-kind args1 result1) (fun-kind args2 result2))
       (if (kind=? result1 result2)
           ((list=? kind=?) args1 args2)
           #f)]
      [_ #f]))

  (define (type=? [t1 : Type] [t2 : Type]) : Boolean
    (case (tuple2 t1 t2)
      [(tuple2 (var-type v1) (var-type v2))
       (bytes=? v1 v2)]
      [(tuple2
         (abstract-type mod1 name1 args1)
         (abstract-type mod2 name2 args2))
       (if (bytes=? mod1 mod2)
           (if (bytes=? name1 name2)
               ((list=? type=?) args1 args2)
               #f)
           #f)]
      [(tuple2
         (fun-type type-vars1 args1 result1)
         (fun-type type-vars2 args2 result2))
       (if (type=? result1 result2)
           (if ((list=? bytes=?) type-vars1 type-vars2)
               ((list=? type=?) args1 args2)
               #f)
           #f)]
      [(tuple2
         (type-constructor mod1 name1 args1)
         (type-constructor mod2 name2 args2))
       (if (bytes=? mod1 mod2)
           (if (bytes=? name1 name2)
               ((list=? kind=?) args1 args2)
               #f)
           #f)]
      [_ #f]))

  (define (serialize-type [type : Type]) : Bytes
    (print-sexp (type->sexp type)))

  (define (type->sexp [type : Type]) : Sexp
    (case type
      [(var-type v) (node (varargs list (symbol-sexp #"var") (bytes-sexp v)))]
      [(abstract-type mod name args)
       (node (cons (symbol-sexp #"abstract")
                   (cons (bytes-sexp mod)
                         (cons (bytes-sexp name)
                               (map type->sexp args)))))]
      [(fun-type type-vars args result)
       (node (cons (symbol-sexp #"fun")
                   (cons (node (map bytes-sexp type-vars))
                         (append (map type->sexp args) (cons (type->sexp result) (empty))))))]
      [(type-constructor mod name args)
       (node (cons (symbol-sexp #"tcon")
                   (cons (bytes-sexp mod)
                         (cons (bytes-sexp name)
                               (map kind->sexp args)))))]))

  (define (serialize-kind [kind : Kind]) : Bytes
    (print-sexp (kind->sexp kind)))

  (define (kind->sexp [kind : Kind]) : Sexp
    (case kind
      [(star-kind) (symbol-sexp #"*")]
      [(fun-kind args result)
       (node (varargs list (node (map kind->sexp args))
                           (symbol-sexp #"->")
                           (kind->sexp result)))]))

  (define (sexp->kind [sexp : Sexp]) : (Maybe Kind)
    (case sexp
      [(symbol-sexp #"*") (just (star-kind))]
      [(node (cons (node args) (cons (symbol-sexp #"->") (cons result (empty)))))
       (case (extract-justs (map sexp->kind args))
         [(nothing) (nothing)]
         [(just args)
          (case (sexp->kind result)
            [(nothing) (nothing)]
            [(just result)
             (just (fun-kind args result))])])]
      [_ (nothing)])))
