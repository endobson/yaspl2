#:module (types)
#:import {
  (bytes) {
    #:values
      bytes=?
  }
  (list) {
    #:types
      List
    #:values
      append
      cons
      empty
      extract-justs
      list
      list=?
      map
      reverse
    #:patterns
      cons
      empty
  }
  (maybe) {
    #:types
      Maybe
    #:values
      just
      nothing
    #:patterns
      just
      nothing
  }
  (prim) {
    #:types
      Boolean
      Bytes
  }
  (sexp-parser) {
    #:types
      Sexp
    #:values
      bytes-sexp
      node
      symbol-sexp
    #:patterns
      bytes-sexp
      node
      symbol-sexp
  }
  (sexp-printer) {
    #:values
      print-sexp
  }
  (tuples) {
    #:values
      tuple2
    #:patterns
      tuple2
  }
}
(export
  #:types (Type Kind)
  #:values (star-kind fun-kind kind=? serialize-kind
            abstract-type var-type fun-type type-constructor type=? serialize-type
            kind->sexp sexp->kind type->sexp sexp->type)
  #:patterns (type-constructor fun-type abstract-type var-type))
(types
  (define-type Kind
    (star-kind)
    (fun-kind [args : (List Kind)] [result : Kind]))
  (define-type Type
    (fun-type [type-vars : (List Bytes)] [args : (List Type)] [result : Type])
    (var-type [v : Bytes])
    (abstract-type [module-name : Bytes] [name : Bytes] [args : (List Type)])
    (type-constructor [module-name : Bytes] [name : Bytes] [args : (List Kind)])))

(define (kind=? [k1 : Kind] [k2 : Kind]) : Boolean
  (case (tuple2 k1 k2)
    [(tuple2 (star-kind) (star-kind)) #t]
    [(tuple2 (fun-kind args1 result1) (fun-kind args2 result2))
     (if (kind=? result1 result2)
         ((list=? kind=?) args1 args2)
         #f)]
    [_ #f]))

(define (type=? [t1 : Type] [t2 : Type]) : Boolean
  (case (tuple2 t1 t2)
    [(tuple2 (var-type v1) (var-type v2))
     (bytes=? v1 v2)]
    [(tuple2
       (abstract-type mod1 name1 args1)
       (abstract-type mod2 name2 args2))
     (if (bytes=? mod1 mod2)
         (if (bytes=? name1 name2)
             ((list=? type=?) args1 args2)
             #f)
         #f)]
    [(tuple2
       (fun-type type-vars1 args1 result1)
       (fun-type type-vars2 args2 result2))
     (if (type=? result1 result2)
         (if ((list=? bytes=?) type-vars1 type-vars2)
             ((list=? type=?) args1 args2)
             #f)
         #f)]
    [(tuple2
       (type-constructor mod1 name1 args1)
       (type-constructor mod2 name2 args2))
     (if (bytes=? mod1 mod2)
         (if (bytes=? name1 name2)
             ((list=? kind=?) args1 args2)
             #f)
         #f)]
    [_ #f]))

(define (serialize-type [type : Type]) : Bytes
  (print-sexp (type->sexp type)))

(define (type->sexp [type : Type]) : Sexp
  (case type
    [(var-type v) (node (varargs list (symbol-sexp #"var") (bytes-sexp v)))]
    [(abstract-type mod name args)
     (node (cons (symbol-sexp #"abstract")
                 (cons (bytes-sexp mod)
                       (cons (bytes-sexp name)
                             (map type->sexp args)))))]
    [(fun-type type-vars args result)
     (node (cons (symbol-sexp #"fun")
                 (cons (node (map bytes-sexp type-vars))
                       (append (map type->sexp args) (cons (type->sexp result) (empty))))))]
    [(type-constructor mod name args)
     (node (cons (symbol-sexp #"tcon")
                 (cons (bytes-sexp mod)
                       (cons (bytes-sexp name)
                             (map kind->sexp args)))))]))

(define (extract-type-var [sexp : Sexp]) : (Maybe Bytes)
  (case sexp
    [(bytes-sexp tv) (just tv)]
    [_ (nothing)]))

(define (sexp->type [sexp : Sexp]) : (Maybe Type)
  (case sexp
    [(node (cons (symbol-sexp #"var") (cons (bytes-sexp v) (empty))))
     (just (var-type v))]
    [(node (cons (symbol-sexp #"fun") (cons (node type-vars) types)))
     (case (extract-justs (reverse (map sexp->type types)))
       [(nothing) (nothing)]
       [(just (empty)) (nothing)]
       [(just (cons result rev-arg-types))
        (case (extract-justs (map extract-type-var type-vars))
          [(nothing) (nothing)]
          [(just type-vars)
           (just (fun-type type-vars (reverse rev-arg-types) result))])])]
    [(node (cons (symbol-sexp #"abstract")
                 (cons (bytes-sexp mod)
                       (cons (bytes-sexp name)
                             types))))
     (case (extract-justs (map sexp->type types))
       [(nothing) (nothing)]
       [(just types)
        (just (abstract-type mod name types))])]
    [(node (cons (symbol-sexp #"tcon")
                 (cons (bytes-sexp mod)
                       (cons (bytes-sexp name)
                             kinds))))
     (case (extract-justs (map sexp->kind kinds))
       [(nothing) (nothing)]
       [(just kinds)
        (just (type-constructor mod name kinds))])]
    [_ (nothing)]))

(define (serialize-kind [kind : Kind]) : Bytes
  (print-sexp (kind->sexp kind)))

(define (kind->sexp [kind : Kind]) : Sexp
  (case kind
    [(star-kind) (symbol-sexp #"*")]
    [(fun-kind args result)
     (node (varargs list (node (map kind->sexp args))
                         (symbol-sexp #"->")
                         (kind->sexp result)))]))

(define (sexp->kind [sexp : Sexp]) : (Maybe Kind)
  (case sexp
    [(symbol-sexp #"*") (just (star-kind))]
    [(node (cons (node args) (cons (symbol-sexp #"->") (cons result (empty)))))
     (case (extract-justs (map sexp->kind args))
       [(nothing) (nothing)]
       [(just args)
        (case (sexp->kind result)
          [(nothing) (nothing)]
          [(just result)
           (just (fun-kind args result))])])]
    [_ (nothing)]))
