(module list
  (import
    (prim
      #:types (Byte Boolean Array)
      #:values (+ - < = array-ref array-length)
      #:patterns ())
    (maybe
      #:types (Maybe)
      #:values (just nothing)
      #:patterns ()))
  (export List cons empty cons-head cons-tail reverse length map append
          findf append* list list-ref)
  (types
    (define-type (List a)
      (cons [head a] [tail (List a)])
      (empty)))

  (define (a) (reverse [list : (List a)]) : (List a)
    (reverse-helper list (empty)))
  (define (a) (reverse-helper [l1 : (List a)] [l2 : (List a)]) : (List a)
    (case l1
      [(empty) l2]
      [(cons hd tl) (reverse-helper tl (cons hd l2))]))

  (define (a) (length [l : (List a)]) : Byte
    (case l
      [(empty) 0]
      [(cons e l) (+ 1 (length l))]))

  (define (a b) (map [f : (a -> b)] [l : (List a)]) : (List b)
    (case l
      [(empty) (empty)]
      [(cons e l) (cons (f e) (map f l))]))

  (define (a) (append [l1 : (List a)] [l2 : (List a)]) : (List a)
    (case l1
      [(empty) l2]
      [(cons e l1) (append l1 (cons e l2))]))

  (define (a) (append* [ls : (List (List a))]) : (List a)
    (case ls
      [(empty) (empty)]
      [(cons l ls) (append l (append* ls))]))

  (define (a) (findf [f : (a -> Boolean)] [l : (List a)]) : (Maybe a)
    (case l
      [(empty) (nothing)]
      [(cons a l) (if (f a) (just a) (findf f l))]))

  (define (a) (list [args : (Array a)]) : (List a)
    (list-helper (- (array-length args) 1) args (empty)))

  (define (a) (list-helper [index : Byte] [args : (Array a)] [acc : (List a)]) : (List a)
    (if (< index 0)
        acc
        (list-helper (- index 1) args (cons (array-ref args index) acc))))
  
  (define (a) (list-ref [l : (List a)] [n : Byte]) : (Maybe a)
    (case l
      [(empty) (nothing)]
      [(cons e l) (if (= 0 n) (just e) (list-ref l (- n 1)))])))
