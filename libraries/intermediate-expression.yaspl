#:module (intermediate-expression)
#:import {
  (list)
  (prim)
  (top-level-name)
  (types)
  (yaspl math-operations)
  (yaspl var)
}
(export
  (#:types Expression CaseClause Pattern)
  (#:values int-literal boolean-literal
            local-var-expr global-var-expr if-expr
            begin-expr create-closure-expr call-closure-expr call-function-expr array-expr
            let-expr case-expr case-clause
            bytes-pattern int-pattern variable-pattern abstraction-pattern
            prim-comparison-bin-op prim-numeric-bin-op prim-logical-bin-op
            prim-logical-unary-op
            array-set!-expr array-ref-expr array-length-expr
            bytes-set!-expr bytes-ref-expr bytes-length-expr
            no-op-cast-op make-variant-expr variant-field-ref-expr
            halt-expr join-point-expr join-expr)
  (#:patterns int-literal boolean-literal local-var-expr global-var-expr if-expr
              begin-expr create-closure-expr call-closure-expr call-function-expr array-expr
              array-length-expr array-ref-expr array-set!-expr
              bytes-length-expr bytes-ref-expr bytes-set!-expr
              let-expr case-expr case-clause
              bytes-pattern int-pattern variable-pattern abstraction-pattern
              prim-numeric-bin-op prim-comparison-bin-op prim-logical-bin-op
              prim-logical-unary-op no-op-cast-op make-variant-expr variant-field-ref-expr
              halt-expr join-point-expr join-expr))
(types
  (define-type Expression
    (int-literal [v : Int])
    (boolean-literal [v : Boolean])
    (local-var-expr [v : Var])
    (global-var-expr [v : TopLevelName])
    (if-expr [cond : Expression] [true : Expression] [false : Expression])
    (begin-expr [exprs : (List Expression)] [last-expr : Expression])
    (create-closure-expr [fun-name : TopLevelName] [args : (List Expression)])
    (call-closure-expr [tail-position : Boolean] [op : Expression] [args : (List Expression)])
    (call-function-expr [tail-position : Boolean] [fun-name : TopLevelName] [args : (List Expression)])
    (let-expr [name : Var] [expr : Expression] [body : Expression])
    (case-expr [expr : Expression] [clauses : (List CaseClause)] [default : Expression])
    (array-expr [args : (List Expression)])
    (array-length-expr [array : Expression])
    (array-ref-expr [array : Expression] [offset : Expression])
    (array-set!-expr [array : Expression] [offset : Expression] [value : Expression])
    (bytes-length-expr [bytes : Expression])
    (bytes-ref-expr [bytes : Expression] [offset : Expression])
    (bytes-set!-expr [bytes : Expression] [offset : Expression] [value : Expression])
    (prim-numeric-bin-op [op : NumericBinOp] [left : Expression] [right : Expression])
    (prim-comparison-bin-op [op : ComparisonBinOp] [left : Expression] [right : Expression])
    (prim-logical-bin-op [op : LogicalBinOp] [left : Expression] [right : Expression])
    (prim-logical-unary-op [op : LogicalUnaryOp] [expr : Expression])
    (make-variant-expr [tag : U8] [fields : (List Expression)])
    (variant-field-ref-expr [expr : Expression] [index : Int])
    (no-op-cast-op [src-type : Type] [dest-type : Type] [v : Expression])
    (halt-expr)
    (join-point-expr
      [join-var : Var]
      [join-expr : Expression]
      [body : Expression])
    (join-expr [join-var : Var]))

  (define-type CaseClause
    (case-clause [pattern : Pattern] [expr : Expression]))

  (define-type Pattern
    (bytes-pattern [name : TopLevelName])
    (int-pattern [v : Int])
    (variable-pattern [v : Var])
    (abstraction-pattern [variant-name : Bytes] [tag : U8] [patterns : (List Pattern)])))
