(module extra-action-parser
  (import
    (prim
      #:types (Array Bytes InputPort OutputPort Void Byte S64 Boolean U8)
      #:values (array-length < array-ref bytes-ref bytes-length + *
                = > >= <= - bitwise-and logical-shift-right void panic read-bytes
                make-bytes)
      #:patterns ())
    (bytes subbytes make-null-terminated bytes=? bytes-append ends-with? bytes<
           bytes-ref/octo-le bytes-set!/octo-le)
    (set make-set set->list set-add-all)
    (maybe
      #:types (Maybe)
      #:values (just nothing just-v)
      #:patterns (just nothing))
    (list
      #:types (List)
      #:values (cons empty map reverse list length append* filter sort append list-ref)
      #:patterns (cons empty))
    (either
      #:types (Either)
      #:values (right left)
      #:patterns (right left))
    (dict
      #:types (Dict)
      #:values (make-dict dict-add)
      #:patterns ())
    (numbers integer->decimal-bytes integer->hex-bytes)
    (mach-o
      #:types (MachOLoadCommand MachOFile SymbolTable Section64 SymbolTableEntry
               RelocationEntry)
      #:values (read-mach-o mach-o-file read-symbol-table/strings mach-o-header-commands-size
                read-symbol-table/symbols symbol-table-entry-name symbol-table-entry
                read-relocation-entry symbol-table-entry-value)
      #:patterns (mach-o-file mach-o-header lc-segment64 lc-symtab lc-version-min-macosx
                  lc-data-in-code symbol-table load-segment64 section64
                  symbol-table-entry relocation-entry))
    (mach-o-writer2 write-mach-o-executable)
    (io write-line read-all-bytes write-all-bytes call-with-input-file call-with-output-file newline))
  (export)
  (types
    (define-type ProtoParser
      (proto-parser [input Bytes] [pos S64] [limit S64]))
    (define-type (Result a)
      (result [v a] [parser ProtoParser])
      (error [msg Bytes]))
    (define-type UnparsedField
      (unparsed-varint [number S64] [v S64])
      (unparsed-64 [number S64] [v Bytes])
      (unparsed-32 [number S64] [v Bytes])
      (unparsed-length-delimited [number S64] [v ProtoParser]))
    (define-type FieldTag
      (field-tag [number S64] [type TagType]))
    (define-type TagType
      (tag-varint)
      (tag-length-delimited)
      (tag-64)
      (tag-32))

    (define-type ExtraActionInfo
      (extra-action-info [owner Bytes] [id Bytes] [mnemonic Bytes] [spawn-info SpawnInfo]))
    (define-type SpawnInfo
      (spawn-info [arguments (List Bytes)] [input-files (List Bytes)] [output-files (List Bytes)]))
    
    (define-type ParsedMachO
      (parsed-mach-o
        [text-section Bytes]
        [const-section Bytes]
        [text-relocations (List RelocationEntry)]
        [const-relocations (List RelocationEntry)]
        [symbols (List SymbolTableEntry)]))
    (define-type RelocationMarker
      (relocation-marker
        [address S64]
        [symbol Bytes]
        [type U8])))

  (define (read-varint [parser : ProtoParser]) : (Result S64)
    (case parser
      [(proto-parser input pos limit)
       (read-varint/loop input pos limit)]))

  (define (read-varint/loop [bytes : Bytes] [offset : S64] [limit : S64]) : (Result S64)
    (if (>= offset limit)
        (error #"Varint not terminated correctly.)")
        (let ([v (bytes-ref bytes offset)])
          (if (>= v 128)
              (case (read-varint/loop bytes (+ 1 offset) limit)
                [(error msg) (error msg)]
                [(result v2 parser) (result (+ (- v 128) (* v2 128)) parser)])
              (result v (proto-parser bytes (+ 1 offset) limit))))))

  (define (read-tag [parser : ProtoParser]) : (Result FieldTag)
    (case (read-varint parser)
      [(error msg) (error msg)]
      [(result v parser)
       (let ([field-number (logical-shift-right v 3)])
         (case (bitwise-and v #x07)
           [0 (result (field-tag field-number (tag-varint)) parser)]
           [1 (result (field-tag field-number (tag-64)) parser)]
           [2 (result (field-tag field-number (tag-length-delimited)) parser)]
           [5 (result (field-tag field-number (tag-32)) parser)]
           [_ (error #"Bad tag type")]))]))

  (define (read-field [parser : ProtoParser]) : (Result UnparsedField)
    (case (read-tag parser)
      [(error msg) (error msg)]
      [(result (field-tag n type) parser)
       (case type
         [(tag-length-delimited)
          (case (read-varint parser)
            [(error msg) (error msg)]
            [(result length (proto-parser bytes offset limit))
             (let ([new-limit (+ offset length)])
               (if (> new-limit limit)
                   (error #"Bad length in length delimited field")
                   (result (unparsed-length-delimited n (proto-parser bytes offset new-limit))
                           (proto-parser bytes new-limit limit))))])]
         [_ (error #"Unimplemented tag")])]))

  (define (read-fields [parser : ProtoParser]) : (Either Bytes (List UnparsedField))
    (if (empty-parser? parser)
        (right (empty))
        (case (read-field parser)
          [(error msg) (left msg)]
          [(result field parser)
           (case (read-fields parser)
             [(left msg) (left msg)]
             [(right fields) (right (cons field fields))])])))

  (define (empty-parser? [parser : ProtoParser]) : Boolean
    (case parser
      [(proto-parser _ offset limit)
       (= offset limit)]))

  (define (parse-bytes [parser : ProtoParser]) : Bytes
    (case parser
      [(proto-parser bytes offset limit)
       (subbytes bytes offset limit)]))


  (define (parse-spawn-info [parser : ProtoParser]) : (Either Bytes SpawnInfo)
    (case (read-fields parser)
      [(left msg) (left msg)]
      [(right fields)
       (parse-spawn-info/loop fields (empty) (empty) (empty))]))


  (define (parse-spawn-info/loop
            [fields : (List UnparsedField)]
            [arguments : (List Bytes)]
            [input-files : (List Bytes)]
            [output-files : (List Bytes)]) : (Either Bytes SpawnInfo)
    (case fields
      [(cons (unparsed-length-delimited n sub-parser) fields)
       (case n
         [1 (parse-spawn-info/loop fields (cons (parse-bytes sub-parser) arguments) input-files output-files)]
         [4 (parse-spawn-info/loop fields arguments (cons (parse-bytes sub-parser) input-files) output-files)]
         [5 (parse-spawn-info/loop fields arguments input-files (cons (parse-bytes sub-parser) output-files))]
         [_ (left #"Unknown field in SpawnInfo")])]
      [(cons _ _) (left #"Unsupported tag type in SpawnInfo")]
      [(empty)
       (right (spawn-info (reverse arguments) (reverse input-files) (reverse output-files)))]))

  (define (parse-extra-action-info [parser : ProtoParser]) : (Either Bytes ExtraActionInfo)
    (case (read-fields parser)
      [(left msg) (left msg)]
      [(right
         (cons (unparsed-length-delimited 1 owner-parser)
           (cons (unparsed-length-delimited 2 id-parser)
             (cons (unparsed-length-delimited 5 mnemonic-parser)
               (cons (unparsed-length-delimited 1003 spawn-info-parser) (empty))))))
       (case (parse-spawn-info spawn-info-parser)
         [(left msg) (left msg)]
         [(right spawn-info)
          (right
            (extra-action-info
              (parse-bytes owner-parser)
              (parse-bytes id-parser)
              (parse-bytes mnemonic-parser)
              spawn-info))])]
      [(right _) (left #"Unsupported serialization of ExtraActionInfo")]))

  (define (print-extra-action-info [info : ExtraActionInfo] [output : OutputPort]) : Void
    (case info
      [(extra-action-info owner id mnemonic (spawn-info arguments input-files output-files))
       (let [(write-indented
               (lambda ([v : Bytes])
                 (begin
                   (write-all-bytes #"  " output)
                   (write-line v output))))]
         (begin
           (write-all-bytes #"Owner: " output)
           (write-line owner output)
           (write-all-bytes #"Id: " output)
           (write-line id output)
           (write-all-bytes #"Mnemonic: " output)
           (write-line mnemonic output)
           (write-line #"Arguments:" output)
           (map write-indented arguments)
           (write-line #"Input Files" output)
           (map write-indented input-files)
           (write-line #"Output Files" output)
           (map write-indented output-files)
           (void)))]))

  (define (find-symbol-table [load-commands : (List MachOLoadCommand)]) : SymbolTable
    (case load-commands
      [(empty) (panic #"No symbol table")]
      [(cons (lc-symtab v) _) v]
      [(cons _ lc) (find-symbol-table lc)]))

  (define (find-text-section [load-commands : (List MachOLoadCommand)]) : Section64
    (case load-commands
      [(empty) (panic #"No text section")]
      [(cons (lc-segment64 (load-segment64 _ _ _ _ _ _ _ _ sections)) lc)
       (case (find-text-section* sections)
         [(just sec) sec]
         [_ (find-text-section lc)])]
      [(cons _ lc) (find-text-section lc)]))

  (define (find-text-section* [sections : (List Section64)]) : (Maybe Section64)
    (case sections
      [(empty) (nothing)]
      [(cons sec secs)
       (case sec
         [(section64 #"__text" #"__TEXT" _ _ _ _ _ _)
          (just sec)]
         [_ (find-text-section* secs)])]))

  (define (find-const-section [load-commands : (List MachOLoadCommand)]) : Section64
    (case load-commands
      [(empty) (panic #"No const section")]
      [(cons (lc-segment64 (load-segment64 _ _ _ _ _ _ _ _ sections)) lc)
       (case (find-const-section* sections)
         [(just sec) sec]
         [_ (find-const-section lc)])]
      [(cons _ lc) (find-const-section lc)]))

  (define (find-const-section* [sections : (List Section64)]) : (Maybe Section64)
    (case sections
      [(empty) (nothing)]
      [(cons sec secs)
       (case sec
         [(section64 #"__const" #"__TEXT" _ _ _ _ _ _)
          (just sec)]
         [_ (find-const-section* secs)])]))

  (define (read-symbol-table [mach-o : MachOFile]) : (List SymbolTableEntry)
    (case mach-o
      [(mach-o-file header load-commands bytes)
       (case (find-symbol-table load-commands)
         [(symbol-table offset num-symbols string-offset string-size)
          (read-symbol-table/symbols
            0
            ;; Need to accout for 32 bytes of mach-header and  the load commands.
            (let ([start (- offset (+ 32 (mach-o-header-commands-size header)))])
              (subbytes bytes start (+ start (* num-symbols 16))))
            ;; Need to accout for 32 bytes of mach-header and  the load commands.
            (let ([start (- string-offset (+ 32 (mach-o-header-commands-size header)))])
              (subbytes bytes start (+ start string-size))))])]))

  (define (read-relocations [num : S64] [offset : S64] [bytes : Bytes]) : (List RelocationEntry)
    (if (= 0 num)
        (empty)
        (cons
          (read-relocation-entry offset bytes)
          (read-relocations (- num 1) (+ offset 8) bytes))))

  (define (read-text-section [mach-o : MachOFile]) : Bytes
    (case mach-o
      [(mach-o-file header load-commands bytes)
       (case (find-text-section load-commands)
        [(section64 _ _ _ size offset _ _ _)
         ;; Need to accout for 32 bytes of mach-header and the load commands
         (let ([start (- offset (+ 32 (mach-o-header-commands-size header)))])
           (subbytes bytes start (+ start size)))])]))

  (define (read-text-relocations [mach-o : MachOFile]) : Bytes
    (case mach-o
      [(mach-o-file header load-commands bytes)
       (case (find-text-section load-commands)
        [(section64 _ _ _ _ _ relocation-offset num-relocations _)
         ;; Need to accout for 32 bytes of mach-header and the load commands
         (let ([start (- relocation-offset (+ 32 (mach-o-header-commands-size header)))])
           (read-relocations num-relocations start bytes))])]))


  (define (read-const-section [mach-o : MachOFile]) : Bytes
    (case mach-o
      [(mach-o-file header load-commands bytes)
       (case (find-const-section load-commands)
        [(section64 _ _ _ size offset _ _ _)
         ;; Need to accout for 32 bytes of mach-header and the load commands
         (let ([start (- offset (+ 32 (mach-o-header-commands-size header)))])
           (subbytes bytes start (+ start size)))])]))

  (define (read-const-relocations [mach-o : MachOFile]) : Bytes
    (case mach-o
      [(mach-o-file header load-commands bytes)
       (case (find-const-section load-commands)
        [(section64 _ _ _ _ _ relocation-offset num-relocations _)
         ;; Need to accout for 32 bytes of mach-header and the load commands
         (let ([start (- relocation-offset (+ 32 (mach-o-header-commands-size header)))])
           (read-relocations num-relocations start bytes))])]))

  (define (symbol-table-entry-name=? [s1 : SymbolTableEntry] [s2 : SymbolTableEntry]) : Boolean
    (case s1
      [(symbol-table-entry name1 _ _ _ _)
       (case s2
         [(symbol-table-entry name2 _ _ _ _)
          (bytes=? name1 name2)])]))

  (define (symbol-table-entry-name< [s1 : SymbolTableEntry] [s2 : SymbolTableEntry]) : Boolean
    (case s1
      [(symbol-table-entry name1 _ _ _ _)
       (case s2
         [(symbol-table-entry name2 _ _ _ _)
          (bytes< name1 name2)])]))

  (define (parse-mach-o [mach-o : MachOFile]) : ParsedMachO
    (parsed-mach-o
      (read-text-section mach-o)
      (read-const-section mach-o)
      (read-text-relocations mach-o)
      (read-const-relocations mach-o)
      (read-symbol-table mach-o)))


  (define (get-offset-symbols [parsed-mach-os : (List ParsedMachO)] [text-offset : S64] [const-offset : S64])
    : (List SymbolTableEntry)
    (case parsed-mach-os
      [(empty) (empty)]
      [(cons (parsed-mach-o text const _ _ symbols) parsed-mach-os)
       (append 
         (map
           (lambda ([entry : SymbolTableEntry])
             (case entry
               [(symbol-table-entry name type 1 desc value)
                (symbol-table-entry name type 1 desc (+ text-offset value))]
               [(symbol-table-entry name type 2 desc value)
                (symbol-table-entry name type 2 desc (- (+ const-offset value) (bytes-length text)))]
               [(symbol-table-entry name type sect desc value)
                (symbol-table-entry name type sect desc value)]))
           symbols)
         (get-offset-symbols parsed-mach-os
                             (+ text-offset (bytes-length text))
                             (+ const-offset (bytes-length const))))]))


  (define (get-relocation-markers [parsed-mach-os : (List ParsedMachO)] [text-offset : S64] [const-offset : S64])
    : (List RelocationMarker)
    (case parsed-mach-os
      [(empty) (empty)]
      [(cons (parsed-mach-o text const text-relocations const-relocations symbols) parsed-mach-os)
       (append 
         (map
           (lambda ([entry : RelocationEntry])
             (case entry
               [(relocation-entry address symbol-num type)
                (relocation-marker
                  (+ text-offset address)
                  (symbol-table-entry-name (just-v (list-ref symbols symbol-num)))
                  type)]))
           text-relocations)
         (append 
           (map
             (lambda ([entry : RelocationEntry])
               (case entry
                 [(relocation-entry address symbol-num type)
                  (relocation-marker
                    (+ const-offset address)
                    (symbol-table-entry-name (just-v (list-ref symbols symbol-num)))
                    type)]))
             const-relocations)
           (get-relocation-markers parsed-mach-os
                                   (+ text-offset (bytes-length text))
                                   (+ const-offset (bytes-length const)))))]))

  (define (find-symbol-entry [symbol : Bytes] [symbols : (List SymbolTableEntry)]) : SymbolTableEntry
    (case symbols
      [(empty) (panic #"Couldn't find symbol")]
      [(cons entry symbols)
       (case entry
         [(symbol-table-entry name _ _ _ _)
          (if (bytes=? symbol name)
              entry
              (find-symbol-entry symbol symbols))])]))

  (define (apply-const-relocations
            [rels : (List RelocationMarker)]
            [symbols : (List SymbolTableEntry)]
            [const-section : Bytes]) : Void
    (case rels
      [(empty) (void)]
      [(cons (relocation-marker offset symbol #x0E) rels)
       (begin
         (bytes-set!/octo-le
           const-section
           offset
           (+ (bytes-ref/octo-le const-section offset)
              (symbol-table-entry-value
                (find-symbol-entry symbol symbols))))
         (apply-const-relocations rels symbols const-section))]
      [(cons _ rels)
       (apply-const-relocations rels symbols const-section)]))

  (define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Byte
    (if (< (array-length args) 3)
        (begin
          (write-line #"Too few arguments" stderr)
          1)
        (let ([bytes (call-with-input-file (array-ref args 1) read-all-bytes)])
          (let ([output-file-name (array-ref args 2)])
            (let ([limit (bytes-length bytes)])
              (case (parse-extra-action-info (proto-parser bytes 0 limit))
                [(left msg)
                 (begin
                   (write-line msg stderr)
                   1)]
                [(right info)
                 (case info
                   [(extra-action-info owner id mnemonic (spawn-info arguments input-files output-files))
                    (case mnemonic
                      [#"YasplLink"
                       (let ([mach-o-files
                              (map
                                (lambda ([input-path : Bytes])
                                  (call-with-input-file input-path
                                    (lambda ([input-file : InputPort])
                                      (case (read-mach-o input-file)
                                        [(right mach-o-file)
                                         mach-o-file]
                                        [(left msg)
                                         (panic msg)]))))
                                (filter
                                  (lambda ([input-path : Bytes])
                                    (ends-with? input-path #".o"))
                                  input-files))])
                         (let ([parsed-mach-o-files (map parse-mach-o mach-o-files)])
                           (let ([symbol-table-entries
                                  (sort
                                    (set->list
                                      (set-add-all
                                        ;; TODO make sure that the right definition is kept
                                        (make-set symbol-table-entry-name=?)
                                        (cons (symbol-table-entry #"__mh_execute_header" 3 1 #x10
                                                                  #x100000000)
                                              (get-offset-symbols parsed-mach-o-files
                                                                  ;; TODO why #x79a
                                                                  (+ #x100000000 #x79a)
                                                                  (+ #x100000000 (+ #x7b2 #x67e))))))
                                    symbol-table-entry-name<)])
                             (let ([relocation-markers
                                    (get-relocation-markers parsed-mach-o-files 0 0)])
                               (let ([text-section
                                       (bytes-append (map parsed-mach-o-text-section parsed-mach-o-files))])
                                 (let ([const-section
                                         (bytes-append (map parsed-mach-o-const-section parsed-mach-o-files))])
                                   (begin
                                     (apply-const-relocations
                                       relocation-markers
                                       symbol-table-entries
                                       const-section)
                                     (case (write-mach-o-executable
                                             symbol-table-entries
                                             text-section const-section
                                             output-file-name)
                                       [(left v)
                                        (begin
                                          (write-line v stderr)
                                          1)]
                                       [(right _)
                                        0]))))))))]
                      [x
                        (begin
                          (write-line x stderr)
                          1)])])])))))))
