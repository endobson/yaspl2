#:module (validator)
#:import {
  (bytes) {
    #:values
      bytes-append
      bytes=?
  }
  (dict) {
    #:values
      dict-keys
  }
  (either) {
    #:types
      Either
    #:values
      left
      right
    #:patterns
      left
      right
  }
  (free-variables) {
    #:values
      free-patterns/function-definition
      free-types/function-definition
      free-types/type-definitions
      free-variables/function-definition
  }
  (join-list) {
    #:types
      JoinList
    #:values
      append-jl
      append-jl*
      concat-jl
      empty-jl
      jl->list
      join-list
  }
  (list) {
    #:types
      List
    #:values
      append
      append*
      cons
      empty
      filter-map
      find/maybe
      findf
      foldl
      interleave
      list
      map
    #:patterns
      cons
      empty
  }
  (maybe) {
    #:types
      Maybe
    #:values
      just
      nothing
    #:patterns
      just
      nothing
  }
  (module-signature) {
    #:types
      ModuleSignature
    #:values
      module-signature-name
    #:patterns
      module-signature
  }
  (multi-set) {
    #:types
      MultiSet
    #:values
      make-multi-set
      multi-set-add
      multi-set-add-all
      multi-set-count
      multi-set-keys
  }
  (prim) {
    #:types
      Bytes
    #:values
      >
  }
  (set) {
    #:types
      Set
    #:values
      make-set
      set->list
      set-add-all
      set-member?
      set-remove-all
  }
  (source-language) {
    #:types
      Block
      BlockDefinition
      CaseClause
      Export
      Expression
      FunctionDefinition
      Import
      Imports
      Module
      Pattern
      PreType
      TypeDefinition
      VariantDefinition
      VariantField
    #:values
      export-exported-name
      export-local-name
      function-definition-name
      import-exported-name
      module-definitions
      module-imports
      module-name
      module-types
    #:patterns
      abstraction-pattern
      app-expr
      begin-expr
      block
      boolean-literal
      bytes-literal
      bytes-pattern
      case-clause
      case-expr
      exports
      function-definition
      if-expr
      ignore-pattern
      import
      imports
      int-literal
      int-pattern
      lambda-expr
      let-expr
      match-def
      module
      type-definition
      var-expr
      varargs-app-expr
      variable-pattern
      variant-definition
      variant-field
  }
  (tuples) {
    #:types
      Tuple2
      Tuple3
    #:values
      tuple3
    #:patterns
      tuple2
      tuple3
  }
}
(export
  #:types ()
  #:values (validate-module
            module-imported-environment module-imported-pattern-environment
            module-imported-type-environment
            module-defined-functions module-errors->bytes)
  #:patterns ())
(types
  (define-type ModuleErrors
    (module-errors
      [module-name : Bytes]
      [error : (List ModuleError)]))
  (define-type ModuleError
    (duplicate-module-bindings
      [types : (List Bytes)]
      [values : (List Bytes)]
      [patterns : (List Bytes)])
    (undefined-exports
      [types : (List Bytes)]
      [values : (List Bytes)]
      [patterns : (List Bytes)])
    (duplicate-exports
      [types : (List Bytes)]
      [values : (List Bytes)]
      [patterns : (List Bytes)])
    (non-existent-imports/module [module-name : Bytes])
    (non-existent-imports/bindings
      [module-name : Bytes]
      [types : (List Bytes)]
      [values : (List Bytes)]
      [patterns : (List Bytes)])
    (non-unique-name)
    (function-error [name : Bytes] [error : FunctionError]))
  (define-type FunctionError
    (free-variables
      [types : (List Bytes)]
      [values : (List Bytes)]
      [patterns : (List Bytes)])
    (duplicate-bindings
      [names : (List Bytes)])))

(define (validate-module [mod : Module] [sigs : (List ModuleSignature)]) : (Maybe ModuleErrors)
  (case (validate-module/duplicate-bindings mod)
    [(left v) (just (module-errors (module-name mod) (varargs list v)))]
    [(right (tuple3 type-env env pat-env))
     (case
       (append*
         (varargs list
           (validate-module/free-variables mod type-env env pat-env)
           (validate-module/undefined-exports mod type-env env pat-env)
           (validate-module/duplicate-exports mod)
           (validate-module/imports-exist mod sigs)
           (validate-module/unique-name mod sigs)
           (validate-module/unique-bindings mod)))
       [(empty)
        (nothing)]
       [errors
        (just (module-errors (module-name mod) errors))])]))

;; Checks to make sure that there are no duplicate bindings.
;; If there are returns (left <error-message>), otherwise returns
;; (right (tuple3 <types> <values> <patterns>))
(define (validate-module/duplicate-bindings [mod : Module])
  : (Either ModuleError (Tuple3 (Set Bytes) (Set Bytes) (Set Bytes)))
  (let ([env (module-environment mod)])
    (case (find-duplicates env)
      [value-dups
       (let ([pattern-env (module-pattern-environment mod)])
         (case (find-duplicates pattern-env)
           [pattern-dups
            (let ([type-env (module-type-environment mod)])
              (case (find-duplicates type-env)
                [type-dups
                 (case (tuple3 value-dups pattern-dups type-dups)
                   [(tuple3 (empty) (empty) (empty))
                    (right (tuple3 (multi-set-keys type-env)
                                          (multi-set-keys env)
                                          (multi-set-keys pattern-env)))]
                   [_
                    (left (duplicate-module-bindings type-dups value-dups pattern-dups))])]))]))])))

(define (validate-module/unique-name [mod : Module] [sigs : (List ModuleSignature)])
  : (List ModuleError)
  (filter-map
    (lambda ([sig : ModuleSignature]) : (Maybe ModuleError)
      (case sig
        [(module-signature name _ _ _ _ _)
         (if (bytes=? name (module-name mod))
             (just (non-unique-name))
             (nothing))]))
    sigs))

(define (find-duplicates [ms : (MultiSet Bytes)]) : (List Bytes)
  (find-duplicates/list (set->list (multi-set-keys ms)) ms))

(define (find-duplicates/list [l : (List Bytes)] [ms : (MultiSet Bytes)]) : (List Bytes)
  (case l
    [(empty) (empty)]
    [(cons e l)
     (if (> (multi-set-count ms e) 1)
       (cons e (find-duplicates/list l ms))
       (find-duplicates/list l ms))]))

(define (validate-module/undefined-exports
          [mod : Module]
          [type-env : (Set Bytes)]
          [value-env : (Set Bytes)]
          [pattern-env : (Set Bytes)])
  : (List ModuleError)
  (match-define (module _ _ (exports types values patterns) _ _) mod)
  (let ([check-exports
          (lambda ([exports : (List Export)] [env : (Set Bytes)])
            (set->list
              (set-remove-all
                (set-add-all (make-set bytes=?) (map export-local-name exports))
                (set->list env))))])

    (case (tuple3
            (check-exports types type-env)
            (check-exports values value-env)
            (check-exports patterns pattern-env))
      [(tuple3 (empty) (empty) (empty))
       (empty)]
      [(tuple3 types values patterns)
       (varargs list (undefined-exports types values patterns))])))

(define (validate-module/duplicate-exports [mod : Module])
  : (List ModuleError)
  (match-define (module _ _ (exports types values patterns) _ _) mod)
  (let ([check-exports
          (lambda ([exports : (List Export)])
            (find-duplicates
              (multi-set-add-all
                (make-multi-set bytes=?)
                (map export-exported-name exports))))])
    (case (tuple3
            (check-exports types)
            (check-exports values)
            (check-exports patterns))
      [(tuple3 (empty) (empty) (empty))
       (empty)]
      [(tuple3 types values patterns)
       (varargs list (duplicate-exports types values patterns))])))

(define (validate-module/free-variables
          [mod : Module]
          [type-env : (Set Bytes)]
          [value-env : (Set Bytes)]
          [pattern-env : (Set Bytes)]) : (List ModuleError)
  (let ([validate-function-definition/free-variables
          (lambda ([def : FunctionDefinition]) : (Maybe ModuleError)
            (case (tuple3
                    (set->list (free-types/function-definition def type-env (make-set bytes=?)))
                    (set->list (free-variables/function-definition def value-env (make-set bytes=?)))
                    (set->list (free-patterns/function-definition def pattern-env (make-set bytes=?))))
              [(tuple3 (empty) (empty) (empty))
               (nothing)]
              [(tuple3 types values patterns)
               (just (function-error
                       (function-definition-name def)
                       (free-variables types values patterns)))]))])
    (append
      (let ([free-types
              (set->list (free-types/type-definitions
                           (module-types mod) type-env (make-set bytes=?)))])
        (case free-types
          [(empty) (empty)]
          [types
           (varargs list
             (function-error
               #"TypeDefinitions"
               (free-variables types (empty) (empty))))]))
      (filter-map
        validate-function-definition/free-variables
        (module-definitions mod)))))

(define (module-type-environment [mod : Module]) : (MultiSet Bytes)
  (case mod
    [(module _ imports _ types definitions)
     (add-importss-type-bindings imports
       (add-type-definitions-bindings types
         (make-multi-set bytes=?)))]))

(define (module-imported-type-environment [mod : Module]) : (MultiSet Bytes)
  (case mod
    [(module _ imports _ types definitions)
     (add-importss-type-bindings imports
       (make-multi-set bytes=?))]))

(define (module-environment [mod : Module]) : (MultiSet Bytes)
  (case mod
    [(module _ imports _ types definitions)
     (add-importss-bindings imports
       (add-constructor-bindings/types types
         (add-accessor-bindings/types types
           (add-definitions-bindings definitions
             (make-multi-set bytes=?)))))]))

(define (module-defined-functions [mod : Module]) : (MultiSet Bytes)
  (case mod
    [(module _ imports _ types definitions)
     (add-definitions-bindings definitions
       (make-multi-set bytes=?))]))

(define (module-imported-environment [mod : Module]) : (MultiSet Bytes)
  (case mod
    [(module _ imports _ _ _)
     (add-importss-bindings imports
       (make-multi-set bytes=?))]))

(define (module-pattern-environment [mod : Module]) : (MultiSet Bytes)
  (case mod
    [(module _ imports _ types _)
       (add-importss-pattern-bindings imports
         (add-constructor-bindings/types types
           (make-multi-set bytes=?)))]))

(define (module-imported-pattern-environment [mod : Module]) : (MultiSet Bytes)
  (case mod
    [(module _ imports _ _ _)
       (add-importss-pattern-bindings imports
         (make-multi-set bytes=?))]))

(define (add-definitions-bindings [defs : (List FunctionDefinition)] [env : (MultiSet Bytes)])
  : (MultiSet Bytes)
  (case defs
    [(empty) env]
    [(cons (function-definition name _ _ _) defs)
     (add-definitions-bindings defs (multi-set-add env name))]))

(define (add-accessor-bindings/types [types : (List TypeDefinition)] [env : (MultiSet Bytes)])
  : (MultiSet Bytes)
  (case types
    [(empty) env]
    [(cons (type-definition name _ variants) types)
     (add-accessor-bindings/types types (add-accessor-bindings/variants variants env))]))

(define (add-constructor-bindings/types [types : (List TypeDefinition)] [env : (MultiSet Bytes)])
  : (MultiSet Bytes)
  (case types
    [(empty) env]
    [(cons (type-definition name _ variants) types)
     (add-constructor-bindings/types types (add-constructor-bindings/variants variants env))]))


(define (add-type-definitions-bindings [types : (List TypeDefinition)] [env : (MultiSet Bytes)])
  : (MultiSet Bytes)
  (case types
    [(empty) env]
    [(cons (type-definition name _ _) types)
     (add-type-definitions-bindings types (multi-set-add env name))]))

(define (add-constructor-bindings/variants [variants : (List VariantDefinition)] [env : (MultiSet Bytes)])
  : (MultiSet Bytes)
  (case variants
    [(empty) env]
    [(cons (variant-definition name _) variants)
     (add-constructor-bindings/variants variants (multi-set-add env name))]))


(define (add-accessor-bindings/variants [variants : (List VariantDefinition)] [env : (MultiSet Bytes)])
  : (MultiSet Bytes)
  (case variants
    [(cons (variant-definition name fields) (empty))
     (add-variant-field-bindings name fields env)]
    [_ env]))

(define (add-variant-field-bindings [variant : Bytes]
                                    [fields : (List VariantField)] [env : (MultiSet Bytes)])
  : (MultiSet Bytes)
  (case fields
    [(empty) env]
    [(cons (variant-field name _) fields)
     (let ([acc-name (bytes-append (varargs list variant #"-" name))])
       (add-variant-field-bindings variant fields (multi-set-add env acc-name)))]))

(define (add-importss-type-bindings [importss : (List Imports)] [env : (MultiSet Bytes)])
  : (MultiSet Bytes)
  (case importss
    [(empty) env]
    [(cons (imports _ types _ _) importss)
     (add-importss-type-bindings importss (add-imports-bindings types env))]))

(define (add-importss-bindings [importss : (List Imports)] [env : (MultiSet Bytes)])
  : (MultiSet Bytes)
  (case importss
    [(empty) env]
    [(cons (imports _ _ values _) importss)
     (add-importss-bindings importss (add-imports-bindings values env))]))

(define (add-importss-pattern-bindings [importss : (List Imports)] [env : (MultiSet Bytes)])
  : (MultiSet Bytes)
  (case importss
    [(empty) env]
    [(cons (imports _ _ _ patterns) importss)
     (add-importss-pattern-bindings importss (add-imports-bindings patterns env))]))


(define (add-imports-bindings [imports : (List Import)] [env : (MultiSet Bytes)])
  : (MultiSet Bytes)
  (case imports
    [(empty) env]
    [(cons (import _ name) imports)
     (add-imports-bindings imports (multi-set-add env name))]))



(define (A) (first-just [ms : (List (Maybe A))]) : (Maybe A)
  (case ms
    [(empty) (nothing)]
    [(cons (nothing) ms) (first-just ms)]
    [(cons (just v) ms) (just v)]))

(define (validate-imports [imports : (List Import)] [exported : (Set Bytes)])
  : (List Bytes)
  (filter-map
    (lambda ([import : Import]) : (Maybe Bytes)
      (if (set-member? exported (import-exported-name import))
          (nothing)
          (just (import-exported-name import))))
    imports))

(define (find-signature [name : Bytes] [sigs : (List ModuleSignature)]) : (Maybe ModuleSignature)
  (findf (lambda ([sig : ModuleSignature]) (bytes=? name (module-signature-name sig))) sigs))

(define (validate-module/imports-exist [mod : Module] [sigs : (List ModuleSignature)]) :
  (List ModuleError)
  (filter-map
    (lambda ([imports : Imports]) : (Maybe ModuleError)
      (case imports
        [(imports import-name types values patterns)
         (case (find-signature import-name sigs)
           [(nothing)
            (just (non-existent-imports/module import-name))]
           [(just (module-signature mod-name e-vals e-patterns e-types _ _))
            (case (tuple3
                    (validate-imports types (dict-keys e-types))
                    (validate-imports values (dict-keys e-vals))
                    (validate-imports patterns (dict-keys e-patterns)))
              [(tuple3 (empty) (empty) (empty))
               (nothing)]
              [(tuple3 types values patterns)
               (just (non-existent-imports/bindings import-name types values patterns))])])]))
    (module-imports mod)))

(define (validate-module/unique-bindings [mod : Module]) : (List ModuleError)
  (filter-map
    check-unique-bindings/function-definition
    (module-definitions mod)))

(define (check-unique-bindings/function-definition [def : FunctionDefinition]) : (Maybe ModuleError)
  (case def
    [(function-definition name _ args body)
     (case (check-unique-bindings/args args)
       [(just args)
        (just (function-error name (duplicate-bindings args)))]
       [(nothing)
        (case (check-unique-bindings/block body)
          [(just args) (just (function-error name (duplicate-bindings args)))]
          [(nothing) (nothing)])])]))

(define (check-unique-bindings/args [args : (List Bytes)]) : (Maybe (List Bytes))
  (case (find-duplicates (multi-set-add-all (make-multi-set bytes=?) args))
    [(empty)
     (nothing)]
    [dups
     (just dups)]))

(define (check-unique-bindings/block [b : Block]) : (Maybe (List Bytes))
  (case b
    [(block defs expr)
     (case (check-unique-bindings/block-definitions defs)
       [(just v) (just v)]
       [(nothing) (check-unique-bindings/expr expr)])]))

(define (check-unique-bindings/block-definitions [defs : (List BlockDefinition)])
  : (Maybe (List Bytes))
  (find/maybe
    (lambda ([def : BlockDefinition])
      (case def
        [(match-def pattern expr)
         (case (check-unique-bindings/args (pattern-bindings pattern))
           [(just v) (just v)]
           [(nothing)
            (check-unique-bindings/expr expr)])]))
    defs))

(define (check-unique-bindings/expr [expr : Expression]) : (Maybe (List Bytes))
  (case expr
    [(int-literal _) (nothing)]
    [(bytes-literal _) (nothing)]
    [(boolean-literal _) (nothing)]
    [(var-expr _) (nothing)]
    [(if-expr c t f)
     (check-unique-bindings/exprs (varargs list c t f))]
    [(begin-expr first rest)
     (check-unique-bindings/exprs (cons first rest))]
    [(app-expr op args)
     (check-unique-bindings/exprs (cons op args))]
    [(varargs-app-expr op args)
     (check-unique-bindings/exprs (cons op args))]
    [(let-expr name expr body)
     (check-unique-bindings/exprs (varargs list expr body))]
    [(lambda-expr args return-type body)
     (case (check-unique-bindings/args
             (map (lambda ([t : (Tuple2 Bytes PreType)]) (case t [(tuple2 name _) name])) args))
       [(just v) (just v)]
       [(nothing)
        (check-unique-bindings/expr body)])]
    [(case-expr expr clauses)
     (case (check-unique-bindings/expr expr)
       [(just v) (just v)]
       [(nothing)
        (check-unique-bindings/clauses clauses)])]))

(define (check-unique-bindings/exprs [exprs : (List Expression)]) : (Maybe (List Bytes))
  (find/maybe check-unique-bindings/expr exprs))

(define (check-unique-bindings/clauses [clauses : (List CaseClause)]) : (Maybe (List Bytes))
  (find/maybe
    (lambda ([clause : CaseClause])
      (case clause
        [(case-clause pattern body)
         (case (check-unique-bindings/args (pattern-bindings pattern))
           [(just v) (just v)]
           [(nothing)
            (check-unique-bindings/block body)])]))
    clauses))

(define (pattern-bindings [p : Pattern]) : (List Bytes)
  (pattern-bindings* p (empty)))
(define (pattern-bindings* [p : Pattern] [acc : (List Bytes)]) : (List Bytes)
  (case p
    [(bytes-pattern _) acc]
    [(int-pattern _) acc]
    [(ignore-pattern) acc]
    [(variable-pattern v) (cons v acc)]
    [(abstraction-pattern _ pats)
     (foldl pattern-bindings* pats acc)]))

(define (module-errors->bytes [me : ModuleErrors]) : Bytes
  (case me
    [(module-errors mod-name errors)
     (bytes-append
       (map (lambda ([error : ModuleError]) (module-error->bytes mod-name error)) errors))]))

(define (module-error->bytes [mod-name : Bytes] [error : ModuleError]) : Bytes
  (case error
    [(duplicate-module-bindings types values patterns)
     (let ([warn-duplicates
             (lambda ([kind : Bytes] [bindings : (List Bytes)]) : (JoinList Bytes)
               (case bindings
                 [(empty) (empty-jl)]
                 [_
                  (append-jl
                    (varargs join-list #"  " kind #" bindings:\n")
                    (concat-jl (map (lambda ([binding : Bytes])
                                      (varargs join-list #"    " binding #"\n"))
                                    bindings)))]))])
        (bytes-append
          (jl->list
            (varargs append-jl*
              (varargs join-list #"Duplicate bindings in module " mod-name #":\n")
              (warn-duplicates #"Type" types)
              (warn-duplicates #"Value" values)
              (warn-duplicates #"Pattern" patterns)))))]
    [(non-unique-name)
     (bytes-append (varargs list #"Module named \"" mod-name #"\" already exists."))]
    [(undefined-exports types values patterns)
     (let ([warn-undefined-exports
             (lambda ([kind : Bytes] [names : (List Bytes)]) : (JoinList Bytes)
               (case names
                 [(empty) (empty-jl)]
                 [_
                   (append-jl
                     (varargs join-list #"  " kind #" exports:\n")
                     (concat-jl (map (lambda ([name : Bytes])
                                       (varargs join-list #"    " name #"\n"))
                                     names)))]))])
        (bytes-append
          (jl->list
            (append-jl
              (varargs join-list #"Undefined exports in module " mod-name #":\n")
              (varargs append-jl*
                (warn-undefined-exports #"Type" types)
                (warn-undefined-exports #"Value" values)
                (warn-undefined-exports #"Pattern" patterns))))))]
    [(duplicate-exports types values patterns)
     (let ([warn-duplicate-exports
             (lambda ([kind : Bytes] [names : (List Bytes)]) : (JoinList Bytes)
               (case names
                 [(empty) (empty-jl)]
                 [_
                   (append-jl
                     (varargs join-list #"  " kind #" exports:\n")
                     (concat-jl (map (lambda ([name : Bytes])
                                       (varargs join-list #"    " name #"\n"))
                                     names)))]))])
        (bytes-append
          (jl->list
            (append-jl
              (varargs join-list #"Duplicate exports in module " mod-name #":\n")
              (varargs append-jl*
                (warn-duplicate-exports #"Type" types)
                (warn-duplicate-exports #"Value" values)
                (warn-duplicate-exports #"Pattern" patterns))))))]
    [(non-existent-imports/module import-name)
     (bytes-append
       (varargs list #"Missing import in " mod-name #". Could not find module: " import-name #"\n"))]
    [(non-existent-imports/bindings import-name types values patterns)
     (let ([warn-no-exports
             (lambda ([kind : Bytes] [names : (List Bytes)]) : (JoinList Bytes)
               (case names
                 [(empty) (empty-jl)]
                 [_
                   (append-jl
                     (varargs join-list #"  " kind #" imports:\n")
                     (concat-jl (map (lambda ([name : Bytes])
                                       (varargs join-list #"    " name #"\n"))
                                     names)))]))])
        (bytes-append
          (jl->list
            (append-jl
              (varargs join-list
                #"Undefined imports in module " mod-name #" from module " import-name #":\n")
              (varargs append-jl*
                (warn-no-exports #"Type" types)
                (warn-no-exports #"Value" values)
                (warn-no-exports #"Pattern" patterns))))))]
    [(function-error function-name (free-variables types values patterns))
     (let ([warn-free-variables
             (lambda ([kind : Bytes] [names : (List Bytes)]) : (JoinList Bytes)
               (case names
                 [(empty) (empty-jl)]
                 [_
                   (append-jl
                     (varargs join-list #"  " kind #":\n")
                     (concat-jl (map (lambda ([name : Bytes])
                                       (varargs join-list #"    " name #"\n"))
                                     names)))]))])
        (bytes-append
          (jl->list
            (append-jl
              (varargs join-list
                #"Free variables in module " mod-name #" in function " function-name #":\n")
              (varargs append-jl*
                (warn-free-variables #"Types" types)
                (warn-free-variables #"Values" values)
                (warn-free-variables #"Patterns" patterns))))))]
    [(function-error function-name (duplicate-bindings dups))
     (bytes-append
       (append
         (varargs list #"Duplicate bindings in " mod-name #" in " function-name #": ")
         (interleave dups #", ")))]))
