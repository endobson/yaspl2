#:module (validator)
#:import {
  (bytes)
  (data indexed-set)
  (data source-location)
  (dict)
  (either)
  (free-variables)
  (join-list)
  (list)
  (maybe)
  (module-name)
  (module-signature)
  (multi-set)
  (numbers)
  (prim)
  {(resolved-imports-language)
    {#:types
      Module
    }
    {#:values
      module-definitions
      module-name
      module-types
    }
    {#:patterns
      imports
      module
    }
  }
  (set)
  {(source-language)
    {#:types
      Block
      BlockDefinition
      CaseClause
      Export
      Expression
      FunctionArg
      FunctionDefinition
      Pattern
      TypeDefinition
      VariantDefinition
      VariantField
    }
    {#:values
      export-exported-name
      export-local-name
      function-definition-name
    }
    {#:patterns
      abstraction-pattern
      annotated-expr
      app-expr
      begin-expr
      block
      boolean-literal
      bytes-literal
      bytes-pattern
      case-clause
      case-expr
      exports
      function-arg
      function-definition
      if-expr
      ignore-pattern
      int-literal
      int-pattern
      lambda-expr
      let-expr
      match-def
      type-definition
      var-expr
      varargs-app-expr
      variable-pattern
      variant-definition
      variant-field
    }
  }
  (tuples)
}
(export
  (#:types)
  (#:values validate-module module-errors->bytes)
  (#:patterns))
(types
  (define-type ModuleErrors
    (module-errors
      [module-name : ModName]
      [error : (List ModuleError)]))
  (define-type ModuleError
    (duplicate-module-bindings
      [types : (List Bytes)]
      [values : (List Bytes)]
      [patterns : (List Bytes)])
    (undefined-exports
      [types : (List Bytes)]
      [values : (List Bytes)]
      [patterns : (List Bytes)])
    (duplicate-exports
      [types : (List Bytes)]
      [values : (List Bytes)]
      [patterns : (List Bytes)])
    (non-unique-name)
    (function-error [name : Bytes] [error : FunctionError]))
  (define-type FunctionError
    (free-variables
      [types : (List FreeVar)]
      [values : (List FreeVar)]
      [patterns : (List FreeVar)])
    (duplicate-bindings
      [names : (List Bytes)])))

(define (validate-module [mod : Module] [sigs : (IndexedSet ModuleSignature ModName)]) : (Maybe ModuleErrors)
  (case (validate-module/duplicate-bindings mod)
    [(left v) (just (module-errors (module-name mod) (varargs list v)))]
    [(right (tuple3 type-env env pat-env))
     (case
       (append*
         (varargs list
           (validate-module/free-variables mod type-env env pat-env)
           (validate-module/undefined-exports mod type-env env pat-env)
           (validate-module/duplicate-exports mod)
           (validate-module/unique-name mod sigs)
           (validate-module/unique-bindings mod)))
       [(empty)
        (nothing)]
       [errors
        (just (module-errors (module-name mod) errors))])]))

;; Checks to make sure that there are no duplicate bindings.
;; If there are returns (left <error-message>), otherwise returns
;; (right (tuple3 <types> <values> <patterns>))
(define (validate-module/duplicate-bindings [mod : Module])
  : (Either ModuleError (Tuple3 (Set Bytes) (Set Bytes) (Set Bytes)))
  (let ([env (module-environment mod)])
    (case (find-duplicates env)
      [value-dups
       (let ([pattern-env (module-pattern-environment mod)])
         (case (find-duplicates pattern-env)
           [pattern-dups
            (let ([type-env (module-type-environment mod)])
              (case (find-duplicates type-env)
                [type-dups
                 (case (tuple3 value-dups pattern-dups type-dups)
                   [(tuple3 (empty) (empty) (empty))
                    (right (tuple3 (multi-set-keys type-env)
                                   (multi-set-keys env)
                                   (multi-set-keys pattern-env)))]
                   [_
                    (left (duplicate-module-bindings type-dups value-dups pattern-dups))])]))]))])))

(define (validate-module/unique-name [mod : Module] [sigs : (IndexedSet ModuleSignature ModName)])
  : (List ModuleError)
  (case (indexed-set-ref sigs (module-name mod))
    [(nothing)
     (empty)]
    [(just _)
     (cons (non-unique-name) (empty))]))

(define (find-duplicates [ms : (MultiSet Bytes)]) : (List Bytes)
  (find-duplicates/list (set->list (multi-set-keys ms)) ms))

(define (find-duplicates/list [l : (List Bytes)] [ms : (MultiSet Bytes)]) : (List Bytes)
  (case l
    [(empty) (empty)]
    [(cons e l)
     (if (> (multi-set-count ms e) 1)
       (cons e (find-duplicates/list l ms))
       (find-duplicates/list l ms))]))

(define (validate-module/undefined-exports
          [mod : Module]
          [type-env : (Set Bytes)]
          [value-env : (Set Bytes)]
          [pattern-env : (Set Bytes)])
  : (List ModuleError)
  (match-define (module _ _ (exports types values patterns) _ _) mod)
  (let ([check-exports
          (lambda ([exports : (List Export)] [env : (Set Bytes)])
            (set->list
              (set-remove-all
                (set-add-all (make-set bytes-cmp) (map export-local-name exports))
                (set->list env))))])

    (case (tuple3
            (check-exports types type-env)
            (check-exports values value-env)
            (check-exports patterns pattern-env))
      [(tuple3 (empty) (empty) (empty))
       (empty)]
      [(tuple3 types values patterns)
       (varargs list (undefined-exports types values patterns))])))

(define (validate-module/duplicate-exports [mod : Module])
  : (List ModuleError)
  (match-define (module _ _ (exports types values patterns) _ _) mod)
  (let ([check-exports
          (lambda ([exports : (List Export)])
            (find-duplicates
              (multi-set-add-all
                (make-multi-set bytes-cmp)
                (map export-exported-name exports))))])
    (case (tuple3
            (check-exports types)
            (check-exports values)
            (check-exports patterns))
      [(tuple3 (empty) (empty) (empty))
       (empty)]
      [(tuple3 types values patterns)
       (varargs list (duplicate-exports types values patterns))])))

(define (validate-module/free-variables
          [mod : Module]
          [type-env : (Set Bytes)]
          [value-env : (Set Bytes)]
          [pattern-env : (Set Bytes)]) : (List ModuleError)
  (let ([validate-function-definition/free-variables
          (lambda ([def : FunctionDefinition]) : (Maybe ModuleError)
            (case (tuple3
                    (free-types/function-definition def type-env (empty))
                    (free-variables/function-definition def value-env (empty))
                    (free-patterns/function-definition def pattern-env (empty)))
              [(tuple3 (empty) (empty) (empty))
               (nothing)]
              [(tuple3 types values patterns)
               (just (function-error
                       (function-definition-name def)
                       (free-variables types values patterns)))]))])
    (append
      (let ([free-types (free-types/type-definitions (module-types mod) type-env (empty))])
        (case free-types
          [(empty) (empty)]
          [types
           (varargs list
             (function-error
               #"TypeDefinitions"
               (free-variables types (empty) (empty))))]))
      (filter-map
        validate-function-definition/free-variables
        (module-definitions mod)))))

(define (module-type-environment [mod : Module]) : (MultiSet Bytes)
  (case mod
    [(module _ (imports imported-types _ _ _) _ types _)
     (multi-set-add-all
       (add-type-definitions-bindings types
         (make-multi-set bytes-cmp))
       (set->list (dict-keys imported-types)))]))


(define (module-environment [mod : Module]) : (MultiSet Bytes)
  (case mod
    [(module _ (imports _ imported-values _ _) _ types definitions)
     (multi-set-add-all
       (add-constructor-bindings/types types
         (add-accessor-bindings/types types
           (add-definitions-bindings definitions
             (make-multi-set bytes-cmp))))
       (set->list (dict-keys imported-values)))]))

(define (module-pattern-environment [mod : Module]) : (MultiSet Bytes)
  (case mod
    [(module _ (imports _ _ imported-patterns _) _ types _)
     (multi-set-add-all
       (add-constructor-bindings/types types
         (make-multi-set bytes-cmp))
       (set->list (dict-keys imported-patterns)))]))

(define (add-definitions-bindings [defs : (List FunctionDefinition)] [env : (MultiSet Bytes)])
  : (MultiSet Bytes)
  (case defs
    [(empty) env]
    [(cons (function-definition name _ _ _ _) defs)
     (add-definitions-bindings defs (multi-set-add env name))]))

(define (add-accessor-bindings/types [types : (List TypeDefinition)] [env : (MultiSet Bytes)])
  : (MultiSet Bytes)
  (case types
    [(empty) env]
    [(cons (type-definition _ _ variants) types)
     (add-accessor-bindings/types types (add-accessor-bindings/variants variants env))]))

(define (add-constructor-bindings/types [types : (List TypeDefinition)] [env : (MultiSet Bytes)])
  : (MultiSet Bytes)
  (case types
    [(empty) env]
    [(cons (type-definition _ _ variants) types)
     (add-constructor-bindings/types types (add-constructor-bindings/variants variants env))]))


(define (add-type-definitions-bindings [types : (List TypeDefinition)] [env : (MultiSet Bytes)])
  : (MultiSet Bytes)
  (case types
    [(empty) env]
    [(cons (type-definition name _ _) types)
     (add-type-definitions-bindings types (multi-set-add env name))]))

(define (add-constructor-bindings/variants [variants : (List VariantDefinition)] [env : (MultiSet Bytes)])
  : (MultiSet Bytes)
  (case variants
    [(empty) env]
    [(cons (variant-definition name _) variants)
     (add-constructor-bindings/variants variants (multi-set-add env name))]))


(define (add-accessor-bindings/variants [variants : (List VariantDefinition)] [env : (MultiSet Bytes)])
  : (MultiSet Bytes)
  (case variants
    [(cons (variant-definition name fields) (empty))
     (add-variant-field-bindings name fields env)]
    [_ env]))

(define (add-variant-field-bindings [variant : Bytes]
                                    [fields : (List VariantField)] [env : (MultiSet Bytes)])
  : (MultiSet Bytes)
  (case fields
    [(empty) env]
    [(cons (variant-field name _) fields)
     (let ([acc-name (bytes-append (varargs list variant #"-" name))])
       (add-variant-field-bindings variant fields (multi-set-add env acc-name)))]))

(define (validate-module/unique-bindings [mod : Module]) : (List ModuleError)
  (filter-map
    check-unique-bindings/function-definition
    (module-definitions mod)))

(define (check-unique-bindings/function-definition [def : FunctionDefinition]) : (Maybe ModuleError)
  (case def
    [(function-definition name _ fun-args _ body)
     (case (check-unique-bindings/args (function-args-bindings fun-args))
       [(just args)
        (just (function-error name (duplicate-bindings args)))]
       [(nothing)
        (case (check-unique-bindings/block body)
          [(just args) (just (function-error name (duplicate-bindings args)))]
          [(nothing) (nothing)])])]))

(define (check-unique-bindings/args [args : (List Bytes)]) : (Maybe (List Bytes))
  (case (find-duplicates (multi-set-add-all (make-multi-set bytes-cmp) args))
    [(empty)
     (nothing)]
    [dups
     (just dups)]))

(define (check-unique-bindings/block [b : Block]) : (Maybe (List Bytes))
  (case b
    [(block defs expr)
     (case (check-unique-bindings/block-definitions defs)
       [(just v) (just v)]
       [(nothing) (check-unique-bindings/expr expr)])]))

(define (check-unique-bindings/block-definitions [defs : (List BlockDefinition)])
  : (Maybe (List Bytes))
  (find/maybe
    (lambda ([def : BlockDefinition])
      (case def
        [(match-def pattern _type expr)
         (case (check-unique-bindings/args (pattern-bindings pattern))
           [(just v) (just v)]
           [(nothing)
            (check-unique-bindings/expr expr)])]))
    defs))

(define (check-unique-bindings/expr [expr : Expression]) : (Maybe (List Bytes))
  (case expr
    [(int-literal _) (nothing)]
    [(bytes-literal _) (nothing)]
    [(boolean-literal _) (nothing)]
    [(var-expr _ _) (nothing)]
    [(annotated-expr _ expr)
     (check-unique-bindings/expr expr)]
    [(if-expr c t f)
     (check-unique-bindings/exprs (varargs list c t f))]
    [(begin-expr exprs expr)
     (check-unique-bindings/exprs (cons expr exprs))]
    [(app-expr _ op args)
     (check-unique-bindings/exprs (cons op args))]
    [(varargs-app-expr _ op args)
     (check-unique-bindings/exprs (cons op args))]
    [(let-expr _name expr body)
     (case (check-unique-bindings/expr expr)
       [(just v) (just v)]
       [(nothing)
        (check-unique-bindings/block body)])]
    [(lambda-expr fun-args _return-type body)
     (case (check-unique-bindings/args (function-args-bindings fun-args))
       [(just v) (just v)]
       [(nothing)
        (check-unique-bindings/block body)])]
    [(case-expr expr clauses)
     (case (check-unique-bindings/expr expr)
       [(just v) (just v)]
       [(nothing)
        (check-unique-bindings/clauses clauses)])]))

(define (check-unique-bindings/exprs [exprs : (List Expression)]) : (Maybe (List Bytes))
  (find/maybe check-unique-bindings/expr exprs))

(define (check-unique-bindings/clauses [clauses : (List CaseClause)]) : (Maybe (List Bytes))
  (find/maybe
    (lambda ([clause : CaseClause])
      (case clause
        [(case-clause pattern body)
         (case (check-unique-bindings/args (pattern-bindings pattern))
           [(just v) (just v)]
           [(nothing)
            (check-unique-bindings/block body)])]))
    clauses))

(define (function-args-bindings [args : (List FunctionArg)]) : (List Bytes)
  (foldl
    (lambda ([arg : FunctionArg] [acc : (List Bytes)])
      (match-define (function-arg pattern _type) arg)
      (pattern-bindings* pattern acc))
    args
    (ann (List Bytes) (empty))))


(define (pattern-bindings [p : Pattern]) : (List Bytes)
  (pattern-bindings* p (empty)))
(define (pattern-bindings* [p : Pattern] [acc : (List Bytes)]) : (List Bytes)
  (case p
    [(bytes-pattern _ _) acc]
    [(int-pattern _ _) acc]
    [(ignore-pattern _) acc]
    [(variable-pattern v _) (cons v acc)]
    [(abstraction-pattern _ pats _)
     (foldl pattern-bindings* pats acc)]))

(define (module-errors->bytes [me : ModuleErrors]) : Bytes
  (case me
    [(module-errors mod-name errors)
     (bytes-append
       (map (lambda ([error : ModuleError]) (module-error->bytes mod-name error)) errors))]))

(define (module-error->bytes [mod-name : ModName] [error : ModuleError]) : Bytes
  (case error
    [(duplicate-module-bindings types values patterns)
     (let ([warn-duplicates
             (lambda ([kind : Bytes] [bindings : (List Bytes)]) : (JoinList Bytes)
               (case bindings
                 [(empty) (empty-jl)]
                 [_
                  (append-jl
                    (varargs join-list #"  " kind #" bindings:\n")
                    (concat-jl (map (lambda ([binding : Bytes])
                                      (varargs join-list #"    " binding #"\n"))
                                    bindings)))]))])
        (bytes-append
          (jl->list
            (varargs append-jl*
              (varargs join-list #"Duplicate bindings in module " (mod-name->bytes mod-name) #":\n")
              (warn-duplicates #"Type" types)
              (warn-duplicates #"Value" values)
              (warn-duplicates #"Pattern" patterns)))))]
    [(non-unique-name)
     (bytes-append (varargs list #"Module \"" (mod-name->bytes mod-name) #"\" already exists."))]
    [(undefined-exports types values patterns)
     (let ([warn-undefined-exports
             (lambda ([kind : Bytes] [names : (List Bytes)]) : (JoinList Bytes)
               (case names
                 [(empty) (empty-jl)]
                 [_
                   (append-jl
                     (varargs join-list #"  " kind #" exports:\n")
                     (concat-jl (map (lambda ([name : Bytes])
                                       (varargs join-list #"    " name #"\n"))
                                     names)))]))])
        (bytes-append
          (jl->list
            (append-jl
              (varargs join-list #"Undefined exports in module " (mod-name->bytes mod-name) #":\n")
              (varargs append-jl*
                (warn-undefined-exports #"Type" types)
                (warn-undefined-exports #"Value" values)
                (warn-undefined-exports #"Pattern" patterns))))))]
    [(duplicate-exports types values patterns)
     (let ([warn-duplicate-exports
             (lambda ([kind : Bytes] [names : (List Bytes)]) : (JoinList Bytes)
               (case names
                 [(empty) (empty-jl)]
                 [_
                   (append-jl
                     (varargs join-list #"  " kind #" exports:\n")
                     (concat-jl (map (lambda ([name : Bytes])
                                       (varargs join-list #"    " name #"\n"))
                                     names)))]))])
        (bytes-append
          (jl->list
            (append-jl
              (varargs join-list #"Duplicate exports in module " (mod-name->bytes mod-name) #":\n")
              (varargs append-jl*
                (warn-duplicate-exports #"Type" types)
                (warn-duplicate-exports #"Value" values)
                (warn-duplicate-exports #"Pattern" patterns))))))]
    [(function-error function-name (free-variables types values patterns))
     (match-define warn-free-variables
       (lambda ([kind : Bytes] [names : (List FreeVar)]) : (JoinList Bytes)
         (case names
           [(empty) (empty-jl)]
           [_
             (append-jl
               (varargs join-list #"  " kind #":\n")
               (concat-jl (map (lambda ([v : FreeVar])
                                 (match-define
                                   (free-var name (source-span source start-row start-column _ _)) v)
                                 (match-define source-file
                                   (case source
                                     [(unnamed-source) #"<unknown>"]
                                     [(source-file path) path]))
                                 (varargs join-list
                                   #"    " name
                                   #" [" source-file #":"
                                   (integer->decimal-bytes start-row) #":"
                                   (integer->decimal-bytes start-column)
                                   #"]\n"))
                               names)))])))
     (bytes-append
       (jl->list
         (append-jl
           (varargs join-list
             #"Free variables in module " (mod-name->bytes mod-name) #" in function " function-name #":\n")
           (varargs append-jl*
             (warn-free-variables #"Types" types)
             (warn-free-variables #"Values" values)
             (warn-free-variables #"Patterns" patterns)))))]
    [(function-error function-name (duplicate-bindings dups))
     (bytes-append
       (append
         (varargs list #"Duplicate bindings in " (mod-name->bytes mod-name) #" in " function-name #": ")
         (interleave dups #", ")))]))
