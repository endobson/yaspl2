#:module (resolved-vars-language)
#:import {
  (bytes)
  (dict)
  {(expanded-datatypes-language)
    {#:types
      [Block ed:Block]
      [BlockDefinition ed:BlockDefinition]
      [CaseClause ed:CaseClause]
      [Exports ed:Exports]
      [Expression ed:Expression]
      [FunctionDefinition ed:FunctionDefinition]
      Imports
      [Module ed:Module]
      [Pattern ed:Pattern]
      PatternExport
      TypeExport
      [ValueExport ed:ValueExport]
    }
    {#:values
      [module-definitions ed:module-definitions]
      [module-imports ed:module-imports]
      [module-name ed:module-name]
    }
    {#:patterns
      [abstraction-pattern ed:abstraction-pattern]
      [annotated-expr ed:annotated-expr]
      [app-expr ed:app-expr]
      [begin-expr ed:begin-expr]
      [block ed:block]
      [boolean-literal ed:boolean-literal]
      [bytes-literal ed:bytes-literal]
      [bytes-pattern ed:bytes-pattern]
      [case-clause ed:case-clause]
      [case-expr ed:case-expr]
      [exports ed:exports]
      [function-definition ed:function-definition]
      [if-expr ed:if-expr]
      [ignore-pattern ed:ignore-pattern]
      imports
      [int-literal ed:int-literal]
      [int-pattern ed:int-pattern]
      [lambda-expr ed:lambda-expr]
      [let-expr ed:let-expr]
      [match-def ed:match-def]
      [module ed:module]
      pattern-export
      type-export
      [value-export ed:value-export]
      [var-expr ed:var-expr]
      [varargs-app-expr ed:varargs-app-expr]
      [variable-pattern ed:variable-pattern]
      [variant-accessor ed:variant-accessor]
      [variant-constructor ed:variant-constructor]
    }
  }
  (list)
  (maybe)
  (module-name)
  (module-signature)
  (prim)
  (top-level-name)
  (tuples)
  (types)
  (yaspl var)
}
(export
  (#:types CaseClause Exports Expression FunctionDefinition Imports Module Pattern PatternExport
           TypeExport ValueExport)
  (#:values resolve-vars module-definitions module-imports module-name)
  (#:patterns abstraction-pattern annotated-expr app-expr begin-expr boolean-literal
              bytes-literal bytes-pattern case-clause case-expr exports function-definition
              global-var-expr if-expr imports int-literal int-pattern lambda-expr let-expr
              local-var-expr module pattern-export type-export value-export
              varargs-app-expr variable-pattern variant-constructor variant-accessor))
(types
  (define-type Module
    (module [name : ModName]
            [imports : Imports]
            [exports : Exports]
            [definitions : (List FunctionDefinition)]))

  (define-type Exports
    (exports [types : (List TypeExport)]
             [values : (List ValueExport)]
             [patterns : (List PatternExport)]))
  (define-type ValueExport
    (value-export [exported-name : Bytes] [top-level-name : TopLevelName] [type : Type]))


  (define-type FunctionDefinition
    (function-definition [name : Bytes]
                         [type-vars : (List Bytes)]
                         [args : (List (Tuple2 Var Type))]
                         [return-type : Type]
                         [next-var : VarNumber]
                         [body : Expression])
    (variant-constructor
      [name : Bytes]
      ;; TODO include something more useful than field names here
      [fields : (List Bytes)]
      [tag : U8])
    (variant-accessor
      [name : Bytes]
      [field-offset : Int]))

  (define-type Expression
    (int-literal [v : Int])
    (bytes-literal [v : Bytes])
    (boolean-literal [v : Boolean])
    (local-var-expr [v : Var])
    (global-var-expr [v : TopLevelName])
    (annotated-expr [t : Type] [e : Expression])
    (if-expr [cond : Expression] [true : Expression] [false : Expression])
    (begin-expr [exprs : (List Expression)] [last-expr : Expression])
    (app-expr [tail-position : Boolean] [op : Expression] [args : (List Expression)])
    (varargs-app-expr [tail-position : Boolean] [op : Expression] [args : (List Expression)])
    (let-expr [var : Var] [expr : Expression] [body : Expression])
    (lambda-expr [args : (List (Tuple2 Var Type))] [type : (Maybe Type)] [body : Expression])
    (case-expr [expr : Expression] [clauses : (List CaseClause)]))

  (define-type CaseClause
    (case-clause [pattern : Pattern] [body : Expression]))

  (define-type Pattern
    (bytes-pattern [v : Bytes])
    (int-pattern [v : Int])
    (variable-pattern [v : Var])
    (abstraction-pattern [descriptor : PatternSignature] [patterns : (List Pattern)]))

  (define-type Environment
    (environment
      [local-variables : (Dict Bytes Var)]
      [global-variables : (Dict Bytes TopLevelName)]
      [module-name : ModName]))

  (define-type State
    (state [counter : VarNumber])))

(define (resolve-vars [mod : ed:Module]) : Module
  (match-define (ed:module name imports exports definitions) mod)
  (match-define global-env (setup-value-environment mod))
  (match-define env (environment (make-dict bytes-cmp) global-env name))

  (module name imports
          (resolve-vars/exports exports env)
          (map (lambda ([f : ed:FunctionDefinition]) (resolve-vars/function-definition f env))
               definitions)))

(define (setup-value-environment [mod : ed:Module]) : (Dict Bytes TopLevelName)
  (add-all-imported-functions
    (add-locally-defined-functions
      (make-dict bytes-cmp)
      mod)
    mod))

(define (add-all-imported-functions [env : (Dict Bytes TopLevelName)] [mod : ed:Module])
  : (Dict Bytes TopLevelName)
  (match-define (imports values _) (ed:module-imports mod))
  (merge-dicts
    (dict-value-map values
      (lambda ([v : ValueSignature])
        (value-signature-value v)))
    env))

(define (add-locally-defined-functions [env : (Dict Bytes TopLevelName)] [mod : ed:Module])
  : (Dict Bytes TopLevelName)
  (foldl
    (lambda ([def : ed:FunctionDefinition] [env : (Dict Bytes TopLevelName)])
      (case def
        [(ed:function-definition name _ _ _ _)
         (dict-add env name (top-level-name (ed:module-name mod) name))]
        [(ed:variant-constructor type-name variant-name _ _)
         (dict-add
           env
           variant-name
           (top-level-name
             (ed:module-name mod)
             (bytes-append
               (varargs list type-name #"_" variant-name #"_closure"))))]
        [(ed:variant-accessor type-name variant-name field-name _)
         (dict-add
           env
           (bytes-append (varargs list variant-name #"-" field-name))
           (top-level-name
             (ed:module-name mod)
             (bytes-append
               (varargs list type-name #"_" variant-name #"_" field-name #"_closure"))))]))
    (ed:module-definitions mod)
    env))

(define (resolve-vars/exports [e : ed:Exports] [env : Environment]) : Exports
  (case e
    [(ed:exports types values patterns)
     (exports
       types
       (map (lambda ([e : ed:ValueExport]) (resolve-vars/value-export e env)) values)
       patterns)]))

(define (resolve-vars/value-export [e : ed:ValueExport] [env : Environment]) : ValueExport
  (case e
    [(ed:value-export local-name exported-name type)
     (case (dict-ref (environment-global-variables env) local-name)
       [(just v)
        (value-export exported-name v type)]
       [(nothing)
        (panic #"Unbound variable for export")])]))

(define (resolve-vars/function-definition [f : ed:FunctionDefinition] [env : Environment])
  : FunctionDefinition
  (case f
    [(ed:function-definition name type-vars args return-type body)
     (match-define state (state (initial-var-number)))
     (match-define arg-names (map parse-arg-name args))
     (match-define (tuple2 env state) (environment-add-locals env arg-names state))
     (match-define (tuple2 body state) (resolve-vars/block body env state))
     (match-define (state next-var) state)
     (function-definition
       name
       type-vars
       (map (lambda ([t : (Tuple2 Bytes Type)]) (resolve-vars/arg-type t env)) args)
       return-type
       next-var
       body)]
    [(ed:variant-constructor type-name variant-name fields tag)
     (variant-constructor (bytes-append (varargs list type-name #"_" variant-name)) fields tag)]
    [(ed:variant-accessor type-name variant-name field-name field-offset)
     (variant-accessor
       (bytes-append (varargs list type-name #"_" variant-name #"_" field-name))
       field-offset)]))

(define (resolve-vars/arg-type [t : (Tuple2 Bytes Type)] [env : Environment])
  : (Tuple2 Var Type)
  (case t
    [(tuple2 arg ty)
     (case (dict-ref (environment-local-variables env) arg)
       [(nothing) (panic #"No value found for function arg")]
       [(just var) (tuple2 var ty)])]))


(define (resolve-vars/block [block : ed:Block] [env : Environment] [state : State])
  : (Tuple2 Expression State)
  (match-define (ed:block defs expr) block)
  (resolve-vars/block* defs expr env state))

(define (resolve-vars/block*
          [defs : (List ed:BlockDefinition)] [body : ed:Expression]
          [env : Environment] [state : State])
  : (Tuple2 Expression State)
  (case defs
    [(empty)
     (resolve-vars/expr body env state) ]
    [(cons (ed:match-def pattern _ expr) defs)
     (match-define (tuple2 expr state) (resolve-vars/expr expr env state))
     (match-define (tuple3 pattern env state) (resolve-vars/pattern pattern env state))
     (match-define (tuple2 rec-expr state) (resolve-vars/block* defs body env state))
     (tuple2 (case-expr expr (varargs list (case-clause pattern rec-expr))) state)]))

(define (resolve-vars/expr [expr : ed:Expression] [env : Environment] [state : State])
  : (Tuple2 Expression State)
  (case expr
    [(ed:var-expr v)
     (case (dict-ref (environment-local-variables env) v)
       [(just v)
        (tuple2 (local-var-expr v) state)]
       [(nothing)
        (case (dict-ref (environment-global-variables env) v)
          [(just v)
           (tuple2 (global-var-expr v) state)]
          [(nothing)
           (panic #"Unbound variable")])])]
    [(ed:lambda-expr args+tys return-type body)
     (match-define args (map parse-arg-name args+tys))
     (match-define (tuple2 env state) (environment-add-locals env args state))
     (match-define (tuple2 body state) (resolve-vars/expr body env state))
     (tuple2
       (lambda-expr
         (map (lambda ([t : (Tuple2 Bytes Type)]) (resolve-vars/arg-type t env)) args+tys)
         return-type
         body)
       state)]
    ;; Structural cases
    [(ed:int-literal v)
     (tuple2 (int-literal v) state)]
    [(ed:bytes-literal v)
     (tuple2 (bytes-literal v) state)]
    [(ed:boolean-literal v)
     (tuple2 (boolean-literal v) state)]
    [(ed:if-expr c t f)
     (match-define (tuple2 c state) (resolve-vars/expr c env state))
     (match-define (tuple2 t state) (resolve-vars/expr t env state))
     (match-define (tuple2 f state) (resolve-vars/expr f env state))
     (tuple2 (if-expr c t f) state)]
    [(ed:begin-expr es e)
     (match-define (tuple2 es state) (resolve-vars/exprs es env state))
     (match-define (tuple2 e state) (resolve-vars/expr e env state))
     (tuple2 (begin-expr es e) state)]
    [(ed:let-expr name expr body)
     (match-define (tuple2 expr state) (resolve-vars/expr expr env state))
     (match-define (tuple3 env var state) (environment-add-local env name state))
     (match-define (tuple2 body state) (resolve-vars/block body env state))
     (tuple2 (let-expr var expr body) state)]
    [(ed:case-expr expr clauses)
     (match-define (tuple2 expr state) (resolve-vars/expr expr env state))
     (match-define (tuple2 clauses state) (resolve-vars/case-clauses clauses env state))
     (tuple2 (case-expr expr clauses) state)]
    [(ed:annotated-expr type expr)
     (match-define (tuple2 expr state) (resolve-vars/expr expr env state))
     (tuple2 (annotated-expr type expr) state)]
    [(ed:app-expr tail-position op args)
     (match-define (tuple2 op state) (resolve-vars/expr op env state))
     (match-define (tuple2 args state) (resolve-vars/exprs args env state))
     (tuple2 (app-expr tail-position op args) state)]
    [(ed:varargs-app-expr tail-position op args)
     (match-define (tuple2 op state) (resolve-vars/expr op env state))
     (match-define (tuple2 args state) (resolve-vars/exprs args env state))
     (tuple2 (varargs-app-expr tail-position op args) state)]))

(define (resolve-vars/exprs [exprs : (List ed:Expression)] [env : Environment] [state : State])
  : (Tuple2 (List Expression) State)
  (case exprs
    [(empty) (tuple2 (empty) state)]
    [(cons e es)
     (match-define (tuple2 e state) (resolve-vars/expr e env state))
     (match-define (tuple2 es state) (resolve-vars/exprs es env state))
     (tuple2 (cons e es) state)]))


(define (resolve-vars/case-clause [c : ed:CaseClause] [env : Environment] [state : State])
  : (Tuple2 CaseClause State)
  (case c
    [(ed:case-clause pat body)
     (match-define (tuple3 pat env state) (resolve-vars/pattern pat env state))
     (match-define (tuple2 expr state) (resolve-vars/block body env state))
     (tuple2 (case-clause pat expr) state)]))

(define (resolve-vars/case-clauses [cs : (List ed:CaseClause)] [env : Environment] [state : State])
  : (Tuple2 (List CaseClause) State)
  (case cs
    [(empty) (tuple2 (empty) state)]
    [(cons c cs)
     (match-define (tuple2 c state) (resolve-vars/case-clause c env state))
     (match-define (tuple2 cs state) (resolve-vars/case-clauses cs env state))
     (tuple2 (cons c cs) state)]))

(define (resolve-vars/pattern [p : ed:Pattern] [env : Environment] [state : State])
  : (Tuple3 Pattern Environment State)
  (case p
    [(ed:int-pattern v)
     (tuple3 (int-pattern v) env state)]
    [(ed:bytes-pattern v)
     (tuple3 (bytes-pattern v) env state)]
    [(ed:ignore-pattern)
     (match-define (tuple2 var-num state) (get-next-index state))
     (tuple3 (variable-pattern (var #"_" var-num)) env state)]
    [(ed:variable-pattern v)
     (match-define (tuple3 env var state) (environment-add-local env v state))
     (tuple3 (variable-pattern var) env state)]
    [(ed:abstraction-pattern desc patterns)
     (match-define (tuple3 patterns env state) (resolve-vars/patterns patterns env state))
     (tuple3 (abstraction-pattern desc patterns) env state)]))

(define (resolve-vars/patterns [ps : (List ed:Pattern)] [env : Environment] [state : State])
  : (Tuple3 (List Pattern) Environment State)
  (case ps
    [(empty) (tuple3 (empty) env state)]
    [(cons p ps)
     (match-define (tuple3 p env state) (resolve-vars/pattern p env state))
     (match-define (tuple3 ps env state) (resolve-vars/patterns ps env state))
     (tuple3 (cons p ps) env state)]))

(define (get-next-index [acc : State]) : (Tuple2 VarNumber State)
  (case acc
    [(state counter)
     (tuple2 counter (state (next-var-number counter)))]))

(define (environment-add-local [env : Environment] [local : Bytes] [state : State])
  : (Tuple3 Environment Var State)
  (match-define (environment locals globals name) env)
  (match-define (tuple2 var-num state) (get-next-index state))
  (match-define v (var local var-num))
  (tuple3
    (environment (dict-set locals local v) globals name)
    v
    state))

(define (environment-add-locals [env : Environment] [locals : (List Bytes)] [state : State])
  : (Tuple2 Environment State)
  (case locals
    [(empty) (tuple2 env state)]
    [(cons local locals)
     (case (environment-add-local env local state)
       [(tuple3 env _ state)
        (environment-add-locals env locals state)])]))

(define (parse-arg-name [arg+ty : (Tuple2 Bytes Type)]) : Bytes
  (case arg+ty
    [(tuple2 arg ty) arg]))
