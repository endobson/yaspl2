#:module (resolved-vars-language)
#:import {
  (bytes)
  (data source-location)
  (dict)
  {(expanded-datatypes-language)
    {#:types
      [Block ed:Block]
      [BlockDefinition ed:BlockDefinition]
      [CaseClause ed:CaseClause]
      [DatatypeDefinition ed:DatatypeDefinition]
      [Export ed:Export]
      [Exports ed:Exports]
      [Expression ed:Expression]
      [FunctionArg ed:FunctionArg]
      [FunctionDefinition ed:FunctionDefinition]
      [Imports ed:Imports]
      [Module ed:Module]
      [Pattern ed:Pattern]
      PatternExport
      [StaticDefinition ed:StaticDefinition]
      TypeExport
      [ValueExport ed:ValueExport]
    }
    {#:values
      [module-definitions ed:module-definitions]
      [module-imports ed:module-imports]
      [module-name ed:module-name]
      [module-static-definitions ed:module-static-definitions]
    }
    {#:patterns
      [abstraction-pattern ed:abstraction-pattern]
      [annotated-expr ed:annotated-expr]
      [app-expr ed:app-expr]
      [begin-expr ed:begin-expr]
      [block ed:block]
      [boolean-literal ed:boolean-literal]
      [bytes-literal ed:bytes-literal]
      [bytes-pattern ed:bytes-pattern]
      [case-clause ed:case-clause]
      [case-expr ed:case-expr]
      [export ed:export]
      [exports ed:exports]
      [function-arg ed:function-arg]
      [function-definition ed:function-definition]
      [if-expr ed:if-expr]
      [ignore-pattern ed:ignore-pattern]
      [imports ed:imports]
      [int-literal ed:int-literal]
      [int-pattern ed:int-pattern]
      [lambda-expr ed:lambda-expr]
      [let-expr ed:let-expr]
      [match-def ed:match-def]
      [module ed:module]
      pattern-export
      type-export
      [value-export ed:value-export]
      [var-expr ed:var-expr]
      [varargs-app-expr ed:varargs-app-expr]
      [varargs-definition ed:varargs-definition]
      [variable-pattern ed:variable-pattern]
      [variant-accessor ed:variant-accessor]
      [variant-constructor ed:variant-constructor]
    }
  }
  (list)
  (maybe)
  (module-name)
  (module-signature)
  (prim)
  (top-level-name)
  (tuples)
  (types)
  (yaspl var)
}
(export
  (#:types CaseClause DatatypeDefinition Exports Expression FunctionDefinition FunctionArg Imports
           Module Pattern PatternExport StaticExport TypeExport ValueExport)
  (#:values resolve-vars module-definitions module-imports module-name
            function-arg-name function-arg-type)
  (#:patterns abstraction-pattern app-expr begin-expr boolean-literal
              bytes-literal bytes-pattern case-clause case-expr exports function-definition function-arg
              global-var-expr if-expr imports int-literal int-pattern lambda-expr let-expr
              local-var-expr module pattern-export type-export value-export varargs-export
              varargs-app-expr variable-pattern variant-constructor variant-accessor))
(types
  (define-type Module
    (module [name : ModName]
            [imports : Imports]
            [exports : Exports]
            [definitions : (List FunctionDefinition)]
            [datatype-definitions : (List DatatypeDefinition)]))

  (define-type Exports
    (exports [types : (List TypeExport)]
             [values : (List ValueExport)]
             [patterns : (List PatternExport)]
             [statics : (List StaticExport)]))
  (define-type ValueExport
    (value-export [exported-name : Bytes] [top-level-name : TopLevelName] [type : Type]))
  (define-type StaticExport
    (varargs-export
      [exported-name : Bytes]
      [type-vars : (List Bytes)]
      [arg-type : Type]
      [return-type : Type]
      [cons-func : TopLevelName]
      [empty-func : TopLevelName]))
  (define-type Imports
    (imports
      [static-info : (Dict TopLevelName TopLevelSignature)]))

  (define-type FunctionDefinition
    (function-definition
      [function-name : TopLevelName]
      [closure-name : TopLevelName]
      [type-vars : (List Bytes)]
      [args : (List FunctionArg)]
      [return-type : Type]
      [next-var : VarNumber]
      [body : Expression]))
  (define-type DatatypeDefinition
    (variant-constructor
      [variant-name : Bytes]
      [function-name : TopLevelName]
      [closure-name : TopLevelName]
      [const-name : TopLevelName]
      [descriptor-name : TopLevelName]
      [variant-name-name : TopLevelName]
      ;; TODO include something more useful than field names here
      [fields : (List Bytes)]
      [tag : U8])
    (variant-accessor
      [function-name : TopLevelName]
      [closure-name : TopLevelName]
      [field-offset : Int]))
  (define-type FunctionArg
    (function-arg
      [name : Var]
      [type : Type]))

  (define-type Expression
    (int-literal [v : Int])
    (bytes-literal [v : Bytes])
    (boolean-literal [v : Boolean])
    (local-var-expr [v : Var])
    (global-var-expr [v : TopLevelName])
    (if-expr [cond : Expression] [true : Expression] [false : Expression])
    (begin-expr [exprs : (List Expression)] [last-expr : Expression])
    (app-expr [tail-position : Boolean] [op : Expression] [args : (List Expression)])
    (varargs-app-expr
      [tail-position : Boolean] [cons : TopLevelName] [empty : TopLevelName]
      [args : (List Expression)])
    (let-expr [var : Var] [expr : Expression] [body : Expression])
    (lambda-expr [args : (List FunctionArg)] [type : (Maybe Type)] [body : Expression])
    (case-expr [expr : Expression] [clauses : (List CaseClause)]))

  (define-type CaseClause
    (case-clause [pattern : Pattern] [body : Expression]))

  (define-type Pattern
    (bytes-pattern [v : Bytes])
    (int-pattern [v : Int])
    (variable-pattern [v : Var])
    (abstraction-pattern [descriptor : PatternSignature] [patterns : (List Pattern)]))

  (define-type Environment
    (environment
      [local-variables : (Dict Bytes Var)]
      [global-variables : (Dict Bytes TopLevelName)]
      [global-statics : (Dict Bytes TopLevelStaticInfo)]
      [module-name : ModName]))

  (define-type TopLevelStaticInfo
    (varargs-top-level-info
      [type-vars : (List Bytes)]
      [arg-type : Type]
      [return-type : Type]
      [cons-func : TopLevelName]
      [empty-func : TopLevelName]))

  (define-type State
    (state [counter : VarNumber])))

(define (resolve-vars [mod : ed:Module]) : Module
  (match-define (ed:module name imports exports definitions datatype-definitions _statics) mod)

  (match-define datatype-definitions : (Dict Bytes DatatypeDefinition)
    (dict-add-all
      (make-dict bytes-cmp)
      (map (lambda ([def : ed:DatatypeDefinition])
             (resolve-vars/datatype-definition def name))
           datatype-definitions)))

  (match-define global-env (setup-value-environment mod datatype-definitions))
  (match-define global-statics : (Dict Bytes TopLevelStaticInfo)
    (setup-static-environment mod global-env))
  (match-define env (environment (make-dict bytes-cmp) global-env global-statics name))

  (module name
          (resolve-vars/imports imports)
          (resolve-vars/exports exports env)
          (map (lambda ([f : ed:FunctionDefinition]) (resolve-vars/function-definition f env))
               definitions)
          (dict-values datatype-definitions)))

(define (setup-value-environment
          [mod : ed:Module]
          [datatype-definitions : (Dict Bytes DatatypeDefinition)]) : (Dict Bytes TopLevelName)
  (add-all-imported-functions
    (add-locally-defined-functions
      (add-datatype-definitions
        (make-dict bytes-cmp)
        datatype-definitions)
      mod)
    mod))

(define (add-all-imported-functions [env : (Dict Bytes TopLevelName)] [mod : ed:Module])
  : (Dict Bytes TopLevelName)
  (match-define (ed:imports values _ _) (ed:module-imports mod))
  (merge-dicts
    (dict-value-map values
      (lambda ([v : ValueSignature])
        (value-signature-value v)))
    env))

(define (add-locally-defined-functions [env : (Dict Bytes TopLevelName)] [mod : ed:Module])
  : (Dict Bytes TopLevelName)
  (foldl
    (lambda ([def : ed:FunctionDefinition] [env : (Dict Bytes TopLevelName)])
      (case def
        [(ed:function-definition name _ _ _ _)
         (dict-add env name (top-level-name (ed:module-name mod)
                                            (bytes-append (varargs list name #"_closure"))))]))
    (ed:module-definitions mod)
    env))

(define (add-datatype-definitions
          [env : (Dict Bytes TopLevelName)]
          [datatype-definitions : (Dict Bytes DatatypeDefinition)])
  : (Dict Bytes TopLevelName)
  (merge-dicts
    env
    (dict-value-map
      datatype-definitions
      (lambda ([data : DatatypeDefinition])
        (case data
          [(variant-constructor _ _ closure-name _ _ _ _ _)
           closure-name]
          [(variant-accessor _ closure-name _)
           closure-name])))))

(define (setup-static-environment
          [mod : ed:Module]
          [global-env : (Dict Bytes TopLevelName)])
  : (Dict Bytes TopLevelStaticInfo)
  (add-all-imported-statics
    (add-locally-defined-statics
      (make-dict bytes-cmp)
      mod
      global-env)
    mod))

(define (add-locally-defined-statics
          [env : (Dict Bytes TopLevelStaticInfo)]
          [mod : ed:Module]
          [global-env : (Dict Bytes TopLevelName)])
  : (Dict Bytes TopLevelStaticInfo)
  (dict-add-all
    env
    (map
      (lambda ([def : ed:StaticDefinition]) : (Tuple2 Bytes TopLevelStaticInfo)
        (case def
          [(ed:varargs-definition
             name type-vars arg-type return-type
             (source-span-annotated cons-func _) (source-span-annotated empty-func _))
           (case (dict-ref global-env cons-func)
             [(just cons-func)
              (case (dict-ref global-env empty-func)
                [(just empty-func)
                 (tuple2 name (varargs-top-level-info type-vars arg-type return-type cons-func empty-func))]
                [(nothing)
                 (panic #"Unbound empty-func")])]
             [(nothing)
              (panic #"Unbound cons-func")])]))
      (ed:module-static-definitions mod))))

(define (add-all-imported-statics
          [env : (Dict Bytes TopLevelStaticInfo)]
          [mod : ed:Module])
  : (Dict Bytes TopLevelStaticInfo)
  (match-define (ed:imports _ statics _) (ed:module-imports mod))
  (merge-dicts
    env
    (dict-value-map
      statics
      (lambda ([sig : StaticSignature]) : TopLevelStaticInfo
        (case sig
          [(varargs-signature type-vars arg-type return-type cons-func empty-func)
           (varargs-top-level-info type-vars arg-type return-type cons-func empty-func)])))))

(define (resolve-vars/imports [i : ed:Imports]) : Imports
  (match-define (ed:imports _ _ static-info) i)
  (imports static-info))

(define (resolve-vars/exports [e : ed:Exports] [env : Environment]) : Exports
  (case e
    [(ed:exports types values patterns statics)
     (exports
       types
       (map (lambda ([e : ed:ValueExport]) (resolve-vars/value-export e env)) values)
       patterns
       (map (lambda ([e : ed:Export]) (resolve-vars/static-export e env)) statics))]))

(define (resolve-vars/value-export [e : ed:ValueExport] [env : Environment]) : ValueExport
  (case e
    [(ed:value-export local-name exported-name type)
     (case (dict-ref (environment-global-variables env) local-name)
       [(just v)
        (value-export exported-name v type)]
       [(nothing)
        (panic #"Unbound variable for export")])]))

(define (resolve-vars/static-export [e : ed:Export] [env : Environment]) : StaticExport
  (case e
    [(ed:export local-name exported-name)
     (case (dict-ref (environment-global-statics env) local-name)
       [(just (varargs-top-level-info type-vars arg-type return-type cons-func empty-func))
        (varargs-export exported-name type-vars arg-type return-type cons-func empty-func)]
       [(nothing)
        (panic #"Unbound variable for export")])]))

(define (resolve-vars/function-definition [f : ed:FunctionDefinition] [env : Environment])
  : FunctionDefinition
  (case f
    [(ed:function-definition name type-vars args return-type body)
     (match-define state (state (initial-var-number)))
     (match-define (tuple2 (tuple2 args body) state)
       (resolve-vars/function-body args body env state))
     (match-define (state next-var) state)
     (function-definition
       (top-level-name (environment-module-name env) name)
       (top-level-name (environment-module-name env) (bytes-append (varargs list name #"_closure")))
       type-vars args return-type next-var body)]))

(define (resolve-vars/datatype-definition [f : ed:DatatypeDefinition] [mod-name : ModName])
  : (Tuple2 Bytes DatatypeDefinition)
  (case f
    [(ed:variant-constructor type-name variant-name fields tag)
     (match-define make-name
       (lambda ([suffix : Bytes])
         (top-level-name mod-name (bytes-append (varargs list type-name #"_" variant-name suffix)))))
     (tuple2
       variant-name
       (variant-constructor
         variant-name
         (make-name #"")
         (make-name #"_closure")
         (make-name #"_const")
         (make-name #"_descriptor")
         (make-name #"_variantname")
         fields
         tag))]
    [(ed:variant-accessor type-name variant-name field-name field-offset)
     (match-define make-name
       (lambda ([suffix : Bytes])
         (top-level-name
           mod-name
           (bytes-append (varargs list type-name #"_" variant-name #"_" field-name suffix)))))
     (tuple2
       (bytes-append (varargs list variant-name #"-" field-name))
       (variant-accessor
         (make-name #"")
         (make-name #"_closure")
         field-offset))]))

;; TODO optimize this so that we don't add unnecessary patterns
(define (resolve-vars/function-arg
          [arg : ed:FunctionArg]
          [env : Environment]
          [state : State])
  : (Tuple3 (Tuple2 FunctionArg (Maybe Pattern)) Environment State)
  (case arg
    [(ed:function-arg (ed:variable-pattern v _) type)
     (match-define (tuple3 env var state) (environment-add-local env v state))
     (tuple3 (tuple2 (function-arg var type) (nothing)) env state)]
    [(ed:function-arg pattern type)
     (match-define (tuple2 var-num state) (get-next-index state))
     (match-define (tuple3 pattern env state)
       (resolve-vars/pattern pattern env state))
     (tuple3 (tuple2
               (function-arg (var #"arg" var-num) type)
               (just pattern))
             env
             state)]))


(define (resolve-vars/function-body
          [args : (List ed:FunctionArg)]
          [body : ed:Block]
          [env : Environment]
          [state : State])
  : (Tuple2 (Tuple2 (List FunctionArg) Expression) State)
  (match-define (tuple3 args env state) (resolve-vars/function-args args env state))
  (match-define (tuple2 body state) (resolve-vars/block body env state))
  (match-define body
    (foldl
      (lambda ([arg : (Tuple2 FunctionArg (Maybe Pattern))] [body : Expression])
        (case arg
          [(tuple2 (function-arg var type) (nothing))
           body]
          [(tuple2 (function-arg var type) (just pattern))
           (case-expr (local-var-expr var)
                      (varargs list (case-clause pattern body)))]))
      args
      body))
  (tuple2
    (tuple2
      (map
        (lambda ([arg : (Tuple2 FunctionArg (Maybe Pattern))])
          (case arg [(tuple2 fun-arg _) fun-arg]))
        args)
      body)
    state))

(define (resolve-vars/function-args
          [args : (List ed:FunctionArg)]
          [env : Environment]
          [state : State])
  : (Tuple3 (List (Tuple2 FunctionArg (Maybe Pattern))) Environment State)
  (case args
    [(empty)
     (tuple3 (empty) env state)]
    [(cons arg args)
     (match-define (tuple3 arg env state) (resolve-vars/function-arg arg env state))
     (match-define (tuple3 args env state) (resolve-vars/function-args args env state))
     (tuple3 (cons arg args) env state)]))




(define (resolve-vars/block [block : ed:Block] [env : Environment] [state : State])
  : (Tuple2 Expression State)
  (match-define (ed:block defs expr) block)
  (resolve-vars/block* defs expr env state))

(define (resolve-vars/block*
          [defs : (List ed:BlockDefinition)] [body : ed:Expression]
          [env : Environment] [state : State])
  : (Tuple2 Expression State)
  (case defs
    [(empty)
     (resolve-vars/expr body env state) ]
    [(cons (ed:match-def pattern _ expr) defs)
     (match-define (tuple2 expr state) (resolve-vars/expr expr env state))
     (match-define (tuple3 pattern env state) (resolve-vars/pattern pattern env state))
     (match-define (tuple2 rec-expr state) (resolve-vars/block* defs body env state))
     (tuple2 (case-expr expr (varargs list (case-clause pattern rec-expr))) state)]))

(define (resolve-vars/expr [expr : ed:Expression] [env : Environment] [state : State])
  : (Tuple2 Expression State)
  (case expr
    [(ed:var-expr v _)
     (case (dict-ref (environment-local-variables env) v)
       [(just v)
        (tuple2 (local-var-expr v) state)]
       [(nothing)
        (case (dict-ref (environment-global-variables env) v)
          [(just v)
           (tuple2 (global-var-expr v) state)]
          [(nothing)
           (panic #"Unbound variable")])])]
    [(ed:lambda-expr args return-type body _)
     (match-define (tuple2 (tuple2 args body) state)
       (resolve-vars/function-body args body env state))
     (tuple2 (lambda-expr args return-type body) state)]
    ;; Structural cases
    [(ed:int-literal v _)
     (tuple2 (int-literal v) state)]
    [(ed:bytes-literal v _)
     (tuple2 (bytes-literal v) state)]
    [(ed:boolean-literal v _)
     (tuple2 (boolean-literal v) state)]
    [(ed:if-expr c t f _)
     (match-define (tuple2 c state) (resolve-vars/expr c env state))
     (match-define (tuple2 t state) (resolve-vars/expr t env state))
     (match-define (tuple2 f state) (resolve-vars/expr f env state))
     (tuple2 (if-expr c t f) state)]
    [(ed:begin-expr es e _)
     (match-define (tuple2 es state) (resolve-vars/exprs es env state))
     (match-define (tuple2 e state) (resolve-vars/expr e env state))
     (tuple2 (begin-expr es e) state)]
    [(ed:let-expr name expr body _)
     (match-define (tuple2 expr state) (resolve-vars/expr expr env state))
     (match-define (tuple3 env var state) (environment-add-local env name state))
     (match-define (tuple2 body state) (resolve-vars/block body env state))
     (tuple2 (let-expr var expr body) state)]
    [(ed:case-expr expr clauses _)
     (match-define (tuple2 expr state) (resolve-vars/expr expr env state))
     (match-define (tuple2 clauses state) (resolve-vars/case-clauses clauses env state))
     (tuple2 (case-expr expr clauses) state)]
    [(ed:annotated-expr _ expr _)
     (match-define (tuple2 expr state) (resolve-vars/expr expr env state))
     (tuple2 expr state)]
    [(ed:app-expr tail-position op args _)
     (match-define (tuple2 op state) (resolve-vars/expr op env state))
     (match-define (tuple2 args state) (resolve-vars/exprs args env state))
     (tuple2 (app-expr tail-position op args) state)]
    [(ed:varargs-app-expr tail-position (source-span-annotated op _) args _)
     (case (dict-ref (environment-global-statics env) op)
       [(nothing) (panic #"Unbound static")]
       [(just (varargs-top-level-info _ _ _ cons-func empty-func))
        (match-define (tuple2 args state) (resolve-vars/exprs args env state))
        (tuple2 (varargs-app-expr tail-position cons-func empty-func args) state)])]))

(define (resolve-vars/exprs [exprs : (List ed:Expression)] [env : Environment] [state : State])
  : (Tuple2 (List Expression) State)
  (case exprs
    [(empty) (tuple2 (empty) state)]
    [(cons e es)
     (match-define (tuple2 e state) (resolve-vars/expr e env state))
     (match-define (tuple2 es state) (resolve-vars/exprs es env state))
     (tuple2 (cons e es) state)]))


(define (resolve-vars/case-clause [c : ed:CaseClause] [env : Environment] [state : State])
  : (Tuple2 CaseClause State)
  (case c
    [(ed:case-clause pat body)
     (match-define (tuple3 pat env state) (resolve-vars/pattern pat env state))
     (match-define (tuple2 expr state) (resolve-vars/block body env state))
     (tuple2 (case-clause pat expr) state)]))

(define (resolve-vars/case-clauses [cs : (List ed:CaseClause)] [env : Environment] [state : State])
  : (Tuple2 (List CaseClause) State)
  (case cs
    [(empty) (tuple2 (empty) state)]
    [(cons c cs)
     (match-define (tuple2 c state) (resolve-vars/case-clause c env state))
     (match-define (tuple2 cs state) (resolve-vars/case-clauses cs env state))
     (tuple2 (cons c cs) state)]))

(define (resolve-vars/pattern [p : ed:Pattern] [env : Environment] [state : State])
  : (Tuple3 Pattern Environment State)
  (case p
    [(ed:int-pattern v _)
     (tuple3 (int-pattern v) env state)]
    [(ed:bytes-pattern v _)
     (tuple3 (bytes-pattern v) env state)]
    [(ed:ignore-pattern _)
     (match-define (tuple2 var-num state) (get-next-index state))
     (tuple3 (variable-pattern (var #"_" var-num)) env state)]
    [(ed:variable-pattern v _)
     (match-define (tuple3 env var state) (environment-add-local env v state))
     (tuple3 (variable-pattern var) env state)]
    [(ed:abstraction-pattern desc patterns _)
     (match-define (tuple3 patterns env state) (resolve-vars/patterns patterns env state))
     (tuple3 (abstraction-pattern desc patterns) env state)]))

(define (resolve-vars/patterns [ps : (List ed:Pattern)] [env : Environment] [state : State])
  : (Tuple3 (List Pattern) Environment State)
  (case ps
    [(empty) (tuple3 (empty) env state)]
    [(cons p ps)
     (match-define (tuple3 p env state) (resolve-vars/pattern p env state))
     (match-define (tuple3 ps env state) (resolve-vars/patterns ps env state))
     (tuple3 (cons p ps) env state)]))

(define (get-next-index [acc : State]) : (Tuple2 VarNumber State)
  (case acc
    [(state counter)
     (tuple2 counter (state (next-var-number counter)))]))

(define (environment-add-local [env : Environment] [local : Bytes] [state : State])
  : (Tuple3 Environment Var State)
  (match-define (environment locals globals statics name) env)
  (match-define (tuple2 var-num state) (get-next-index state))
  (match-define v (var local var-num))
  (tuple3
    (environment (dict-set locals local v) globals statics name)
    v
    state))
