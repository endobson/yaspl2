#:module sexp-printer
#:import {
  bytes {
    #:values
      bytes-append
  }
  join-list {
    #:types
      JoinList
    #:values
      concat-jl
      cons-jl
      jl->list
      join-list
      single-jl
      snoc-jl
  }
  list {
    #:values
      interleave
      map
  }
  numbers {
    #:values
      integer->decimal-bytes
  }
  prim {
    #:types
      Bytes
  }
  sexp-parser {
    #:types
      Sexp
    #:patterns
      boolean-sexp
      brace-node
      bracket-node
      bytes-sexp
      keyword-sexp
      node
      number-sexp
      symbol-sexp
  }
}
(export
  #:types ()
  #:values (print-sexp)
  #:patterns ())
(types)

(define (print-sexp [sexp : Sexp]) : Bytes
  (bytes-append (jl->list (print-sexp* sexp))))

(define (print-sexp* [sexp : Sexp]) : (JoinList Bytes)
  (case sexp
    [(boolean-sexp v) (single-jl (if v #"#t" #"#f"))]
    [(bytes-sexp v) (varargs join-list #"#\"" v #"\"")]
    [(keyword-sexp v) (varargs join-list #"#:" v)]
    [(symbol-sexp v) (single-jl v)]
    [(number-sexp v) (single-jl (integer->decimal-bytes v))]
    [(node v)
     (cons-jl
       #"("
       (snoc-jl
         (concat-jl (interleave (map print-sexp* v) (single-jl #" ")))
         #")"))]
    [(bracket-node v)
     (cons-jl
       #"["
       (snoc-jl
         (concat-jl (interleave (map print-sexp* v) (single-jl #" ")))
         #"]"))]
    [(brace-node v)
     (cons-jl
       #"{"
       (snoc-jl
         (concat-jl (interleave (map print-sexp* v) (single-jl #" ")))
         #"}"))]))
