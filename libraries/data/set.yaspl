#:module set
(import
  (list
    #:types (List)
    #:values (andmap cons empty filter foldl length)
    #:patterns (cons empty))
  (maybe
    #:types (Maybe)
    #:values (just nothing)
    #:patterns ())
  (prim
    #:types (Boolean Int)
    #:values (= and)
    #:patterns ())
  (tuples
    #:types (Tuple2)
    #:values (tuple2)
    #:patterns ()))
(export
  #:types (Set)
  #:values (make-set set-add set->list set-member? set-remove set-add-all
            set-remove-all set-count set-intersect set-difference set=? set-union set-union*
            set-split)
  #:patterns ())
(types
  (define-type (Set a)
    (set [eq? : (a a -> Boolean)] [vals : (List a)])))

(define (a) (make-set [eq : (a a -> Boolean)]) : (Set a)
  (set eq (empty)))

(define (a) (set->list [s : (Set a)]) : (List a)
  (set-vals s))

(define (a) (set-count [s : (Set a)]) : Int
  (length (set-vals s)))

(define (a) (set-add [s : (Set a)] [v : a]) : (Set a)
  (if (set-member? s v)
      s
      (case s
        [(set eq vs)
         (set eq (cons v vs))])))

(define (a) (set-add-all [s : (Set a)] [vs : (List a)])  : (Set a)
  (case vs
    [(empty) s]
    [(cons v vs) (set-add-all (set-add s v) vs)]))

(define (a) (set-remove [s : (Set a)] [v : a]) : (Set a)
  (case s
    [(set eq vs)
     (set eq (set-remove-helper eq vs v))]))

(define (a) (set-remove-all [s : (Set a)] [vs : (List a)]) : (Set a)
  (case vs
    [(empty) s]
    [(cons v vs) (set-remove-all (set-remove s v) vs)]))


(define (a) (set-remove-helper [eq : (a a -> Boolean)] [vs : (List a)] [v : a]) : (List a)
  (case vs
    [(empty) (empty)]
    [(cons v2 vs)
     (if (eq v v2)
         vs
         (cons v2 (set-remove-helper eq vs v)))]))

(define (a) (set-split [s : (Set a)]) : (Maybe (Tuple2 a (Set a)))
  (case s
    [(set _ (empty)) (nothing)]
    [(set eq (cons v vs)) (just (tuple2 v (set eq vs)))]))

(define (a) (set-member? [s : (Set a)] [v : a]) : Boolean
  (case s
    [(set eq vs)
     (set-member?-helper eq vs v)]))

(define (a) (set-member?-helper [eq : (a a -> Boolean)] [vs : (List a)] [v : a]) : Boolean
  (case vs
    [(empty) #f]
    [(cons v2 vs)
     (if (eq v v2)
         #t
         (set-member?-helper eq vs v))]))

(define (a) (set-intersect [s1 : (Set a)] [s2 : (Set a)]) : (Set a)
  (case s1
    [(set eq _)
     (set eq (filter (lambda ([x : a]) (set-member? s1 x)) (set->list s2)))]))

(define (a) (set-difference [s1 : (Set a)] [s2 : (Set a)]) : (Set a)
  (foldl
    (lambda ([e : a] [s : (Set a)])
      (set-remove s e))
    (set->list s2)
    s1))

(define (a) (set-union [s1 : (Set a)] [s2 : (Set a)]) : (Set a)
  (foldl
    (lambda ([e : a] [s : (Set a)])
      (set-add s e))
    (set->list s2)
    s1))

(define (a) (set-union* [s1 : (Set a)] [ss : (List (Set a))]) : (Set a)
  (foldl
    (lambda ([new-set : (Set a)] [acc : (Set a)])
      (set-union acc new-set))
    ss
    s1))

(define (a) (set=? [s1 : (Set a)] [s2 : (Set a)]) : Boolean
  (and (= (set-count s1) (set-count s2))
       (andmap
         (lambda ([v : a]) (set-member? s2 v))
         (set->list s1))))
