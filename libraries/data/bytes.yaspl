#:module (bytes)
#:import {
  (data ordering)
  (list)
  (numbers)
  (prim)
}
(export
  (#:types)
  (#:values bytes-copy! bytes=? subbytes bytes-append bytes make-null-terminated
            starts-with? ends-with?
            bytes-ref/quad-le bytes-set!/quad-le bytes-set!/s32-le
            bytes-ref/u64-le bytes-set!/u64-le
            sum bytes<
            bytes-split bytes-cmp)
  (#:patterns))
(types)

(define (bytes< [left : Bytes] [right : Bytes]) : Boolean
  (case (bytes-cmp left right)
    [(less-than) #t]
    [_ #f]))

(define (bytes-cmp [left : Bytes] [right : Bytes]) : Ordering
  (bytes-cmp-helper 0 left right))

(define (bytes-cmp-helper [offset : Int] [left : Bytes] [right : Bytes]) : Ordering
  (if (or (>= offset (bytes-length left)) (>= offset (bytes-length right)))
      (int-cmp (bytes-length left) (bytes-length right))
      (let ([l-value (u8->s64 (bytes-ref left offset))])
        (let ([r-value (u8->s64 (bytes-ref right offset))])
          (if (< l-value r-value)
              (less-than)
              (if (< r-value l-value)
                  (greater-than)
                  (bytes-cmp-helper (+ offset 1) left right)))))))

(define (bytes-copy! [src : Bytes] [s-start : Int] [s-end : Int] [dest : Bytes] [d-start : Int])
  : Void
  (if (= s-start s-end)
      (void)
      (begin
        (bytes-set! dest d-start (bytes-ref src s-start))
        (bytes-copy! src (+ s-start 1) s-end dest (+ d-start 1)))))


(define (starts-with? [bytes : Bytes] [prefix : Bytes]) : Boolean
  (if (>= (bytes-length bytes) (bytes-length prefix))
      (bytes=? (subbytes bytes 0 (bytes-length prefix)) prefix)
      #f))

(define (ends-with? [bytes : Bytes] [suffix : Bytes]) : Boolean
  (if (>= (bytes-length bytes) (bytes-length suffix))
      (bytes=? (subbytes bytes (- (bytes-length bytes) (bytes-length suffix)) (bytes-length bytes)) suffix)
      #f))

(define (subbytes [src : Bytes] [start : Int] [end : Int]) : Bytes
  (let ([new-bytes (make-bytes (- end start))])
    (begin
      (bytes-copy! src start end new-bytes 0)
      new-bytes)))

(define (bytes=? [b1 : Bytes] [b2 : Bytes]) : Boolean
  (case (bytes-cmp b1 b2)
    [(equal-to) #t]
    [_ #f]))

;; TODO move this to a better module
(define (sum [nums : (List Int)]) : Int
  (sum-helper nums 0))
(define (sum-helper [nums : (List Int)] [acc : Int]) : Int
  (case nums
    [(empty) acc]
    [(cons num nums) (sum-helper nums (+ num acc))]))


(define (bytes-append [bytess : (List Bytes)]) : Bytes
  (let ([acc (make-bytes (sum (map bytes-length bytess)))])
    (bytes-append-helper acc 0 bytess)))
(define (bytes-append-helper [acc : Bytes] [offset : Int] [bytess : (List Bytes)]) : Bytes
  (case bytess
    [(empty) acc]
    [(cons input bytess)
     (let ([len (bytes-length input)])
       (begin
         (bytes-copy! input 0 len acc offset)
         (bytes-append-helper acc (+ offset len) bytess)))]))

;; TODO make this take U8s
(define (bytes [vs : (Array Int)]) : Bytes
  (let ([acc (make-bytes (array-length vs))])
    (bytes-helper vs 0 acc)))
(define (bytes-helper [vs : (Array Int)] [offset : Int] [acc : Bytes]) : Bytes
  (if (= offset (array-length vs))
      acc
      (begin
        (bytes-set! acc offset (u8 (array-ref vs offset)))
        (bytes-helper vs (+ 1 offset) acc))))

(define (make-null-terminated [bytes : Bytes]) : Bytes
  (let ([new-bytes (make-bytes (+ (bytes-length bytes) 1))])
    (begin
      (bytes-copy! bytes 0 (bytes-length bytes) new-bytes 0)
      new-bytes)))

;; TODO make this return S32/U32
(define (bytes-ref/quad-le [bytes : Bytes] [offset : Int]) : Int
  (+ (u8->s64 (bytes-ref bytes (+ offset 0)))
     (* 256
        (+ (u8->s64 (bytes-ref bytes (+ offset 1)))
            (* 256
               (+ (u8->s64 (bytes-ref bytes (+ offset 2)))
                  (* 256
                     (u8->s64 (bytes-ref bytes (+ offset 3))))))))))

(define (bytes-ref/u64-le [bytes : Bytes] [offset : Int]) : U64
  (u64
    (+ (u8->s64 (bytes-ref bytes (+ offset 0)))
       (* 256
          (+ (u8->s64 (bytes-ref bytes (+ offset 1)))
             (* 256
                (+ (u8->s64 (bytes-ref bytes (+ offset 2)))
                   (* 256
                      (+ (u8->s64 (bytes-ref bytes (+ offset 3)))
                         (* 256
                            (+ (u8->s64 (bytes-ref bytes (+ offset 4)))
                               (* 256
                                  (+ (u8->s64 (bytes-ref bytes (+ offset 5)))
                                     (* 256
                                        (+ (u8->s64 (bytes-ref bytes (+ offset 6)))
                                           (* 256
                                              (u8->s64 (bytes-ref bytes (+ offset 7)))))))))))))))))))


(define (bytes-set!/quad-le [bytes : Bytes] [offset : Int] [v : U32]) : Void
  (begin
    (bytes-set! bytes offset       (u32/le-byte0 v))
    (bytes-set! bytes (+ offset 1) (u32/le-byte1 v))
    (bytes-set! bytes (+ offset 2) (u32/le-byte2 v))
    (bytes-set! bytes (+ offset 3) (u32/le-byte3 v))))

(define (bytes-set!/s32-le [bytes : Bytes] [offset : Int] [v : S32]) : Void
  (begin
    (bytes-set! bytes offset       (s32/le-byte0 v))
    (bytes-set! bytes (+ offset 1) (s32/le-byte1 v))
    (bytes-set! bytes (+ offset 2) (s32/le-byte2 v))
    (bytes-set! bytes (+ offset 3) (s32/le-byte3 v))))

(define (bytes-set!/u64-le [bytes : Bytes] [offset : Int] [u : U64]) : Void
  (match-define v (u64->s64 u))
  (begin
    (bytes-set! bytes offset       (u8 (bitwise-and v #xFF)))
    (bytes-set! bytes (+ offset 1) (u8 (bitwise-and (logical-shift-right v 8) #xFF)))
    (bytes-set! bytes (+ offset 2) (u8 (bitwise-and (logical-shift-right v 16) #xFF)))
    (bytes-set! bytes (+ offset 3) (u8 (bitwise-and (logical-shift-right v 24) #xFF)))
    (bytes-set! bytes (+ offset 4) (u8 (bitwise-and (logical-shift-right v 32) #xFF)))
    (bytes-set! bytes (+ offset 5) (u8 (bitwise-and (logical-shift-right v 40) #xFF)))
    (bytes-set! bytes (+ offset 6) (u8 (bitwise-and (logical-shift-right v 48) #xFF)))
    (bytes-set! bytes (+ offset 7) (u8 (bitwise-and (logical-shift-right v 56) #xFF)))))

(define (bytes-split [bytes : Bytes] [sep : Bytes]) : (List Bytes)
  (bytes-split* bytes 0 0 sep))

(define (bytes-split* [bytes : Bytes] [start : Int] [cur : Int] [sep : Bytes]) : (List Bytes)
  (if (= cur (bytes-length bytes))
      (cons (subbytes bytes start cur) (empty))
      (if (starts-with? (subbytes bytes cur (bytes-length bytes)) sep)
          (cons (subbytes bytes start cur)
                (bytes-split* bytes (+ cur (bytes-length sep)) (+ cur (bytes-length sep)) sep))
          (bytes-split* bytes start (+ 1 cur) sep))))
