#:module (data red-black-tree-test)
#:import {
  (bytes)
  (data ordering)
  (data red-black-tree)
  (list)
  (maybe)
  (prim)
  (yunit)
}
(export)
(types)

(define (int-cmp [i1 : Int] [i2 : Int]) : Ordering
  (if (= i1 i2)
      (equal-to)
      (if (< i1 i2)
          (less-than)
          (greater-than))))

(define (check-rb-tree-contains [t : (RedBlackTree Int Bytes)] [k : Int] [v : Bytes])
  : (-> (Maybe FailedAssertion))
  (lambda ()
    (case (rb-tree-ref t k)
      [(nothing) (just (failure #"No entry for key"))]
      [(just v2)
       (if (bytes=? v v2)
           (nothing)
           (just (failure #"Values don't match")))])))

(define (check-rb-tree-does-not-contain [t : (RedBlackTree Int Bytes)] [k : Int])
  : (-> (Maybe FailedAssertion))
  (lambda ()
    (case (rb-tree-ref t k)
      [(nothing) (nothing)]
      [(just v2)
       (just (failure #"Entry for key"))])))

(define (empty-rb-tree) : (RedBlackTree Int Bytes)
  (make-rb-tree int-cmp))


(define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Int
  (yunit/main stderr
    (varargs list
      (new-test-case #"rb-ref empty"
        (check-rb-tree-does-not-contain
          (empty-rb-tree)
          0))
      (new-test-case #"rb-ref entry exists"
        (check-rb-tree-contains
          (rb-tree-set (empty-rb-tree) 0 #"hello")
          0
          #"hello"))
      (new-test-case #"rb-ref other-entry"
        (check-rb-tree-does-not-contain
          (rb-tree-set (empty-rb-tree) 0 #"hello")
          1)))))
