#:module (data red-black-tree-assoc-test-driver-main)
#:import {
  (bytes)
  (data ordering)
  (data red-black-tree) {
    #:types
      RedBlackTree
    #:values
      make-rb-tree
      rb-tree-ref
      rb-tree-remove
      rb-tree-set
      rb-tree->sexp
      rb-tree->broken-invariants
  }
  (either)
  (io)
  (list)
  (maybe)
  (prim)
  (sexp-parser)
  (sexp-printer)
}
(export)
(types
  (define-type Command
    (set-value [k : Int] [v : Int])
    (remove-value [k : Int])
    (query-values [ks : (List Int)])))


(define (parse-command [s : Sexp]) : (Either Bytes Command)
  (case s
    [(node (cons (symbol-sexp #"add") (cons (number-sexp k) (cons (number-sexp v) (empty)))))
     (right (set-value k v))]
    [(node (cons (symbol-sexp #"remove") (cons (number-sexp k) (empty))))
     (right (remove-value k))]
    [(node (cons (symbol-sexp #"query") values))
     (case (extract-rights (map parse-number values))
       [(left v) (left v)]
       [(right ks)
        (right (query-values ks))])]
    [_ (left (bytes-append (varargs list #"Unparseable Sexp: " (print-sexp s))))]))

(define (parse-number [s : Sexp]) : (Either Bytes Int)
  (case s
    [(number-sexp k) (right k)]
    [_ (left #"Not a number")]))

(define (handle-commands [commands : (List Command)]
                         [tree : (RedBlackTree Int Int)]
                         [output : OutputPort])
  : (Maybe Bytes)
  (case commands
    [(empty) (nothing)]
    [(cons c commands)
     (let ([tree (handle-command c tree output)])
       (case (rb-tree->broken-invariants tree)
         [(just v)
          (begin
            (write-line (print-sexp (rb-tree->sexp tree number-sexp number-sexp)) output)
            (just v))]
         [(nothing)
          (handle-commands commands tree output)]))]))

(define (handle-command [command : Command] [tree : (RedBlackTree Int Int)] [output : OutputPort])
  : (RedBlackTree Int Int)
  (case command
    [(set-value k v)
     (rb-tree-set tree k v)]
    [(remove-value k)
     (rb-tree-remove tree k)]
    [(query-values ks)
     (begin
       ;(write-line (print-sexp (rb-tree->sexp tree number-sexp number-sexp)) output)
       ;(write-line
       ;  (print-sexp
       ;    (node
       ;      (filter-map
       ;        (lambda ([k : Int]) : (Maybe Sexp)
       ;          (case (rb-tree-ref tree k)
       ;            [(nothing) (nothing)]
       ;            [(just v)
       ;             (just (bracket-node (cons (number-sexp k) (cons (number-sexp v) (empty)))))]))
       ;        ks)))
       ;  output)
       tree)]))

(define (int-cmp [i1 : Int] [i2 : Int]) : Ordering
  (if (= i1 i2)
      (equal-to)
      (if (< i1 i2)
          (less-than)
          (greater-than))))

(define (empty-rb-tree) : (RedBlackTree Int Int)
  (make-rb-tree int-cmp))

(define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Int
  (case (parse-sexps (read-all-bytes stdin))
    [(left v)
     (begin
       (write-line v stderr)
       1)]
    [(right sexps)
     (case (extract-rights (map parse-command sexps))
       [(left v)
        (begin
          (write-line v stderr)
          1)]
       [(right commands)
        (case (handle-commands commands (empty-rb-tree) stdout)
          [(just v)
           (begin
             (write-line v stderr)
             1)]
          [(nothing)
           0])])]))
