(module arithmetic-expr
  (import
    (prim panic)
    (sexp-parser parse-sexp)
    (io read-all-bytes)
    (either right-v)
    (bytes bytes=?))
  (export parse-arith-expr main)
  (types
    (define-type ArithExpr
      (num-lit [v Byte])
      (num-op-expr [v NumOp] [left arith-expr] [right arith-expr]))
    (define-type NumOp
      (plus-op)
      (minus-op)
      (times-op)))

  (define (parse-arith-expr sexp)
    (case sexp
      [(node ops)
       (case ops
         [(cons sym ops)
          (case ops
            [(cons arg1 ops)
             (case ops
               [(cons arg2 ops)
                (case ops
                  [(empty) (parse-arith/fun-two-args sym arg1 arg2)]
                  [(cons arg3 ops) (panic #"Too many arguments")])]
               [(empty) (panic #"Too few arguments: got 1")])]
            [(empty) (panic #"Too few arguments: got 0")])]
         [(empty) (panic #"No function symbol")])]
      [(symbol-sexp bytes) (panic #"Symbols not supported")]
      [(number-sexp byte) (num-lit byte)]))

  (define (parse-arith/fun-two-args sym arg1 arg2)
    (let ([arg1-parsed (parse-arith-expr arg1)])
      (let ([arg2-parsed (parse-arith-expr arg2)])
        (case sym
          [(node args) (panic #"Function position is a node")]
          [(number-sexp v) (panic #"Function position is a number")]
          [(symbol-sexp bytes)
           (num-op-expr (bytes->num-op bytes) arg1-parsed arg2-parsed)]))))

  (define (bytes->num-op bytes)
    (if (bytes=? bytes #"+")
        (plus-op)
        (if (bytes=? bytes #"-")
            (minus-op)
            (if (bytes=? bytes #"*")
                (times-op)
                (panic #"Unknown op")))))

  (define (main stdin stdout stderr)
    (begin
      (parse-arith-expr (right-v (parse-sexp (read-all-bytes stdin))))
      0)))
