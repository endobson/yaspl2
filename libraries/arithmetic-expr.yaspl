(module arithmetic-expr
  (import
    (prim
      #:types (Bytes Byte Boolean InputPort OutputPort Void)
      #:values (panic or void)
      #:patterns ())
    (sexp-parser
      #:types (Sexp)
      #:values (parse-sexp)
      #:patterns (node symbol-sexp number-sexp))
    (io read-all-bytes)
    (either
      #:types (Either)
      #:values ()
      #:patterns (right))
    (list
      #:types (List)
      #:values (cons empty)
      #:patterns (cons empty))
    (bytes bytes=?))
  (export ArithExpr NumOp Module Function parse-module parse-arith-expr main)
  (types
    (define-type Module
      (module [functions (List Function)]))
    (define-type Function
      (function [name Bytes] [arg-names (List Bytes)] [body ArithExpr]))
    (define-type ArithExpr
      (num-lit [v Byte])
      (fun-call-expr [fun Bytes] [args (List ArithExpr)])
      (num-op-expr [v NumOp] [left ArithExpr] [right ArithExpr]))
    (define-type NumOp
      (plus-op)
      (minus-op)
      (times-op)))

  (define (parse-module [sexp : Sexp]) : Module
    (case sexp
      [(node sexps)
       (case sexps
         [(cons mod-sym function-sexps)
          (if (module-symbol? mod-sym)
              (module (parse-functions function-sexps))
              (panic #"Not a module symbol."))])]
      [(symbol-sexp bytes) (panic #"Not a module form")]))

  (define (parse-functions [sexps : (List Sexp)]) : (List Function)
    (case sexps
      [(empty) (empty)]
      [(cons sexp sexps)
       (cons (parse-function sexp) (parse-functions sexps))]))

  (define (parse-function [sexp : Sexp]) : Function
    (case sexp
      [(node sexps)
       (case sexps
         [(cons fun-sym sexps)
          (if (define-symbol? fun-sym)
              (case sexps
                [(cons name-args sexps)
                 (let ([name (extract-name name-args)])
                   (let ([args (extract-args name-args)])
                     (case sexps
                       [(cons body sexps)
                        (case sexps
                          [(empty) (function name args (parse-arith-expr body))]
                          [(cons sexp sexps) (panic #"Too many forms in define")])]
                       [(empty) (panic #"Too few forms in define: no body")])))]
                [(empty) (panic #"Too few forms in define: no name/args")])
              (panic #"Not a define symbol"))])]
      [(symbol-sexp bytes) (panic #"Not a define form")]))

  (define (module-symbol? [sexp : Sexp]) : Boolean
    (case sexp
      [(symbol-sexp bytes) (bytes=? bytes #"module")]))

  (define (define-symbol? [sexp : Sexp]) : Boolean
    (case sexp
      [(symbol-sexp bytes) (bytes=? bytes #"define")]))

  (define (num-op-symbol-bytes? [bytes : Bytes]) : Boolean
    (or (bytes=? bytes #"+")
        (or (bytes=? bytes #"-")
            (bytes=? bytes #"*"))))

  (define (extract-name [sexp : Sexp]) : Bytes
    (case sexp
      [(node sexps)
       (case sexps
         [(cons sexp sexps)
          (case sexp
            [(symbol-sexp bytes) bytes])])]
      [(symbol-sexp bytes) (panic #"Bad name/args")]))


  (define (extract-args [sexp : Sexp]) : (List Bytes)
    (case sexp
      [(node sexps)
       (case sexps
         [(cons sexp sexps)
          (extract-args-helper sexps)])]))

  (define (extract-args-helper [sexps : (List Sexp)]) : (List Bytes)
    (case sexps
      [(empty) (empty)]
      [(cons sexp sexps)
       (case sexp
         [(symbol-sexp bytes) (cons bytes (extract-args-helper sexps))])]))


  (define (parse-arith-expr [sexp : Sexp]) : ArithExpr
    (case sexp
      [(node sexps)
       (case sexps
         [(cons sym args)
          (parse-arith-expr/fun-call sym args)]
         [(empty) (panic #"No function symbol")])]
      [(symbol-sexp bytes) (panic #"Symbols not supported")]
      [(number-sexp byte) (num-lit byte)]))


  (define (parse-arith-expr/fun-call [sym : Sexp] [args : (List Sexp)]) : ArithExpr
    (case sym
      [(node args) (panic #"Function position is a node")]
      [(number-sexp v) (panic #"Function position is a number")]
      [(symbol-sexp bytes)
       (if (num-op-symbol-bytes? bytes)
           (case args
             [(cons arg1 args)
              (case args
                [(cons arg2 args)
                 (case args
                   [(empty)
                    (num-op-expr
                      (bytes->num-op bytes)
                      (parse-arith-expr arg1)
                      (parse-arith-expr arg2))]
                   [(cons arg3 args) (panic #"Too many arguments")])]
                [(empty) (panic #"Too few arguments: got 1")])]
             [(empty) (panic #"Too few arguments: got 0")])
           (fun-call-expr
             bytes
             (parse-arith-exprs args)))]))


  (define (parse-arith-exprs [sexps : (List Sexp)]) : (List ArithExpr)
    (case sexps
      [(empty) (empty)]
      [(cons expr exprs)
       (cons (parse-arith-exprs expr) (parse-arith-exprs exprs))]))


  (define (bytes->num-op [bytes : Bytes]) : NumOp
    (if (bytes=? bytes #"+")
        (plus-op)
        (if (bytes=? bytes #"-")
            (minus-op)
            (if (bytes=? bytes #"*")
                (times-op)
                (panic #"Unknown op")))))

  ;; TODO switch this to a polymorphic version
  (define (ignore-module [module : Module]) : Void
    (void))

  ;; TODO switch this to a polymorphic version
  (define (extract-sexp [either : (Either Bytes Sexp)]) : Sexp
    (case either
      [(right v) v]))

  (define (main [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Byte
    (begin
      (ignore-module (parse-module (extract-sexp (parse-sexp (read-all-bytes stdin)))))
      0)))
