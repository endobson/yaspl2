(module arithmetic-expr
  (import
    (prim panic)
    (sexp-parser parse-sexp)
    (io read-all-bytes)
    (either right-v)
    (list cons empty)
    (bytes bytes=?))
  (export parse-module parse-arith-expr main)
  (types
    (define-type Module
      (module [functions (List Function)]))
    (define-type Function
      (function [name Bytes] [arg-names (List Bytes)] [body ArithExpr]))
    (define-type ArithExpr
      (num-lit [v Byte])
      (num-op-expr [v NumOp] [left arith-expr] [right arith-expr]))
    (define-type NumOp
      (plus-op)
      (minus-op)
      (times-op)))

  (define (parse-module sexp)
    (case sexp
      [(node sexps)
       (case sexps
         [(cons mod-sym function-sexps)
          (if (module-symbol? mod-sym)
              (module (parse-functions function-sexps))
              (panic "Not a module symbol."))])]
      [(symbol-sexp bytes) (panic "Not a module form")]))

  (define (parse-functions sexps)
    (case sexps
      [(empty) (empty)]
      [(cons sexp sexps)
       (cons (parse-function sexp) (parse-functions sexps))]))

  (define (parse-function sexp)
    (case sexp
      [(node sexps)
       (case sexps
         [(cons fun-sym sexps)
          (if (define-symbol? fun-sym)
              (case sexps
                [(cons name-args sexps)
                 (let ([name (extract-name name-args)])
                   (let ([args (extract-args name-args)])
                     (case sexps
                       [(cons body sexps)
                        (case sexps
                          [(empty) (function name args (parse-arith-expr body))]
                          [(cons sexp sexps) (panic "Too many forms in define")])]
                       [(empty) (panic #"Too few forms in define: no body")])))]
                [(empty) (panic #"Too few forms in define: no name/args")])
              (panic "Not a define symbol"))])]
      [(symbol-sexp bytes) (panic "Not a define form")]))

  (define (module-symbol? sexp)
    (case sexp
      [(symbol-sexp bytes) (bytes=? bytes #"module")]))

  (define (define-symbol? sexp)
    (case sexp
      [(symbol-sexp bytes) (bytes=? bytes #"define")]))

  (define (extract-name sexp)
    (case sexp
      [(node sexps)
       (case sexps
         [(cons sexp sexps)
          (case sexp
            [(symbol-sexp bytes) bytes])])]
      [(symbol-sexp bytes) (panic #"Bad name/args")]))


  (define (extract-args sexp)
    (case sexp
      [(node sexps)
       (case sexps
         [(cons sexp sexps)
          (extract-args-helper sexps)])]))

  (define (extract-args-helper sexps)
    (case sexps
      [(empty) (empty)]
      [(cons sexp sexps)
       (case sexp
         [(symbol-sexp bytes) (cons bytes (extract-args-helper sexps))])]))


  (define (parse-arith-expr sexp)
    (case sexp
      [(node ops)
       (case ops
         [(cons sym ops)
          (case ops
            [(cons arg1 ops)
             (case ops
               [(cons arg2 ops)
                (case ops
                  [(empty) (parse-arith/fun-two-args sym arg1 arg2)]
                  [(cons arg3 ops) (panic #"Too many arguments")])]
               [(empty) (panic #"Too few arguments: got 1")])]
            [(empty) (panic #"Too few arguments: got 0")])]
         [(empty) (panic #"No function symbol")])]
      [(symbol-sexp bytes) (panic #"Symbols not supported")]
      [(number-sexp byte) (num-lit byte)]))

  (define (parse-arith/fun-two-args sym arg1 arg2)
    (let ([arg1-parsed (parse-arith-expr arg1)])
      (let ([arg2-parsed (parse-arith-expr arg2)])
        (case sym
          [(node args) (panic #"Function position is a node")]
          [(number-sexp v) (panic #"Function position is a number")]
          [(symbol-sexp bytes)
           (num-op-expr (bytes->num-op bytes) arg1-parsed arg2-parsed)]))))

  (define (bytes->num-op bytes)
    (if (bytes=? bytes #"+")
        (plus-op)
        (if (bytes=? bytes #"-")
            (minus-op)
            (if (bytes=? bytes #"*")
                (times-op)
                (panic #"Unknown op")))))

  (define (main stdin stdout stderr)
    (begin
      (parse-module (right-v (parse-sexp (read-all-bytes stdin))))
      0)))
