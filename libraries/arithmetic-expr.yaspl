(module arithmetic-expr
  (import
    (prim
      #:types (Bytes Byte Boolean InputPort OutputPort Void)
      #:values (panic or void)
      #:patterns ())
    (sexp-parser
      #:types (Sexp)
      #:values (parse-sexp)
      #:patterns (node symbol-sexp number-sexp))
    (io read-all-bytes)
    (either
      #:types (Either)
      #:values ()
      #:patterns (right left))
    (list
      #:types (List)
      #:values (cons empty)
      #:patterns (cons empty))
    (bytes bytes=?))
  (export ArithExpr NumOp Module Function parse-module parse-arith-expr main)
  (types
    (define-type Module
      (module [functions (List Function)]))
    (define-type Function
      (function [name Bytes] [arg-names (List Bytes)] [body ArithExpr]))
    (define-type ArithExpr
      (num-lit [v Byte])
      (var-expr [v Bytes])
      (fun-call-expr [fun Bytes] [args (List ArithExpr)])
      (let-expr [var Bytes] [expr ArithExpr] [body ArithExpr])
      (num-op-expr [v NumOp] [left ArithExpr] [right ArithExpr]))
    (define-type NumOp
      (plus-op)
      (minus-op)
      (times-op))
    (define-type Binder
      (binder [name Bytes] [expr ArithExpr])))

  (define (parse-module [sexp : Sexp]) : Module
    (case sexp
      [(node (cons mod-sym function-sexps))
       (if (module-symbol? mod-sym)
           (module (parse-functions function-sexps))
           (panic #"Not a module symbol."))]
      [_ (panic #"Not a module form")]))

  (define (parse-functions [sexps : (List Sexp)]) : (List Function)
    (case sexps
      [(empty) (empty)]
      [(cons sexp sexps)
       (cons (parse-function sexp) (parse-functions sexps))]))

  (define (parse-function [sexp : Sexp]) : Function
    (case sexp
      [(node sexps)
       (case sexps
         [(cons fun-sym sexps)
          (if (define-symbol? fun-sym)
              (case sexps
                [(cons name-args sexps)
                 (let ([name (extract-name name-args)])
                   (let ([args (extract-args name-args)])
                     (case sexps
                       [(cons body sexps)
                        (case sexps
                          [(empty) (function name args (parse-arith-expr body))]
                          [(cons sexp sexps) (panic #"Too many forms in define")])]
                       [(empty) (panic #"Too few forms in define: no body")])))]
                [(empty) (panic #"Too few forms in define: no name/args")])
              (panic #"Not a define symbol"))]
         [(empty) (panic #"Not a define form")])]
      [_ (panic #"Not a define form")]))

  (define (module-symbol? [sexp : Sexp]) : Boolean
    (case sexp
      [(symbol-sexp bytes) (bytes=? bytes #"module")]
      [_ #f]))

  (define (define-symbol? [sexp : Sexp]) : Boolean
    (case sexp
      [(symbol-sexp bytes) (bytes=? bytes #"define")]
      [_ #f]))

  (define (let-symbol? [sexp : Sexp]) : Boolean
    (case sexp
      [(symbol-sexp bytes) (bytes=? bytes #"let")]
      [_ #f]))


  (define (num-op-symbol-bytes? [bytes : Bytes]) : Boolean
    (or (bytes=? bytes #"+")
        (or (bytes=? bytes #"-")
            (bytes=? bytes #"*"))))

  (define (extract-name [sexp : Sexp]) : Bytes
    (case sexp
      [(node (cons (symbol-sexp bytes) _))
       bytes]
      [_ (panic #"Bad name/args")]))


  (define (extract-args [sexp : Sexp]) : (List Bytes)
    (case sexp
      [(node (cons _ sexps))
       (extract-args-helper sexps)]
      [_ (panic #"Bad name/args")]))

  (define (extract-args-helper [sexps : (List Sexp)]) : (List Bytes)
    (case sexps
      [(empty) (empty)]
      [(cons sexp sexps)
       (case sexp
         [(symbol-sexp bytes) (cons bytes (extract-args-helper sexps))]
         [_ (panic #"Bad args")])]))


  (define (parse-arith-expr [sexp : Sexp]) : ArithExpr
    (case sexp
      [(node sexps)
       (case sexps
         [(cons sym args)
          (if (let-symbol? sym)
              (parse-let-expr args)
              (parse-arith-expr/fun-call sym args))]
         [(empty) (panic #"No function symbol")])]
      [(symbol-sexp bytes)
       (var-expr bytes)]
      [(number-sexp byte) (num-lit byte)]
      [_ (panic #"Bad arith expr")]))

  (define (parse-let-expr [args : (List Sexp)]) : ArithExpr
    (case args
      [(empty) (panic #"Too short let")]
      [(cons bind args)
       (case args
         [(empty) (panic #"Too short let")]
         [(cons body args)
          (case args
            [(cons arg args) (panic #"Too long let")]
            [(empty)
             (case (parse-binders/1 bind)
               [(binder name expr)
                (let-expr name expr (parse-arith-expr body))])])])]))

  (define (parse-binders/1 [sexp : Sexp]) : Binder
    (case (parse-binders/sexp sexp)
      [(empty) (panic #"Too short binders")]
      [(cons binder binders)
       (case binders
         [(cons binder binders) (panic #"Too long binders")]
         [(empty) binder])]))

  (define (parse-binders/sexp [sexp : Sexp]) : (List Binder)
    (case sexp
      [(node sexps)
       (parse-binders sexps)]
      [_ (panic #"Not a valid list of binders")]))

  (define (parse-binders [sexps : (List Sexp)]) : (List Binder)
    (case sexps
      [(cons sexp sexps)
       (cons (parse-binder sexp) (parse-binders sexps))]
      [(empty) (empty)]))

  (define (parse-binder [sexp : Sexp]) : Binder
    (case sexp
      [(node sexps)
       (case sexps
         [(empty) (panic #"Too short binder")]
         [(cons sym sexps)
          (case sexps
            [(empty) (panic #"Too short binder")]
            [(cons expr sexps)
             (case sexps
               [(cons expr sexps) (panic #"Too long binder")]
               [(empty)
                (case sym
                  [(symbol-sexp name) (binder name (parse-arith-expr expr))]
                  [_ (panic #"Not a valid binding identifier")])])])])]
      [_ (panic #"Symbol is not a valid binder")]))


  (define (parse-arith-expr/fun-call [sym : Sexp] [args : (List Sexp)]) : ArithExpr
    (case sym
      [(symbol-sexp bytes)
       (if (num-op-symbol-bytes? bytes)
           (case args
             [(cons arg1 args)
              (case args
                [(cons arg2 args)
                 (case args
                   [(empty)
                    (num-op-expr
                      (bytes->num-op bytes)
                      (parse-arith-expr arg1)
                      (parse-arith-expr arg2))]
                   [(cons arg3 args) (panic #"Too many arguments")])]
                [(empty) (panic #"Too few arguments: got 1")])]
             [(empty) (panic #"Too few arguments: got 0")])
           (fun-call-expr
             bytes
             (parse-arith-exprs args)))]
      [_ (panic #"Bad function call")]))


  (define (parse-arith-exprs [sexps : (List Sexp)]) : (List ArithExpr)
    (case sexps
      [(empty) (empty)]
      [(cons expr exprs)
       (cons (parse-arith-expr expr) (parse-arith-exprs exprs))]))


  (define (bytes->num-op [bytes : Bytes]) : NumOp
    (if (bytes=? bytes #"+")
        (plus-op)
        (if (bytes=? bytes #"-")
            (minus-op)
            (if (bytes=? bytes #"*")
                (times-op)
                (panic #"Unknown op")))))

  ;; TODO move this to a core library
  (define (a) (ignore [v : a]) : Void
    (void))

  (define (a) (extract-either [either : (Either Bytes a)]) : a
    (case either
      [(right v) v]
      [(left b) (panic b)]))

  (define (main [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Byte
    (begin
      (ignore (parse-module (extract-either (parse-sexp (read-all-bytes stdin)))))
      0)))
