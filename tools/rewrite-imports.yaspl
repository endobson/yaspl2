#:module (tools rewrite-imports)
#:import {
  (bytes)
  (compiler)
  (data source-location)
  (either)
  (io)
  (join-list)
  (lexer)
  (list)
  (maybe)
  (module-name)
  (prim)
  (sexp-parser)
  (source-language)
}
(export)
(types)

(define (import->bytes [i : Import]) : Bytes
  (match-define (import exported local) i)
  (if (bytes=? exported local)
      local
      (bytes-append (varargs list #"[" exported #" " local #"]"))))

(define (remove-import-section [b : Bytes]) : (Either Bytes Bytes)
  (match-define lexer (make-lexer (sourced-bytes (unnamed-source) b)))
  (case (skip-sexp lexer)
    [(left v) (left v)]
    [(right lexer)
     (case (skip-sexp lexer)
       [(left v) (left v)]
       [(right lexer)
        (case (skip-sexp lexer)
          [(left v) (left v)]
          [(right lexer)
           (case (skip-sexp lexer)
             [(left v) (left v)]
             [(right lexer)
              (right (lexer-remaining-input lexer))])])])]))

(define (skip-sexp [l : Lexer]) : (Either Bytes Lexer)
  (case (parse-sexp l)
    [(nothing) (left #"End of file")]
    [(just (sexp-result-error v)) (left v)]
    [(just (sexp-result _ lexer)) (right lexer)]))


(define (import< [a : Import] [b : Import]) : Boolean
  (bytes< (import-exported-name a) (import-exported-name b)))

(define (imports-module-name [i : Imports]) : ModName
  (case i
    [(partial-imports mod-name _ _ _) mod-name]
    [(full-imports mod-name) mod-name]))

(define (imports< [i1 : Imports] [i2 : Imports]) : Boolean
  (mod-name< (imports-module-name i1) (imports-module-name i2)))


(define (rewrite-imports* [mod-name : ModName] [imports : (List Imports)] [module-file-name : Bytes])
  : (Either Bytes Bytes)
  (case (remove-import-section (call-with-input-file module-file-name read-all-bytes))
    [(left v) (left v)]
    [(right rest-of-module)
     (right
       (bytes-append
         (jl->list
           (varargs append-jl*
             (single-jl #"#:module ")
             (single-jl (mod-name->bytes mod-name))
             (single-jl #"\n")
             (single-jl #"#:import {\n")
             (concat-jl
               (map (lambda ([i : Imports]) : (JoinList Bytes)
                      (case i
                        [(full-imports mod-name)
                         (varargs join-list #"  " (mod-name->bytes mod-name) #"\n")]
                        [(partial-imports mod-name types values patterns)
                         (varargs append-jl*
                           (varargs join-list #"  {" (mod-name->bytes mod-name) #"\n")
                           (case types
                             [(empty)
                              (empty-jl)]
                             [_
                              (cons-jl
                                #"    {#:types\n"
                                (snoc-jl
                                  (concat-jl
                                    (map
                                      (lambda ([i : Import])
                                        (varargs join-list #"      " (import->bytes i) #"\n"))
                                      (sort types import<)))
                                  #"    }\n"))])
                           (case values
                             [(empty)
                              (empty-jl)]
                             [_
                              (cons-jl
                                #"    {#:values\n"
                                (snoc-jl
                                  (concat-jl
                                    (map
                                      (lambda ([i : Import])
                                        (varargs join-list #"      " (import->bytes i) #"\n"))
                                      (sort values import<)))
                                  #"    }\n"))])
                           (case patterns
                             [(empty)
                              (empty-jl)]
                             [_
                              (cons-jl
                                #"    {#:patterns\n"
                                (snoc-jl
                                  (concat-jl
                                    (map
                                      (lambda ([i : Import])
                                        (varargs join-list #"      " (import->bytes i) #"\n"))
                                      (sort patterns import<)))
                                  #"    }\n"))])
                           (single-jl #"  }\n"))]))
                    (sort imports imports<)))
             (single-jl #"}")
             (single-jl rest-of-module)))))]))

(define (rewrite-imports [mod-name : ModName] [imports : (List Imports)] [module-file-name : Bytes])
  : (Maybe Bytes)
  (case (rewrite-imports* mod-name imports module-file-name)
    [(left v) (just v)]
    [(right new-contents)
     (begin
       (delete-file module-file-name)
       (call-with-output-file/void module-file-name
         (lambda ([output : OutputPort])
           (write-all-bytes new-contents output)))
       (set-file-or-directory-permissions
         (make-null-terminated module-file-name)
         432) ;; Octal 660
       (nothing))]))

(define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Int
  (case (array->list args)
    [(empty)
     (begin
       (write-line #"No executable specified???" stderr)
       1)]
    [(cons _ (empty))
     (begin
       (write-line #"No input file name supplied." stderr)
       1)]
    [(cons _ (cons _ (cons _ _)))
     (begin
       (write-line #"Too many arguments supplied." stderr)
       1)]
    [(cons _ (cons input-file-name (empty)))
     (case (parse-module-file input-file-name)
       [(left v)
        (begin
          (write-line v stderr)
          1)]
       [(right mod)
        (case (rewrite-imports (module-name mod) (module-imports mod) input-file-name)
          [(just v)
           (begin
             (write-line v stderr)
             1)]
          [(nothing)
           0])])]))
