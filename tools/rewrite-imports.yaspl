#:module (tools rewrite-imports)
#:import {
  (bytes)
  (compiler)
  (either)
  (io)
  (lexer)
  (list)
  (maybe)
  (module-name)
  (prim)
  (sexp-parser)
  (source-language)
}
(export)
(types)

(define (import->bytes [i : Import]) : Bytes
  (match-define (import exported local) i)
  (if (bytes=? exported local)
      local
      (bytes-append (varargs list #"[" exported #" " local #"]"))))

(define (remove-import-section [b : Bytes]) : (Either Bytes Bytes)
  (match-define lexer (make-lexer b))
  (case (skip-sexp lexer)
    [(left v) (left v)]
    [(right lexer)
     (case (skip-sexp lexer)
       [(left v) (left v)]
       [(right lexer)
        (case (skip-sexp lexer)
          [(left v) (left v)]
          [(right lexer)
           (case (skip-sexp lexer)
             [(left v) (left v)]
             [(right lexer)
              (right (lexer-remaining-input lexer))])])])]))

(define (skip-sexp [l : Lexer]) : (Either Bytes Lexer)
  (case (parse-sexp l)
    [(nothing) (left #"End of file")]
    [(just (sexp-result-error v)) (left v)]
    [(just (sexp-result _ lexer)) (right lexer)]))


(define (import< [a : Import] [b : Import]) : Boolean
  (bytes< (import-exported-name a) (import-exported-name b)))

(define (imports-module-name [i : Imports]) : ModName
  (case i
    [(partial-imports mod-name _ _ _) mod-name]
    [(full-imports mod-name) mod-name]))

(define (imports< [i1 : Imports] [i2 : Imports]) : Boolean
  (mod-name< (imports-module-name i1) (imports-module-name i2)))


(define (rewrite-imports [mod-name : ModName] [imports : (List Imports)] [module-file-name : Bytes])
  : (Maybe Bytes)
  (case (remove-import-section (call-with-input-file module-file-name read-all-bytes))
    [(left v) (just v)]
    [(right rest-of-module)
     (begin
       (delete-file module-file-name)
       (call-with-output-file/void module-file-name
         (lambda ([output : OutputPort])
           (begin
             (set-file-or-directory-permissions
               (make-null-terminated module-file-name)
               432) ;; Octal 660
             (write-line
               (bytes-append (varargs list #"#:module " (mod-name->bytes mod-name)))
               output)
             (write-line #"#:import {" output)
             (for-each
               (lambda ([i : Imports])
                 (case i
                   [(full-imports mod-name)
                    (write-line (bytes-append (varargs list #"  " (mod-name->bytes mod-name))) output)]
                   [(partial-imports mod-name types values patterns)
                    (begin
                      (write-line (bytes-append (varargs list #"  {" (mod-name->bytes mod-name))) output)
                      (case types
                        [(empty)
                         (void)]
                        [_
                         (begin
                           (write-line #"    {#:types" output)
                           (for-each
                             (lambda ([i : Import])
                               (begin
                                 (write-all-bytes #"      " output)
                                 (write-line (import->bytes i) output)))
                             (sort types import<))
                           (write-line #"    }" output))])
                      (case values
                        [(empty)
                         (void)]
                        [_
                         (begin
                           (write-line #"    {#:values" output)
                           (for-each
                             (lambda ([i : Import])
                               (begin
                                 (write-all-bytes #"      " output)
                                 (write-line (import->bytes i) output)))
                             (sort values import<))
                           (write-line #"    }" output))])
                      (case patterns
                        [(empty)
                         (void)]
                        [_
                         (begin
                           (write-line #"    {#:patterns" output)
                           (for-each
                             (lambda ([i : Import])
                               (begin
                                 (write-all-bytes #"      " output)
                                 (write-line (import->bytes i) output)))
                             (sort patterns import<))
                           (write-line #"    }" output))])
                      (write-line #"  }" output))]))
               (sort imports imports<))
             (write-all-bytes #"}" output)
             (write-all-bytes rest-of-module output))))
       (nothing))]))

(define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Int
  (case (array->list args)
    [(empty)
     (begin
       (write-line #"No executable specified???" stderr)
       1)]
    [(cons _ (empty))
     (begin
       (write-line #"No input file name supplied." stderr)
       1)]
    [(cons _ (cons _ (cons _ _)))
     (begin
       (write-line #"Too many arguments supplied." stderr)
       1)]
    [(cons _ (cons input-file-name (empty)))
     (case (parse-module-file input-file-name)
       [(left v)
        (begin
          (write-line v stderr)
          1)]
       [(right mod)
        (case (rewrite-imports (module-name mod) (module-imports mod) input-file-name)
          [(just v)
           (begin
             (write-line v stderr)
             1)]
          [(nothing)
           0])])]))
