#:module (ir-printer-main)
#:import {
  (bytes)
  (compiler)
  (either)
  (io)
  (join-list)
  (list)
  (lower-x86-64) {
    #:values
      reg->bytes
  }
  (module-signature)
  (module-signature-serialization)
  (prim)
  (print-lowered-register-language) {
    #:values
      [print-function l:print-function]
  }
  (print-register-language) {
    #:values
      [print-function r:print-function]
  }
  (register-language) {
    #:patterns
      [function-definition r:function-definition]
  }
  (register-language-compiler)
  (tuples)
  (yaspl top-level-objects)
  (yaspl top-level-objects-to-x86-64)
  (yaspl x86-64-assembly)
  (yaspl x86-64-assembly-printer)
}
(export)
(types)

(define (parse-signature-files [files : (List Bytes)]) : (Either Bytes (List ModuleSignature))
  (case files
    [(empty) (right (empty))]
    [(cons name files)
     (case (deserialize-module-signature (call-with-input-file name read-all-bytes))
       [(left v) (left v)]
       [(right sig)
        (case (parse-signature-files files)
          [(left v) (left v)]
          [(right sigs) (right (cons sig sigs))])])]))

(define (handle-failure-result [msg : Bytes] [stderr : OutputPort]) : Int
  (begin
    (write-line msg stderr)
    1))

(define (main [args : (Array Bytes)] [stdin : InputPort] [stdout : OutputPort] [stderr : OutputPort]) : Int
  (case (array->list args)
    [(empty)
     (handle-failure-result #"No binary!?" stderr)]
    [(cons _ (empty))
     (handle-failure-result #"No module file provided." stderr)]
    [(cons _ (cons _ (empty)))
     (handle-failure-result #"No output directory provided." stderr)]
    [(cons _ (cons main-module-file (cons output-directory signature-files)))
     (case (parse-module-file main-module-file)
       [(left v) (handle-failure-result v stderr)]
       [(right main-module)
        (case (parse-signature-files signature-files)
          [(left v) (handle-failure-result v stderr)]
          [(right signatures)
           (case (compile-main-module main-module signatures)
             [(left v) (handle-failure-result v stderr)]
             [(right (tuple2 objects _))
              (match-define (assembly-fragments text-fragments _) (convert-objects objects))
              (begin
                (make-directory output-directory)
                (for-each
                  (lambda ([o : TopLevelObject]) : Void
                    (case o
                      [(register-function-tlo fun)
                       (case fun
                         [(r:function-definition name _ _ _ _)
                          (begin
                            (call-with-output-file
                              (bytes-append (varargs list output-directory #"/" name #".reg"))
                              (lambda ([port : OutputPort])
                                (write-all-bytes (r:print-function fun) port)))
                            (case (compile-function fun)
                              [(left v) (panic v)]
                              [(right (tuple2 lowered text))
                               (begin
                                 (call-with-output-file
                                   (bytes-append (varargs list output-directory #"/" name #".lower"))
                                   (lambda ([port : OutputPort])
                                     (write-all-bytes (l:print-function lowered reg->bytes) port)))
                                 (call-with-output-file
                                   (bytes-append (varargs list output-directory #"/" name #".assem"))
                                   (lambda ([port : OutputPort])
                                     (let ([bytes (bytes-append
                                                    (jl->list (assembly-commands->bytes
                                                      (jl->list (text-fragment->commands text)))))])
                                       (write-all-bytes bytes port)))))]))])]
                      [_ (void)]))
                  objects)
                0)])])])]))
